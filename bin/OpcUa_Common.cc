// This C++ source file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for AvdootChalke (avdootchalke@avdootchalke-VirtualBox) on Thu Jul 26 15:22:27 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

/* Including header files */

#include "OpcUa_Common.hh"

namespace OpcUa__Common {

/* Prototypes of static functions */

static void pre_init_module();

/* Literal string constants */

static const unsigned char module_checksum[] = { 0xc0, 0x26, 0x68, 0x9d, 0x0f, 0x3a, 0x77, 0x0c, 0x4e, 0xca, 0xb3, 0x81, 0x0d, 0xa0, 0x53, 0x0d };

/* Global variable definitions */

static INTEGER const_Bad__TcpServerTooBusy;
const INTEGER& Bad__TcpServerTooBusy = const_Bad__TcpServerTooBusy;
static INTEGER const_Bad__TcpMessageTypeInvalid;
const INTEGER& Bad__TcpMessageTypeInvalid = const_Bad__TcpMessageTypeInvalid;
static INTEGER const_Bad__TcpSecureChannelUnknown;
const INTEGER& Bad__TcpSecureChannelUnknown = const_Bad__TcpSecureChannelUnknown;
static INTEGER const_Bad__TcpMessageTooLarge;
const INTEGER& Bad__TcpMessageTooLarge = const_Bad__TcpMessageTooLarge;
static INTEGER const_Bad__Timeout;
const INTEGER& Bad__Timeout = const_Bad__Timeout;
static INTEGER const_Bad__TcpNotEnoughResources;
const INTEGER& Bad__TcpNotEnoughResources = const_Bad__TcpNotEnoughResources;
static INTEGER const_Bad__TcpInternalError;
const INTEGER& Bad__TcpInternalError = const_Bad__TcpInternalError;
static INTEGER const_Bad__TcpEndpointUrlInvalid;
const INTEGER& Bad__TcpEndpointUrlInvalid = const_Bad__TcpEndpointUrlInvalid;
static INTEGER const_Bad__SecurityChecksFailed;
const INTEGER& Bad__SecurityChecksFailed = const_Bad__SecurityChecksFailed;
static INTEGER const_Bad__RequestInterrupted;
const INTEGER& Bad__RequestInterrupted = const_Bad__RequestInterrupted;
static INTEGER const_Bad__RequestTimeout;
const INTEGER& Bad__RequestTimeout = const_Bad__RequestTimeout;
static INTEGER const_Bad__SecureChannelClosed;
const INTEGER& Bad__SecureChannelClosed = const_Bad__SecureChannelClosed;
static INTEGER const_Bad__SecureChannelTokenUnknown;
const INTEGER& Bad__SecureChannelTokenUnknown = const_Bad__SecureChannelTokenUnknown;
static INTEGER const_Bad__CertificateUntrusted;
const INTEGER& Bad__CertificateUntrusted = const_Bad__CertificateUntrusted;
static INTEGER const_Bad__CertificateTimeInvalid;
const INTEGER& Bad__CertificateTimeInvalid = const_Bad__CertificateTimeInvalid;
static INTEGER const_Bad__CertificateIssuerTimeInvalid;
const INTEGER& Bad__CertificateIssuerTimeInvalid = const_Bad__CertificateIssuerTimeInvalid;
static INTEGER const_Bad__CertificateUseNotAllowed;
const INTEGER& Bad__CertificateUseNotAllowed = const_Bad__CertificateUseNotAllowed;
static INTEGER const_Bad__CertificateIssuerUseNotAllowed;
const INTEGER& Bad__CertificateIssuerUseNotAllowed = const_Bad__CertificateIssuerUseNotAllowed;
static INTEGER const_Bad__CertificateRevocationUnknown;
const INTEGER& Bad__CertificateRevocationUnknown = const_Bad__CertificateRevocationUnknown;
static INTEGER const_Bad__CertificateIssuerRevocationUnknown;
const INTEGER& Bad__CertificateIssuerRevocationUnknown = const_Bad__CertificateIssuerRevocationUnknown;
static INTEGER const_Bad__CertificateRevoked;
const INTEGER& Bad__CertificateRevoked = const_Bad__CertificateRevoked;
// No XER for CommonServiceResultCodes
const TTCN_Typedescriptor_t CommonServiceResultCodes_descr_ = { "@OpcUa_Common.CommonServiceResultCodes", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
// No XER for CommonOperationLevelResultCodes
const TTCN_Typedescriptor_t CommonOperationLevelResultCodes_descr_ = { "@OpcUa_Common.CommonOperationLevelResultCodes", NULL, NULL, NULL, NULL, &ENUMERATED_json_, NULL, NULL, TTCN_Typedescriptor_t::DONTCARE };
TTCN_Module module_object("OpcUa_Common", __DATE__, __TIME__, module_checksum, pre_init_module, NULL, 0U, 4294967295U, 4294967295U, 4294967295U, NULL, 0LU, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL);

static const RuntimeVersionChecker ver_checker(  current_runtime_version.requires_major_version_6,
  current_runtime_version.requires_minor_version_3,
  current_runtime_version.requires_patch_level_0,  current_runtime_version.requires_runtime_1);

/* Member functions of C++ classes */

CommonServiceResultCodes::CommonServiceResultCodes()
{
enum_value = UNBOUND_VALUE;
}

CommonServiceResultCodes::CommonServiceResultCodes(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @OpcUa_Common.CommonServiceResultCodes with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

CommonServiceResultCodes::CommonServiceResultCodes(enum_type other_value)
{
enum_value = other_value;
}

CommonServiceResultCodes::CommonServiceResultCodes(const CommonServiceResultCodes& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
enum_value = other_value.enum_value;
}

CommonServiceResultCodes& CommonServiceResultCodes::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @OpcUa_Common.CommonServiceResultCodes.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

CommonServiceResultCodes& CommonServiceResultCodes::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

CommonServiceResultCodes& CommonServiceResultCodes::operator=(const CommonServiceResultCodes& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
enum_value = other_value.enum_value;
return *this;
}

boolean CommonServiceResultCodes::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return enum_value == other_value;
}

boolean CommonServiceResultCodes::operator==(const CommonServiceResultCodes& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return enum_value == other_value.enum_value;
}

boolean CommonServiceResultCodes::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return enum_value < other_value;
}

boolean CommonServiceResultCodes::operator<(const CommonServiceResultCodes& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return enum_value < other_value.enum_value;
}

boolean CommonServiceResultCodes::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return enum_value > other_value;
}

boolean CommonServiceResultCodes::operator>(const CommonServiceResultCodes& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return enum_value > other_value.enum_value;
}

const char *CommonServiceResultCodes::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case Good: return "Good";
case Good__CompletesAsynchronously: return "Good_CompletesAsynchronously";
case Good__SubscriptionTransferred: return "Good_SubscriptionTransferred";
case Bad__CertificateHostNameInvalid: return "Bad_CertificateHostNameInvalid";
case Bad__CertificateChainIncomplete: return "Bad_CertificateChainIncomplete";
case Bad__CertificateIssuerRevocationUnknown: return "Bad_CertificateIssuerRevocationUnknown";
case Bad__CertificateIssuerUseNotAllowed: return "Bad_CertificateIssuerUseNotAllowed";
case Bad__CertificateIssuerTimeInvalid: return "Bad_CertificateIssuerTimeInvalid";
case Bad__CertificateIssuerRevoked: return "Bad_CertificateIssuerRevoked";
case Bad__CertificateInvalid: return "Bad_CertificateInvalid";
case Bad__CertificateRevocationUnknown: return "Bad_CertificateRevocationUnknown";
case Bad__CertificateRevoked: return "Bad_CertificateRevoked";
case Bad__CertificateTimeInvalid: return "Bad_CertificateTimeInvalid";
case Bad__CertificateUriInvalid: return "Bad_CertificateUriInvalid";
case Bad__CertificateUntrusted: return "Bad_CertificateUntrusted";
case Bad__CertificateUseNotAllowed: return "Bad_CertificateUseNotAllowed";
case Bad__CommunicationError: return "Bad_CommunicationError";
case Bad__DataTypeIdUnknown: return "Bad_DataTypeIdUnknown";
case Bad__DecodingError: return "Bad_DecodingError";
case Bad__EncodingError: return "Bad_EncodingError";
case Bad__EncodingLimitsExceeded: return "Bad_EncodingLimitsExceeded";
case Bad__IdentityTokenInvalid: return "Bad_IdentityTokenInvalid";
case Bad__IdentityTokenRejected: return "Bad_IdentityTokenRejected";
case Bad__InternalError: return "Bad_InternalError";
case Bad__InvalidArgument: return "Bad_InvalidArgument";
case Bad__InvalidState: return "Bad_InvalidState";
case Bad__InvalidTimestamp: return "Bad_InvalidTimestamp";
case Bad__LicenseExpired: return "Bad_LicenseExpired";
case Bad__LicenseLimitsExceeded: return "Bad_LicenseLimitsExceeded";
case Bad__LicenseNotAvailable: return "Bad_LicenseNotAvailable";
case Bad__NothingToDo: return "Bad_NothingToDo";
case Bad__OutOfMemory: return "Bad_OutOfMemory";
case Bad__RequestCancelledByClient: return "Bad_RequestCancelledByClient";
case Bad__RequestTooLarge: return "Bad_RequestTooLarge";
case Bad__ResponseTooLarge: return "Bad_ResponseTooLarge";
case Bad__RequestHeaderInvalid: return "Bad_RequestHeaderInvalid";
case Bad__ResourceUnavailable: return "Bad_ResourceUnavailable";
case Bad__SecureChannelIdInvalid: return "Bad_SecureChannelIdInvalid";
case Bad__SecurityChecksFailed: return "Bad_SecurityChecksFailed";
case Bad__ServerHalted: return "Bad_ServerHalted";
case Bad__ServerNotConnected: return "Bad_ServerNotConnected";
case Bad__ServerUriInvalid: return "Bad_ServerUriInvalid";
case Bad__ServiceUnsupported: return "Bad_ServiceUnsupported";
case Bad__SessionIdInvalid: return "Bad_SessionIdInvalid";
case Bad__SessionClosed: return "Bad_SessionClosed";
case Bad__SessionNotActivated: return "Bad_SessionNotActivated";
case Bad__Shutdown: return "Bad_Shutdown";
case Bad__SubscriptionIdInvalid: return "Bad_SubscriptionIdInvalid";
case Bad__Timeout: return "Bad_Timeout";
case Bad__TimestampsToReturnInvalid: return "Bad_TimestampsToReturnInvalid";
case Bad__TooManyOperations: return "Bad_TooManyOperations";
case Bad__UnexpectedError: return "Bad_UnexpectedError";
case Bad__UnknownResponse: return "Bad_UnknownResponse";
case Bad__UserAccessDenied: return "Bad_UserAccessDenied";
case Bad__ViewIdUnknown: return "Bad_ViewIdUnknown";
case Bad__ViewTimestampInvalid: return "Bad_ViewTimestampInvalid";
case Bad__ViewParameterMismatchInvalid: return "Bad_ViewParameterMismatchInvalid";
case Bad__ViewVersionInvalid: return "Bad_ViewVersionInvalid";
default: return "<unknown>";
}
}

CommonServiceResultCodes::enum_type CommonServiceResultCodes::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "Good")) return Good;
else if (!strcmp(str_par, "Good_CompletesAsynchronously")) return Good__CompletesAsynchronously;
else if (!strcmp(str_par, "Good_SubscriptionTransferred")) return Good__SubscriptionTransferred;
else if (!strcmp(str_par, "Bad_CertificateHostNameInvalid")) return Bad__CertificateHostNameInvalid;
else if (!strcmp(str_par, "Bad_CertificateChainIncomplete")) return Bad__CertificateChainIncomplete;
else if (!strcmp(str_par, "Bad_CertificateIssuerRevocationUnknown")) return Bad__CertificateIssuerRevocationUnknown;
else if (!strcmp(str_par, "Bad_CertificateIssuerUseNotAllowed")) return Bad__CertificateIssuerUseNotAllowed;
else if (!strcmp(str_par, "Bad_CertificateIssuerTimeInvalid")) return Bad__CertificateIssuerTimeInvalid;
else if (!strcmp(str_par, "Bad_CertificateIssuerRevoked")) return Bad__CertificateIssuerRevoked;
else if (!strcmp(str_par, "Bad_CertificateInvalid")) return Bad__CertificateInvalid;
else if (!strcmp(str_par, "Bad_CertificateRevocationUnknown")) return Bad__CertificateRevocationUnknown;
else if (!strcmp(str_par, "Bad_CertificateRevoked")) return Bad__CertificateRevoked;
else if (!strcmp(str_par, "Bad_CertificateTimeInvalid")) return Bad__CertificateTimeInvalid;
else if (!strcmp(str_par, "Bad_CertificateUriInvalid")) return Bad__CertificateUriInvalid;
else if (!strcmp(str_par, "Bad_CertificateUntrusted")) return Bad__CertificateUntrusted;
else if (!strcmp(str_par, "Bad_CertificateUseNotAllowed")) return Bad__CertificateUseNotAllowed;
else if (!strcmp(str_par, "Bad_CommunicationError")) return Bad__CommunicationError;
else if (!strcmp(str_par, "Bad_DataTypeIdUnknown")) return Bad__DataTypeIdUnknown;
else if (!strcmp(str_par, "Bad_DecodingError")) return Bad__DecodingError;
else if (!strcmp(str_par, "Bad_EncodingError")) return Bad__EncodingError;
else if (!strcmp(str_par, "Bad_EncodingLimitsExceeded")) return Bad__EncodingLimitsExceeded;
else if (!strcmp(str_par, "Bad_IdentityTokenInvalid")) return Bad__IdentityTokenInvalid;
else if (!strcmp(str_par, "Bad_IdentityTokenRejected")) return Bad__IdentityTokenRejected;
else if (!strcmp(str_par, "Bad_InternalError")) return Bad__InternalError;
else if (!strcmp(str_par, "Bad_InvalidArgument")) return Bad__InvalidArgument;
else if (!strcmp(str_par, "Bad_InvalidState")) return Bad__InvalidState;
else if (!strcmp(str_par, "Bad_InvalidTimestamp")) return Bad__InvalidTimestamp;
else if (!strcmp(str_par, "Bad_LicenseExpired")) return Bad__LicenseExpired;
else if (!strcmp(str_par, "Bad_LicenseLimitsExceeded")) return Bad__LicenseLimitsExceeded;
else if (!strcmp(str_par, "Bad_LicenseNotAvailable")) return Bad__LicenseNotAvailable;
else if (!strcmp(str_par, "Bad_NothingToDo")) return Bad__NothingToDo;
else if (!strcmp(str_par, "Bad_OutOfMemory")) return Bad__OutOfMemory;
else if (!strcmp(str_par, "Bad_RequestCancelledByClient")) return Bad__RequestCancelledByClient;
else if (!strcmp(str_par, "Bad_RequestTooLarge")) return Bad__RequestTooLarge;
else if (!strcmp(str_par, "Bad_ResponseTooLarge")) return Bad__ResponseTooLarge;
else if (!strcmp(str_par, "Bad_RequestHeaderInvalid")) return Bad__RequestHeaderInvalid;
else if (!strcmp(str_par, "Bad_ResourceUnavailable")) return Bad__ResourceUnavailable;
else if (!strcmp(str_par, "Bad_SecureChannelIdInvalid")) return Bad__SecureChannelIdInvalid;
else if (!strcmp(str_par, "Bad_SecurityChecksFailed")) return Bad__SecurityChecksFailed;
else if (!strcmp(str_par, "Bad_ServerHalted")) return Bad__ServerHalted;
else if (!strcmp(str_par, "Bad_ServerNotConnected")) return Bad__ServerNotConnected;
else if (!strcmp(str_par, "Bad_ServerUriInvalid")) return Bad__ServerUriInvalid;
else if (!strcmp(str_par, "Bad_ServiceUnsupported")) return Bad__ServiceUnsupported;
else if (!strcmp(str_par, "Bad_SessionIdInvalid")) return Bad__SessionIdInvalid;
else if (!strcmp(str_par, "Bad_SessionClosed")) return Bad__SessionClosed;
else if (!strcmp(str_par, "Bad_SessionNotActivated")) return Bad__SessionNotActivated;
else if (!strcmp(str_par, "Bad_Shutdown")) return Bad__Shutdown;
else if (!strcmp(str_par, "Bad_SubscriptionIdInvalid")) return Bad__SubscriptionIdInvalid;
else if (!strcmp(str_par, "Bad_Timeout")) return Bad__Timeout;
else if (!strcmp(str_par, "Bad_TimestampsToReturnInvalid")) return Bad__TimestampsToReturnInvalid;
else if (!strcmp(str_par, "Bad_TooManyOperations")) return Bad__TooManyOperations;
else if (!strcmp(str_par, "Bad_UnexpectedError")) return Bad__UnexpectedError;
else if (!strcmp(str_par, "Bad_UnknownResponse")) return Bad__UnknownResponse;
else if (!strcmp(str_par, "Bad_UserAccessDenied")) return Bad__UserAccessDenied;
else if (!strcmp(str_par, "Bad_ViewIdUnknown")) return Bad__ViewIdUnknown;
else if (!strcmp(str_par, "Bad_ViewTimestampInvalid")) return Bad__ViewTimestampInvalid;
else if (!strcmp(str_par, "Bad_ViewParameterMismatchInvalid")) return Bad__ViewParameterMismatchInvalid;
else if (!strcmp(str_par, "Bad_ViewVersionInvalid")) return Bad__ViewVersionInvalid;
else return UNKNOWN_VALUE;
}

boolean CommonServiceResultCodes::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 23:
case 24:
case 25:
case 26:
case 27:
case 28:
case 29:
case 30:
case 31:
case 32:
case 33:
case 34:
case 35:
case 36:
case 37:
case 38:
case 39:
case 40:
case 41:
case 42:
case 43:
case 44:
case 45:
case 46:
case 47:
case 48:
case 49:
case 50:
case 51:
case 52:
case 53:
case 54:
case 55:
case 56:
case 57:
return TRUE;
default:
return FALSE;
}
}

int CommonServiceResultCodes::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @OpcUa_Common.CommonServiceResultCodes.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int CommonServiceResultCodes::enum2int(const CommonServiceResultCodes& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @OpcUa_Common.CommonServiceResultCodes.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void CommonServiceResultCodes::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @OpcUa_Common.CommonServiceResultCodes.", int_val);
enum_value = (enum_type)int_val;
}

CommonServiceResultCodes::operator CommonServiceResultCodes::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return enum_value;
}

void CommonServiceResultCodes::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void CommonServiceResultCodes::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@OpcUa_Common.CommonServiceResultCodes");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @OpcUa_Common.CommonServiceResultCodes.");
  }
}

void CommonServiceResultCodes::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
text_buf.push_int(enum_value);
}

void CommonServiceResultCodes::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @OpcUa_Common.CommonServiceResultCodes.", enum_value);
}

void CommonServiceResultCodes_template::copy_template(const CommonServiceResultCodes_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CommonServiceResultCodes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
}
}

CommonServiceResultCodes_template::CommonServiceResultCodes_template()
{
}

CommonServiceResultCodes_template::CommonServiceResultCodes_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CommonServiceResultCodes_template::CommonServiceResultCodes_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!CommonServiceResultCodes::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @OpcUa_Common.CommonServiceResultCodes with unknown numeric value %d.", other_value);
single_value = (CommonServiceResultCodes::enum_type)other_value;
}

CommonServiceResultCodes_template::CommonServiceResultCodes_template(CommonServiceResultCodes::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

CommonServiceResultCodes_template::CommonServiceResultCodes_template(const CommonServiceResultCodes& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == CommonServiceResultCodes::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
single_value = other_value.enum_value;
}

CommonServiceResultCodes_template::CommonServiceResultCodes_template(const OPTIONAL<CommonServiceResultCodes>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (CommonServiceResultCodes::enum_type)(const CommonServiceResultCodes&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @OpcUa_Common.CommonServiceResultCodes from an unbound optional field.");
}
}

CommonServiceResultCodes_template::CommonServiceResultCodes_template(const CommonServiceResultCodes_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

CommonServiceResultCodes_template::~CommonServiceResultCodes_template()
{
clean_up();
}

boolean CommonServiceResultCodes_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean CommonServiceResultCodes_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != CommonServiceResultCodes::UNBOUND_VALUE;
}

void CommonServiceResultCodes_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

CommonServiceResultCodes_template& CommonServiceResultCodes_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CommonServiceResultCodes_template& CommonServiceResultCodes_template::operator=(int other_value)
{
if (!CommonServiceResultCodes::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @OpcUa_Common.CommonServiceResultCodes.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (CommonServiceResultCodes::enum_type)other_value;
return *this;
}

CommonServiceResultCodes_template& CommonServiceResultCodes_template::operator=(CommonServiceResultCodes::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

CommonServiceResultCodes_template& CommonServiceResultCodes_template::operator=(const CommonServiceResultCodes& other_value)
{
if (other_value.enum_value == CommonServiceResultCodes::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @OpcUa_Common.CommonServiceResultCodes to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

CommonServiceResultCodes_template& CommonServiceResultCodes_template::operator=(const OPTIONAL<CommonServiceResultCodes>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (CommonServiceResultCodes::enum_type)(const CommonServiceResultCodes&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
}
return *this;
}

CommonServiceResultCodes_template& CommonServiceResultCodes_template::operator=(const CommonServiceResultCodes_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CommonServiceResultCodes_template::match(CommonServiceResultCodes::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
}
return FALSE;
}

boolean CommonServiceResultCodes_template::match(const CommonServiceResultCodes& other_value, boolean) const
{
if (other_value.enum_value == CommonServiceResultCodes::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @OpcUa_Common.CommonServiceResultCodes with an unbound value.");
return match(other_value.enum_value);
}

CommonServiceResultCodes::enum_type CommonServiceResultCodes_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return single_value;
}

void CommonServiceResultCodes_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CommonServiceResultCodes_template[list_length];
}

CommonServiceResultCodes_template& CommonServiceResultCodes_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
return value_list.list_value[list_index];
}

void CommonServiceResultCodes_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(CommonServiceResultCodes::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CommonServiceResultCodes_template::log_match(const CommonServiceResultCodes& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void CommonServiceResultCodes_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
}
}

void CommonServiceResultCodes_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (CommonServiceResultCodes::enum_type)text_buf.pull_int().get_val();
if (!CommonServiceResultCodes::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @OpcUa_Common.CommonServiceResultCodes.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CommonServiceResultCodes_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @OpcUa_Common.CommonServiceResultCodes.");
}
}

boolean CommonServiceResultCodes_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CommonServiceResultCodes_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CommonServiceResultCodes_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CommonServiceResultCodes_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    CommonServiceResultCodes::enum_type enum_val = CommonServiceResultCodes::str_to_enum(m_p->get_enumerated());
    if (!CommonServiceResultCodes::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @OpcUa_Common.CommonServiceResultCodes.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@OpcUa_Common.CommonServiceResultCodes");
  }
  is_ifpresent = param.get_ifpresent();
}

void CommonServiceResultCodes_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@OpcUa_Common.CommonServiceResultCodes");
}

CommonOperationLevelResultCodes::CommonOperationLevelResultCodes()
{
enum_value = UNBOUND_VALUE;
}

CommonOperationLevelResultCodes::CommonOperationLevelResultCodes(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Initializing a variable of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes with invalid numeric value %d.", other_value);
enum_value = (enum_type)other_value;
}

CommonOperationLevelResultCodes::CommonOperationLevelResultCodes(enum_type other_value)
{
enum_value = other_value;
}

CommonOperationLevelResultCodes::CommonOperationLevelResultCodes(const CommonOperationLevelResultCodes& other_value)
: Base_Type()
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Copying an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
enum_value = other_value.enum_value;
}

CommonOperationLevelResultCodes& CommonOperationLevelResultCodes::operator=(int other_value)
{
if (!is_valid_enum(other_value)) TTCN_error("Assigning unknown numeric value %d to a variable of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.", other_value);
enum_value = (enum_type)other_value;
return *this;
}

CommonOperationLevelResultCodes& CommonOperationLevelResultCodes::operator=(enum_type other_value)
{
enum_value = other_value;
return *this;
}

CommonOperationLevelResultCodes& CommonOperationLevelResultCodes::operator=(const CommonOperationLevelResultCodes& other_value)
{
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
enum_value = other_value.enum_value;
return *this;
}

boolean CommonOperationLevelResultCodes::operator==(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return enum_value == other_value;
}

boolean CommonOperationLevelResultCodes::operator==(const CommonOperationLevelResultCodes& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return enum_value == other_value.enum_value;
}

boolean CommonOperationLevelResultCodes::operator<(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return enum_value < other_value;
}

boolean CommonOperationLevelResultCodes::operator<(const CommonOperationLevelResultCodes& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return enum_value < other_value.enum_value;
}

boolean CommonOperationLevelResultCodes::operator>(enum_type other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return enum_value > other_value;
}

boolean CommonOperationLevelResultCodes::operator>(const CommonOperationLevelResultCodes& other_value) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("The left operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
if (other_value.enum_value == UNBOUND_VALUE) TTCN_error("The right operand of comparison is an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return enum_value > other_value.enum_value;
}

const char *CommonOperationLevelResultCodes::enum_to_str(enum_type enum_par)
{
switch (enum_par) {
case Good__Clamped: return "Good_Clamped";
case Good__Overload: return "Good_Overload";
case Uncertain: return "Uncertain";
case Bad: return "Bad";
case Bad__AttributeIdInvalid: return "Bad_AttributeIdInvalid";
case Bad__BrowseDirectionInvalid: return "Bad_BrowseDirectionInvalid";
case Bad__BrowseNameInvalid: return "Bad_BrowseNameInvalid";
case Bad__ContentFilterInvalid: return "Bad_ContentFilterInvalid";
case Bad__ContinuationPointInvalid: return "Bad_ContinuationPointInvalid";
case Bad__DataEncodingInvalid: return "Bad_DataEncodingInvalid";
case Bad__DataEncodingUnsupported: return "Bad_DataEncodingUnsupported";
case Bad__EventFilterInvalid: return "Bad_EventFilterInvalid";
case Bad__FilterNotAllowed: return "Bad_FilterNotAllowed";
case Bad__FilterOperandInvalid: return "Bad_FilterOperandInvalid";
case Bad__HistoryOperationInvalid: return "Bad_HistoryOperationInvalid";
case Bad__HistoryOperationUnsupported: return "Bad_HistoryOperationUnsupported";
case Bad__IndexRangeInvalid: return "Bad_IndexRangeInvalid";
case Bad__IndexRangeNoData: return "Bad_IndexRangeNoData";
case Bad__MonitoredItemFilterInvalid: return "Bad_MonitoredItemFilterInvalid";
case Bad__MonitoredItemFilterUnsupported: return "Bad_MonitoredItemFilterUnsupported";
case Bad__MonitoredItemIdInvalid: return "Bad_MonitoredItemIdInvalid";
case Bad__MonitoringModeInvalid: return "Bad_MonitoringModeInvalid";
case Bad__NoCommunication: return "Bad_NoCommunication";
case Bad__NoContinuationPoints: return "Bad_NoContinuationPoints";
case Bad__NodeClassInvalid: return "Bad_NodeClassInvalid";
case Bad__NodeIdInvalid: return "Bad_NodeIdInvalid";
case Bad__NodeIdUnknown: return "Bad_NodeIdUnknown";
case Bad__NoDeleteRights: return "Bad_NoDeleteRights";
case Bad__NodeNotInView: return "Bad_NodeNotInView";
case Bad__NotFound: return "Bad_NotFound";
case Bad__NotImplemented: return "Bad_NotImplemented";
case Bad__NotReadable: return "Bad_NotReadable";
case Bad__NotSupported: return "Bad_NotSupported";
case Bad__NotWritable: return "Bad_NotWritable";
case Bad__ObjectDeleted: return "Bad_ObjectDeleted";
case Bad__OutOfRange: return "Bad_OutOfRange";
case Bad__ReferenceTypeIdInvalid: return "Bad_ReferenceTypeIdInvalid";
case Bad__SecurityModeInsufficient: return "Bad_SecurityModeInsufficient";
case Bad__SourceNodeIdInvalid: return "Bad_SourceNodeIdInvalid";
case Bad__StructureMissing: return "Bad_StructureMissing";
case Bad__TargetNodeIdInvalid: return "Bad_TargetNodeIdInvalid";
case Bad__TypeDefinitionInvalid: return "Bad_TypeDefinitionInvalid";
case Bad__TypeMismatch: return "Bad_TypeMismatch";
case Bad__WaitingForInitialData: return "Bad_WaitingForInitialData";
default: return "<unknown>";
}
}

CommonOperationLevelResultCodes::enum_type CommonOperationLevelResultCodes::str_to_enum(const char *str_par)
{
if (!strcmp(str_par, "Good_Clamped")) return Good__Clamped;
else if (!strcmp(str_par, "Good_Overload")) return Good__Overload;
else if (!strcmp(str_par, "Uncertain")) return Uncertain;
else if (!strcmp(str_par, "Bad")) return Bad;
else if (!strcmp(str_par, "Bad_AttributeIdInvalid")) return Bad__AttributeIdInvalid;
else if (!strcmp(str_par, "Bad_BrowseDirectionInvalid")) return Bad__BrowseDirectionInvalid;
else if (!strcmp(str_par, "Bad_BrowseNameInvalid")) return Bad__BrowseNameInvalid;
else if (!strcmp(str_par, "Bad_ContentFilterInvalid")) return Bad__ContentFilterInvalid;
else if (!strcmp(str_par, "Bad_ContinuationPointInvalid")) return Bad__ContinuationPointInvalid;
else if (!strcmp(str_par, "Bad_DataEncodingInvalid")) return Bad__DataEncodingInvalid;
else if (!strcmp(str_par, "Bad_DataEncodingUnsupported")) return Bad__DataEncodingUnsupported;
else if (!strcmp(str_par, "Bad_EventFilterInvalid")) return Bad__EventFilterInvalid;
else if (!strcmp(str_par, "Bad_FilterNotAllowed")) return Bad__FilterNotAllowed;
else if (!strcmp(str_par, "Bad_FilterOperandInvalid")) return Bad__FilterOperandInvalid;
else if (!strcmp(str_par, "Bad_HistoryOperationInvalid")) return Bad__HistoryOperationInvalid;
else if (!strcmp(str_par, "Bad_HistoryOperationUnsupported")) return Bad__HistoryOperationUnsupported;
else if (!strcmp(str_par, "Bad_IndexRangeInvalid")) return Bad__IndexRangeInvalid;
else if (!strcmp(str_par, "Bad_IndexRangeNoData")) return Bad__IndexRangeNoData;
else if (!strcmp(str_par, "Bad_MonitoredItemFilterInvalid")) return Bad__MonitoredItemFilterInvalid;
else if (!strcmp(str_par, "Bad_MonitoredItemFilterUnsupported")) return Bad__MonitoredItemFilterUnsupported;
else if (!strcmp(str_par, "Bad_MonitoredItemIdInvalid")) return Bad__MonitoredItemIdInvalid;
else if (!strcmp(str_par, "Bad_MonitoringModeInvalid")) return Bad__MonitoringModeInvalid;
else if (!strcmp(str_par, "Bad_NoCommunication")) return Bad__NoCommunication;
else if (!strcmp(str_par, "Bad_NoContinuationPoints")) return Bad__NoContinuationPoints;
else if (!strcmp(str_par, "Bad_NodeClassInvalid")) return Bad__NodeClassInvalid;
else if (!strcmp(str_par, "Bad_NodeIdInvalid")) return Bad__NodeIdInvalid;
else if (!strcmp(str_par, "Bad_NodeIdUnknown")) return Bad__NodeIdUnknown;
else if (!strcmp(str_par, "Bad_NoDeleteRights")) return Bad__NoDeleteRights;
else if (!strcmp(str_par, "Bad_NodeNotInView")) return Bad__NodeNotInView;
else if (!strcmp(str_par, "Bad_NotFound")) return Bad__NotFound;
else if (!strcmp(str_par, "Bad_NotImplemented")) return Bad__NotImplemented;
else if (!strcmp(str_par, "Bad_NotReadable")) return Bad__NotReadable;
else if (!strcmp(str_par, "Bad_NotSupported")) return Bad__NotSupported;
else if (!strcmp(str_par, "Bad_NotWritable")) return Bad__NotWritable;
else if (!strcmp(str_par, "Bad_ObjectDeleted")) return Bad__ObjectDeleted;
else if (!strcmp(str_par, "Bad_OutOfRange")) return Bad__OutOfRange;
else if (!strcmp(str_par, "Bad_ReferenceTypeIdInvalid")) return Bad__ReferenceTypeIdInvalid;
else if (!strcmp(str_par, "Bad_SecurityModeInsufficient")) return Bad__SecurityModeInsufficient;
else if (!strcmp(str_par, "Bad_SourceNodeIdInvalid")) return Bad__SourceNodeIdInvalid;
else if (!strcmp(str_par, "Bad_StructureMissing")) return Bad__StructureMissing;
else if (!strcmp(str_par, "Bad_TargetNodeIdInvalid")) return Bad__TargetNodeIdInvalid;
else if (!strcmp(str_par, "Bad_TypeDefinitionInvalid")) return Bad__TypeDefinitionInvalid;
else if (!strcmp(str_par, "Bad_TypeMismatch")) return Bad__TypeMismatch;
else if (!strcmp(str_par, "Bad_WaitingForInitialData")) return Bad__WaitingForInitialData;
else return UNKNOWN_VALUE;
}

boolean CommonOperationLevelResultCodes::is_valid_enum(int int_par)
{
switch (int_par) {
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
case 10:
case 11:
case 12:
case 13:
case 14:
case 15:
case 16:
case 17:
case 18:
case 19:
case 20:
case 21:
case 22:
case 23:
case 24:
case 25:
case 26:
case 27:
case 28:
case 29:
case 30:
case 31:
case 32:
case 33:
case 34:
case 35:
case 36:
case 37:
case 38:
case 39:
case 40:
case 41:
case 42:
case 43:
return TRUE;
default:
return FALSE;
}
}

int CommonOperationLevelResultCodes::enum2int(enum_type enum_par)
{
if (enum_par==UNBOUND_VALUE || enum_par==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par;
}

int CommonOperationLevelResultCodes::enum2int(const CommonOperationLevelResultCodes& enum_par)
{
if (enum_par.enum_value==UNBOUND_VALUE || enum_par.enum_value==UNKNOWN_VALUE) TTCN_error("The argument of function enum2int() is an %s value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.", enum_par==UNBOUND_VALUE?"unbound":"invalid");
return enum_par.enum_value;
}

void CommonOperationLevelResultCodes::int2enum(int int_val)
{
if (!is_valid_enum(int_val)) TTCN_error("Assigning invalid numeric value %d to a variable of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.", int_val);
enum_value = (enum_type)int_val;
}

CommonOperationLevelResultCodes::operator CommonOperationLevelResultCodes::enum_type() const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Using the value of an unbound variable of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return enum_value;
}

void CommonOperationLevelResultCodes::log() const
{
if (enum_value != UNBOUND_VALUE) TTCN_Logger::log_event_enum(enum_to_str(enum_value), enum_value);
else TTCN_Logger::log_event_unbound();
}

void CommonOperationLevelResultCodes::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_VALUE, "enumerated value");
  if (param.get_type()!=Module_Param::MP_Enumerated) param.type_error("enumerated value", "@OpcUa_Common.CommonOperationLevelResultCodes");
  enum_value = str_to_enum(param.get_enumerated());
  if (!is_valid_enum(enum_value)) {
    param.error("Invalid enumerated value for type @OpcUa_Common.CommonOperationLevelResultCodes.");
  }
}

void CommonOperationLevelResultCodes::encode_text(Text_Buf& text_buf) const
{
if (enum_value == UNBOUND_VALUE) TTCN_error("Text encoder: Encoding an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
text_buf.push_int(enum_value);
}

void CommonOperationLevelResultCodes::decode_text(Text_Buf& text_buf)
{
enum_value = (enum_type)text_buf.pull_int().get_val();
if (!is_valid_enum(enum_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.", enum_value);
}

void CommonOperationLevelResultCodes_template::copy_template(const CommonOperationLevelResultCodes_template& other_value)
{
set_selection(other_value);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = other_value.single_value;
break;
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = other_value.value_list.n_values;
value_list.list_value = new CommonOperationLevelResultCodes_template[value_list.n_values];
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
value_list.list_value[list_count].copy_template(other_value.value_list.list_value[list_count]);
break;
default:
TTCN_error("Copying an uninitialized/unsupported template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
}
}

CommonOperationLevelResultCodes_template::CommonOperationLevelResultCodes_template()
{
}

CommonOperationLevelResultCodes_template::CommonOperationLevelResultCodes_template(template_sel other_value)
 : Base_Template(other_value)
{
check_single_selection(other_value);
}

CommonOperationLevelResultCodes_template::CommonOperationLevelResultCodes_template(int other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (!CommonOperationLevelResultCodes::is_valid_enum(other_value)) TTCN_error("Initializing a template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes with unknown numeric value %d.", other_value);
single_value = (CommonOperationLevelResultCodes::enum_type)other_value;
}

CommonOperationLevelResultCodes_template::CommonOperationLevelResultCodes_template(CommonOperationLevelResultCodes::enum_type other_value)
 : Base_Template(SPECIFIC_VALUE)
{
single_value = other_value;
}

CommonOperationLevelResultCodes_template::CommonOperationLevelResultCodes_template(const CommonOperationLevelResultCodes& other_value)
 : Base_Template(SPECIFIC_VALUE)
{
if (other_value.enum_value == CommonOperationLevelResultCodes::UNBOUND_VALUE) TTCN_error("Creating a template from an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
single_value = other_value.enum_value;
}

CommonOperationLevelResultCodes_template::CommonOperationLevelResultCodes_template(const OPTIONAL<CommonOperationLevelResultCodes>& other_value)
{
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (CommonOperationLevelResultCodes::enum_type)(const CommonOperationLevelResultCodes&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Creating a template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes from an unbound optional field.");
}
}

CommonOperationLevelResultCodes_template::CommonOperationLevelResultCodes_template(const CommonOperationLevelResultCodes_template& other_value)
 : Base_Template()
{
copy_template(other_value);
}

CommonOperationLevelResultCodes_template::~CommonOperationLevelResultCodes_template()
{
clean_up();
}

boolean CommonOperationLevelResultCodes_template::is_bound() const
{
if (template_selection == UNINITIALIZED_TEMPLATE && !is_ifpresent) return FALSE;
return TRUE;
}

boolean CommonOperationLevelResultCodes_template::is_value() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) return FALSE;
return single_value != CommonOperationLevelResultCodes::UNBOUND_VALUE;
}

void CommonOperationLevelResultCodes_template::clean_up()
{
if (template_selection == VALUE_LIST || template_selection == COMPLEMENTED_LIST) delete [] value_list.list_value;
template_selection = UNINITIALIZED_TEMPLATE;
}

CommonOperationLevelResultCodes_template& CommonOperationLevelResultCodes_template::operator=(template_sel other_value)
{
check_single_selection(other_value);
clean_up();
set_selection(other_value);
return *this;
}

CommonOperationLevelResultCodes_template& CommonOperationLevelResultCodes_template::operator=(int other_value)
{
if (!CommonOperationLevelResultCodes::is_valid_enum(other_value)) TTCN_warning("Assigning unknown numeric value %d to a template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.", other_value);
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = (CommonOperationLevelResultCodes::enum_type)other_value;
return *this;
}

CommonOperationLevelResultCodes_template& CommonOperationLevelResultCodes_template::operator=(CommonOperationLevelResultCodes::enum_type other_value)
{
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value;
return *this;
}

CommonOperationLevelResultCodes_template& CommonOperationLevelResultCodes_template::operator=(const CommonOperationLevelResultCodes& other_value)
{
if (other_value.enum_value == CommonOperationLevelResultCodes::UNBOUND_VALUE) TTCN_error("Assignment of an unbound value of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes to a template.");
clean_up();
set_selection(SPECIFIC_VALUE);
single_value = other_value.enum_value;
return *this;
}

CommonOperationLevelResultCodes_template& CommonOperationLevelResultCodes_template::operator=(const OPTIONAL<CommonOperationLevelResultCodes>& other_value)
{
clean_up();
switch (other_value.get_selection()) {
case OPTIONAL_PRESENT:
set_selection(SPECIFIC_VALUE);
single_value = (CommonOperationLevelResultCodes::enum_type)(const CommonOperationLevelResultCodes&)other_value;
break;
case OPTIONAL_OMIT:
set_selection(OMIT_VALUE);
break;
default:
TTCN_error("Assignment of an unbound optional field to a template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
}
return *this;
}

CommonOperationLevelResultCodes_template& CommonOperationLevelResultCodes_template::operator=(const CommonOperationLevelResultCodes_template& other_value)
{
if (&other_value != this) {
clean_up();
copy_template(other_value);
}
return *this;
}

boolean CommonOperationLevelResultCodes_template::match(CommonOperationLevelResultCodes::enum_type other_value, boolean) const
{
switch (template_selection) {
case SPECIFIC_VALUE:
return single_value == other_value;
case OMIT_VALUE:
return FALSE;
case ANY_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
for (unsigned int list_count = 0; list_count < value_list.n_values; list_count++)
if (value_list.list_value[list_count].match(other_value)) return template_selection == VALUE_LIST;
return template_selection == COMPLEMENTED_LIST;
default:
TTCN_error("Matching an uninitialized/unsupported template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
}
return FALSE;
}

boolean CommonOperationLevelResultCodes_template::match(const CommonOperationLevelResultCodes& other_value, boolean) const
{
if (other_value.enum_value == CommonOperationLevelResultCodes::UNBOUND_VALUE) TTCN_error("Matching a template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes with an unbound value.");
return match(other_value.enum_value);
}

CommonOperationLevelResultCodes::enum_type CommonOperationLevelResultCodes_template::valueof() const
{
if (template_selection != SPECIFIC_VALUE || is_ifpresent) TTCN_error("Performing a valueof or send operation on a non-specific template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return single_value;
}

void CommonOperationLevelResultCodes_template::set_type(template_sel template_type, unsigned int list_length)
{
if (template_type != VALUE_LIST && template_type != COMPLEMENTED_LIST) TTCN_error("Setting an invalid list type for a template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
clean_up();
set_selection(template_type);
value_list.n_values = list_length;
value_list.list_value = new CommonOperationLevelResultCodes_template[list_length];
}

CommonOperationLevelResultCodes_template& CommonOperationLevelResultCodes_template::list_item(unsigned int list_index)
{
if (template_selection != VALUE_LIST && template_selection != COMPLEMENTED_LIST) TTCN_error("Accessing a list element in a non-list template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
if (list_index >= value_list.n_values) TTCN_error("Index overflow in a value list template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
return value_list.list_value[list_index];
}

void CommonOperationLevelResultCodes_template::log() const
{
switch (template_selection) {
case SPECIFIC_VALUE:
TTCN_Logger::log_event_enum(CommonOperationLevelResultCodes::enum_to_str(single_value), single_value);
break;
case COMPLEMENTED_LIST:
TTCN_Logger::log_event_str("complement ");
case VALUE_LIST:
TTCN_Logger::log_char('(');
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++) {
if (elem_count > 0) TTCN_Logger::log_event_str(", ");
value_list.list_value[elem_count].log();
}
TTCN_Logger::log_char(')');
break;
default:
log_generic();
}
log_ifpresent();
}

void CommonOperationLevelResultCodes_template::log_match(const CommonOperationLevelResultCodes& match_value, boolean) const
{
match_value.log();
TTCN_Logger::log_event_str(" with ");
log();
if (match(match_value)) TTCN_Logger::log_event_str(" matched");
else TTCN_Logger::log_event_str(" unmatched");
}

void CommonOperationLevelResultCodes_template::encode_text(Text_Buf& text_buf) const
{
encode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
text_buf.push_int(single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
text_buf.push_int(value_list.n_values);
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].encode_text(text_buf);
break;
default:
TTCN_error("Text encoder: Encoding an uninitialized/unsupported template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
}
}

void CommonOperationLevelResultCodes_template::decode_text(Text_Buf& text_buf)
{
clean_up();
decode_text_base(text_buf);
switch (template_selection) {
case SPECIFIC_VALUE:
single_value = (CommonOperationLevelResultCodes::enum_type)text_buf.pull_int().get_val();
if (!CommonOperationLevelResultCodes::is_valid_enum(single_value)) TTCN_error("Text decoder: Unknown numeric value %d was received for a template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.", single_value);
case OMIT_VALUE:
case ANY_VALUE:
case ANY_OR_OMIT:
break;
case VALUE_LIST:
case COMPLEMENTED_LIST:
value_list.n_values = text_buf.pull_int().get_val();
value_list.list_value = new CommonOperationLevelResultCodes_template[value_list.n_values];
for (unsigned int elem_count = 0; elem_count < value_list.n_values; elem_count++)
value_list.list_value[elem_count].decode_text(text_buf);
break;
default:
TTCN_error("Text decoder: An unknown/unsupported selection was received for a template of enumerated type @OpcUa_Common.CommonOperationLevelResultCodes.");
}
}

boolean CommonOperationLevelResultCodes_template::is_present(boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return FALSE;
return !match_omit(legacy);
}

boolean CommonOperationLevelResultCodes_template::match_omit(boolean legacy) const
{
if (is_ifpresent) return TRUE;
switch (template_selection) {
case OMIT_VALUE:
case ANY_OR_OMIT:
return TRUE;
case VALUE_LIST:
case COMPLEMENTED_LIST:
if (legacy) {
for (unsigned int i=0; i<value_list.n_values; i++)
if (value_list.list_value[i].match_omit())
return template_selection==VALUE_LIST;
return template_selection==COMPLEMENTED_LIST;
} // else fall through
default:
return FALSE;
}
return FALSE;
}

void CommonOperationLevelResultCodes_template::set_param(Module_Param& param)
{
  param.basic_check(Module_Param::BC_TEMPLATE, "enumerated template");
  Module_Param_Ptr m_p = &param;
  switch (m_p->get_type()) {
  case Module_Param::MP_Omit:
    *this = OMIT_VALUE;
    break;
  case Module_Param::MP_Any:
    *this = ANY_VALUE;
    break;
  case Module_Param::MP_AnyOrNone:
    *this = ANY_OR_OMIT;
    break;
  case Module_Param::MP_List_Template:
  case Module_Param::MP_ComplementList_Template: {
    CommonOperationLevelResultCodes_template new_temp;
    new_temp.set_type(m_p->get_type()==Module_Param::MP_List_Template ? VALUE_LIST : COMPLEMENTED_LIST, m_p->get_size());
    for (size_t p_i=0; p_i<m_p->get_size(); p_i++) {
      new_temp.list_item(p_i).set_param(*m_p->get_elem(p_i));
    }
    *this = new_temp;
    break; }
  case Module_Param::MP_Enumerated: {
    CommonOperationLevelResultCodes::enum_type enum_val = CommonOperationLevelResultCodes::str_to_enum(m_p->get_enumerated());
    if (!CommonOperationLevelResultCodes::is_valid_enum(enum_val)) {
      param.error("Invalid enumerated value for type @OpcUa_Common.CommonOperationLevelResultCodes.");
    }
    *this = enum_val;
  } break;
  default:
    param.type_error("enumerated template", "@OpcUa_Common.CommonOperationLevelResultCodes");
  }
  is_ifpresent = param.get_ifpresent();
}

void CommonOperationLevelResultCodes_template::check_restriction(template_res t_res, const char* t_name,
boolean legacy) const
{
if (template_selection==UNINITIALIZED_TEMPLATE) return;
switch ((t_name&&(t_res==TR_VALUE))?TR_OMIT:t_res) {
case TR_VALUE:
if (!is_ifpresent && template_selection==SPECIFIC_VALUE) return;
break;
case TR_OMIT:
if (!is_ifpresent && (template_selection==OMIT_VALUE || template_selection==SPECIFIC_VALUE)) return;
break;
case TR_PRESENT:
if (!match_omit(legacy)) return;
break;
default:
return;
}
TTCN_error("Restriction `%s' on template of type %s violated.", get_res_name(t_res), t_name ? t_name : "@OpcUa_Common.CommonOperationLevelResultCodes");
}


/* Bodies of static functions */

static void pre_init_module()
{
TTCN_Location current_location("OpcUa_Common.ttcn", 0, TTCN_Location::LOCATION_UNKNOWN, "OpcUa_Common");
current_location.update_lineno(18);
/* OpcUa_Common.ttcn, line 18 */
{ INTEGER INTEGER_tmp("2155675648");
const_Bad__TcpServerTooBusy = INTEGER_tmp; }
current_location.update_lineno(19);
/* OpcUa_Common.ttcn, line 19 */
{ INTEGER INTEGER_tmp("2155741184");
const_Bad__TcpMessageTypeInvalid = INTEGER_tmp; }
current_location.update_lineno(20);
/* OpcUa_Common.ttcn, line 20 */
{ INTEGER INTEGER_tmp("2155806720");
const_Bad__TcpSecureChannelUnknown = INTEGER_tmp; }
current_location.update_lineno(21);
/* OpcUa_Common.ttcn, line 21 */
{ INTEGER INTEGER_tmp("2155872256");
const_Bad__TcpMessageTooLarge = INTEGER_tmp; }
current_location.update_lineno(22);
/* OpcUa_Common.ttcn, line 22 */
{ INTEGER INTEGER_tmp("2148139008");
const_Bad__Timeout = INTEGER_tmp; }
current_location.update_lineno(23);
/* OpcUa_Common.ttcn, line 23 */
{ INTEGER INTEGER_tmp("2155937792");
const_Bad__TcpNotEnoughResources = INTEGER_tmp; }
current_location.update_lineno(24);
/* OpcUa_Common.ttcn, line 24 */
{ INTEGER INTEGER_tmp("2156003328");
const_Bad__TcpInternalError = INTEGER_tmp; }
current_location.update_lineno(25);
/* OpcUa_Common.ttcn, line 25 */
{ INTEGER INTEGER_tmp("2156068864");
const_Bad__TcpEndpointUrlInvalid = INTEGER_tmp; }
current_location.update_lineno(26);
/* OpcUa_Common.ttcn, line 26 */
{ INTEGER INTEGER_tmp("2148728832");
const_Bad__SecurityChecksFailed = INTEGER_tmp; }
current_location.update_lineno(27);
/* OpcUa_Common.ttcn, line 27 */
{ INTEGER INTEGER_tmp("2156134400");
const_Bad__RequestInterrupted = INTEGER_tmp; }
current_location.update_lineno(28);
/* OpcUa_Common.ttcn, line 28 */
{ INTEGER INTEGER_tmp("2156199936");
const_Bad__RequestTimeout = INTEGER_tmp; }
current_location.update_lineno(29);
/* OpcUa_Common.ttcn, line 29 */
{ INTEGER INTEGER_tmp("2156265472");
const_Bad__SecureChannelClosed = INTEGER_tmp; }
current_location.update_lineno(30);
/* OpcUa_Common.ttcn, line 30 */
{ INTEGER INTEGER_tmp("2156331008");
const_Bad__SecureChannelTokenUnknown = INTEGER_tmp; }
current_location.update_lineno(31);
/* OpcUa_Common.ttcn, line 31 */
{ INTEGER INTEGER_tmp("2156396544");
const_Bad__CertificateUntrusted = INTEGER_tmp; }
current_location.update_lineno(32);
/* OpcUa_Common.ttcn, line 32 */
{ INTEGER INTEGER_tmp("2148794368");
const_Bad__CertificateTimeInvalid = INTEGER_tmp; }
current_location.update_lineno(33);
/* OpcUa_Common.ttcn, line 33 */
{ INTEGER INTEGER_tmp("2148859904");
const_Bad__CertificateIssuerTimeInvalid = INTEGER_tmp; }
current_location.update_lineno(34);
/* OpcUa_Common.ttcn, line 34 */
{ INTEGER INTEGER_tmp("2149056512");
const_Bad__CertificateUseNotAllowed = INTEGER_tmp; }
current_location.update_lineno(35);
/* OpcUa_Common.ttcn, line 35 */
{ INTEGER INTEGER_tmp("2149122048");
const_Bad__CertificateIssuerUseNotAllowed = INTEGER_tmp; }
current_location.update_lineno(36);
/* OpcUa_Common.ttcn, line 36 */
{ INTEGER INTEGER_tmp("2149253120");
const_Bad__CertificateRevocationUnknown = INTEGER_tmp; }
current_location.update_lineno(37);
/* OpcUa_Common.ttcn, line 37 */
{ INTEGER INTEGER_tmp("2149318656");
const_Bad__CertificateIssuerRevocationUnknown = INTEGER_tmp; }
current_location.update_lineno(38);
/* OpcUa_Common.ttcn, line 38 */
{ INTEGER INTEGER_tmp("2149384192");
const_Bad__CertificateRevoked = INTEGER_tmp; }
}


} /* end of namespace */
