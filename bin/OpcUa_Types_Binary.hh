// This C++ header file was generated by the TTCN-3 compiler
// of the TTCN-3 Test Executor version CRL 113 200/6 R3A
// for AvdootChalke (avdootchalke@avdootchalke-VirtualBox) on Thu Jul 26 15:22:27 2018

// Copyright (c) 2000-2017 Ericsson Telecom AB

// Do not edit this file unless you know what you are doing.

#ifndef OpcUa__Types__Binary_HH
#define OpcUa__Types__Binary_HH

#ifdef TITAN_RUNTIME_2
#error Generated code does not match with used runtime.\
 Code was generated without -R option but -DTITAN_RUNTIME_2 was used.
#endif

/* Header file includes */

#include <TTCN3.hh>

#if TTCN3_VERSION != 60300
#error Version mismatch detected.\
 Please check the version of the TTCN-3 compiler and the base library.\
 Run make clean and rebuild the project if the version of the compiler changed recently.
#endif

#ifndef LINUX
#error This file should be compiled on LINUX
#endif

#undef OpcUa__Types__Binary_HH
#endif

namespace OpcUa__Types__Binary {

/* Forward declarations of classes */

class MessageSecurityMode;
class MessageSecurityMode_template;
class SecurityTokenRequestType;
class SecurityTokenRequestType_template;
class NodeClass;
class NodeClass_template;
class StructureType;
class StructureType_template;
class ApplicationType;
class ApplicationType_template;
class DataChangeTrigger;
class DataChangeTrigger_template;
class MonitoringMode;
class MonitoringMode_template;
class BrowseDirection;
class BrowseDirection_template;
class TimestampsToReturn;
class TimestampsToReturn_template;
class UserIdentityTokenType;
class UserIdentityTokenType_template;
class PerformUpdateType;
class PerformUpdateType_template;
class PerformUpdateTypeExtended;
class PerformUpdateTypeExtended_template;
class IdType;
class IdType_template;
class FilterOperator;
class FilterOperator_template;
class OpenFileMode;
class OpenFileMode_template;
class TrustListMasks;
class TrustListMasks_template;
class ByteString;
class ByteString_template;
class NullArray;
class NullArray_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER ByteArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template ByteArray_template;
class RealByteString;
class RealByteString_template;
class String;
class String_template;
class NonNullString;
class NonNullString_template;
class NodeIdType;
class NodeIdType_template;
class TwoByteNodeId;
class TwoByteNodeId_template;
class FourByteNodeId;
class FourByteNodeId_template;
class NumericNodeId;
class NumericNodeId_template;
class StringNodeId;
class StringNodeId_template;
class Guid;
class Guid_template;
class GuidNodeId;
class GuidNodeId_template;
class ByteStringNodeId;
class ByteStringNodeId_template;
class NodeId;
class NodeId_template;
class ExpandedNodeId;
class ExpandedNodeId_template;
class ExtensibleParameter;
class ExtensibleParameter_template;
class ExtensibleParameterBody;
class ExtensibleParameterBody_template;
class ElementOperand;
class ElementOperand_template;
class Variant;
class Variant_template;
class VariantSingleValue;
class VariantSingleValue_template;
class QualifiedName;
class QualifiedName_template;
class LocalizedText;
class LocalizedText_template;
class ExtensionObject;
class ExtensionObject_template;
class ExtensionObjectBody;
class ExtensionObjectBody_template;
class ListOfByte;
class ListOfByte_template;
class ListOfByteArray;
class ListOfByteArray_template;
class DataValue;
class DataValue_template;
class ListOfVariant;
class ListOfVariant_template;
class VariantArray;
class VariantArray_template;
class ListOfVariantArray;
class ListOfVariantArray_template;
class DiagnosticInfo;
class DiagnosticInfo_template;
class VariantArrayValue;
class VariantArrayValue_template;
class ListOfBoolean;
class ListOfBoolean_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER BooleanArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template BooleanArray_template;
class ListOfBooleanArray;
class ListOfBooleanArray_template;
class ListOfSByte;
class ListOfSByte_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER SByteArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template SByteArray_template;
class ListOfSByteArray;
class ListOfSByteArray_template;
class ListOfInt16;
class ListOfInt16_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER Int16Array;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template Int16Array_template;
class ListOfInt16Array;
class ListOfInt16Array_template;
class ListOfUInt16;
class ListOfUInt16_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER UInt16Array;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template UInt16Array_template;
class ListOfUInt16Array;
class ListOfUInt16Array_template;
class ListOfInt32;
class ListOfInt32_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER Int32Array;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template Int32Array_template;
class ListOfInt32Array;
class ListOfInt32Array_template;
class ListOfUInt32;
class ListOfUInt32_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER UInt32Array;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template UInt32Array_template;
class ListOfUInt32Array;
class ListOfUInt32Array_template;
class ListOfInt64;
class ListOfInt64_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER Int64Array;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template Int64Array_template;
class ListOfInt64Array;
class ListOfInt64Array_template;
class ListOfUInt64;
class ListOfUInt64_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER UInt64Array;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template UInt64Array_template;
class ListOfUInt64Array;
class ListOfUInt64Array_template;
class ListOfFloat;
class ListOfFloat_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__FLOAT FloatArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__FLOAT_template FloatArray_template;
class ListOfFloatArray;
class ListOfFloatArray_template;
class ListOfDouble;
class ListOfDouble_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__FLOAT DoubleArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__FLOAT_template DoubleArray_template;
class ListOfDoubleArray;
class ListOfDoubleArray_template;
class ListOfString;
class ListOfString_template;
class StringArray;
class StringArray_template;
class ListOfStringArray;
class ListOfStringArray_template;
class ListOfDateTime;
class ListOfDateTime_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER DateTimeArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template DateTimeArray_template;
class ListOfDateTimeArray;
class ListOfDateTimeArray_template;
class ListOfGuid;
class ListOfGuid_template;
class GuidArray;
class GuidArray_template;
class ListOfGuidArray;
class ListOfGuidArray_template;
class ListOfByteString;
class ListOfByteString_template;
class ByteStringArray;
class ByteStringArray_template;
class ListOfByteStringArray;
class ListOfByteStringArray_template;
class ListOfXmlElement;
class ListOfXmlElement_template;
class XmlElementArray;
class XmlElementArray_template;
class ListOfXmlElementArray;
class ListOfXmlElementArray_template;
class ListOfNodeId;
class ListOfNodeId_template;
class NodeIdArray;
class NodeIdArray_template;
class ListOfNodeIdArray;
class ListOfNodeIdArray_template;
class ListOfExpandedNodeId;
class ListOfExpandedNodeId_template;
class ExpandedNodeIdArray;
class ExpandedNodeIdArray_template;
class ListOfExpandedNodeIdArray;
class ListOfExpandedNodeIdArray_template;
class ListOfStatusCode;
class ListOfStatusCode_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER StatusCodeArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template StatusCodeArray_template;
class ListOfStatusCodeArray;
class ListOfStatusCodeArray_template;
class ListOfQualifiedName;
class ListOfQualifiedName_template;
class QualifiedNameArray;
class QualifiedNameArray_template;
class ListOfQualifiedNameArray;
class ListOfQualifiedNameArray_template;
class ListOfLocalizedText;
class ListOfLocalizedText_template;
class LocalizedTextArray;
class LocalizedTextArray_template;
class ListOfLocalizedTextArray;
class ListOfLocalizedTextArray_template;
class ListOfExtensionObject;
class ListOfExtensionObject_template;
class ExtensionObjectArray;
class ExtensionObjectArray_template;
class ListOfExtensionObjectArray;
class ListOfExtensionObjectArray_template;
class ListOfDataValue;
class ListOfDataValue_template;
class DataValueArray;
class DataValueArray_template;
class ListOfDataValueArray;
class ListOfDataValueArray_template;
class ListOfDiagnosticInfo;
class ListOfDiagnosticInfo_template;
class DiagnosticInfoArray;
class DiagnosticInfoArray_template;
class ListOfDiagnosticInfoArray;
class ListOfDiagnosticInfoArray_template;
class LiteralOperand;
class LiteralOperand_template;
class ListOfRelativePathElement;
class ListOfRelativePathElement_template;
class RelativePathElementArray;
class RelativePathElementArray_template;
class RelativePathElement;
class RelativePathElement_template;
class ListOfRelativePathElementArray;
class ListOfRelativePathElementArray_template;
class RelativePath;
class RelativePath_template;
class AttributeOperand;
class AttributeOperand_template;
class SimpleAttributeOperand;
class SimpleAttributeOperand_template;
class DataChangeFilter;
class DataChangeFilter_template;
class ListOfSimpleAttributeOperand;
class ListOfSimpleAttributeOperand_template;
class SimpleAttributeOperandArray;
class SimpleAttributeOperandArray_template;
class ListOfSimpleAttributeOperandArray;
class ListOfSimpleAttributeOperandArray_template;
class ListOfContentFilterElement;
class ListOfContentFilterElement_template;
class ContentFilterElementArray;
class ContentFilterElementArray_template;
class ListOfExtensibleParameter;
class ListOfExtensibleParameter_template;
class ExtensibleParameterArray;
class ExtensibleParameterArray_template;
class ListOfExtensibleParameterArray;
class ListOfExtensibleParameterArray_template;
class ContentFilterElement;
class ContentFilterElement_template;
class ListOfContentFilterElementArray;
class ListOfContentFilterElementArray_template;
class ContentFilter;
class ContentFilter_template;
class EventFilter;
class EventFilter_template;
class AggregateConfiguration;
class AggregateConfiguration_template;
class AggregateFilter;
class AggregateFilter_template;
class ListOfContentFilterElementResult;
class ListOfContentFilterElementResult_template;
class ContentFilterElementResultArray;
class ContentFilterElementResultArray_template;
class ContentFilterElementResult;
class ContentFilterElementResult_template;
class ListOfContentFilterElementResultArray;
class ListOfContentFilterElementResultArray_template;
class ContentFilterResult;
class ContentFilterResult_template;
class EventFilterResult;
class EventFilterResult_template;
class AggregateFilterResult;
class AggregateFilterResult_template;
class ObjectAttributes;
class ObjectAttributes_template;
class VariableAttributes;
class VariableAttributes_template;
class MethodAttributes;
class MethodAttributes_template;
class ObjectTypeAttributes;
class ObjectTypeAttributes_template;
class VariableTypeAttributes;
class VariableTypeAttributes_template;
class ReferenceTypeAttributes;
class ReferenceTypeAttributes_template;
class DataTypeAttributes;
class DataTypeAttributes_template;
class ViewAttributes;
class ViewAttributes_template;
class ListOfGenericAttributeValue;
class ListOfGenericAttributeValue_template;
class GenericAttributeValueArray;
class GenericAttributeValueArray_template;
class GenericAttributeValue;
class GenericAttributeValue_template;
class ListOfGenericAttributeValueArray;
class ListOfGenericAttributeValueArray_template;
class GenericAttributes;
class GenericAttributes_template;
class UserNameIdentityToken;
class UserNameIdentityToken_template;
class X509IdentityToken;
class X509IdentityToken_template;
class IssuedIdentityToken;
class IssuedIdentityToken_template;
class AnonymousIdentityToken;
class AnonymousIdentityToken_template;
class MdnsDiscoveryConfiguration;
class MdnsDiscoveryConfiguration_template;
class ReadEventDetails;
class ReadEventDetails_template;
class ReadRawModifiedDetails;
class ReadRawModifiedDetails_template;
class ReadProcessedDetails;
class ReadProcessedDetails_template;
class ListOfUtcTime;
class ListOfUtcTime_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER UtcTimeArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template UtcTimeArray_template;
class ListOfUtcTimeArray;
class ListOfUtcTimeArray_template;
class ReadAtTimeDetails;
class ReadAtTimeDetails_template;
class UpdateDataDetails;
class UpdateDataDetails_template;
class UpdateStructureDataDetails;
class UpdateStructureDataDetails_template;
class UpdateEventDetails;
class UpdateEventDetails_template;
class DeleteRawModifiedDetails;
class DeleteRawModifiedDetails_template;
class DeleteAtTimeDetails;
class DeleteAtTimeDetails_template;
class DeleteEventDetails;
class DeleteEventDetails_template;
class ListOfMonitoredItemNotification;
class ListOfMonitoredItemNotification_template;
class MonitoredItemNotificationArray;
class MonitoredItemNotificationArray_template;
class MonitoredItemNotification;
class MonitoredItemNotification_template;
class ListOfMonitoredItemNotificationArray;
class ListOfMonitoredItemNotificationArray_template;
class DataChangeNotification;
class DataChangeNotification_template;
class ListOfEventFieldList;
class ListOfEventFieldList_template;
class EventFieldListArray;
class EventFieldListArray_template;
class ListOfBaseDataType;
class ListOfBaseDataType_template;
class EventFieldList;
class EventFieldList_template;
class ListOfEventFieldListArray;
class ListOfEventFieldListArray_template;
class EventNotificationList;
class EventNotificationList_template;
class StatusChangeNotification;
class StatusChangeNotification_template;
class Decimal;
class Decimal_template;
class TimeZoneDataType;
class TimeZoneDataType_template;
class Argument;
class Argument_template;
class EnumValueType;
class EnumValueType_template;
class OptionSet;
class OptionSet_template;
class ListOfStructureField;
class ListOfStructureField_template;
class StructureFieldArray;
class StructureFieldArray_template;
class StructureField;
class StructureField_template;
class ListOfStructureFieldArray;
class ListOfStructureFieldArray_template;
class StructureDefinition;
class StructureDefinition_template;
class ListOfEnumField;
class ListOfEnumField_template;
class EnumFieldArray;
class EnumFieldArray_template;
class EnumField;
class EnumField_template;
class ListOfEnumFieldArray;
class ListOfEnumFieldArray_template;
class EnumDefinition;
class EnumDefinition_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER CounterArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template CounterArray_template;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER IntegerIdArray;
typedef PreGenRecordOf::PREGEN__RECORD__OF__INTEGER_template IntegerIdArray_template;
class LocaleIdArray;
class LocaleIdArray_template;
class ContinuationPointArray;
class ContinuationPointArray_template;
class DecimalArray;
class DecimalArray_template;
class EnumValueTypeArray;
class EnumValueTypeArray_template;
class ApplicationDescriptionArray;
class ApplicationDescriptionArray_template;
class ApplicationDescription;
class ApplicationDescription_template;
class BrowseResultArray;
class BrowseResultArray_template;
class ListOfReferenceDescription;
class ListOfReferenceDescription_template;
class ReferenceDescriptionArray;
class ReferenceDescriptionArray_template;
class ReferenceDescription;
class ReferenceDescription_template;
class ListOfReferenceDescriptionArray;
class ListOfReferenceDescriptionArray_template;
class BrowseResult;
class BrowseResult_template;
class EndpointDescriptionArray;
class EndpointDescriptionArray_template;
class ListOfUserTokenPolicy;
class ListOfUserTokenPolicy_template;
class UserTokenPolicyArray;
class UserTokenPolicyArray_template;
class UserTokenPolicy;
class UserTokenPolicy_template;
class ListOfUserTokenPolicyArray;
class ListOfUserTokenPolicyArray_template;
class EndpointDescription;
class EndpointDescription_template;
class MonitoringParametersArray;
class MonitoringParametersArray_template;
class MonitoringParameters;
class MonitoringParameters_template;
class QueryDataSetArray;
class QueryDataSetArray_template;
class QueryDataSet;
class QueryDataSet_template;
class ReadValueIdArray;
class ReadValueIdArray_template;
class ReadValueId;
class ReadValueId_template;
class ApplicationInstanceCertificateArray;
class ApplicationInstanceCertificateArray_template;
class ApplicationInstanceIssuerIdentifier;
class ApplicationInstanceIssuerIdentifier_template;
class ApplicationInstanceSubjectIdentifier;
class ApplicationInstanceSubjectIdentifier_template;
class ApplicationInstanceCertificate;
class ApplicationInstanceCertificate_template;
class ChannelSecurityTokenArray;
class ChannelSecurityTokenArray_template;
class ChannelSecurityToken;
class ChannelSecurityToken_template;
class ServerOnNetworkArray;
class ServerOnNetworkArray_template;
class ServerOnNetwork;
class ServerOnNetwork_template;
class AddNodesItemArray;
class AddNodesItemArray_template;
class AddNodesItem;
class AddNodesItem_template;
class AddNodesResultArray;
class AddNodesResultArray_template;
class AddNodesResult;
class AddNodesResult_template;
class AddReferencesItemArray;
class AddReferencesItemArray_template;
class AddReferencesItem;
class AddReferencesItem_template;
class DeleteNodesItemArray;
class DeleteNodesItemArray_template;
class DeleteNodesItem;
class DeleteNodesItem_template;
class DeleteReferencesItemArray;
class DeleteReferencesItemArray_template;
class DeleteReferencesItem;
class DeleteReferencesItem_template;
class SignedSoftwareCertificateArray;
class SignedSoftwareCertificateArray_template;
class SignedSoftwareCertificate;
class SignedSoftwareCertificate_template;
class BrowseDescriptionArray;
class BrowseDescriptionArray_template;
class BrowseDescription;
class BrowseDescription_template;
class BrowsePathArray;
class BrowsePathArray_template;
class BrowsePath;
class BrowsePath_template;
class BrowsePathResultArray;
class BrowsePathResultArray_template;
class ListOfBrowsePathTarget;
class ListOfBrowsePathTarget_template;
class BrowsePathTargetArray;
class BrowsePathTargetArray_template;
class BrowsePathTarget;
class BrowsePathTarget_template;
class ListOfBrowsePathTargetArray;
class ListOfBrowsePathTargetArray_template;
class BrowsePathResult;
class BrowsePathResult_template;
class NodeTypeDescriptionArray;
class NodeTypeDescriptionArray_template;
class ListOfQueryDataDescription;
class ListOfQueryDataDescription_template;
class QueryDataDescriptionArray;
class QueryDataDescriptionArray_template;
class QueryDataDescription;
class QueryDataDescription_template;
class ListOfQueryDataDescriptionArray;
class ListOfQueryDataDescriptionArray_template;
class NodeTypeDescription;
class NodeTypeDescription_template;
class ParsingResultArray;
class ParsingResultArray_template;
class ParsingResult;
class ParsingResult_template;
class HistoryReadValueIdArray;
class HistoryReadValueIdArray_template;
class HistoryReadValueId;
class HistoryReadValueId_template;
class HistoryReadResultArray;
class HistoryReadResultArray_template;
class HistoryReadResult;
class HistoryReadResult_template;
class WriteValueArray;
class WriteValueArray_template;
class WriteValue;
class WriteValue_template;
class HistoryUpdateResultArray;
class HistoryUpdateResultArray_template;
class HistoryUpdateResult;
class HistoryUpdateResult_template;
class CallMethodRequestArray;
class CallMethodRequestArray_template;
class CallMethodRequest;
class CallMethodRequest_template;
class CallMethodResultArray;
class CallMethodResultArray_template;
class CallMethodResult;
class CallMethodResult_template;
class MonitoredItemCreateRequestArray;
class MonitoredItemCreateRequestArray_template;
class MonitoredItemCreateRequest;
class MonitoredItemCreateRequest_template;
class MonitoredItemCreateResultArray;
class MonitoredItemCreateResultArray_template;
class MonitoredItemCreateResult;
class MonitoredItemCreateResult_template;
class MonitoredItemModifyRequestArray;
class MonitoredItemModifyRequestArray_template;
class MonitoredItemModifyRequest;
class MonitoredItemModifyRequest_template;
class MonitoredItemModifyResultArray;
class MonitoredItemModifyResultArray_template;
class MonitoredItemModifyResult;
class MonitoredItemModifyResult_template;
class SubscriptionAcknowledgementArray;
class SubscriptionAcknowledgementArray_template;
class SubscriptionAcknowledgement;
class SubscriptionAcknowledgement_template;
class TransferResultArray;
class TransferResultArray_template;
class ListOfCounter;
class ListOfCounter_template;
class ListOfCounterArray;
class ListOfCounterArray_template;
class TransferResult;
class TransferResult_template;
class ListOfIntegerIdArray;
class ListOfIntegerIdArray_template;
class ListOfLocaleIdArray;
class ListOfLocaleIdArray_template;
class ListOfContinuationPointArray;
class ListOfContinuationPointArray_template;
class ListOfDecimalArray;
class ListOfDecimalArray_template;
class ListOfEnumValueTypeArray;
class ListOfEnumValueTypeArray_template;
class ListOfApplicationDescriptionArray;
class ListOfApplicationDescriptionArray_template;
class ListOfBrowseResultArray;
class ListOfBrowseResultArray_template;
class ListOfEndpointDescriptionArray;
class ListOfEndpointDescriptionArray_template;
class ListOfMonitoringParametersArray;
class ListOfMonitoringParametersArray_template;
class ListOfQueryDataSetArray;
class ListOfQueryDataSetArray_template;
class ListOfReadValueIdArray;
class ListOfReadValueIdArray_template;
class ListOfApplicationInstanceCertificateArray;
class ListOfApplicationInstanceCertificateArray_template;
class ListOfChannelSecurityTokenArray;
class ListOfChannelSecurityTokenArray_template;
class ListOfServerOnNetworkArray;
class ListOfServerOnNetworkArray_template;
class ListOfAddNodesItemArray;
class ListOfAddNodesItemArray_template;
class ListOfAddNodesResultArray;
class ListOfAddNodesResultArray_template;
class ListOfAddReferencesItemArray;
class ListOfAddReferencesItemArray_template;
class ListOfDeleteNodesItemArray;
class ListOfDeleteNodesItemArray_template;
class ListOfDeleteReferencesItemArray;
class ListOfDeleteReferencesItemArray_template;
class ListOfSignedSoftwareCertificateArray;
class ListOfSignedSoftwareCertificateArray_template;
class ListOfBrowseDescriptionArray;
class ListOfBrowseDescriptionArray_template;
class ListOfBrowsePathArray;
class ListOfBrowsePathArray_template;
class ListOfBrowsePathResultArray;
class ListOfBrowsePathResultArray_template;
class ListOfNodeTypeDescriptionArray;
class ListOfNodeTypeDescriptionArray_template;
class ListOfParsingResultArray;
class ListOfParsingResultArray_template;
class ListOfHistoryReadValueIdArray;
class ListOfHistoryReadValueIdArray_template;
class ListOfHistoryReadResultArray;
class ListOfHistoryReadResultArray_template;
class ListOfWriteValueArray;
class ListOfWriteValueArray_template;
class ListOfHistoryUpdateResultArray;
class ListOfHistoryUpdateResultArray_template;
class ListOfCallMethodRequestArray;
class ListOfCallMethodRequestArray_template;
class ListOfCallMethodResultArray;
class ListOfCallMethodResultArray_template;
class ListOfMonitoredItemCreateRequestArray;
class ListOfMonitoredItemCreateRequestArray_template;
class ListOfMonitoredItemCreateResultArray;
class ListOfMonitoredItemCreateResultArray_template;
class ListOfMonitoredItemModifyRequestArray;
class ListOfMonitoredItemModifyRequestArray_template;
class ListOfMonitoredItemModifyResultArray;
class ListOfMonitoredItemModifyResultArray_template;
class ListOfSubscriptionAcknowledgementArray;
class ListOfSubscriptionAcknowledgementArray_template;
class ListOfTransferResultArray;
class ListOfTransferResultArray_template;
class ListOfIntegerId;
class ListOfIntegerId_template;
class ListOfLocaleId;
class ListOfLocaleId_template;
class ListOfContinuationPoint;
class ListOfContinuationPoint_template;
class ListOfDecimal;
class ListOfDecimal_template;
class ListOfEnumValueType;
class ListOfEnumValueType_template;
class ListOfApplicationDescription;
class ListOfApplicationDescription_template;
class ListOfBrowseResult;
class ListOfBrowseResult_template;
class ListOfEndpointDescription;
class ListOfEndpointDescription_template;
class ListOfMonitoringParameters;
class ListOfMonitoringParameters_template;
class ListOfQueryDataSet;
class ListOfQueryDataSet_template;
class ListOfReadValueId;
class ListOfReadValueId_template;
class ListOfApplicationInstanceCertificate;
class ListOfApplicationInstanceCertificate_template;
class ListOfChannelSecurityToken;
class ListOfChannelSecurityToken_template;
class ListOfServerOnNetwork;
class ListOfServerOnNetwork_template;
class ListOfAddNodesItem;
class ListOfAddNodesItem_template;
class ListOfAddNodesResult;
class ListOfAddNodesResult_template;
class ListOfAddReferencesItem;
class ListOfAddReferencesItem_template;
class ListOfDeleteNodesItem;
class ListOfDeleteNodesItem_template;
class ListOfDeleteReferencesItem;
class ListOfDeleteReferencesItem_template;
class ListOfSignedSoftwareCertificate;
class ListOfSignedSoftwareCertificate_template;
class ListOfBrowseDescription;
class ListOfBrowseDescription_template;
class ListOfBrowsePath;
class ListOfBrowsePath_template;
class ListOfBrowsePathResult;
class ListOfBrowsePathResult_template;
class ListOfNodeTypeDescription;
class ListOfNodeTypeDescription_template;
class ListOfParsingResult;
class ListOfParsingResult_template;
class ListOfHistoryReadValueId;
class ListOfHistoryReadValueId_template;
class ListOfHistoryReadResult;
class ListOfHistoryReadResult_template;
class ListOfWriteValue;
class ListOfWriteValue_template;
class ListOfHistoryUpdateResult;
class ListOfHistoryUpdateResult_template;
class ListOfCallMethodRequest;
class ListOfCallMethodRequest_template;
class ListOfCallMethodResult;
class ListOfCallMethodResult_template;
class ListOfMonitoredItemCreateRequest;
class ListOfMonitoredItemCreateRequest_template;
class ListOfMonitoredItemCreateResult;
class ListOfMonitoredItemCreateResult_template;
class ListOfMonitoredItemModifyRequest;
class ListOfMonitoredItemModifyRequest_template;
class ListOfMonitoredItemModifyResult;
class ListOfMonitoredItemModifyResult_template;
class ListOfSubscriptionAcknowledgement;
class ListOfSubscriptionAcknowledgement_template;
class ListOfTransferResult;
class ListOfTransferResult_template;
class NotificationMessage;
class NotificationMessage_template;
class RegisteredServer;
class RegisteredServer_template;
class EncryptedSecret;
class EncryptedSecret_template;
class RsaEncryptedSecret;
class RsaEncryptedSecret_template;
class ViewDescription;
class ViewDescription_template;
class TrustListDataType;
class TrustListDataType_template;
class SignatureData;
class SignatureData_template;
class MessageHeader;
class MessageHeader_template;
class SecurityHeader;
class SecurityHeader_template;
class AsymmetricSecurityHeader;
class AsymmetricSecurityHeader_template;
class SymmetricSecurityHeader;
class SymmetricSecurityHeader_template;
class SequenceHeader;
class SequenceHeader_template;
class MessageFooter;
class MessageFooter_template;
class AdditionalHeader;
class AdditionalHeader_template;
class RequestHeader;
class RequestHeader_template;
class ResponseHeader;
class ResponseHeader_template;
class ServiceFault;
class ServiceFault_template;
class HelloMessage;
class HelloMessage_template;
class AckMessage;
class AckMessage_template;
class ErrorMessage;
class ErrorMessage_template;
class ReverseHelloMessage;
class ReverseHelloMessage_template;
class FindServiceRequest;
class FindServiceRequest_template;
class FindServiceResponse;
class FindServiceResponse_template;
class FindServersOnNetworkRequest;
class FindServersOnNetworkRequest_template;
class FindServersOnNetworkResponse;
class FindServersOnNetworkResponse_template;
class GetEndpointsRequest;
class GetEndpointsRequest_template;
class GetEndpointsResponse;
class GetEndpointsResponse_template;
class RegisterServerRequest;
class RegisterServerRequest_template;
class RegisterServerResponse;
class RegisterServerResponse_template;
class RegisterServer2Request;
class RegisterServer2Request_template;
class RegisterServer2Response;
class RegisterServer2Response_template;
class OpenSecureChannelRequest;
class OpenSecureChannelRequest_template;
class OpenSecureChannelResponse;
class OpenSecureChannelResponse_template;
class CloseSecureChannelRequest;
class CloseSecureChannelRequest_template;
class CloseSecureChannelResponse;
class CloseSecureChannelResponse_template;
class CreateSessionRequest;
class CreateSessionRequest_template;
class CreateSessionResponse;
class CreateSessionResponse_template;
class ActivateSessionRequest;
class ActivateSessionRequest_template;
class ActivateSessionResponse;
class ActivateSessionResponse_template;
class CloseSessionRequest;
class CloseSessionRequest_template;
class CloseSessionResponse;
class CloseSessionResponse_template;
class CancelRequestRequest;
class CancelRequestRequest_template;
class CancelRequestResponse;
class CancelRequestResponse_template;
class AddNodesRequest;
class AddNodesRequest_template;
class AddNodesResponse;
class AddNodesResponse_template;
class AddReferencesRequest;
class AddReferencesRequest_template;
class AddReferencesResponse;
class AddReferencesResponse_template;
class DeleteNodesRequest;
class DeleteNodesRequest_template;
class DeleteNodesResponse;
class DeleteNodesResponse_template;
class DeleteReferencesRequest;
class DeleteReferencesRequest_template;
class DeleteReferencesResponse;
class DeleteReferencesResponse_template;
class BrowseRequest;
class BrowseRequest_template;
class BrowseResponse;
class BrowseResponse_template;
class BrowseNextRequest;
class BrowseNextRequest_template;
class BrowseNextResponse;
class BrowseNextResponse_template;
class TranslateBrowsePathsToNodeIdsRequest;
class TranslateBrowsePathsToNodeIdsRequest_template;
class TranslateBrowsePathsToNodeIdsResponse;
class TranslateBrowsePathsToNodeIdsResponse_template;
class RegisterNodesRequest;
class RegisterNodesRequest_template;
class RegisterNodesResponse;
class RegisterNodesResponse_template;
class UnregisterNodesRequest;
class UnregisterNodesRequest_template;
class UnregisterNodesResponse;
class UnregisterNodesResponse_template;
class QueryFirstRequest;
class QueryFirstRequest_template;
class QueryFirstResponse;
class QueryFirstResponse_template;
class QueryNextRequest;
class QueryNextRequest_template;
class QueryNextResponse;
class QueryNextResponse_template;
class ReadRequest;
class ReadRequest_template;
class ReadResponse;
class ReadResponse_template;
class HistoryReadRequest;
class HistoryReadRequest_template;
class HistoryReadResponse;
class HistoryReadResponse_template;
class WriteRequest;
class WriteRequest_template;
class WriteResponse;
class WriteResponse_template;
class HistoryUpdateRequest;
class HistoryUpdateRequest_template;
class HistoryUpdateResponse;
class HistoryUpdateResponse_template;
class CallRequest;
class CallRequest_template;
class CallResponse;
class CallResponse_template;
class CreateMonitoredItemsRequest;
class CreateMonitoredItemsRequest_template;
class CreateMonitoredItemsResponse;
class CreateMonitoredItemsResponse_template;
class ModifyMonitoredItemsRequest;
class ModifyMonitoredItemsRequest_template;
class ModifyMonitoredItemsResponse;
class ModifyMonitoredItemsResponse_template;
class SetMonitoringModeRequest;
class SetMonitoringModeRequest_template;
class SetMonitoringModeResponse;
class SetMonitoringModeResponse_template;
class SetTriggeringRequest;
class SetTriggeringRequest_template;
class SetTriggeringResponse;
class SetTriggeringResponse_template;
class DeleteMonitoredItemsRequest;
class DeleteMonitoredItemsRequest_template;
class DeleteMonitoredItemsResponse;
class DeleteMonitoredItemsResponse_template;
class CreateSubscriptionRequest;
class CreateSubscriptionRequest_template;
class CreateSubscriptionResponse;
class CreateSubscriptionResponse_template;
class ModifySubscriptionRequest;
class ModifySubscriptionRequest_template;
class ModifySubscriptionResponse;
class ModifySubscriptionResponse_template;
class SetPublishingModeRequest;
class SetPublishingModeRequest_template;
class SetPublishingModeResponse;
class SetPublishingModeResponse_template;
class PublishRequest;
class PublishRequest_template;
class PublishResponse;
class PublishResponse_template;
class RepublishRequest;
class RepublishRequest_template;
class RepublishResponse;
class RepublishResponse_template;
class TransferSubscriptionsRequest;
class TransferSubscriptionsRequest_template;
class TransferSubscriptionsResponse;
class TransferSubscriptionsResponse_template;
class DeleteSubscriptionsRequest;
class DeleteSubscriptionsRequest_template;
class DeleteSubscriptionsResponse;
class DeleteSubscriptionsResponse_template;
class SessionlessServices;
class SessionlessServices_template;
class SessionlessInvokeResponse;
class SessionlessInvokeResponse_template;
class SessionlessInvokeRequest;
class SessionlessInvokeRequest_template;
class ServiceList;
class ServiceList_template;
class OpcMessages;
class OpcMessages_template;
class MessageChunk;
class MessageChunk_template;
class ServiceBody;
class ServiceBody_template;

} /* end of namespace */

#ifndef OpcUa__Types__Binary_HH
#define OpcUa__Types__Binary_HH

namespace OpcUa__Types__Binary {

/* Type definitions */

typedef INTEGER Byte;
typedef INTEGER_template Byte_template;
typedef INTEGER Boolean;
typedef INTEGER_template Boolean_template;
typedef INTEGER Bit;
typedef INTEGER_template Bit_template;
typedef INTEGER Bit4;
typedef INTEGER_template Bit4_template;
typedef INTEGER Bit6;
typedef INTEGER_template Bit6_template;
typedef INTEGER SByte;
typedef INTEGER_template SByte_template;
typedef INTEGER Int16;
typedef INTEGER_template Int16_template;
typedef INTEGER UInt16;
typedef INTEGER_template UInt16_template;
typedef INTEGER UInt24;
typedef INTEGER_template UInt24_template;
typedef INTEGER Int32;
typedef INTEGER_template Int32_template;
typedef INTEGER UInt32;
typedef INTEGER_template UInt32_template;
typedef INTEGER Int64;
typedef INTEGER_template Int64_template;
typedef INTEGER UInt64;
typedef INTEGER_template UInt64_template;
typedef FLOAT Float;
typedef FLOAT_template Float_template;
typedef FLOAT Double;
typedef FLOAT_template Double_template;
typedef FLOAT Duration;
typedef FLOAT_template Duration_template;
typedef INTEGER DateTime;
typedef INTEGER_template DateTime_template;
typedef INTEGER UtcTime;
typedef INTEGER_template UtcTime_template;
typedef INTEGER VersionTime;
typedef INTEGER_template VersionTime_template;
typedef INTEGER Counter;
typedef INTEGER_template Counter_template;
typedef INTEGER Index;
typedef INTEGER_template Index_template;
typedef INTEGER IntegerId;
typedef INTEGER_template IntegerId_template;
typedef OCTETSTRING Image;
typedef OCTETSTRING_template Image_template;
typedef OCTETSTRING ImageBMP;
typedef OCTETSTRING_template ImageBMP_template;
typedef OCTETSTRING ImageGIF;
typedef OCTETSTRING_template ImageGIF_template;
typedef OCTETSTRING ImageJPG;
typedef OCTETSTRING_template ImageJPG_template;
typedef OCTETSTRING ImagePNG;
typedef OCTETSTRING_template ImagePNG_template;
typedef ByteString AudioData;
typedef ByteString_template AudioData_template;
typedef String LocaleId;
typedef String_template LocaleId_template;
typedef ByteString ContinuationPoint;
typedef ByteString_template ContinuationPoint_template;
typedef String NumericRange;
typedef String_template NumericRange_template;
typedef NodeId SessionAuthenticationToken;
typedef NodeId_template SessionAuthenticationToken_template;
typedef ByteString XmlElement;
typedef ByteString_template XmlElement_template;
typedef INTEGER StatusCode;
typedef INTEGER_template StatusCode_template;
typedef Variant BaseDataType;
typedef Variant_template BaseDataType_template;
typedef VALUE_ARRAY<INTEGER, 25, 0> ObjectAttributes_reserveBits;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 25, 0> ObjectAttributes_reserveBits_template;
typedef VALUE_ARRAY<INTEGER, 20, 0> VariableAttributes_reserveBits;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 20, 0> VariableAttributes_reserveBits_template;
typedef INTEGER DataType;
typedef INTEGER_template DataType_template;
typedef VALUE_ARRAY<INTEGER, 26, 0> MethodAttributes_reserveBits;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 26, 0> MethodAttributes_reserveBits_template;
typedef VALUE_ARRAY<INTEGER, 27, 0> ObjectTypeAttributes_reserveBits;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 27, 0> ObjectTypeAttributes_reserveBits_template;
typedef VALUE_ARRAY<INTEGER, 23, 0> VariableTypeAttributes_reserveBits;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 23, 0> VariableTypeAttributes_reserveBits_template;
typedef VALUE_ARRAY<INTEGER, 25, 0> ReferenceTypeAttributes_reserveBits;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 25, 0> ReferenceTypeAttributes_reserveBits_template;
typedef VALUE_ARRAY<INTEGER, 27, 0> DataTypeAttributes_reserveBits;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 27, 0> DataTypeAttributes_reserveBits_template;
typedef VALUE_ARRAY<INTEGER, 26, 0> ViewAttributes_reserveBits;
typedef TEMPLATE_ARRAY<INTEGER, INTEGER_template, 26, 0> ViewAttributes_reserveBits_template;

/* Class definitions */

class MessageSecurityMode : public Base_Type { // enum
friend class MessageSecurityMode_template;
public:
enum enum_type { INVALID__0 = 0, NONE__1 = 1, SIGN__2 = 2, SIGNANDENCRYPT__3 = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
MessageSecurityMode();
MessageSecurityMode(int other_value);
MessageSecurityMode(enum_type other_value);
MessageSecurityMode(const MessageSecurityMode& other_value);

MessageSecurityMode& operator=(int other_value);
MessageSecurityMode& operator=(enum_type other_value);
MessageSecurityMode& operator=(const MessageSecurityMode& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MessageSecurityMode& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MessageSecurityMode& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MessageSecurityMode& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MessageSecurityMode& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MessageSecurityMode& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MessageSecurityMode& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MessageSecurityMode& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MessageSecurityMode_template : public Base_Template {
union {
MessageSecurityMode::enum_type single_value;
struct {
unsigned int n_values;
MessageSecurityMode_template *list_value;
} value_list;
};

void copy_template(const MessageSecurityMode_template& other_value);

public:
MessageSecurityMode_template();
MessageSecurityMode_template(template_sel other_value);
MessageSecurityMode_template(int other_value);
MessageSecurityMode_template(MessageSecurityMode::enum_type other_value);
MessageSecurityMode_template(const MessageSecurityMode& other_value);
MessageSecurityMode_template(const OPTIONAL<MessageSecurityMode>& other_value);
MessageSecurityMode_template(const MessageSecurityMode_template& other_value);
~MessageSecurityMode_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MessageSecurityMode_template& operator=(template_sel other_value);
MessageSecurityMode_template& operator=(int other_value);
MessageSecurityMode_template& operator=(MessageSecurityMode::enum_type other_value);
MessageSecurityMode_template& operator=(const MessageSecurityMode& other_value);
MessageSecurityMode_template& operator=(const OPTIONAL<MessageSecurityMode>& other_value);
MessageSecurityMode_template& operator=(const MessageSecurityMode_template& other_value);

boolean match(MessageSecurityMode::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const MessageSecurityMode& other_value, boolean legacy = FALSE) const;
MessageSecurityMode::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MessageSecurityMode_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MessageSecurityMode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SecurityTokenRequestType : public Base_Type { // enum
friend class SecurityTokenRequestType_template;
public:
enum enum_type { ISSUE__0 = 0, RENEW__1 = 1, UNKNOWN_VALUE = 2, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
SecurityTokenRequestType();
SecurityTokenRequestType(int other_value);
SecurityTokenRequestType(enum_type other_value);
SecurityTokenRequestType(const SecurityTokenRequestType& other_value);

SecurityTokenRequestType& operator=(int other_value);
SecurityTokenRequestType& operator=(enum_type other_value);
SecurityTokenRequestType& operator=(const SecurityTokenRequestType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const SecurityTokenRequestType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SecurityTokenRequestType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const SecurityTokenRequestType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const SecurityTokenRequestType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const SecurityTokenRequestType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const SecurityTokenRequestType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const SecurityTokenRequestType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SecurityTokenRequestType_template : public Base_Template {
union {
SecurityTokenRequestType::enum_type single_value;
struct {
unsigned int n_values;
SecurityTokenRequestType_template *list_value;
} value_list;
};

void copy_template(const SecurityTokenRequestType_template& other_value);

public:
SecurityTokenRequestType_template();
SecurityTokenRequestType_template(template_sel other_value);
SecurityTokenRequestType_template(int other_value);
SecurityTokenRequestType_template(SecurityTokenRequestType::enum_type other_value);
SecurityTokenRequestType_template(const SecurityTokenRequestType& other_value);
SecurityTokenRequestType_template(const OPTIONAL<SecurityTokenRequestType>& other_value);
SecurityTokenRequestType_template(const SecurityTokenRequestType_template& other_value);
~SecurityTokenRequestType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
SecurityTokenRequestType_template& operator=(template_sel other_value);
SecurityTokenRequestType_template& operator=(int other_value);
SecurityTokenRequestType_template& operator=(SecurityTokenRequestType::enum_type other_value);
SecurityTokenRequestType_template& operator=(const SecurityTokenRequestType& other_value);
SecurityTokenRequestType_template& operator=(const OPTIONAL<SecurityTokenRequestType>& other_value);
SecurityTokenRequestType_template& operator=(const SecurityTokenRequestType_template& other_value);

boolean match(SecurityTokenRequestType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const SecurityTokenRequestType& other_value, boolean legacy = FALSE) const;
SecurityTokenRequestType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SecurityTokenRequestType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SecurityTokenRequestType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class NodeClass : public Base_Type { // enum
friend class NodeClass_template;
public:
enum enum_type { UNSPECIFIED__0 = 0, OBJECT__1 = 1, VARIABLE__2 = 2, METHOD__4 = 4, OBJECT__TYPE__8 = 8, VARIABLE__TYPE__16 = 16, REFERENCE__TYPE__32 = 32, DATA__TYPE__64 = 64, VIEW__128 = 128, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
NodeClass();
NodeClass(int other_value);
NodeClass(enum_type other_value);
NodeClass(const NodeClass& other_value);

NodeClass& operator=(int other_value);
NodeClass& operator=(enum_type other_value);
NodeClass& operator=(const NodeClass& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const NodeClass& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const NodeClass& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const NodeClass& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const NodeClass& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const NodeClass& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const NodeClass& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const NodeClass& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NodeClass_template : public Base_Template {
union {
NodeClass::enum_type single_value;
struct {
unsigned int n_values;
NodeClass_template *list_value;
} value_list;
};

void copy_template(const NodeClass_template& other_value);

public:
NodeClass_template();
NodeClass_template(template_sel other_value);
NodeClass_template(int other_value);
NodeClass_template(NodeClass::enum_type other_value);
NodeClass_template(const NodeClass& other_value);
NodeClass_template(const OPTIONAL<NodeClass>& other_value);
NodeClass_template(const NodeClass_template& other_value);
~NodeClass_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
NodeClass_template& operator=(template_sel other_value);
NodeClass_template& operator=(int other_value);
NodeClass_template& operator=(NodeClass::enum_type other_value);
NodeClass_template& operator=(const NodeClass& other_value);
NodeClass_template& operator=(const OPTIONAL<NodeClass>& other_value);
NodeClass_template& operator=(const NodeClass_template& other_value);

boolean match(NodeClass::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const NodeClass& other_value, boolean legacy = FALSE) const;
NodeClass::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NodeClass_template& list_item(unsigned int list_index);
void log() const;
void log_match(const NodeClass& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class StructureType : public Base_Type { // enum
friend class StructureType_template;
public:
enum enum_type { STRUCTURE__0 = 0, STRUCTURE__WITH__OPTIONAL__FIELDS__1 = 1, UNION__2 = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
StructureType();
StructureType(int other_value);
StructureType(enum_type other_value);
StructureType(const StructureType& other_value);

StructureType& operator=(int other_value);
StructureType& operator=(enum_type other_value);
StructureType& operator=(const StructureType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const StructureType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const StructureType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const StructureType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const StructureType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const StructureType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const StructureType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const StructureType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class StructureType_template : public Base_Template {
union {
StructureType::enum_type single_value;
struct {
unsigned int n_values;
StructureType_template *list_value;
} value_list;
};

void copy_template(const StructureType_template& other_value);

public:
StructureType_template();
StructureType_template(template_sel other_value);
StructureType_template(int other_value);
StructureType_template(StructureType::enum_type other_value);
StructureType_template(const StructureType& other_value);
StructureType_template(const OPTIONAL<StructureType>& other_value);
StructureType_template(const StructureType_template& other_value);
~StructureType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
StructureType_template& operator=(template_sel other_value);
StructureType_template& operator=(int other_value);
StructureType_template& operator=(StructureType::enum_type other_value);
StructureType_template& operator=(const StructureType& other_value);
StructureType_template& operator=(const OPTIONAL<StructureType>& other_value);
StructureType_template& operator=(const StructureType_template& other_value);

boolean match(StructureType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const StructureType& other_value, boolean legacy = FALSE) const;
StructureType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
StructureType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const StructureType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ApplicationType : public Base_Type { // enum
friend class ApplicationType_template;
public:
enum enum_type { SERVER__0 = 0, CLIENT__1 = 1, CLIENTANDSERVER__2 = 2, DISCOVERYSERVER__3 = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
ApplicationType();
ApplicationType(int other_value);
ApplicationType(enum_type other_value);
ApplicationType(const ApplicationType& other_value);

ApplicationType& operator=(int other_value);
ApplicationType& operator=(enum_type other_value);
ApplicationType& operator=(const ApplicationType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const ApplicationType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ApplicationType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const ApplicationType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const ApplicationType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const ApplicationType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const ApplicationType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const ApplicationType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ApplicationType_template : public Base_Template {
union {
ApplicationType::enum_type single_value;
struct {
unsigned int n_values;
ApplicationType_template *list_value;
} value_list;
};

void copy_template(const ApplicationType_template& other_value);

public:
ApplicationType_template();
ApplicationType_template(template_sel other_value);
ApplicationType_template(int other_value);
ApplicationType_template(ApplicationType::enum_type other_value);
ApplicationType_template(const ApplicationType& other_value);
ApplicationType_template(const OPTIONAL<ApplicationType>& other_value);
ApplicationType_template(const ApplicationType_template& other_value);
~ApplicationType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
ApplicationType_template& operator=(template_sel other_value);
ApplicationType_template& operator=(int other_value);
ApplicationType_template& operator=(ApplicationType::enum_type other_value);
ApplicationType_template& operator=(const ApplicationType& other_value);
ApplicationType_template& operator=(const OPTIONAL<ApplicationType>& other_value);
ApplicationType_template& operator=(const ApplicationType_template& other_value);

boolean match(ApplicationType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const ApplicationType& other_value, boolean legacy = FALSE) const;
ApplicationType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ApplicationType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ApplicationType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class DataChangeTrigger : public Base_Type { // enum
friend class DataChangeTrigger_template;
public:
enum enum_type { STATUS__0 = 0, STATUS__VALUE__1 = 1, STATUS__VALUE__TIMESTAMP__2 = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
DataChangeTrigger();
DataChangeTrigger(int other_value);
DataChangeTrigger(enum_type other_value);
DataChangeTrigger(const DataChangeTrigger& other_value);

DataChangeTrigger& operator=(int other_value);
DataChangeTrigger& operator=(enum_type other_value);
DataChangeTrigger& operator=(const DataChangeTrigger& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const DataChangeTrigger& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DataChangeTrigger& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const DataChangeTrigger& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const DataChangeTrigger& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const DataChangeTrigger& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const DataChangeTrigger& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const DataChangeTrigger& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DataChangeTrigger_template : public Base_Template {
union {
DataChangeTrigger::enum_type single_value;
struct {
unsigned int n_values;
DataChangeTrigger_template *list_value;
} value_list;
};

void copy_template(const DataChangeTrigger_template& other_value);

public:
DataChangeTrigger_template();
DataChangeTrigger_template(template_sel other_value);
DataChangeTrigger_template(int other_value);
DataChangeTrigger_template(DataChangeTrigger::enum_type other_value);
DataChangeTrigger_template(const DataChangeTrigger& other_value);
DataChangeTrigger_template(const OPTIONAL<DataChangeTrigger>& other_value);
DataChangeTrigger_template(const DataChangeTrigger_template& other_value);
~DataChangeTrigger_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
DataChangeTrigger_template& operator=(template_sel other_value);
DataChangeTrigger_template& operator=(int other_value);
DataChangeTrigger_template& operator=(DataChangeTrigger::enum_type other_value);
DataChangeTrigger_template& operator=(const DataChangeTrigger& other_value);
DataChangeTrigger_template& operator=(const OPTIONAL<DataChangeTrigger>& other_value);
DataChangeTrigger_template& operator=(const DataChangeTrigger_template& other_value);

boolean match(DataChangeTrigger::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const DataChangeTrigger& other_value, boolean legacy = FALSE) const;
DataChangeTrigger::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DataChangeTrigger_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DataChangeTrigger& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MonitoringMode : public Base_Type { // enum
friend class MonitoringMode_template;
public:
enum enum_type { DISABLED__0 = 0, SAMPLING__1 = 1, REPORTING__2 = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
MonitoringMode();
MonitoringMode(int other_value);
MonitoringMode(enum_type other_value);
MonitoringMode(const MonitoringMode& other_value);

MonitoringMode& operator=(int other_value);
MonitoringMode& operator=(enum_type other_value);
MonitoringMode& operator=(const MonitoringMode& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const MonitoringMode& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MonitoringMode& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const MonitoringMode& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const MonitoringMode& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const MonitoringMode& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const MonitoringMode& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const MonitoringMode& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoringMode_template : public Base_Template {
union {
MonitoringMode::enum_type single_value;
struct {
unsigned int n_values;
MonitoringMode_template *list_value;
} value_list;
};

void copy_template(const MonitoringMode_template& other_value);

public:
MonitoringMode_template();
MonitoringMode_template(template_sel other_value);
MonitoringMode_template(int other_value);
MonitoringMode_template(MonitoringMode::enum_type other_value);
MonitoringMode_template(const MonitoringMode& other_value);
MonitoringMode_template(const OPTIONAL<MonitoringMode>& other_value);
MonitoringMode_template(const MonitoringMode_template& other_value);
~MonitoringMode_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
MonitoringMode_template& operator=(template_sel other_value);
MonitoringMode_template& operator=(int other_value);
MonitoringMode_template& operator=(MonitoringMode::enum_type other_value);
MonitoringMode_template& operator=(const MonitoringMode& other_value);
MonitoringMode_template& operator=(const OPTIONAL<MonitoringMode>& other_value);
MonitoringMode_template& operator=(const MonitoringMode_template& other_value);

boolean match(MonitoringMode::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const MonitoringMode& other_value, boolean legacy = FALSE) const;
MonitoringMode::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MonitoringMode_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MonitoringMode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class BrowseDirection : public Base_Type { // enum
friend class BrowseDirection_template;
public:
enum enum_type { FORWARD__0 = 0, INVERSE__1 = 1, BOTH__2 = 2, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
BrowseDirection();
BrowseDirection(int other_value);
BrowseDirection(enum_type other_value);
BrowseDirection(const BrowseDirection& other_value);

BrowseDirection& operator=(int other_value);
BrowseDirection& operator=(enum_type other_value);
BrowseDirection& operator=(const BrowseDirection& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const BrowseDirection& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const BrowseDirection& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const BrowseDirection& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const BrowseDirection& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const BrowseDirection& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const BrowseDirection& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const BrowseDirection& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseDirection_template : public Base_Template {
union {
BrowseDirection::enum_type single_value;
struct {
unsigned int n_values;
BrowseDirection_template *list_value;
} value_list;
};

void copy_template(const BrowseDirection_template& other_value);

public:
BrowseDirection_template();
BrowseDirection_template(template_sel other_value);
BrowseDirection_template(int other_value);
BrowseDirection_template(BrowseDirection::enum_type other_value);
BrowseDirection_template(const BrowseDirection& other_value);
BrowseDirection_template(const OPTIONAL<BrowseDirection>& other_value);
BrowseDirection_template(const BrowseDirection_template& other_value);
~BrowseDirection_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowseDirection_template& operator=(template_sel other_value);
BrowseDirection_template& operator=(int other_value);
BrowseDirection_template& operator=(BrowseDirection::enum_type other_value);
BrowseDirection_template& operator=(const BrowseDirection& other_value);
BrowseDirection_template& operator=(const OPTIONAL<BrowseDirection>& other_value);
BrowseDirection_template& operator=(const BrowseDirection_template& other_value);

boolean match(BrowseDirection::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const BrowseDirection& other_value, boolean legacy = FALSE) const;
BrowseDirection::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowseDirection_template& list_item(unsigned int list_index);
void log() const;
void log_match(const BrowseDirection& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TimestampsToReturn : public Base_Type { // enum
friend class TimestampsToReturn_template;
public:
enum enum_type { SOURCE__0 = 0, SERVER__1 = 1, BOTH__2 = 2, NEITHER__3 = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
TimestampsToReturn();
TimestampsToReturn(int other_value);
TimestampsToReturn(enum_type other_value);
TimestampsToReturn(const TimestampsToReturn& other_value);

TimestampsToReturn& operator=(int other_value);
TimestampsToReturn& operator=(enum_type other_value);
TimestampsToReturn& operator=(const TimestampsToReturn& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const TimestampsToReturn& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TimestampsToReturn& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const TimestampsToReturn& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const TimestampsToReturn& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const TimestampsToReturn& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const TimestampsToReturn& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const TimestampsToReturn& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TimestampsToReturn_template : public Base_Template {
union {
TimestampsToReturn::enum_type single_value;
struct {
unsigned int n_values;
TimestampsToReturn_template *list_value;
} value_list;
};

void copy_template(const TimestampsToReturn_template& other_value);

public:
TimestampsToReturn_template();
TimestampsToReturn_template(template_sel other_value);
TimestampsToReturn_template(int other_value);
TimestampsToReturn_template(TimestampsToReturn::enum_type other_value);
TimestampsToReturn_template(const TimestampsToReturn& other_value);
TimestampsToReturn_template(const OPTIONAL<TimestampsToReturn>& other_value);
TimestampsToReturn_template(const TimestampsToReturn_template& other_value);
~TimestampsToReturn_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
TimestampsToReturn_template& operator=(template_sel other_value);
TimestampsToReturn_template& operator=(int other_value);
TimestampsToReturn_template& operator=(TimestampsToReturn::enum_type other_value);
TimestampsToReturn_template& operator=(const TimestampsToReturn& other_value);
TimestampsToReturn_template& operator=(const OPTIONAL<TimestampsToReturn>& other_value);
TimestampsToReturn_template& operator=(const TimestampsToReturn_template& other_value);

boolean match(TimestampsToReturn::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const TimestampsToReturn& other_value, boolean legacy = FALSE) const;
TimestampsToReturn::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TimestampsToReturn_template& list_item(unsigned int list_index);
void log() const;
void log_match(const TimestampsToReturn& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UserIdentityTokenType : public Base_Type { // enum
friend class UserIdentityTokenType_template;
public:
enum enum_type { ANONYMOUS__0 = 0, USERNAME__1 = 1, CERTIFICATE__2 = 2, ISSUEDTOKEN__3 = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
UserIdentityTokenType();
UserIdentityTokenType(int other_value);
UserIdentityTokenType(enum_type other_value);
UserIdentityTokenType(const UserIdentityTokenType& other_value);

UserIdentityTokenType& operator=(int other_value);
UserIdentityTokenType& operator=(enum_type other_value);
UserIdentityTokenType& operator=(const UserIdentityTokenType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const UserIdentityTokenType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UserIdentityTokenType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const UserIdentityTokenType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const UserIdentityTokenType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const UserIdentityTokenType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const UserIdentityTokenType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const UserIdentityTokenType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UserIdentityTokenType_template : public Base_Template {
union {
UserIdentityTokenType::enum_type single_value;
struct {
unsigned int n_values;
UserIdentityTokenType_template *list_value;
} value_list;
};

void copy_template(const UserIdentityTokenType_template& other_value);

public:
UserIdentityTokenType_template();
UserIdentityTokenType_template(template_sel other_value);
UserIdentityTokenType_template(int other_value);
UserIdentityTokenType_template(UserIdentityTokenType::enum_type other_value);
UserIdentityTokenType_template(const UserIdentityTokenType& other_value);
UserIdentityTokenType_template(const OPTIONAL<UserIdentityTokenType>& other_value);
UserIdentityTokenType_template(const UserIdentityTokenType_template& other_value);
~UserIdentityTokenType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
UserIdentityTokenType_template& operator=(template_sel other_value);
UserIdentityTokenType_template& operator=(int other_value);
UserIdentityTokenType_template& operator=(UserIdentityTokenType::enum_type other_value);
UserIdentityTokenType_template& operator=(const UserIdentityTokenType& other_value);
UserIdentityTokenType_template& operator=(const OPTIONAL<UserIdentityTokenType>& other_value);
UserIdentityTokenType_template& operator=(const UserIdentityTokenType_template& other_value);

boolean match(UserIdentityTokenType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const UserIdentityTokenType& other_value, boolean legacy = FALSE) const;
UserIdentityTokenType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UserIdentityTokenType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const UserIdentityTokenType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class PerformUpdateType : public Base_Type { // enum
friend class PerformUpdateType_template;
public:
enum enum_type { INSERT__1 = 1, REPLACE__2 = 2, UPDATE__3 = 3, UNKNOWN_VALUE = 0, UNBOUND_VALUE = 4 };
private:
enum_type enum_value;

public:
PerformUpdateType();
PerformUpdateType(int other_value);
PerformUpdateType(enum_type other_value);
PerformUpdateType(const PerformUpdateType& other_value);

PerformUpdateType& operator=(int other_value);
PerformUpdateType& operator=(enum_type other_value);
PerformUpdateType& operator=(const PerformUpdateType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const PerformUpdateType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PerformUpdateType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const PerformUpdateType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const PerformUpdateType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const PerformUpdateType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const PerformUpdateType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const PerformUpdateType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class PerformUpdateType_template : public Base_Template {
union {
PerformUpdateType::enum_type single_value;
struct {
unsigned int n_values;
PerformUpdateType_template *list_value;
} value_list;
};

void copy_template(const PerformUpdateType_template& other_value);

public:
PerformUpdateType_template();
PerformUpdateType_template(template_sel other_value);
PerformUpdateType_template(int other_value);
PerformUpdateType_template(PerformUpdateType::enum_type other_value);
PerformUpdateType_template(const PerformUpdateType& other_value);
PerformUpdateType_template(const OPTIONAL<PerformUpdateType>& other_value);
PerformUpdateType_template(const PerformUpdateType_template& other_value);
~PerformUpdateType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
PerformUpdateType_template& operator=(template_sel other_value);
PerformUpdateType_template& operator=(int other_value);
PerformUpdateType_template& operator=(PerformUpdateType::enum_type other_value);
PerformUpdateType_template& operator=(const PerformUpdateType& other_value);
PerformUpdateType_template& operator=(const OPTIONAL<PerformUpdateType>& other_value);
PerformUpdateType_template& operator=(const PerformUpdateType_template& other_value);

boolean match(PerformUpdateType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const PerformUpdateType& other_value, boolean legacy = FALSE) const;
PerformUpdateType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PerformUpdateType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PerformUpdateType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class PerformUpdateTypeExtended : public Base_Type { // enum
friend class PerformUpdateTypeExtended_template;
public:
enum enum_type { INSERT__1 = 1, REPLACE__2 = 2, UPDATE__3 = 3, REMOVE__4 = 4, UNKNOWN_VALUE = 0, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
PerformUpdateTypeExtended();
PerformUpdateTypeExtended(int other_value);
PerformUpdateTypeExtended(enum_type other_value);
PerformUpdateTypeExtended(const PerformUpdateTypeExtended& other_value);

PerformUpdateTypeExtended& operator=(int other_value);
PerformUpdateTypeExtended& operator=(enum_type other_value);
PerformUpdateTypeExtended& operator=(const PerformUpdateTypeExtended& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const PerformUpdateTypeExtended& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const PerformUpdateTypeExtended& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const PerformUpdateTypeExtended& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const PerformUpdateTypeExtended& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const PerformUpdateTypeExtended& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const PerformUpdateTypeExtended& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const PerformUpdateTypeExtended& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class PerformUpdateTypeExtended_template : public Base_Template {
union {
PerformUpdateTypeExtended::enum_type single_value;
struct {
unsigned int n_values;
PerformUpdateTypeExtended_template *list_value;
} value_list;
};

void copy_template(const PerformUpdateTypeExtended_template& other_value);

public:
PerformUpdateTypeExtended_template();
PerformUpdateTypeExtended_template(template_sel other_value);
PerformUpdateTypeExtended_template(int other_value);
PerformUpdateTypeExtended_template(PerformUpdateTypeExtended::enum_type other_value);
PerformUpdateTypeExtended_template(const PerformUpdateTypeExtended& other_value);
PerformUpdateTypeExtended_template(const OPTIONAL<PerformUpdateTypeExtended>& other_value);
PerformUpdateTypeExtended_template(const PerformUpdateTypeExtended_template& other_value);
~PerformUpdateTypeExtended_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
PerformUpdateTypeExtended_template& operator=(template_sel other_value);
PerformUpdateTypeExtended_template& operator=(int other_value);
PerformUpdateTypeExtended_template& operator=(PerformUpdateTypeExtended::enum_type other_value);
PerformUpdateTypeExtended_template& operator=(const PerformUpdateTypeExtended& other_value);
PerformUpdateTypeExtended_template& operator=(const OPTIONAL<PerformUpdateTypeExtended>& other_value);
PerformUpdateTypeExtended_template& operator=(const PerformUpdateTypeExtended_template& other_value);

boolean match(PerformUpdateTypeExtended::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const PerformUpdateTypeExtended& other_value, boolean legacy = FALSE) const;
PerformUpdateTypeExtended::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PerformUpdateTypeExtended_template& list_item(unsigned int list_index);
void log() const;
void log_match(const PerformUpdateTypeExtended& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class IdType : public Base_Type { // enum
friend class IdType_template;
public:
enum enum_type { NUMERIC__0 = 0, STRING__1 = 1, GUID__2 = 2, OPAQUE__3 = 3, UNKNOWN_VALUE = 4, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
IdType();
IdType(int other_value);
IdType(enum_type other_value);
IdType(const IdType& other_value);

IdType& operator=(int other_value);
IdType& operator=(enum_type other_value);
IdType& operator=(const IdType& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const IdType& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const IdType& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const IdType& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const IdType& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const IdType& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const IdType& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const IdType& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class IdType_template : public Base_Template {
union {
IdType::enum_type single_value;
struct {
unsigned int n_values;
IdType_template *list_value;
} value_list;
};

void copy_template(const IdType_template& other_value);

public:
IdType_template();
IdType_template(template_sel other_value);
IdType_template(int other_value);
IdType_template(IdType::enum_type other_value);
IdType_template(const IdType& other_value);
IdType_template(const OPTIONAL<IdType>& other_value);
IdType_template(const IdType_template& other_value);
~IdType_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
IdType_template& operator=(template_sel other_value);
IdType_template& operator=(int other_value);
IdType_template& operator=(IdType::enum_type other_value);
IdType_template& operator=(const IdType& other_value);
IdType_template& operator=(const OPTIONAL<IdType>& other_value);
IdType_template& operator=(const IdType_template& other_value);

boolean match(IdType::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const IdType& other_value, boolean legacy = FALSE) const;
IdType::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IdType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const IdType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class FilterOperator : public Base_Type { // enum
friend class FilterOperator_template;
public:
enum enum_type { Equals__0 = 0, IsNull__1 = 1, GreaterThan__2 = 2, LessThan__3 = 3, GreaterThanOrEqual__4 = 4, LessThanOrEqual__5 = 5, Like__6 = 6, Not__7 = 7, Between__8 = 8, InList__9 = 9, And__10 = 10, Or__11 = 11, Cast__12 = 12, InView__13 = 13, OfType__14 = 14, RelatedTo__15 = 15, BitwiseAnd__16 = 16, BitwiseOr__17 = 17, UNKNOWN_VALUE = 18, UNBOUND_VALUE = 19 };
private:
enum_type enum_value;

public:
FilterOperator();
FilterOperator(int other_value);
FilterOperator(enum_type other_value);
FilterOperator(const FilterOperator& other_value);

FilterOperator& operator=(int other_value);
FilterOperator& operator=(enum_type other_value);
FilterOperator& operator=(const FilterOperator& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const FilterOperator& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const FilterOperator& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const FilterOperator& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const FilterOperator& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const FilterOperator& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const FilterOperator& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const FilterOperator& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class FilterOperator_template : public Base_Template {
union {
FilterOperator::enum_type single_value;
struct {
unsigned int n_values;
FilterOperator_template *list_value;
} value_list;
};

void copy_template(const FilterOperator_template& other_value);

public:
FilterOperator_template();
FilterOperator_template(template_sel other_value);
FilterOperator_template(int other_value);
FilterOperator_template(FilterOperator::enum_type other_value);
FilterOperator_template(const FilterOperator& other_value);
FilterOperator_template(const OPTIONAL<FilterOperator>& other_value);
FilterOperator_template(const FilterOperator_template& other_value);
~FilterOperator_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
FilterOperator_template& operator=(template_sel other_value);
FilterOperator_template& operator=(int other_value);
FilterOperator_template& operator=(FilterOperator::enum_type other_value);
FilterOperator_template& operator=(const FilterOperator& other_value);
FilterOperator_template& operator=(const OPTIONAL<FilterOperator>& other_value);
FilterOperator_template& operator=(const FilterOperator_template& other_value);

boolean match(FilterOperator::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const FilterOperator& other_value, boolean legacy = FALSE) const;
FilterOperator::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
FilterOperator_template& list_item(unsigned int list_index);
void log() const;
void log_match(const FilterOperator& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class OpenFileMode : public Base_Type { // enum
friend class OpenFileMode_template;
public:
enum enum_type { READ__1 = 1, WRITE__2 = 2, ERASE__EXISTING__4 = 4, APPEND__8 = 8, UNKNOWN_VALUE = 0, UNBOUND_VALUE = 3 };
private:
enum_type enum_value;

public:
OpenFileMode();
OpenFileMode(int other_value);
OpenFileMode(enum_type other_value);
OpenFileMode(const OpenFileMode& other_value);

OpenFileMode& operator=(int other_value);
OpenFileMode& operator=(enum_type other_value);
OpenFileMode& operator=(const OpenFileMode& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const OpenFileMode& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const OpenFileMode& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const OpenFileMode& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const OpenFileMode& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const OpenFileMode& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const OpenFileMode& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const OpenFileMode& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class OpenFileMode_template : public Base_Template {
union {
OpenFileMode::enum_type single_value;
struct {
unsigned int n_values;
OpenFileMode_template *list_value;
} value_list;
};

void copy_template(const OpenFileMode_template& other_value);

public:
OpenFileMode_template();
OpenFileMode_template(template_sel other_value);
OpenFileMode_template(int other_value);
OpenFileMode_template(OpenFileMode::enum_type other_value);
OpenFileMode_template(const OpenFileMode& other_value);
OpenFileMode_template(const OPTIONAL<OpenFileMode>& other_value);
OpenFileMode_template(const OpenFileMode_template& other_value);
~OpenFileMode_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
OpenFileMode_template& operator=(template_sel other_value);
OpenFileMode_template& operator=(int other_value);
OpenFileMode_template& operator=(OpenFileMode::enum_type other_value);
OpenFileMode_template& operator=(const OpenFileMode& other_value);
OpenFileMode_template& operator=(const OPTIONAL<OpenFileMode>& other_value);
OpenFileMode_template& operator=(const OpenFileMode_template& other_value);

boolean match(OpenFileMode::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const OpenFileMode& other_value, boolean legacy = FALSE) const;
OpenFileMode::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
OpenFileMode_template& list_item(unsigned int list_index);
void log() const;
void log_match(const OpenFileMode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TrustListMasks : public Base_Type { // enum
friend class TrustListMasks_template;
public:
enum enum_type { none__0 = 0, trustedCertificates__1 = 1, trustedCrls__2 = 2, issuerCertificates__4 = 4, issuerCrls__8 = 8, all__15 = 15, UNKNOWN_VALUE = 3, UNBOUND_VALUE = 5 };
private:
enum_type enum_value;

public:
TrustListMasks();
TrustListMasks(int other_value);
TrustListMasks(enum_type other_value);
TrustListMasks(const TrustListMasks& other_value);

TrustListMasks& operator=(int other_value);
TrustListMasks& operator=(enum_type other_value);
TrustListMasks& operator=(const TrustListMasks& other_value);

boolean operator==(enum_type other_value) const;
boolean operator==(const TrustListMasks& other_value) const;
inline boolean operator!=(enum_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TrustListMasks& other_value) const { return !(*this == other_value); }
boolean operator<(enum_type other_value) const;
boolean operator<(const TrustListMasks& other_value) const;
boolean operator>(enum_type other_value) const;
boolean operator>(const TrustListMasks& other_value) const;
inline boolean operator<=(enum_type other_value) const { return !(*this > other_value); }
inline boolean operator<=(const TrustListMasks& other_value) const { return !(*this > other_value); }
inline boolean operator>=(enum_type other_value) const { return !(*this < other_value); }
inline boolean operator>=(const TrustListMasks& other_value) const { return !(*this < other_value); }

static const char *enum_to_str(enum_type enum_par);
static enum_type str_to_enum(const char *str_par);
static boolean is_valid_enum(int int_par);

static int enum2int(enum_type enum_par);
static int enum2int(const TrustListMasks& enum_par);
int as_int() const { return enum2int(enum_value); }
void from_int(int p_val) { *this = p_val; }
void int2enum(int int_val);
operator enum_type() const;
inline boolean is_bound() const { return enum_value != UNBOUND_VALUE; }
inline boolean is_value() const { return enum_value != UNBOUND_VALUE; }
inline void clean_up(){ enum_value = UNBOUND_VALUE; }
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TrustListMasks_template : public Base_Template {
union {
TrustListMasks::enum_type single_value;
struct {
unsigned int n_values;
TrustListMasks_template *list_value;
} value_list;
};

void copy_template(const TrustListMasks_template& other_value);

public:
TrustListMasks_template();
TrustListMasks_template(template_sel other_value);
TrustListMasks_template(int other_value);
TrustListMasks_template(TrustListMasks::enum_type other_value);
TrustListMasks_template(const TrustListMasks& other_value);
TrustListMasks_template(const OPTIONAL<TrustListMasks>& other_value);
TrustListMasks_template(const TrustListMasks_template& other_value);
~TrustListMasks_template();

boolean is_bound() const;
boolean is_value() const;
void clean_up();
TrustListMasks_template& operator=(template_sel other_value);
TrustListMasks_template& operator=(int other_value);
TrustListMasks_template& operator=(TrustListMasks::enum_type other_value);
TrustListMasks_template& operator=(const TrustListMasks& other_value);
TrustListMasks_template& operator=(const OPTIONAL<TrustListMasks>& other_value);
TrustListMasks_template& operator=(const TrustListMasks_template& other_value);

boolean match(TrustListMasks::enum_type other_value, boolean legacy = FALSE) const;
boolean match(const TrustListMasks& other_value, boolean legacy = FALSE) const;
TrustListMasks::enum_type valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TrustListMasks_template& list_item(unsigned int list_index);
void log() const;
void log_match(const TrustListMasks& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ByteString : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullByteString = 1, ALT_realByteString = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullByteString;
RealByteString *field_realByteString;
};
void copy_value(const ByteString& other_value);

public:
ByteString();
ByteString(const ByteString& other_value);
~ByteString();
ByteString& operator=(const ByteString& other_value);
boolean operator==(const ByteString& other_value) const;
inline boolean operator!=(const ByteString& other_value) const { return !(*this == other_value); }
NullArray& nullByteString();
const NullArray& nullByteString() const;
RealByteString& realByteString();
const RealByteString& realByteString() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ByteString_template : public Base_Template {
union {
struct {
ByteString::union_selection_type union_selection;
union {
NullArray_template *field_nullByteString;
RealByteString_template *field_realByteString;
};
} single_value;
struct {
unsigned int n_values;
ByteString_template *list_value;
} value_list;
};
void copy_value(const ByteString& other_value);

void copy_template(const ByteString_template& other_value);

public:
ByteString_template();
ByteString_template(template_sel other_value);
ByteString_template(const ByteString& other_value);
ByteString_template(const OPTIONAL<ByteString>& other_value);
ByteString_template(const ByteString_template& other_value);
~ByteString_template();
void clean_up();
ByteString_template& operator=(template_sel other_value);
ByteString_template& operator=(const ByteString& other_value);
ByteString_template& operator=(const OPTIONAL<ByteString>& other_value);
ByteString_template& operator=(const ByteString_template& other_value);
boolean match(const ByteString& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ByteString valueof() const;
ByteString_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullByteString();
const NullArray_template& nullByteString() const;
RealByteString_template& realByteString();
const RealByteString_template& realByteString() const;
boolean ischosen(ByteString::union_selection_type checked_selection) const;
void log() const;
void log_match(const ByteString& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class NullArray : public Base_Type {
  INTEGER field_arrayLength;
public:
  NullArray();
  NullArray(const INTEGER& par_arrayLength);
  NullArray(const NullArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  NullArray& operator=(const NullArray& other_value);
  boolean operator==(const NullArray& other_value) const;
  inline boolean operator!=(const NullArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NullArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
NullArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const NullArray& other_value);
void copy_template(const NullArray_template& other_value);

public:
NullArray_template();
NullArray_template(template_sel other_value);
NullArray_template(const NullArray& other_value);
NullArray_template(const OPTIONAL<NullArray>& other_value);
NullArray_template(const NullArray_template& other_value);
~NullArray_template();
NullArray_template& operator=(template_sel other_value);
NullArray_template& operator=(const NullArray& other_value);
NullArray_template& operator=(const OPTIONAL<NullArray>& other_value);
NullArray_template& operator=(const NullArray_template& other_value);
boolean match(const NullArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
NullArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
int size_of() const;
void log() const;
void log_match(const NullArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RealByteString : public Base_Type {
  INTEGER field_lengthValue;
  ByteArray field_byteStringValue;
public:
  RealByteString();
  RealByteString(const INTEGER& par_lengthValue,
    const ByteArray& par_byteStringValue);
  RealByteString(const RealByteString& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RealByteString& operator=(const RealByteString& other_value);
  boolean operator==(const RealByteString& other_value) const;
  inline boolean operator!=(const RealByteString& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& lengthValue()
    {return field_lengthValue;}
  inline const INTEGER& lengthValue() const
    {return field_lengthValue;}
  inline ByteArray& byteStringValue()
    {return field_byteStringValue;}
  inline const ByteArray& byteStringValue() const
    {return field_byteStringValue;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RealByteString_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RealByteString_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RealByteString& other_value);
void copy_template(const RealByteString_template& other_value);

public:
RealByteString_template();
RealByteString_template(template_sel other_value);
RealByteString_template(const RealByteString& other_value);
RealByteString_template(const OPTIONAL<RealByteString>& other_value);
RealByteString_template(const RealByteString_template& other_value);
~RealByteString_template();
RealByteString_template& operator=(template_sel other_value);
RealByteString_template& operator=(const RealByteString& other_value);
RealByteString_template& operator=(const OPTIONAL<RealByteString>& other_value);
RealByteString_template& operator=(const RealByteString_template& other_value);
boolean match(const RealByteString& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RealByteString valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RealByteString_template& list_item(unsigned int list_index) const;
INTEGER_template& lengthValue();
const INTEGER_template& lengthValue() const;
ByteArray_template& byteStringValue();
const ByteArray_template& byteStringValue() const;
int size_of() const;
void log() const;
void log_match(const RealByteString& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class String : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullString = 1, ALT_realString = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullString;
NonNullString *field_realString;
};
void copy_value(const String& other_value);

public:
String();
String(const String& other_value);
~String();
String& operator=(const String& other_value);
boolean operator==(const String& other_value) const;
inline boolean operator!=(const String& other_value) const { return !(*this == other_value); }
NullArray& nullString();
const NullArray& nullString() const;
NonNullString& realString();
const NonNullString& realString() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class String_template : public Base_Template {
union {
struct {
String::union_selection_type union_selection;
union {
NullArray_template *field_nullString;
NonNullString_template *field_realString;
};
} single_value;
struct {
unsigned int n_values;
String_template *list_value;
} value_list;
};
void copy_value(const String& other_value);

void copy_template(const String_template& other_value);

public:
String_template();
String_template(template_sel other_value);
String_template(const String& other_value);
String_template(const OPTIONAL<String>& other_value);
String_template(const String_template& other_value);
~String_template();
void clean_up();
String_template& operator=(template_sel other_value);
String_template& operator=(const String& other_value);
String_template& operator=(const OPTIONAL<String>& other_value);
String_template& operator=(const String_template& other_value);
boolean match(const String& other_value, boolean legacy = FALSE) const;
boolean is_value() const;String valueof() const;
String_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullString();
const NullArray_template& nullString() const;
NonNullString_template& realString();
const NonNullString_template& realString() const;
boolean ischosen(String::union_selection_type checked_selection) const;
void log() const;
void log_match(const String& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class NonNullString : public Base_Type {
  INTEGER field_stringLength;
  CHARSTRING field_stringValue;
public:
  NonNullString();
  NonNullString(const INTEGER& par_stringLength,
    const CHARSTRING& par_stringValue);
  NonNullString(const NonNullString& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  NonNullString& operator=(const NonNullString& other_value);
  boolean operator==(const NonNullString& other_value) const;
  inline boolean operator!=(const NonNullString& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& stringLength()
    {return field_stringLength;}
  inline const INTEGER& stringLength() const
    {return field_stringLength;}
  inline CHARSTRING& stringValue()
    {return field_stringValue;}
  inline const CHARSTRING& stringValue() const
    {return field_stringValue;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NonNullString_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
NonNullString_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const NonNullString& other_value);
void copy_template(const NonNullString_template& other_value);

public:
NonNullString_template();
NonNullString_template(template_sel other_value);
NonNullString_template(const NonNullString& other_value);
NonNullString_template(const OPTIONAL<NonNullString>& other_value);
NonNullString_template(const NonNullString_template& other_value);
~NonNullString_template();
NonNullString_template& operator=(template_sel other_value);
NonNullString_template& operator=(const NonNullString& other_value);
NonNullString_template& operator=(const OPTIONAL<NonNullString>& other_value);
NonNullString_template& operator=(const NonNullString_template& other_value);
boolean match(const NonNullString& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
NonNullString valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NonNullString_template& list_item(unsigned int list_index) const;
INTEGER_template& stringLength();
const INTEGER_template& stringLength() const;
CHARSTRING_template& stringValue();
const CHARSTRING_template& stringValue() const;
int size_of() const;
void log() const;
void log_match(const NonNullString& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NodeIdType : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_twoByte = 1, ALT_fourByte = 2, ALT_numeric = 3, ALT_string = 4, ALT_guid = 5, ALT_byteString = 6 };
private:
union_selection_type union_selection;
union {
TwoByteNodeId *field_twoByte;
FourByteNodeId *field_fourByte;
NumericNodeId *field_numeric;
StringNodeId *field_string;
GuidNodeId *field_guid;
ByteStringNodeId *field_byteString;
};
void copy_value(const NodeIdType& other_value);

public:
NodeIdType();
NodeIdType(const NodeIdType& other_value);
~NodeIdType();
NodeIdType& operator=(const NodeIdType& other_value);
boolean operator==(const NodeIdType& other_value) const;
inline boolean operator!=(const NodeIdType& other_value) const { return !(*this == other_value); }
TwoByteNodeId& twoByte();
const TwoByteNodeId& twoByte() const;
FourByteNodeId& fourByte();
const FourByteNodeId& fourByte() const;
NumericNodeId& numeric();
const NumericNodeId& numeric() const;
StringNodeId& string();
const StringNodeId& string() const;
GuidNodeId& guid();
const GuidNodeId& guid() const;
ByteStringNodeId& byteString();
const ByteStringNodeId& byteString() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NodeIdType_template : public Base_Template {
union {
struct {
NodeIdType::union_selection_type union_selection;
union {
TwoByteNodeId_template *field_twoByte;
FourByteNodeId_template *field_fourByte;
NumericNodeId_template *field_numeric;
StringNodeId_template *field_string;
GuidNodeId_template *field_guid;
ByteStringNodeId_template *field_byteString;
};
} single_value;
struct {
unsigned int n_values;
NodeIdType_template *list_value;
} value_list;
};
void copy_value(const NodeIdType& other_value);

void copy_template(const NodeIdType_template& other_value);

public:
NodeIdType_template();
NodeIdType_template(template_sel other_value);
NodeIdType_template(const NodeIdType& other_value);
NodeIdType_template(const OPTIONAL<NodeIdType>& other_value);
NodeIdType_template(const NodeIdType_template& other_value);
~NodeIdType_template();
void clean_up();
NodeIdType_template& operator=(template_sel other_value);
NodeIdType_template& operator=(const NodeIdType& other_value);
NodeIdType_template& operator=(const OPTIONAL<NodeIdType>& other_value);
NodeIdType_template& operator=(const NodeIdType_template& other_value);
boolean match(const NodeIdType& other_value, boolean legacy = FALSE) const;
boolean is_value() const;NodeIdType valueof() const;
NodeIdType_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
TwoByteNodeId_template& twoByte();
const TwoByteNodeId_template& twoByte() const;
FourByteNodeId_template& fourByte();
const FourByteNodeId_template& fourByte() const;
NumericNodeId_template& numeric();
const NumericNodeId_template& numeric() const;
StringNodeId_template& string();
const StringNodeId_template& string() const;
GuidNodeId_template& guid();
const GuidNodeId_template& guid() const;
ByteStringNodeId_template& byteString();
const ByteStringNodeId_template& byteString() const;
boolean ischosen(NodeIdType::union_selection_type checked_selection) const;
void log() const;
void log_match(const NodeIdType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class TwoByteNodeId : public Base_Type {
  INTEGER field_nodeValue;
public:
  TwoByteNodeId();
  TwoByteNodeId(const INTEGER& par_nodeValue);
  TwoByteNodeId(const TwoByteNodeId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TwoByteNodeId& operator=(const TwoByteNodeId& other_value);
  boolean operator==(const TwoByteNodeId& other_value) const;
  inline boolean operator!=(const TwoByteNodeId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& nodeValue()
    {return field_nodeValue;}
  inline const INTEGER& nodeValue() const
    {return field_nodeValue;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TwoByteNodeId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TwoByteNodeId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TwoByteNodeId& other_value);
void copy_template(const TwoByteNodeId_template& other_value);

public:
TwoByteNodeId_template();
TwoByteNodeId_template(template_sel other_value);
TwoByteNodeId_template(const TwoByteNodeId& other_value);
TwoByteNodeId_template(const OPTIONAL<TwoByteNodeId>& other_value);
TwoByteNodeId_template(const TwoByteNodeId_template& other_value);
~TwoByteNodeId_template();
TwoByteNodeId_template& operator=(template_sel other_value);
TwoByteNodeId_template& operator=(const TwoByteNodeId& other_value);
TwoByteNodeId_template& operator=(const OPTIONAL<TwoByteNodeId>& other_value);
TwoByteNodeId_template& operator=(const TwoByteNodeId_template& other_value);
boolean match(const TwoByteNodeId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TwoByteNodeId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TwoByteNodeId_template& list_item(unsigned int list_index) const;
INTEGER_template& nodeValue();
const INTEGER_template& nodeValue() const;
int size_of() const;
void log() const;
void log_match(const TwoByteNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class FourByteNodeId : public Base_Type {
  INTEGER field_nameSpace;
  INTEGER field_nodeValue;
public:
  FourByteNodeId();
  FourByteNodeId(const INTEGER& par_nameSpace,
    const INTEGER& par_nodeValue);
  FourByteNodeId(const FourByteNodeId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  FourByteNodeId& operator=(const FourByteNodeId& other_value);
  boolean operator==(const FourByteNodeId& other_value) const;
  inline boolean operator!=(const FourByteNodeId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& nameSpace()
    {return field_nameSpace;}
  inline const INTEGER& nameSpace() const
    {return field_nameSpace;}
  inline INTEGER& nodeValue()
    {return field_nodeValue;}
  inline const INTEGER& nodeValue() const
    {return field_nodeValue;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class FourByteNodeId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
FourByteNodeId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const FourByteNodeId& other_value);
void copy_template(const FourByteNodeId_template& other_value);

public:
FourByteNodeId_template();
FourByteNodeId_template(template_sel other_value);
FourByteNodeId_template(const FourByteNodeId& other_value);
FourByteNodeId_template(const OPTIONAL<FourByteNodeId>& other_value);
FourByteNodeId_template(const FourByteNodeId_template& other_value);
~FourByteNodeId_template();
FourByteNodeId_template& operator=(template_sel other_value);
FourByteNodeId_template& operator=(const FourByteNodeId& other_value);
FourByteNodeId_template& operator=(const OPTIONAL<FourByteNodeId>& other_value);
FourByteNodeId_template& operator=(const FourByteNodeId_template& other_value);
boolean match(const FourByteNodeId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
FourByteNodeId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
FourByteNodeId_template& list_item(unsigned int list_index) const;
INTEGER_template& nameSpace();
const INTEGER_template& nameSpace() const;
INTEGER_template& nodeValue();
const INTEGER_template& nodeValue() const;
int size_of() const;
void log() const;
void log_match(const FourByteNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NumericNodeId : public Base_Type {
  INTEGER field_nameSpace;
  INTEGER field_nodeValue;
public:
  NumericNodeId();
  NumericNodeId(const INTEGER& par_nameSpace,
    const INTEGER& par_nodeValue);
  NumericNodeId(const NumericNodeId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  NumericNodeId& operator=(const NumericNodeId& other_value);
  boolean operator==(const NumericNodeId& other_value) const;
  inline boolean operator!=(const NumericNodeId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& nameSpace()
    {return field_nameSpace;}
  inline const INTEGER& nameSpace() const
    {return field_nameSpace;}
  inline INTEGER& nodeValue()
    {return field_nodeValue;}
  inline const INTEGER& nodeValue() const
    {return field_nodeValue;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NumericNodeId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
NumericNodeId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const NumericNodeId& other_value);
void copy_template(const NumericNodeId_template& other_value);

public:
NumericNodeId_template();
NumericNodeId_template(template_sel other_value);
NumericNodeId_template(const NumericNodeId& other_value);
NumericNodeId_template(const OPTIONAL<NumericNodeId>& other_value);
NumericNodeId_template(const NumericNodeId_template& other_value);
~NumericNodeId_template();
NumericNodeId_template& operator=(template_sel other_value);
NumericNodeId_template& operator=(const NumericNodeId& other_value);
NumericNodeId_template& operator=(const OPTIONAL<NumericNodeId>& other_value);
NumericNodeId_template& operator=(const NumericNodeId_template& other_value);
boolean match(const NumericNodeId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
NumericNodeId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NumericNodeId_template& list_item(unsigned int list_index) const;
INTEGER_template& nameSpace();
const INTEGER_template& nameSpace() const;
INTEGER_template& nodeValue();
const INTEGER_template& nodeValue() const;
int size_of() const;
void log() const;
void log_match(const NumericNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class StringNodeId : public Base_Type {
  INTEGER field_nameSpace;
  String field_nodeValue;
public:
  StringNodeId();
  StringNodeId(const INTEGER& par_nameSpace,
    const String& par_nodeValue);
  StringNodeId(const StringNodeId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  StringNodeId& operator=(const StringNodeId& other_value);
  boolean operator==(const StringNodeId& other_value) const;
  inline boolean operator!=(const StringNodeId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& nameSpace()
    {return field_nameSpace;}
  inline const INTEGER& nameSpace() const
    {return field_nameSpace;}
  inline String& nodeValue()
    {return field_nodeValue;}
  inline const String& nodeValue() const
    {return field_nodeValue;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class StringNodeId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
StringNodeId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const StringNodeId& other_value);
void copy_template(const StringNodeId_template& other_value);

public:
StringNodeId_template();
StringNodeId_template(template_sel other_value);
StringNodeId_template(const StringNodeId& other_value);
StringNodeId_template(const OPTIONAL<StringNodeId>& other_value);
StringNodeId_template(const StringNodeId_template& other_value);
~StringNodeId_template();
StringNodeId_template& operator=(template_sel other_value);
StringNodeId_template& operator=(const StringNodeId& other_value);
StringNodeId_template& operator=(const OPTIONAL<StringNodeId>& other_value);
StringNodeId_template& operator=(const StringNodeId_template& other_value);
boolean match(const StringNodeId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
StringNodeId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
StringNodeId_template& list_item(unsigned int list_index) const;
INTEGER_template& nameSpace();
const INTEGER_template& nameSpace() const;
String_template& nodeValue();
const String_template& nodeValue() const;
int size_of() const;
void log() const;
void log_match(const StringNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Guid : public Base_Type {
  INTEGER field_data1;
  INTEGER field_data2;
  INTEGER field_data3;
  INTEGER field_data41;
  INTEGER field_data42;
  INTEGER field_data43;
  INTEGER field_data44;
  INTEGER field_data45;
  INTEGER field_data46;
  INTEGER field_data47;
  INTEGER field_data48;
public:
  Guid();
  Guid(const INTEGER& par_data1,
    const INTEGER& par_data2,
    const INTEGER& par_data3,
    const INTEGER& par_data41,
    const INTEGER& par_data42,
    const INTEGER& par_data43,
    const INTEGER& par_data44,
    const INTEGER& par_data45,
    const INTEGER& par_data46,
    const INTEGER& par_data47,
    const INTEGER& par_data48);
  Guid(const Guid& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Guid& operator=(const Guid& other_value);
  boolean operator==(const Guid& other_value) const;
  inline boolean operator!=(const Guid& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& data1()
    {return field_data1;}
  inline const INTEGER& data1() const
    {return field_data1;}
  inline INTEGER& data2()
    {return field_data2;}
  inline const INTEGER& data2() const
    {return field_data2;}
  inline INTEGER& data3()
    {return field_data3;}
  inline const INTEGER& data3() const
    {return field_data3;}
  inline INTEGER& data41()
    {return field_data41;}
  inline const INTEGER& data41() const
    {return field_data41;}
  inline INTEGER& data42()
    {return field_data42;}
  inline const INTEGER& data42() const
    {return field_data42;}
  inline INTEGER& data43()
    {return field_data43;}
  inline const INTEGER& data43() const
    {return field_data43;}
  inline INTEGER& data44()
    {return field_data44;}
  inline const INTEGER& data44() const
    {return field_data44;}
  inline INTEGER& data45()
    {return field_data45;}
  inline const INTEGER& data45() const
    {return field_data45;}
  inline INTEGER& data46()
    {return field_data46;}
  inline const INTEGER& data46() const
    {return field_data46;}
  inline INTEGER& data47()
    {return field_data47;}
  inline const INTEGER& data47() const
    {return field_data47;}
  inline INTEGER& data48()
    {return field_data48;}
  inline const INTEGER& data48() const
    {return field_data48;}
  inline int size_of() const
    {return 11;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class Guid_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Guid_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Guid& other_value);
void copy_template(const Guid_template& other_value);

public:
Guid_template();
Guid_template(template_sel other_value);
Guid_template(const Guid& other_value);
Guid_template(const OPTIONAL<Guid>& other_value);
Guid_template(const Guid_template& other_value);
~Guid_template();
Guid_template& operator=(template_sel other_value);
Guid_template& operator=(const Guid& other_value);
Guid_template& operator=(const OPTIONAL<Guid>& other_value);
Guid_template& operator=(const Guid_template& other_value);
boolean match(const Guid& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Guid valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Guid_template& list_item(unsigned int list_index) const;
INTEGER_template& data1();
const INTEGER_template& data1() const;
INTEGER_template& data2();
const INTEGER_template& data2() const;
INTEGER_template& data3();
const INTEGER_template& data3() const;
INTEGER_template& data41();
const INTEGER_template& data41() const;
INTEGER_template& data42();
const INTEGER_template& data42() const;
INTEGER_template& data43();
const INTEGER_template& data43() const;
INTEGER_template& data44();
const INTEGER_template& data44() const;
INTEGER_template& data45();
const INTEGER_template& data45() const;
INTEGER_template& data46();
const INTEGER_template& data46() const;
INTEGER_template& data47();
const INTEGER_template& data47() const;
INTEGER_template& data48();
const INTEGER_template& data48() const;
int size_of() const;
void log() const;
void log_match(const Guid& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GuidNodeId : public Base_Type {
  INTEGER field_nameSpace;
  Guid field_nodeValue;
public:
  GuidNodeId();
  GuidNodeId(const INTEGER& par_nameSpace,
    const Guid& par_nodeValue);
  GuidNodeId(const GuidNodeId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GuidNodeId& operator=(const GuidNodeId& other_value);
  boolean operator==(const GuidNodeId& other_value) const;
  inline boolean operator!=(const GuidNodeId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& nameSpace()
    {return field_nameSpace;}
  inline const INTEGER& nameSpace() const
    {return field_nameSpace;}
  inline Guid& nodeValue()
    {return field_nodeValue;}
  inline const Guid& nodeValue() const
    {return field_nodeValue;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GuidNodeId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GuidNodeId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GuidNodeId& other_value);
void copy_template(const GuidNodeId_template& other_value);

public:
GuidNodeId_template();
GuidNodeId_template(template_sel other_value);
GuidNodeId_template(const GuidNodeId& other_value);
GuidNodeId_template(const OPTIONAL<GuidNodeId>& other_value);
GuidNodeId_template(const GuidNodeId_template& other_value);
~GuidNodeId_template();
GuidNodeId_template& operator=(template_sel other_value);
GuidNodeId_template& operator=(const GuidNodeId& other_value);
GuidNodeId_template& operator=(const OPTIONAL<GuidNodeId>& other_value);
GuidNodeId_template& operator=(const GuidNodeId_template& other_value);
boolean match(const GuidNodeId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GuidNodeId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GuidNodeId_template& list_item(unsigned int list_index) const;
INTEGER_template& nameSpace();
const INTEGER_template& nameSpace() const;
Guid_template& nodeValue();
const Guid_template& nodeValue() const;
int size_of() const;
void log() const;
void log_match(const GuidNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ByteStringNodeId : public Base_Type {
  INTEGER field_nameSpace;
  ByteString field_nodeValue;
public:
  ByteStringNodeId();
  ByteStringNodeId(const INTEGER& par_nameSpace,
    const ByteString& par_nodeValue);
  ByteStringNodeId(const ByteStringNodeId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ByteStringNodeId& operator=(const ByteStringNodeId& other_value);
  boolean operator==(const ByteStringNodeId& other_value) const;
  inline boolean operator!=(const ByteStringNodeId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& nameSpace()
    {return field_nameSpace;}
  inline const INTEGER& nameSpace() const
    {return field_nameSpace;}
  inline ByteString& nodeValue()
    {return field_nodeValue;}
  inline const ByteString& nodeValue() const
    {return field_nodeValue;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ByteStringNodeId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ByteStringNodeId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ByteStringNodeId& other_value);
void copy_template(const ByteStringNodeId_template& other_value);

public:
ByteStringNodeId_template();
ByteStringNodeId_template(template_sel other_value);
ByteStringNodeId_template(const ByteStringNodeId& other_value);
ByteStringNodeId_template(const OPTIONAL<ByteStringNodeId>& other_value);
ByteStringNodeId_template(const ByteStringNodeId_template& other_value);
~ByteStringNodeId_template();
ByteStringNodeId_template& operator=(template_sel other_value);
ByteStringNodeId_template& operator=(const ByteStringNodeId& other_value);
ByteStringNodeId_template& operator=(const OPTIONAL<ByteStringNodeId>& other_value);
ByteStringNodeId_template& operator=(const ByteStringNodeId_template& other_value);
boolean match(const ByteStringNodeId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ByteStringNodeId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ByteStringNodeId_template& list_item(unsigned int list_index) const;
INTEGER_template& nameSpace();
const INTEGER_template& nameSpace() const;
ByteString_template& nodeValue();
const ByteString_template& nodeValue() const;
int size_of() const;
void log() const;
void log_match(const ByteStringNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NodeId : public Base_Type {
  INTEGER field_mask;
  INTEGER field_namespaceUriBit;
  INTEGER field_serverIndexBit;
  INTEGER field_reservedBit1;
  INTEGER field_reservedBit2;
  NodeIdType field_IdType;
public:
  NodeId();
  NodeId(const INTEGER& par_mask,
    const INTEGER& par_namespaceUriBit,
    const INTEGER& par_serverIndexBit,
    const INTEGER& par_reservedBit1,
    const INTEGER& par_reservedBit2,
    const NodeIdType& par_IdType);
  NodeId(const NodeId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  NodeId& operator=(const NodeId& other_value);
  boolean operator==(const NodeId& other_value) const;
  inline boolean operator!=(const NodeId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& mask()
    {return field_mask;}
  inline const INTEGER& mask() const
    {return field_mask;}
  inline INTEGER& namespaceUriBit()
    {return field_namespaceUriBit;}
  inline const INTEGER& namespaceUriBit() const
    {return field_namespaceUriBit;}
  inline INTEGER& serverIndexBit()
    {return field_serverIndexBit;}
  inline const INTEGER& serverIndexBit() const
    {return field_serverIndexBit;}
  inline INTEGER& reservedBit1()
    {return field_reservedBit1;}
  inline const INTEGER& reservedBit1() const
    {return field_reservedBit1;}
  inline INTEGER& reservedBit2()
    {return field_reservedBit2;}
  inline const INTEGER& reservedBit2() const
    {return field_reservedBit2;}
  inline NodeIdType& IdType()
    {return field_IdType;}
  inline const NodeIdType& IdType() const
    {return field_IdType;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NodeId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
NodeId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const NodeId& other_value);
void copy_template(const NodeId_template& other_value);

public:
NodeId_template();
NodeId_template(template_sel other_value);
NodeId_template(const NodeId& other_value);
NodeId_template(const OPTIONAL<NodeId>& other_value);
NodeId_template(const NodeId_template& other_value);
~NodeId_template();
NodeId_template& operator=(template_sel other_value);
NodeId_template& operator=(const NodeId& other_value);
NodeId_template& operator=(const OPTIONAL<NodeId>& other_value);
NodeId_template& operator=(const NodeId_template& other_value);
boolean match(const NodeId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
NodeId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NodeId_template& list_item(unsigned int list_index) const;
INTEGER_template& mask();
const INTEGER_template& mask() const;
INTEGER_template& namespaceUriBit();
const INTEGER_template& namespaceUriBit() const;
INTEGER_template& serverIndexBit();
const INTEGER_template& serverIndexBit() const;
INTEGER_template& reservedBit1();
const INTEGER_template& reservedBit1() const;
INTEGER_template& reservedBit2();
const INTEGER_template& reservedBit2() const;
NodeIdType_template& IdType();
const NodeIdType_template& IdType() const;
int size_of() const;
void log() const;
void log_match(const NodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExpandedNodeId : public Base_Type {
  NodeId field_node;
  OPTIONAL<String> field_namespaceUri;
  OPTIONAL<INTEGER> field_serverIndex;
public:
  ExpandedNodeId();
  ExpandedNodeId(const NodeId& par_node,
    const OPTIONAL<String>& par_namespaceUri,
    const OPTIONAL<INTEGER>& par_serverIndex);
  ExpandedNodeId(const ExpandedNodeId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExpandedNodeId& operator=(const ExpandedNodeId& other_value);
  boolean operator==(const ExpandedNodeId& other_value) const;
  inline boolean operator!=(const ExpandedNodeId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& node()
    {return field_node;}
  inline const NodeId& node() const
    {return field_node;}
  inline OPTIONAL<String>& namespaceUri()
    {return field_namespaceUri;}
  inline const OPTIONAL<String>& namespaceUri() const
    {return field_namespaceUri;}
  inline OPTIONAL<INTEGER>& serverIndex()
    {return field_serverIndex;}
  inline const OPTIONAL<INTEGER>& serverIndex() const
    {return field_serverIndex;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ExpandedNodeId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExpandedNodeId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExpandedNodeId& other_value);
void copy_template(const ExpandedNodeId_template& other_value);

public:
ExpandedNodeId_template();
ExpandedNodeId_template(template_sel other_value);
ExpandedNodeId_template(const ExpandedNodeId& other_value);
ExpandedNodeId_template(const OPTIONAL<ExpandedNodeId>& other_value);
ExpandedNodeId_template(const ExpandedNodeId_template& other_value);
~ExpandedNodeId_template();
ExpandedNodeId_template& operator=(template_sel other_value);
ExpandedNodeId_template& operator=(const ExpandedNodeId& other_value);
ExpandedNodeId_template& operator=(const OPTIONAL<ExpandedNodeId>& other_value);
ExpandedNodeId_template& operator=(const ExpandedNodeId_template& other_value);
boolean match(const ExpandedNodeId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExpandedNodeId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExpandedNodeId_template& list_item(unsigned int list_index) const;
NodeId_template& node();
const NodeId_template& node() const;
String_template& namespaceUri();
const String_template& namespaceUri() const;
INTEGER_template& serverIndex();
const INTEGER_template& serverIndex() const;
int size_of() const;
void log() const;
void log_match(const ExpandedNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtensibleParameter : public Base_Type {
  INTEGER field_encodingByte;
  OPTIONAL<INTEGER> field_twoByteNodeValue;
  OPTIONAL<INTEGER> field_namespaceIndex;
  OPTIONAL<INTEGER> field_fourByteNodeValue;
  INTEGER field_encoding;
  OPTIONAL<INTEGER> field_parameterLength;
  OPTIONAL<ExtensibleParameterBody> field_extensibleParameterBody;
public:
  ExtensibleParameter();
  ExtensibleParameter(const INTEGER& par_encodingByte,
    const OPTIONAL<INTEGER>& par_twoByteNodeValue,
    const OPTIONAL<INTEGER>& par_namespaceIndex,
    const OPTIONAL<INTEGER>& par_fourByteNodeValue,
    const INTEGER& par_encoding,
    const OPTIONAL<INTEGER>& par_parameterLength,
    const OPTIONAL<ExtensibleParameterBody>& par_extensibleParameterBody);
  ExtensibleParameter(const ExtensibleParameter& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtensibleParameter& operator=(const ExtensibleParameter& other_value);
  boolean operator==(const ExtensibleParameter& other_value) const;
  inline boolean operator!=(const ExtensibleParameter& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& encodingByte()
    {return field_encodingByte;}
  inline const INTEGER& encodingByte() const
    {return field_encodingByte;}
  inline OPTIONAL<INTEGER>& twoByteNodeValue()
    {return field_twoByteNodeValue;}
  inline const OPTIONAL<INTEGER>& twoByteNodeValue() const
    {return field_twoByteNodeValue;}
  inline OPTIONAL<INTEGER>& namespaceIndex()
    {return field_namespaceIndex;}
  inline const OPTIONAL<INTEGER>& namespaceIndex() const
    {return field_namespaceIndex;}
  inline OPTIONAL<INTEGER>& fourByteNodeValue()
    {return field_fourByteNodeValue;}
  inline const OPTIONAL<INTEGER>& fourByteNodeValue() const
    {return field_fourByteNodeValue;}
  inline INTEGER& encoding()
    {return field_encoding;}
  inline const INTEGER& encoding() const
    {return field_encoding;}
  inline OPTIONAL<INTEGER>& parameterLength()
    {return field_parameterLength;}
  inline const OPTIONAL<INTEGER>& parameterLength() const
    {return field_parameterLength;}
  inline OPTIONAL<ExtensibleParameterBody>& extensibleParameterBody()
    {return field_extensibleParameterBody;}
  inline const OPTIONAL<ExtensibleParameterBody>& extensibleParameterBody() const
    {return field_extensibleParameterBody;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ExtensibleParameter_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtensibleParameter_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtensibleParameter& other_value);
void copy_template(const ExtensibleParameter_template& other_value);

public:
ExtensibleParameter_template();
ExtensibleParameter_template(template_sel other_value);
ExtensibleParameter_template(const ExtensibleParameter& other_value);
ExtensibleParameter_template(const OPTIONAL<ExtensibleParameter>& other_value);
ExtensibleParameter_template(const ExtensibleParameter_template& other_value);
~ExtensibleParameter_template();
ExtensibleParameter_template& operator=(template_sel other_value);
ExtensibleParameter_template& operator=(const ExtensibleParameter& other_value);
ExtensibleParameter_template& operator=(const OPTIONAL<ExtensibleParameter>& other_value);
ExtensibleParameter_template& operator=(const ExtensibleParameter_template& other_value);
boolean match(const ExtensibleParameter& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtensibleParameter valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtensibleParameter_template& list_item(unsigned int list_index) const;
INTEGER_template& encodingByte();
const INTEGER_template& encodingByte() const;
INTEGER_template& twoByteNodeValue();
const INTEGER_template& twoByteNodeValue() const;
INTEGER_template& namespaceIndex();
const INTEGER_template& namespaceIndex() const;
INTEGER_template& fourByteNodeValue();
const INTEGER_template& fourByteNodeValue() const;
INTEGER_template& encoding();
const INTEGER_template& encoding() const;
INTEGER_template& parameterLength();
const INTEGER_template& parameterLength() const;
ExtensibleParameterBody_template& extensibleParameterBody();
const ExtensibleParameterBody_template& extensibleParameterBody() const;
int size_of() const;
void log() const;
void log_match(const ExtensibleParameter& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtensibleParameterBody : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_elementOperand = 1, ALT_literalOperand = 2, ALT_attributeOperand = 3, ALT_simpleAttributeOperand = 4, ALT_dataChangeFilter = 5, ALT_eventFilter = 6, ALT_aggregateFilter = 7, ALT_eventFilterResult = 8, ALT_aggregateFilterResult = 9, ALT_objectAttributes = 10, ALT_variableAttributes = 11, ALT_methodAttributes = 12, ALT_objectTypeAttributes = 13, ALT_variableTypeAttributes = 14, ALT_referenceTypeAttributes = 15, ALT_dataTypeAttributes = 16, ALT_viewAttributes = 17, ALT_genericAttributes = 18, ALT_userNameIdentityToken = 19, ALT_x509IdentityToken = 20, ALT_issuedIdentityToken = 21, ALT_anonymousIdentityToken = 22, ALT_mdnsDiscoveryConfiguration = 23, ALT_readEventDetails = 24, ALT_readRawModifiedDetails = 25, ALT_readProcessedDetails = 26, ALT_readAtTimeDetails = 27, ALT_dataValues = 28, ALT_updateDataDetails = 29, ALT_updateStructureDataDetails = 30, ALT_updateEventDetails = 31, ALT_deleteRawModifiedDetails = 32, ALT_deleteAtTimeDetails = 33, ALT_deleteEventDetails = 34, ALT_dataChangeNotification = 35, ALT_eventNotificationList = 36, ALT_statusChangeNotification = 37 };
private:
union_selection_type union_selection;
union {
ElementOperand *field_elementOperand;
LiteralOperand *field_literalOperand;
AttributeOperand *field_attributeOperand;
SimpleAttributeOperand *field_simpleAttributeOperand;
DataChangeFilter *field_dataChangeFilter;
EventFilter *field_eventFilter;
AggregateFilter *field_aggregateFilter;
EventFilterResult *field_eventFilterResult;
AggregateFilterResult *field_aggregateFilterResult;
ObjectAttributes *field_objectAttributes;
VariableAttributes *field_variableAttributes;
MethodAttributes *field_methodAttributes;
ObjectTypeAttributes *field_objectTypeAttributes;
VariableTypeAttributes *field_variableTypeAttributes;
ReferenceTypeAttributes *field_referenceTypeAttributes;
DataTypeAttributes *field_dataTypeAttributes;
ViewAttributes *field_viewAttributes;
GenericAttributes *field_genericAttributes;
UserNameIdentityToken *field_userNameIdentityToken;
X509IdentityToken *field_x509IdentityToken;
IssuedIdentityToken *field_issuedIdentityToken;
AnonymousIdentityToken *field_anonymousIdentityToken;
MdnsDiscoveryConfiguration *field_mdnsDiscoveryConfiguration;
ReadEventDetails *field_readEventDetails;
ReadRawModifiedDetails *field_readRawModifiedDetails;
ReadProcessedDetails *field_readProcessedDetails;
ReadAtTimeDetails *field_readAtTimeDetails;
ListOfDataValue *field_dataValues;
UpdateDataDetails *field_updateDataDetails;
UpdateStructureDataDetails *field_updateStructureDataDetails;
UpdateEventDetails *field_updateEventDetails;
DeleteRawModifiedDetails *field_deleteRawModifiedDetails;
DeleteAtTimeDetails *field_deleteAtTimeDetails;
DeleteEventDetails *field_deleteEventDetails;
DataChangeNotification *field_dataChangeNotification;
EventNotificationList *field_eventNotificationList;
StatusChangeNotification *field_statusChangeNotification;
};
void copy_value(const ExtensibleParameterBody& other_value);

public:
ExtensibleParameterBody();
ExtensibleParameterBody(const ExtensibleParameterBody& other_value);
~ExtensibleParameterBody();
ExtensibleParameterBody& operator=(const ExtensibleParameterBody& other_value);
boolean operator==(const ExtensibleParameterBody& other_value) const;
inline boolean operator!=(const ExtensibleParameterBody& other_value) const { return !(*this == other_value); }
ElementOperand& elementOperand();
const ElementOperand& elementOperand() const;
LiteralOperand& literalOperand();
const LiteralOperand& literalOperand() const;
AttributeOperand& attributeOperand();
const AttributeOperand& attributeOperand() const;
SimpleAttributeOperand& simpleAttributeOperand();
const SimpleAttributeOperand& simpleAttributeOperand() const;
DataChangeFilter& dataChangeFilter();
const DataChangeFilter& dataChangeFilter() const;
EventFilter& eventFilter();
const EventFilter& eventFilter() const;
AggregateFilter& aggregateFilter();
const AggregateFilter& aggregateFilter() const;
EventFilterResult& eventFilterResult();
const EventFilterResult& eventFilterResult() const;
AggregateFilterResult& aggregateFilterResult();
const AggregateFilterResult& aggregateFilterResult() const;
ObjectAttributes& objectAttributes();
const ObjectAttributes& objectAttributes() const;
VariableAttributes& variableAttributes();
const VariableAttributes& variableAttributes() const;
MethodAttributes& methodAttributes();
const MethodAttributes& methodAttributes() const;
ObjectTypeAttributes& objectTypeAttributes();
const ObjectTypeAttributes& objectTypeAttributes() const;
VariableTypeAttributes& variableTypeAttributes();
const VariableTypeAttributes& variableTypeAttributes() const;
ReferenceTypeAttributes& referenceTypeAttributes();
const ReferenceTypeAttributes& referenceTypeAttributes() const;
DataTypeAttributes& dataTypeAttributes();
const DataTypeAttributes& dataTypeAttributes() const;
ViewAttributes& viewAttributes();
const ViewAttributes& viewAttributes() const;
GenericAttributes& genericAttributes();
const GenericAttributes& genericAttributes() const;
UserNameIdentityToken& userNameIdentityToken();
const UserNameIdentityToken& userNameIdentityToken() const;
X509IdentityToken& x509IdentityToken();
const X509IdentityToken& x509IdentityToken() const;
IssuedIdentityToken& issuedIdentityToken();
const IssuedIdentityToken& issuedIdentityToken() const;
AnonymousIdentityToken& anonymousIdentityToken();
const AnonymousIdentityToken& anonymousIdentityToken() const;
MdnsDiscoveryConfiguration& mdnsDiscoveryConfiguration();
const MdnsDiscoveryConfiguration& mdnsDiscoveryConfiguration() const;
ReadEventDetails& readEventDetails();
const ReadEventDetails& readEventDetails() const;
ReadRawModifiedDetails& readRawModifiedDetails();
const ReadRawModifiedDetails& readRawModifiedDetails() const;
ReadProcessedDetails& readProcessedDetails();
const ReadProcessedDetails& readProcessedDetails() const;
ReadAtTimeDetails& readAtTimeDetails();
const ReadAtTimeDetails& readAtTimeDetails() const;
ListOfDataValue& dataValues();
const ListOfDataValue& dataValues() const;
UpdateDataDetails& updateDataDetails();
const UpdateDataDetails& updateDataDetails() const;
UpdateStructureDataDetails& updateStructureDataDetails();
const UpdateStructureDataDetails& updateStructureDataDetails() const;
UpdateEventDetails& updateEventDetails();
const UpdateEventDetails& updateEventDetails() const;
DeleteRawModifiedDetails& deleteRawModifiedDetails();
const DeleteRawModifiedDetails& deleteRawModifiedDetails() const;
DeleteAtTimeDetails& deleteAtTimeDetails();
const DeleteAtTimeDetails& deleteAtTimeDetails() const;
DeleteEventDetails& deleteEventDetails();
const DeleteEventDetails& deleteEventDetails() const;
DataChangeNotification& dataChangeNotification();
const DataChangeNotification& dataChangeNotification() const;
EventNotificationList& eventNotificationList();
const EventNotificationList& eventNotificationList() const;
StatusChangeNotification& statusChangeNotification();
const StatusChangeNotification& statusChangeNotification() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ExtensibleParameterBody_template : public Base_Template {
union {
struct {
ExtensibleParameterBody::union_selection_type union_selection;
union {
ElementOperand_template *field_elementOperand;
LiteralOperand_template *field_literalOperand;
AttributeOperand_template *field_attributeOperand;
SimpleAttributeOperand_template *field_simpleAttributeOperand;
DataChangeFilter_template *field_dataChangeFilter;
EventFilter_template *field_eventFilter;
AggregateFilter_template *field_aggregateFilter;
EventFilterResult_template *field_eventFilterResult;
AggregateFilterResult_template *field_aggregateFilterResult;
ObjectAttributes_template *field_objectAttributes;
VariableAttributes_template *field_variableAttributes;
MethodAttributes_template *field_methodAttributes;
ObjectTypeAttributes_template *field_objectTypeAttributes;
VariableTypeAttributes_template *field_variableTypeAttributes;
ReferenceTypeAttributes_template *field_referenceTypeAttributes;
DataTypeAttributes_template *field_dataTypeAttributes;
ViewAttributes_template *field_viewAttributes;
GenericAttributes_template *field_genericAttributes;
UserNameIdentityToken_template *field_userNameIdentityToken;
X509IdentityToken_template *field_x509IdentityToken;
IssuedIdentityToken_template *field_issuedIdentityToken;
AnonymousIdentityToken_template *field_anonymousIdentityToken;
MdnsDiscoveryConfiguration_template *field_mdnsDiscoveryConfiguration;
ReadEventDetails_template *field_readEventDetails;
ReadRawModifiedDetails_template *field_readRawModifiedDetails;
ReadProcessedDetails_template *field_readProcessedDetails;
ReadAtTimeDetails_template *field_readAtTimeDetails;
ListOfDataValue_template *field_dataValues;
UpdateDataDetails_template *field_updateDataDetails;
UpdateStructureDataDetails_template *field_updateStructureDataDetails;
UpdateEventDetails_template *field_updateEventDetails;
DeleteRawModifiedDetails_template *field_deleteRawModifiedDetails;
DeleteAtTimeDetails_template *field_deleteAtTimeDetails;
DeleteEventDetails_template *field_deleteEventDetails;
DataChangeNotification_template *field_dataChangeNotification;
EventNotificationList_template *field_eventNotificationList;
StatusChangeNotification_template *field_statusChangeNotification;
};
} single_value;
struct {
unsigned int n_values;
ExtensibleParameterBody_template *list_value;
} value_list;
};
void copy_value(const ExtensibleParameterBody& other_value);

void copy_template(const ExtensibleParameterBody_template& other_value);

public:
ExtensibleParameterBody_template();
ExtensibleParameterBody_template(template_sel other_value);
ExtensibleParameterBody_template(const ExtensibleParameterBody& other_value);
ExtensibleParameterBody_template(const OPTIONAL<ExtensibleParameterBody>& other_value);
ExtensibleParameterBody_template(const ExtensibleParameterBody_template& other_value);
~ExtensibleParameterBody_template();
void clean_up();
ExtensibleParameterBody_template& operator=(template_sel other_value);
ExtensibleParameterBody_template& operator=(const ExtensibleParameterBody& other_value);
ExtensibleParameterBody_template& operator=(const OPTIONAL<ExtensibleParameterBody>& other_value);
ExtensibleParameterBody_template& operator=(const ExtensibleParameterBody_template& other_value);
boolean match(const ExtensibleParameterBody& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ExtensibleParameterBody valueof() const;
ExtensibleParameterBody_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ElementOperand_template& elementOperand();
const ElementOperand_template& elementOperand() const;
LiteralOperand_template& literalOperand();
const LiteralOperand_template& literalOperand() const;
AttributeOperand_template& attributeOperand();
const AttributeOperand_template& attributeOperand() const;
SimpleAttributeOperand_template& simpleAttributeOperand();
const SimpleAttributeOperand_template& simpleAttributeOperand() const;
DataChangeFilter_template& dataChangeFilter();
const DataChangeFilter_template& dataChangeFilter() const;
EventFilter_template& eventFilter();
const EventFilter_template& eventFilter() const;
AggregateFilter_template& aggregateFilter();
const AggregateFilter_template& aggregateFilter() const;
EventFilterResult_template& eventFilterResult();
const EventFilterResult_template& eventFilterResult() const;
AggregateFilterResult_template& aggregateFilterResult();
const AggregateFilterResult_template& aggregateFilterResult() const;
ObjectAttributes_template& objectAttributes();
const ObjectAttributes_template& objectAttributes() const;
VariableAttributes_template& variableAttributes();
const VariableAttributes_template& variableAttributes() const;
MethodAttributes_template& methodAttributes();
const MethodAttributes_template& methodAttributes() const;
ObjectTypeAttributes_template& objectTypeAttributes();
const ObjectTypeAttributes_template& objectTypeAttributes() const;
VariableTypeAttributes_template& variableTypeAttributes();
const VariableTypeAttributes_template& variableTypeAttributes() const;
ReferenceTypeAttributes_template& referenceTypeAttributes();
const ReferenceTypeAttributes_template& referenceTypeAttributes() const;
DataTypeAttributes_template& dataTypeAttributes();
const DataTypeAttributes_template& dataTypeAttributes() const;
ViewAttributes_template& viewAttributes();
const ViewAttributes_template& viewAttributes() const;
GenericAttributes_template& genericAttributes();
const GenericAttributes_template& genericAttributes() const;
UserNameIdentityToken_template& userNameIdentityToken();
const UserNameIdentityToken_template& userNameIdentityToken() const;
X509IdentityToken_template& x509IdentityToken();
const X509IdentityToken_template& x509IdentityToken() const;
IssuedIdentityToken_template& issuedIdentityToken();
const IssuedIdentityToken_template& issuedIdentityToken() const;
AnonymousIdentityToken_template& anonymousIdentityToken();
const AnonymousIdentityToken_template& anonymousIdentityToken() const;
MdnsDiscoveryConfiguration_template& mdnsDiscoveryConfiguration();
const MdnsDiscoveryConfiguration_template& mdnsDiscoveryConfiguration() const;
ReadEventDetails_template& readEventDetails();
const ReadEventDetails_template& readEventDetails() const;
ReadRawModifiedDetails_template& readRawModifiedDetails();
const ReadRawModifiedDetails_template& readRawModifiedDetails() const;
ReadProcessedDetails_template& readProcessedDetails();
const ReadProcessedDetails_template& readProcessedDetails() const;
ReadAtTimeDetails_template& readAtTimeDetails();
const ReadAtTimeDetails_template& readAtTimeDetails() const;
ListOfDataValue_template& dataValues();
const ListOfDataValue_template& dataValues() const;
UpdateDataDetails_template& updateDataDetails();
const UpdateDataDetails_template& updateDataDetails() const;
UpdateStructureDataDetails_template& updateStructureDataDetails();
const UpdateStructureDataDetails_template& updateStructureDataDetails() const;
UpdateEventDetails_template& updateEventDetails();
const UpdateEventDetails_template& updateEventDetails() const;
DeleteRawModifiedDetails_template& deleteRawModifiedDetails();
const DeleteRawModifiedDetails_template& deleteRawModifiedDetails() const;
DeleteAtTimeDetails_template& deleteAtTimeDetails();
const DeleteAtTimeDetails_template& deleteAtTimeDetails() const;
DeleteEventDetails_template& deleteEventDetails();
const DeleteEventDetails_template& deleteEventDetails() const;
DataChangeNotification_template& dataChangeNotification();
const DataChangeNotification_template& dataChangeNotification() const;
EventNotificationList_template& eventNotificationList();
const EventNotificationList_template& eventNotificationList() const;
StatusChangeNotification_template& statusChangeNotification();
const StatusChangeNotification_template& statusChangeNotification() const;
boolean ischosen(ExtensibleParameterBody::union_selection_type checked_selection) const;
void log() const;
void log_match(const ExtensibleParameterBody& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ElementOperand : public Base_Type {
  INTEGER field_index;
public:
  ElementOperand();
  ElementOperand(const INTEGER& par_index);
  ElementOperand(const ElementOperand& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ElementOperand& operator=(const ElementOperand& other_value);
  boolean operator==(const ElementOperand& other_value) const;
  inline boolean operator!=(const ElementOperand& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& index()
    {return field_index;}
  inline const INTEGER& index() const
    {return field_index;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ElementOperand_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ElementOperand_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ElementOperand& other_value);
void copy_template(const ElementOperand_template& other_value);

public:
ElementOperand_template();
ElementOperand_template(template_sel other_value);
ElementOperand_template(const ElementOperand& other_value);
ElementOperand_template(const OPTIONAL<ElementOperand>& other_value);
ElementOperand_template(const ElementOperand_template& other_value);
~ElementOperand_template();
ElementOperand_template& operator=(template_sel other_value);
ElementOperand_template& operator=(const ElementOperand& other_value);
ElementOperand_template& operator=(const OPTIONAL<ElementOperand>& other_value);
ElementOperand_template& operator=(const ElementOperand_template& other_value);
boolean match(const ElementOperand& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ElementOperand valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ElementOperand_template& list_item(unsigned int list_index) const;
INTEGER_template& index();
const INTEGER_template& index() const;
int size_of() const;
void log() const;
void log_match(const ElementOperand& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Variant : public Base_Type {
  INTEGER field_encodingBits;
  INTEGER field_arrayDimensionsBit;
  INTEGER field_arrayEncodedBit;
  OPTIONAL<INTEGER> field_arrayLength;
  OPTIONAL<VariantSingleValue> field_ValueSingle;
  OPTIONAL<VariantArrayValue> field_ValueArray;
  OPTIONAL<INTEGER> field_arrayDimensionsLenght;
  OPTIONAL<ListOfInt32> field_arrayDimensions;
public:
  Variant();
  Variant(const INTEGER& par_encodingBits,
    const INTEGER& par_arrayDimensionsBit,
    const INTEGER& par_arrayEncodedBit,
    const OPTIONAL<INTEGER>& par_arrayLength,
    const OPTIONAL<VariantSingleValue>& par_ValueSingle,
    const OPTIONAL<VariantArrayValue>& par_ValueArray,
    const OPTIONAL<INTEGER>& par_arrayDimensionsLenght,
    const OPTIONAL<ListOfInt32>& par_arrayDimensions);
  Variant(const Variant& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Variant& operator=(const Variant& other_value);
  boolean operator==(const Variant& other_value) const;
  inline boolean operator!=(const Variant& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& encodingBits()
    {return field_encodingBits;}
  inline const INTEGER& encodingBits() const
    {return field_encodingBits;}
  inline INTEGER& arrayDimensionsBit()
    {return field_arrayDimensionsBit;}
  inline const INTEGER& arrayDimensionsBit() const
    {return field_arrayDimensionsBit;}
  inline INTEGER& arrayEncodedBit()
    {return field_arrayEncodedBit;}
  inline const INTEGER& arrayEncodedBit() const
    {return field_arrayEncodedBit;}
  inline OPTIONAL<INTEGER>& arrayLength()
    {return field_arrayLength;}
  inline const OPTIONAL<INTEGER>& arrayLength() const
    {return field_arrayLength;}
  inline OPTIONAL<VariantSingleValue>& ValueSingle()
    {return field_ValueSingle;}
  inline const OPTIONAL<VariantSingleValue>& ValueSingle() const
    {return field_ValueSingle;}
  inline OPTIONAL<VariantArrayValue>& ValueArray()
    {return field_ValueArray;}
  inline const OPTIONAL<VariantArrayValue>& ValueArray() const
    {return field_ValueArray;}
  inline OPTIONAL<INTEGER>& arrayDimensionsLenght()
    {return field_arrayDimensionsLenght;}
  inline const OPTIONAL<INTEGER>& arrayDimensionsLenght() const
    {return field_arrayDimensionsLenght;}
  inline OPTIONAL<ListOfInt32>& arrayDimensions()
    {return field_arrayDimensions;}
  inline const OPTIONAL<ListOfInt32>& arrayDimensions() const
    {return field_arrayDimensions;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class Variant_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Variant_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Variant& other_value);
void copy_template(const Variant_template& other_value);

public:
Variant_template();
Variant_template(template_sel other_value);
Variant_template(const Variant& other_value);
Variant_template(const OPTIONAL<Variant>& other_value);
Variant_template(const Variant_template& other_value);
~Variant_template();
Variant_template& operator=(template_sel other_value);
Variant_template& operator=(const Variant& other_value);
Variant_template& operator=(const OPTIONAL<Variant>& other_value);
Variant_template& operator=(const Variant_template& other_value);
boolean match(const Variant& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Variant valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Variant_template& list_item(unsigned int list_index) const;
INTEGER_template& encodingBits();
const INTEGER_template& encodingBits() const;
INTEGER_template& arrayDimensionsBit();
const INTEGER_template& arrayDimensionsBit() const;
INTEGER_template& arrayEncodedBit();
const INTEGER_template& arrayEncodedBit() const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
VariantSingleValue_template& ValueSingle();
const VariantSingleValue_template& ValueSingle() const;
VariantArrayValue_template& ValueArray();
const VariantArrayValue_template& ValueArray() const;
INTEGER_template& arrayDimensionsLenght();
const INTEGER_template& arrayDimensionsLenght() const;
ListOfInt32_template& arrayDimensions();
const ListOfInt32_template& arrayDimensions() const;
int size_of() const;
void log() const;
void log_match(const Variant& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class VariantSingleValue : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_bool_ = 1, ALT_sbyte = 2, ALT_byte = 3, ALT_int16 = 4, ALT_uint16 = 5, ALT_int32 = 6, ALT_uint32 = 7, ALT_int64 = 8, ALT_uint64 = 9, ALT_floatValue = 10, ALT_double_ = 11, ALT_string = 12, ALT_datetime = 13, ALT_guid = 14, ALT_bytestring = 15, ALT_xmlelement = 16, ALT_nodeid = 17, ALT_expandednodeid = 18, ALT_statuscode = 19, ALT_qualifiedname = 20, ALT_localizedtext = 21, ALT_extensionobject = 22, ALT_datavalue = 23, ALT_listofvariant = 24, ALT_diagnosticinfo = 25 };
private:
union_selection_type union_selection;
union {
INTEGER *field_bool_;
INTEGER *field_sbyte;
INTEGER *field_byte;
INTEGER *field_int16;
INTEGER *field_uint16;
INTEGER *field_int32;
INTEGER *field_uint32;
INTEGER *field_int64;
INTEGER *field_uint64;
FLOAT *field_floatValue;
FLOAT *field_double_;
String *field_string;
INTEGER *field_datetime;
Guid *field_guid;
ByteString *field_bytestring;
ByteString *field_xmlelement;
NodeId *field_nodeid;
ExpandedNodeId *field_expandednodeid;
INTEGER *field_statuscode;
QualifiedName *field_qualifiedname;
LocalizedText *field_localizedtext;
ExtensionObject *field_extensionobject;
DataValue *field_datavalue;
ListOfVariant *field_listofvariant;
DiagnosticInfo *field_diagnosticinfo;
};
void copy_value(const VariantSingleValue& other_value);

public:
VariantSingleValue();
VariantSingleValue(const VariantSingleValue& other_value);
~VariantSingleValue();
VariantSingleValue& operator=(const VariantSingleValue& other_value);
boolean operator==(const VariantSingleValue& other_value) const;
inline boolean operator!=(const VariantSingleValue& other_value) const { return !(*this == other_value); }
INTEGER& bool_();
const INTEGER& bool_() const;
INTEGER& sbyte();
const INTEGER& sbyte() const;
INTEGER& byte();
const INTEGER& byte() const;
INTEGER& int16();
const INTEGER& int16() const;
INTEGER& uint16();
const INTEGER& uint16() const;
INTEGER& int32();
const INTEGER& int32() const;
INTEGER& uint32();
const INTEGER& uint32() const;
INTEGER& int64();
const INTEGER& int64() const;
INTEGER& uint64();
const INTEGER& uint64() const;
FLOAT& floatValue();
const FLOAT& floatValue() const;
FLOAT& double_();
const FLOAT& double_() const;
String& string();
const String& string() const;
INTEGER& datetime();
const INTEGER& datetime() const;
Guid& guid();
const Guid& guid() const;
ByteString& bytestring();
const ByteString& bytestring() const;
ByteString& xmlelement();
const ByteString& xmlelement() const;
NodeId& nodeid();
const NodeId& nodeid() const;
ExpandedNodeId& expandednodeid();
const ExpandedNodeId& expandednodeid() const;
INTEGER& statuscode();
const INTEGER& statuscode() const;
QualifiedName& qualifiedname();
const QualifiedName& qualifiedname() const;
LocalizedText& localizedtext();
const LocalizedText& localizedtext() const;
ExtensionObject& extensionobject();
const ExtensionObject& extensionobject() const;
DataValue& datavalue();
const DataValue& datavalue() const;
ListOfVariant& listofvariant();
const ListOfVariant& listofvariant() const;
DiagnosticInfo& diagnosticinfo();
const DiagnosticInfo& diagnosticinfo() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class VariantSingleValue_template : public Base_Template {
union {
struct {
VariantSingleValue::union_selection_type union_selection;
union {
INTEGER_template *field_bool_;
INTEGER_template *field_sbyte;
INTEGER_template *field_byte;
INTEGER_template *field_int16;
INTEGER_template *field_uint16;
INTEGER_template *field_int32;
INTEGER_template *field_uint32;
INTEGER_template *field_int64;
INTEGER_template *field_uint64;
FLOAT_template *field_floatValue;
FLOAT_template *field_double_;
String_template *field_string;
INTEGER_template *field_datetime;
Guid_template *field_guid;
ByteString_template *field_bytestring;
ByteString_template *field_xmlelement;
NodeId_template *field_nodeid;
ExpandedNodeId_template *field_expandednodeid;
INTEGER_template *field_statuscode;
QualifiedName_template *field_qualifiedname;
LocalizedText_template *field_localizedtext;
ExtensionObject_template *field_extensionobject;
DataValue_template *field_datavalue;
ListOfVariant_template *field_listofvariant;
DiagnosticInfo_template *field_diagnosticinfo;
};
} single_value;
struct {
unsigned int n_values;
VariantSingleValue_template *list_value;
} value_list;
};
void copy_value(const VariantSingleValue& other_value);

void copy_template(const VariantSingleValue_template& other_value);

public:
VariantSingleValue_template();
VariantSingleValue_template(template_sel other_value);
VariantSingleValue_template(const VariantSingleValue& other_value);
VariantSingleValue_template(const OPTIONAL<VariantSingleValue>& other_value);
VariantSingleValue_template(const VariantSingleValue_template& other_value);
~VariantSingleValue_template();
void clean_up();
VariantSingleValue_template& operator=(template_sel other_value);
VariantSingleValue_template& operator=(const VariantSingleValue& other_value);
VariantSingleValue_template& operator=(const OPTIONAL<VariantSingleValue>& other_value);
VariantSingleValue_template& operator=(const VariantSingleValue_template& other_value);
boolean match(const VariantSingleValue& other_value, boolean legacy = FALSE) const;
boolean is_value() const;VariantSingleValue valueof() const;
VariantSingleValue_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
INTEGER_template& bool_();
const INTEGER_template& bool_() const;
INTEGER_template& sbyte();
const INTEGER_template& sbyte() const;
INTEGER_template& byte();
const INTEGER_template& byte() const;
INTEGER_template& int16();
const INTEGER_template& int16() const;
INTEGER_template& uint16();
const INTEGER_template& uint16() const;
INTEGER_template& int32();
const INTEGER_template& int32() const;
INTEGER_template& uint32();
const INTEGER_template& uint32() const;
INTEGER_template& int64();
const INTEGER_template& int64() const;
INTEGER_template& uint64();
const INTEGER_template& uint64() const;
FLOAT_template& floatValue();
const FLOAT_template& floatValue() const;
FLOAT_template& double_();
const FLOAT_template& double_() const;
String_template& string();
const String_template& string() const;
INTEGER_template& datetime();
const INTEGER_template& datetime() const;
Guid_template& guid();
const Guid_template& guid() const;
ByteString_template& bytestring();
const ByteString_template& bytestring() const;
ByteString_template& xmlelement();
const ByteString_template& xmlelement() const;
NodeId_template& nodeid();
const NodeId_template& nodeid() const;
ExpandedNodeId_template& expandednodeid();
const ExpandedNodeId_template& expandednodeid() const;
INTEGER_template& statuscode();
const INTEGER_template& statuscode() const;
QualifiedName_template& qualifiedname();
const QualifiedName_template& qualifiedname() const;
LocalizedText_template& localizedtext();
const LocalizedText_template& localizedtext() const;
ExtensionObject_template& extensionobject();
const ExtensionObject_template& extensionobject() const;
DataValue_template& datavalue();
const DataValue_template& datavalue() const;
ListOfVariant_template& listofvariant();
const ListOfVariant_template& listofvariant() const;
DiagnosticInfo_template& diagnosticinfo();
const DiagnosticInfo_template& diagnosticinfo() const;
boolean ischosen(VariantSingleValue::union_selection_type checked_selection) const;
void log() const;
void log_match(const VariantSingleValue& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class QualifiedName : public Base_Type {
  INTEGER field_namespaceIndex;
  String field_name;
public:
  QualifiedName();
  QualifiedName(const INTEGER& par_namespaceIndex,
    const String& par_name);
  QualifiedName(const QualifiedName& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QualifiedName& operator=(const QualifiedName& other_value);
  boolean operator==(const QualifiedName& other_value) const;
  inline boolean operator!=(const QualifiedName& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& namespaceIndex()
    {return field_namespaceIndex;}
  inline const INTEGER& namespaceIndex() const
    {return field_namespaceIndex;}
  inline String& name()
    {return field_name;}
  inline const String& name() const
    {return field_name;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QualifiedName_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QualifiedName_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QualifiedName& other_value);
void copy_template(const QualifiedName_template& other_value);

public:
QualifiedName_template();
QualifiedName_template(template_sel other_value);
QualifiedName_template(const QualifiedName& other_value);
QualifiedName_template(const OPTIONAL<QualifiedName>& other_value);
QualifiedName_template(const QualifiedName_template& other_value);
~QualifiedName_template();
QualifiedName_template& operator=(template_sel other_value);
QualifiedName_template& operator=(const QualifiedName& other_value);
QualifiedName_template& operator=(const OPTIONAL<QualifiedName>& other_value);
QualifiedName_template& operator=(const QualifiedName_template& other_value);
boolean match(const QualifiedName& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QualifiedName valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QualifiedName_template& list_item(unsigned int list_index) const;
INTEGER_template& namespaceIndex();
const INTEGER_template& namespaceIndex() const;
String_template& name();
const String_template& name() const;
int size_of() const;
void log() const;
void log_match(const QualifiedName& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LocalizedText : public Base_Type {
  INTEGER field_localeBit;
  INTEGER field_textBit;
  INTEGER field_spareBit1;
  INTEGER field_spareBit2;
  INTEGER field_spareBit3;
  INTEGER field_spareBit4;
  INTEGER field_spareBit5;
  INTEGER field_spareBit6;
  OPTIONAL<String> field_locale;
  OPTIONAL<String> field_text;
public:
  LocalizedText();
  LocalizedText(const INTEGER& par_localeBit,
    const INTEGER& par_textBit,
    const INTEGER& par_spareBit1,
    const INTEGER& par_spareBit2,
    const INTEGER& par_spareBit3,
    const INTEGER& par_spareBit4,
    const INTEGER& par_spareBit5,
    const INTEGER& par_spareBit6,
    const OPTIONAL<String>& par_locale,
    const OPTIONAL<String>& par_text);
  LocalizedText(const LocalizedText& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LocalizedText& operator=(const LocalizedText& other_value);
  boolean operator==(const LocalizedText& other_value) const;
  inline boolean operator!=(const LocalizedText& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& localeBit()
    {return field_localeBit;}
  inline const INTEGER& localeBit() const
    {return field_localeBit;}
  inline INTEGER& textBit()
    {return field_textBit;}
  inline const INTEGER& textBit() const
    {return field_textBit;}
  inline INTEGER& spareBit1()
    {return field_spareBit1;}
  inline const INTEGER& spareBit1() const
    {return field_spareBit1;}
  inline INTEGER& spareBit2()
    {return field_spareBit2;}
  inline const INTEGER& spareBit2() const
    {return field_spareBit2;}
  inline INTEGER& spareBit3()
    {return field_spareBit3;}
  inline const INTEGER& spareBit3() const
    {return field_spareBit3;}
  inline INTEGER& spareBit4()
    {return field_spareBit4;}
  inline const INTEGER& spareBit4() const
    {return field_spareBit4;}
  inline INTEGER& spareBit5()
    {return field_spareBit5;}
  inline const INTEGER& spareBit5() const
    {return field_spareBit5;}
  inline INTEGER& spareBit6()
    {return field_spareBit6;}
  inline const INTEGER& spareBit6() const
    {return field_spareBit6;}
  inline OPTIONAL<String>& locale()
    {return field_locale;}
  inline const OPTIONAL<String>& locale() const
    {return field_locale;}
  inline OPTIONAL<String>& text()
    {return field_text;}
  inline const OPTIONAL<String>& text() const
    {return field_text;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class LocalizedText_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LocalizedText_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LocalizedText& other_value);
void copy_template(const LocalizedText_template& other_value);

public:
LocalizedText_template();
LocalizedText_template(template_sel other_value);
LocalizedText_template(const LocalizedText& other_value);
LocalizedText_template(const OPTIONAL<LocalizedText>& other_value);
LocalizedText_template(const LocalizedText_template& other_value);
~LocalizedText_template();
LocalizedText_template& operator=(template_sel other_value);
LocalizedText_template& operator=(const LocalizedText& other_value);
LocalizedText_template& operator=(const OPTIONAL<LocalizedText>& other_value);
LocalizedText_template& operator=(const LocalizedText_template& other_value);
boolean match(const LocalizedText& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LocalizedText valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LocalizedText_template& list_item(unsigned int list_index) const;
INTEGER_template& localeBit();
const INTEGER_template& localeBit() const;
INTEGER_template& textBit();
const INTEGER_template& textBit() const;
INTEGER_template& spareBit1();
const INTEGER_template& spareBit1() const;
INTEGER_template& spareBit2();
const INTEGER_template& spareBit2() const;
INTEGER_template& spareBit3();
const INTEGER_template& spareBit3() const;
INTEGER_template& spareBit4();
const INTEGER_template& spareBit4() const;
INTEGER_template& spareBit5();
const INTEGER_template& spareBit5() const;
INTEGER_template& spareBit6();
const INTEGER_template& spareBit6() const;
String_template& locale();
const String_template& locale() const;
String_template& text();
const String_template& text() const;
int size_of() const;
void log() const;
void log_match(const LocalizedText& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtensionObject : public Base_Type {
  NodeId field_typeId;
  INTEGER field_encoding;
  INTEGER field_Length;
  OPTIONAL<ExtensionObjectBody> field_body;
public:
  ExtensionObject();
  ExtensionObject(const NodeId& par_typeId,
    const INTEGER& par_encoding,
    const INTEGER& par_Length,
    const OPTIONAL<ExtensionObjectBody>& par_body);
  ExtensionObject(const ExtensionObject& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ExtensionObject& operator=(const ExtensionObject& other_value);
  boolean operator==(const ExtensionObject& other_value) const;
  inline boolean operator!=(const ExtensionObject& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& typeId()
    {return field_typeId;}
  inline const NodeId& typeId() const
    {return field_typeId;}
  inline INTEGER& encoding()
    {return field_encoding;}
  inline const INTEGER& encoding() const
    {return field_encoding;}
  inline INTEGER& Length()
    {return field_Length;}
  inline const INTEGER& Length() const
    {return field_Length;}
  inline OPTIONAL<ExtensionObjectBody>& body()
    {return field_body;}
  inline const OPTIONAL<ExtensionObjectBody>& body() const
    {return field_body;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ExtensionObject_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ExtensionObject_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ExtensionObject& other_value);
void copy_template(const ExtensionObject_template& other_value);

public:
ExtensionObject_template();
ExtensionObject_template(template_sel other_value);
ExtensionObject_template(const ExtensionObject& other_value);
ExtensionObject_template(const OPTIONAL<ExtensionObject>& other_value);
ExtensionObject_template(const ExtensionObject_template& other_value);
~ExtensionObject_template();
ExtensionObject_template& operator=(template_sel other_value);
ExtensionObject_template& operator=(const ExtensionObject& other_value);
ExtensionObject_template& operator=(const OPTIONAL<ExtensionObject>& other_value);
ExtensionObject_template& operator=(const ExtensionObject_template& other_value);
boolean match(const ExtensionObject& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ExtensionObject valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ExtensionObject_template& list_item(unsigned int list_index) const;
NodeId_template& typeId();
const NodeId_template& typeId() const;
INTEGER_template& encoding();
const INTEGER_template& encoding() const;
INTEGER_template& Length();
const INTEGER_template& Length() const;
ExtensionObjectBody_template& body();
const ExtensionObjectBody_template& body() const;
int size_of() const;
void log() const;
void log_match(const ExtensionObject& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ExtensionObjectBody : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_byteString = 1, ALT_xmlElement = 2 };
private:
union_selection_type union_selection;
union {
ListOfByte *field_byteString;
OCTETSTRING *field_xmlElement;
};
void copy_value(const ExtensionObjectBody& other_value);

public:
ExtensionObjectBody();
ExtensionObjectBody(const ExtensionObjectBody& other_value);
~ExtensionObjectBody();
ExtensionObjectBody& operator=(const ExtensionObjectBody& other_value);
boolean operator==(const ExtensionObjectBody& other_value) const;
inline boolean operator!=(const ExtensionObjectBody& other_value) const { return !(*this == other_value); }
ListOfByte& byteString();
const ListOfByte& byteString() const;
OCTETSTRING& xmlElement();
const OCTETSTRING& xmlElement() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ExtensionObjectBody_template : public Base_Template {
union {
struct {
ExtensionObjectBody::union_selection_type union_selection;
union {
ListOfByte_template *field_byteString;
OCTETSTRING_template *field_xmlElement;
};
} single_value;
struct {
unsigned int n_values;
ExtensionObjectBody_template *list_value;
} value_list;
};
void copy_value(const ExtensionObjectBody& other_value);

void copy_template(const ExtensionObjectBody_template& other_value);

public:
ExtensionObjectBody_template();
ExtensionObjectBody_template(template_sel other_value);
ExtensionObjectBody_template(const ExtensionObjectBody& other_value);
ExtensionObjectBody_template(const OPTIONAL<ExtensionObjectBody>& other_value);
ExtensionObjectBody_template(const ExtensionObjectBody_template& other_value);
~ExtensionObjectBody_template();
void clean_up();
ExtensionObjectBody_template& operator=(template_sel other_value);
ExtensionObjectBody_template& operator=(const ExtensionObjectBody& other_value);
ExtensionObjectBody_template& operator=(const OPTIONAL<ExtensionObjectBody>& other_value);
ExtensionObjectBody_template& operator=(const ExtensionObjectBody_template& other_value);
boolean match(const ExtensionObjectBody& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ExtensionObjectBody valueof() const;
ExtensionObjectBody_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfByte_template& byteString();
const ListOfByte_template& byteString() const;
OCTETSTRING_template& xmlElement();
const OCTETSTRING_template& xmlElement() const;
boolean ischosen(ExtensionObjectBody::union_selection_type checked_selection) const;
void log() const;
void log_match(const ExtensionObjectBody& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfByte : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfByteArray *field_realArray;
};
void copy_value(const ListOfByte& other_value);

public:
ListOfByte();
ListOfByte(const ListOfByte& other_value);
~ListOfByte();
ListOfByte& operator=(const ListOfByte& other_value);
boolean operator==(const ListOfByte& other_value) const;
inline boolean operator!=(const ListOfByte& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfByteArray& realArray();
const ListOfByteArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfByte_template : public Base_Template {
union {
struct {
ListOfByte::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfByteArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfByte_template *list_value;
} value_list;
};
void copy_value(const ListOfByte& other_value);

void copy_template(const ListOfByte_template& other_value);

public:
ListOfByte_template();
ListOfByte_template(template_sel other_value);
ListOfByte_template(const ListOfByte& other_value);
ListOfByte_template(const OPTIONAL<ListOfByte>& other_value);
ListOfByte_template(const ListOfByte_template& other_value);
~ListOfByte_template();
void clean_up();
ListOfByte_template& operator=(template_sel other_value);
ListOfByte_template& operator=(const ListOfByte& other_value);
ListOfByte_template& operator=(const OPTIONAL<ListOfByte>& other_value);
ListOfByte_template& operator=(const ListOfByte_template& other_value);
boolean match(const ListOfByte& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfByte valueof() const;
ListOfByte_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfByteArray_template& realArray();
const ListOfByteArray_template& realArray() const;
boolean ischosen(ListOfByte::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfByte& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfByteArray : public Base_Type {
  INTEGER field_arrayLength;
  ByteArray field_arrayValues;
public:
  ListOfByteArray();
  ListOfByteArray(const INTEGER& par_arrayLength,
    const ByteArray& par_arrayValues);
  ListOfByteArray(const ListOfByteArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfByteArray& operator=(const ListOfByteArray& other_value);
  boolean operator==(const ListOfByteArray& other_value) const;
  inline boolean operator!=(const ListOfByteArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ByteArray& arrayValues()
    {return field_arrayValues;}
  inline const ByteArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfByteArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfByteArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfByteArray& other_value);
void copy_template(const ListOfByteArray_template& other_value);

public:
ListOfByteArray_template();
ListOfByteArray_template(template_sel other_value);
ListOfByteArray_template(const ListOfByteArray& other_value);
ListOfByteArray_template(const OPTIONAL<ListOfByteArray>& other_value);
ListOfByteArray_template(const ListOfByteArray_template& other_value);
~ListOfByteArray_template();
ListOfByteArray_template& operator=(template_sel other_value);
ListOfByteArray_template& operator=(const ListOfByteArray& other_value);
ListOfByteArray_template& operator=(const OPTIONAL<ListOfByteArray>& other_value);
ListOfByteArray_template& operator=(const ListOfByteArray_template& other_value);
boolean match(const ListOfByteArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfByteArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfByteArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ByteArray_template& arrayValues();
const ByteArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfByteArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DataValue : public Base_Type {
  INTEGER field_ValueBit;
  INTEGER field_statusBit;
  INTEGER field_sourceTimestampBit;
  INTEGER field_serverTimestampBit;
  INTEGER field_sourcePicoSecondsBit;
  INTEGER field_serverPicoSecondsBit;
  INTEGER field_spareBit1;
  INTEGER field_spareBit2;
  OPTIONAL<Variant> field_Value;
  OPTIONAL<INTEGER> field_status;
  OPTIONAL<INTEGER> field_sourceTimestamp;
  OPTIONAL<INTEGER> field_sourcePicoSeconds;
  OPTIONAL<INTEGER> field_serverTimestamp;
  OPTIONAL<INTEGER> field_serverPicoSeconds;
public:
  DataValue();
  DataValue(const INTEGER& par_ValueBit,
    const INTEGER& par_statusBit,
    const INTEGER& par_sourceTimestampBit,
    const INTEGER& par_serverTimestampBit,
    const INTEGER& par_sourcePicoSecondsBit,
    const INTEGER& par_serverPicoSecondsBit,
    const INTEGER& par_spareBit1,
    const INTEGER& par_spareBit2,
    const OPTIONAL<Variant>& par_Value,
    const OPTIONAL<INTEGER>& par_status,
    const OPTIONAL<INTEGER>& par_sourceTimestamp,
    const OPTIONAL<INTEGER>& par_sourcePicoSeconds,
    const OPTIONAL<INTEGER>& par_serverTimestamp,
    const OPTIONAL<INTEGER>& par_serverPicoSeconds);
  DataValue(const DataValue& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DataValue& operator=(const DataValue& other_value);
  boolean operator==(const DataValue& other_value) const;
  inline boolean operator!=(const DataValue& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& ValueBit()
    {return field_ValueBit;}
  inline const INTEGER& ValueBit() const
    {return field_ValueBit;}
  inline INTEGER& statusBit()
    {return field_statusBit;}
  inline const INTEGER& statusBit() const
    {return field_statusBit;}
  inline INTEGER& sourceTimestampBit()
    {return field_sourceTimestampBit;}
  inline const INTEGER& sourceTimestampBit() const
    {return field_sourceTimestampBit;}
  inline INTEGER& serverTimestampBit()
    {return field_serverTimestampBit;}
  inline const INTEGER& serverTimestampBit() const
    {return field_serverTimestampBit;}
  inline INTEGER& sourcePicoSecondsBit()
    {return field_sourcePicoSecondsBit;}
  inline const INTEGER& sourcePicoSecondsBit() const
    {return field_sourcePicoSecondsBit;}
  inline INTEGER& serverPicoSecondsBit()
    {return field_serverPicoSecondsBit;}
  inline const INTEGER& serverPicoSecondsBit() const
    {return field_serverPicoSecondsBit;}
  inline INTEGER& spareBit1()
    {return field_spareBit1;}
  inline const INTEGER& spareBit1() const
    {return field_spareBit1;}
  inline INTEGER& spareBit2()
    {return field_spareBit2;}
  inline const INTEGER& spareBit2() const
    {return field_spareBit2;}
  inline OPTIONAL<Variant>& Value()
    {return field_Value;}
  inline const OPTIONAL<Variant>& Value() const
    {return field_Value;}
  inline OPTIONAL<INTEGER>& status()
    {return field_status;}
  inline const OPTIONAL<INTEGER>& status() const
    {return field_status;}
  inline OPTIONAL<INTEGER>& sourceTimestamp()
    {return field_sourceTimestamp;}
  inline const OPTIONAL<INTEGER>& sourceTimestamp() const
    {return field_sourceTimestamp;}
  inline OPTIONAL<INTEGER>& sourcePicoSeconds()
    {return field_sourcePicoSeconds;}
  inline const OPTIONAL<INTEGER>& sourcePicoSeconds() const
    {return field_sourcePicoSeconds;}
  inline OPTIONAL<INTEGER>& serverTimestamp()
    {return field_serverTimestamp;}
  inline const OPTIONAL<INTEGER>& serverTimestamp() const
    {return field_serverTimestamp;}
  inline OPTIONAL<INTEGER>& serverPicoSeconds()
    {return field_serverPicoSeconds;}
  inline const OPTIONAL<INTEGER>& serverPicoSeconds() const
    {return field_serverPicoSeconds;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DataValue_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DataValue_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DataValue& other_value);
void copy_template(const DataValue_template& other_value);

public:
DataValue_template();
DataValue_template(template_sel other_value);
DataValue_template(const DataValue& other_value);
DataValue_template(const OPTIONAL<DataValue>& other_value);
DataValue_template(const DataValue_template& other_value);
~DataValue_template();
DataValue_template& operator=(template_sel other_value);
DataValue_template& operator=(const DataValue& other_value);
DataValue_template& operator=(const OPTIONAL<DataValue>& other_value);
DataValue_template& operator=(const DataValue_template& other_value);
boolean match(const DataValue& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DataValue valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DataValue_template& list_item(unsigned int list_index) const;
INTEGER_template& ValueBit();
const INTEGER_template& ValueBit() const;
INTEGER_template& statusBit();
const INTEGER_template& statusBit() const;
INTEGER_template& sourceTimestampBit();
const INTEGER_template& sourceTimestampBit() const;
INTEGER_template& serverTimestampBit();
const INTEGER_template& serverTimestampBit() const;
INTEGER_template& sourcePicoSecondsBit();
const INTEGER_template& sourcePicoSecondsBit() const;
INTEGER_template& serverPicoSecondsBit();
const INTEGER_template& serverPicoSecondsBit() const;
INTEGER_template& spareBit1();
const INTEGER_template& spareBit1() const;
INTEGER_template& spareBit2();
const INTEGER_template& spareBit2() const;
Variant_template& Value();
const Variant_template& Value() const;
INTEGER_template& status();
const INTEGER_template& status() const;
INTEGER_template& sourceTimestamp();
const INTEGER_template& sourceTimestamp() const;
INTEGER_template& sourcePicoSeconds();
const INTEGER_template& sourcePicoSeconds() const;
INTEGER_template& serverTimestamp();
const INTEGER_template& serverTimestamp() const;
INTEGER_template& serverPicoSeconds();
const INTEGER_template& serverPicoSeconds() const;
int size_of() const;
void log() const;
void log_match(const DataValue& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfVariant : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfVariantArray *field_realArray;
};
void copy_value(const ListOfVariant& other_value);

public:
ListOfVariant();
ListOfVariant(const ListOfVariant& other_value);
~ListOfVariant();
ListOfVariant& operator=(const ListOfVariant& other_value);
boolean operator==(const ListOfVariant& other_value) const;
inline boolean operator!=(const ListOfVariant& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfVariantArray& realArray();
const ListOfVariantArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfVariant_template : public Base_Template {
union {
struct {
ListOfVariant::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfVariantArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfVariant_template *list_value;
} value_list;
};
void copy_value(const ListOfVariant& other_value);

void copy_template(const ListOfVariant_template& other_value);

public:
ListOfVariant_template();
ListOfVariant_template(template_sel other_value);
ListOfVariant_template(const ListOfVariant& other_value);
ListOfVariant_template(const OPTIONAL<ListOfVariant>& other_value);
ListOfVariant_template(const ListOfVariant_template& other_value);
~ListOfVariant_template();
void clean_up();
ListOfVariant_template& operator=(template_sel other_value);
ListOfVariant_template& operator=(const ListOfVariant& other_value);
ListOfVariant_template& operator=(const OPTIONAL<ListOfVariant>& other_value);
ListOfVariant_template& operator=(const ListOfVariant_template& other_value);
boolean match(const ListOfVariant& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfVariant valueof() const;
ListOfVariant_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfVariantArray_template& realArray();
const ListOfVariantArray_template& realArray() const;
boolean ischosen(ListOfVariant::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfVariant& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class VariantArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Variant **value_elements;
} *val_ptr;

static const Variant UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const VariantArray& other_value);

public:
  typedef Variant of_type;
VariantArray();
VariantArray(null_type other_value);
VariantArray(const VariantArray& other_value);
~VariantArray();

void clean_up();
VariantArray& operator=(null_type other_value);
VariantArray& operator=(const VariantArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const VariantArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const VariantArray& other_value) const { return !(*this == other_value); }

Variant& operator[](int index_value);
Variant& operator[](const INTEGER& index_value);
const Variant& operator[](int index_value) const;
const Variant& operator[](const INTEGER& index_value) const;

VariantArray operator<<=(int rotate_count) const;
VariantArray operator<<=(const INTEGER& rotate_count) const;
VariantArray operator>>=(int rotate_count) const;
VariantArray operator>>=(const INTEGER& rotate_count) const;

VariantArray operator+(const VariantArray& other_value) const;

VariantArray substr(int index, int returncount) const;

VariantArray replace(int index, int len, const VariantArray& repl) const;

VariantArray replace(int index, int len, const VariantArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class VariantArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
Variant_template **value_elements;
} single_value;
struct {
unsigned int n_values;
VariantArray_template *list_value;
} value_list;
};
void copy_value(const VariantArray& other_value);
void copy_template(const VariantArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
VariantArray_template();
VariantArray_template(template_sel other_value);
VariantArray_template(null_type other_value);
VariantArray_template(const VariantArray& other_value);
VariantArray_template(const OPTIONAL<VariantArray>& other_value);
VariantArray_template(const VariantArray_template& other_value);
~VariantArray_template();

void clean_up();
VariantArray_template& operator=(template_sel other_value);
VariantArray_template& operator=(null_type other_value);
VariantArray_template& operator=(const VariantArray& other_value);
VariantArray_template& operator=(const OPTIONAL<VariantArray>& other_value);
VariantArray_template& operator=(const VariantArray_template& other_value);

Variant_template& operator[](int index_value);
Variant_template& operator[](const INTEGER& index_value);
const Variant_template& operator[](int index_value) const;
const Variant_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const VariantArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
VariantArray valueof() const;
VariantArray substr(int index, int returncount) const;

VariantArray replace(int index, int len, const VariantArray_template& repl) const;

VariantArray replace(int index, int len, const VariantArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
VariantArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const VariantArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfVariantArray : public Base_Type {
  INTEGER field_arrayLength;
  VariantArray field_arrayValues;
public:
  ListOfVariantArray();
  ListOfVariantArray(const INTEGER& par_arrayLength,
    const VariantArray& par_arrayValues);
  ListOfVariantArray(const ListOfVariantArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfVariantArray& operator=(const ListOfVariantArray& other_value);
  boolean operator==(const ListOfVariantArray& other_value) const;
  inline boolean operator!=(const ListOfVariantArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline VariantArray& arrayValues()
    {return field_arrayValues;}
  inline const VariantArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfVariantArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfVariantArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfVariantArray& other_value);
void copy_template(const ListOfVariantArray_template& other_value);

public:
ListOfVariantArray_template();
ListOfVariantArray_template(template_sel other_value);
ListOfVariantArray_template(const ListOfVariantArray& other_value);
ListOfVariantArray_template(const OPTIONAL<ListOfVariantArray>& other_value);
ListOfVariantArray_template(const ListOfVariantArray_template& other_value);
~ListOfVariantArray_template();
ListOfVariantArray_template& operator=(template_sel other_value);
ListOfVariantArray_template& operator=(const ListOfVariantArray& other_value);
ListOfVariantArray_template& operator=(const OPTIONAL<ListOfVariantArray>& other_value);
ListOfVariantArray_template& operator=(const ListOfVariantArray_template& other_value);
boolean match(const ListOfVariantArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfVariantArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfVariantArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
VariantArray_template& arrayValues();
const VariantArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfVariantArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DiagnosticInfo : public Base_Type {
  INTEGER field_symbolicIdBit;
  INTEGER field_namespaceUriBit;
  INTEGER field_localeBit;
  INTEGER field_localisedTextBit;
  INTEGER field_additionalInfoBit;
  INTEGER field_innerStatusCodeBit;
  INTEGER field_innerDiagnosticInfoBit;
  INTEGER field_reserveBit;
  OPTIONAL<INTEGER> field_symbolicId;
  OPTIONAL<INTEGER> field_namespaceUri;
  OPTIONAL<INTEGER> field_locale;
  OPTIONAL<INTEGER> field_localisedText;
  OPTIONAL<String> field_additionalInfo;
  OPTIONAL<INTEGER> field_innerStatusCode;
  OPTIONAL<DiagnosticInfo> field_innerDiagnosticInfo;
public:
  DiagnosticInfo();
  DiagnosticInfo(const INTEGER& par_symbolicIdBit,
    const INTEGER& par_namespaceUriBit,
    const INTEGER& par_localeBit,
    const INTEGER& par_localisedTextBit,
    const INTEGER& par_additionalInfoBit,
    const INTEGER& par_innerStatusCodeBit,
    const INTEGER& par_innerDiagnosticInfoBit,
    const INTEGER& par_reserveBit,
    const OPTIONAL<INTEGER>& par_symbolicId,
    const OPTIONAL<INTEGER>& par_namespaceUri,
    const OPTIONAL<INTEGER>& par_locale,
    const OPTIONAL<INTEGER>& par_localisedText,
    const OPTIONAL<String>& par_additionalInfo,
    const OPTIONAL<INTEGER>& par_innerStatusCode,
    const OPTIONAL<DiagnosticInfo>& par_innerDiagnosticInfo);
  DiagnosticInfo(const DiagnosticInfo& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DiagnosticInfo& operator=(const DiagnosticInfo& other_value);
  boolean operator==(const DiagnosticInfo& other_value) const;
  inline boolean operator!=(const DiagnosticInfo& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& symbolicIdBit()
    {return field_symbolicIdBit;}
  inline const INTEGER& symbolicIdBit() const
    {return field_symbolicIdBit;}
  inline INTEGER& namespaceUriBit()
    {return field_namespaceUriBit;}
  inline const INTEGER& namespaceUriBit() const
    {return field_namespaceUriBit;}
  inline INTEGER& localeBit()
    {return field_localeBit;}
  inline const INTEGER& localeBit() const
    {return field_localeBit;}
  inline INTEGER& localisedTextBit()
    {return field_localisedTextBit;}
  inline const INTEGER& localisedTextBit() const
    {return field_localisedTextBit;}
  inline INTEGER& additionalInfoBit()
    {return field_additionalInfoBit;}
  inline const INTEGER& additionalInfoBit() const
    {return field_additionalInfoBit;}
  inline INTEGER& innerStatusCodeBit()
    {return field_innerStatusCodeBit;}
  inline const INTEGER& innerStatusCodeBit() const
    {return field_innerStatusCodeBit;}
  inline INTEGER& innerDiagnosticInfoBit()
    {return field_innerDiagnosticInfoBit;}
  inline const INTEGER& innerDiagnosticInfoBit() const
    {return field_innerDiagnosticInfoBit;}
  inline INTEGER& reserveBit()
    {return field_reserveBit;}
  inline const INTEGER& reserveBit() const
    {return field_reserveBit;}
  inline OPTIONAL<INTEGER>& symbolicId()
    {return field_symbolicId;}
  inline const OPTIONAL<INTEGER>& symbolicId() const
    {return field_symbolicId;}
  inline OPTIONAL<INTEGER>& namespaceUri()
    {return field_namespaceUri;}
  inline const OPTIONAL<INTEGER>& namespaceUri() const
    {return field_namespaceUri;}
  inline OPTIONAL<INTEGER>& locale()
    {return field_locale;}
  inline const OPTIONAL<INTEGER>& locale() const
    {return field_locale;}
  inline OPTIONAL<INTEGER>& localisedText()
    {return field_localisedText;}
  inline const OPTIONAL<INTEGER>& localisedText() const
    {return field_localisedText;}
  inline OPTIONAL<String>& additionalInfo()
    {return field_additionalInfo;}
  inline const OPTIONAL<String>& additionalInfo() const
    {return field_additionalInfo;}
  inline OPTIONAL<INTEGER>& innerStatusCode()
    {return field_innerStatusCode;}
  inline const OPTIONAL<INTEGER>& innerStatusCode() const
    {return field_innerStatusCode;}
  inline OPTIONAL<DiagnosticInfo>& innerDiagnosticInfo()
    {return field_innerDiagnosticInfo;}
  inline const OPTIONAL<DiagnosticInfo>& innerDiagnosticInfo() const
    {return field_innerDiagnosticInfo;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DiagnosticInfo_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DiagnosticInfo_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DiagnosticInfo& other_value);
void copy_template(const DiagnosticInfo_template& other_value);

public:
DiagnosticInfo_template();
DiagnosticInfo_template(template_sel other_value);
DiagnosticInfo_template(const DiagnosticInfo& other_value);
DiagnosticInfo_template(const OPTIONAL<DiagnosticInfo>& other_value);
DiagnosticInfo_template(const DiagnosticInfo_template& other_value);
~DiagnosticInfo_template();
DiagnosticInfo_template& operator=(template_sel other_value);
DiagnosticInfo_template& operator=(const DiagnosticInfo& other_value);
DiagnosticInfo_template& operator=(const OPTIONAL<DiagnosticInfo>& other_value);
DiagnosticInfo_template& operator=(const DiagnosticInfo_template& other_value);
boolean match(const DiagnosticInfo& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DiagnosticInfo valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DiagnosticInfo_template& list_item(unsigned int list_index) const;
INTEGER_template& symbolicIdBit();
const INTEGER_template& symbolicIdBit() const;
INTEGER_template& namespaceUriBit();
const INTEGER_template& namespaceUriBit() const;
INTEGER_template& localeBit();
const INTEGER_template& localeBit() const;
INTEGER_template& localisedTextBit();
const INTEGER_template& localisedTextBit() const;
INTEGER_template& additionalInfoBit();
const INTEGER_template& additionalInfoBit() const;
INTEGER_template& innerStatusCodeBit();
const INTEGER_template& innerStatusCodeBit() const;
INTEGER_template& innerDiagnosticInfoBit();
const INTEGER_template& innerDiagnosticInfoBit() const;
INTEGER_template& reserveBit();
const INTEGER_template& reserveBit() const;
INTEGER_template& symbolicId();
const INTEGER_template& symbolicId() const;
INTEGER_template& namespaceUri();
const INTEGER_template& namespaceUri() const;
INTEGER_template& locale();
const INTEGER_template& locale() const;
INTEGER_template& localisedText();
const INTEGER_template& localisedText() const;
String_template& additionalInfo();
const String_template& additionalInfo() const;
INTEGER_template& innerStatusCode();
const INTEGER_template& innerStatusCode() const;
DiagnosticInfo_template& innerDiagnosticInfo();
const DiagnosticInfo_template& innerDiagnosticInfo() const;
int size_of() const;
void log() const;
void log_match(const DiagnosticInfo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class VariantArrayValue : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_bool_ = 1, ALT_sbyte = 2, ALT_byte = 3, ALT_int16 = 4, ALT_uint16 = 5, ALT_int32 = 6, ALT_uint32 = 7, ALT_int64 = 8, ALT_uint64 = 9, ALT_floatValue = 10, ALT_double_ = 11, ALT_string = 12, ALT_datetime = 13, ALT_guid = 14, ALT_bytestring = 15, ALT_xmlelement = 16, ALT_nodeid = 17, ALT_expandednodeid = 18, ALT_statuscode = 19, ALT_qualifiedname = 20, ALT_localizedtext = 21, ALT_extensionobject = 22, ALT_datavalue = 23, ALT_listofvariant = 24, ALT_diagnosticinfo = 25 };
private:
union_selection_type union_selection;
union {
ListOfBoolean *field_bool_;
ListOfSByte *field_sbyte;
ListOfByte *field_byte;
ListOfInt16 *field_int16;
ListOfUInt16 *field_uint16;
ListOfInt32 *field_int32;
ListOfUInt32 *field_uint32;
ListOfInt64 *field_int64;
ListOfUInt64 *field_uint64;
ListOfFloat *field_floatValue;
ListOfDouble *field_double_;
ListOfString *field_string;
ListOfDateTime *field_datetime;
ListOfGuid *field_guid;
ListOfByteString *field_bytestring;
ListOfXmlElement *field_xmlelement;
ListOfNodeId *field_nodeid;
ListOfExpandedNodeId *field_expandednodeid;
ListOfStatusCode *field_statuscode;
ListOfQualifiedName *field_qualifiedname;
ListOfLocalizedText *field_localizedtext;
ListOfExtensionObject *field_extensionobject;
ListOfDataValue *field_datavalue;
ListOfVariant *field_listofvariant;
ListOfDiagnosticInfo *field_diagnosticinfo;
};
void copy_value(const VariantArrayValue& other_value);

public:
VariantArrayValue();
VariantArrayValue(const VariantArrayValue& other_value);
~VariantArrayValue();
VariantArrayValue& operator=(const VariantArrayValue& other_value);
boolean operator==(const VariantArrayValue& other_value) const;
inline boolean operator!=(const VariantArrayValue& other_value) const { return !(*this == other_value); }
ListOfBoolean& bool_();
const ListOfBoolean& bool_() const;
ListOfSByte& sbyte();
const ListOfSByte& sbyte() const;
ListOfByte& byte();
const ListOfByte& byte() const;
ListOfInt16& int16();
const ListOfInt16& int16() const;
ListOfUInt16& uint16();
const ListOfUInt16& uint16() const;
ListOfInt32& int32();
const ListOfInt32& int32() const;
ListOfUInt32& uint32();
const ListOfUInt32& uint32() const;
ListOfInt64& int64();
const ListOfInt64& int64() const;
ListOfUInt64& uint64();
const ListOfUInt64& uint64() const;
ListOfFloat& floatValue();
const ListOfFloat& floatValue() const;
ListOfDouble& double_();
const ListOfDouble& double_() const;
ListOfString& string();
const ListOfString& string() const;
ListOfDateTime& datetime();
const ListOfDateTime& datetime() const;
ListOfGuid& guid();
const ListOfGuid& guid() const;
ListOfByteString& bytestring();
const ListOfByteString& bytestring() const;
ListOfXmlElement& xmlelement();
const ListOfXmlElement& xmlelement() const;
ListOfNodeId& nodeid();
const ListOfNodeId& nodeid() const;
ListOfExpandedNodeId& expandednodeid();
const ListOfExpandedNodeId& expandednodeid() const;
ListOfStatusCode& statuscode();
const ListOfStatusCode& statuscode() const;
ListOfQualifiedName& qualifiedname();
const ListOfQualifiedName& qualifiedname() const;
ListOfLocalizedText& localizedtext();
const ListOfLocalizedText& localizedtext() const;
ListOfExtensionObject& extensionobject();
const ListOfExtensionObject& extensionobject() const;
ListOfDataValue& datavalue();
const ListOfDataValue& datavalue() const;
ListOfVariant& listofvariant();
const ListOfVariant& listofvariant() const;
ListOfDiagnosticInfo& diagnosticinfo();
const ListOfDiagnosticInfo& diagnosticinfo() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class VariantArrayValue_template : public Base_Template {
union {
struct {
VariantArrayValue::union_selection_type union_selection;
union {
ListOfBoolean_template *field_bool_;
ListOfSByte_template *field_sbyte;
ListOfByte_template *field_byte;
ListOfInt16_template *field_int16;
ListOfUInt16_template *field_uint16;
ListOfInt32_template *field_int32;
ListOfUInt32_template *field_uint32;
ListOfInt64_template *field_int64;
ListOfUInt64_template *field_uint64;
ListOfFloat_template *field_floatValue;
ListOfDouble_template *field_double_;
ListOfString_template *field_string;
ListOfDateTime_template *field_datetime;
ListOfGuid_template *field_guid;
ListOfByteString_template *field_bytestring;
ListOfXmlElement_template *field_xmlelement;
ListOfNodeId_template *field_nodeid;
ListOfExpandedNodeId_template *field_expandednodeid;
ListOfStatusCode_template *field_statuscode;
ListOfQualifiedName_template *field_qualifiedname;
ListOfLocalizedText_template *field_localizedtext;
ListOfExtensionObject_template *field_extensionobject;
ListOfDataValue_template *field_datavalue;
ListOfVariant_template *field_listofvariant;
ListOfDiagnosticInfo_template *field_diagnosticinfo;
};
} single_value;
struct {
unsigned int n_values;
VariantArrayValue_template *list_value;
} value_list;
};
void copy_value(const VariantArrayValue& other_value);

void copy_template(const VariantArrayValue_template& other_value);

public:
VariantArrayValue_template();
VariantArrayValue_template(template_sel other_value);
VariantArrayValue_template(const VariantArrayValue& other_value);
VariantArrayValue_template(const OPTIONAL<VariantArrayValue>& other_value);
VariantArrayValue_template(const VariantArrayValue_template& other_value);
~VariantArrayValue_template();
void clean_up();
VariantArrayValue_template& operator=(template_sel other_value);
VariantArrayValue_template& operator=(const VariantArrayValue& other_value);
VariantArrayValue_template& operator=(const OPTIONAL<VariantArrayValue>& other_value);
VariantArrayValue_template& operator=(const VariantArrayValue_template& other_value);
boolean match(const VariantArrayValue& other_value, boolean legacy = FALSE) const;
boolean is_value() const;VariantArrayValue valueof() const;
VariantArrayValue_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfBoolean_template& bool_();
const ListOfBoolean_template& bool_() const;
ListOfSByte_template& sbyte();
const ListOfSByte_template& sbyte() const;
ListOfByte_template& byte();
const ListOfByte_template& byte() const;
ListOfInt16_template& int16();
const ListOfInt16_template& int16() const;
ListOfUInt16_template& uint16();
const ListOfUInt16_template& uint16() const;
ListOfInt32_template& int32();
const ListOfInt32_template& int32() const;
ListOfUInt32_template& uint32();
const ListOfUInt32_template& uint32() const;
ListOfInt64_template& int64();
const ListOfInt64_template& int64() const;
ListOfUInt64_template& uint64();
const ListOfUInt64_template& uint64() const;
ListOfFloat_template& floatValue();
const ListOfFloat_template& floatValue() const;
ListOfDouble_template& double_();
const ListOfDouble_template& double_() const;
ListOfString_template& string();
const ListOfString_template& string() const;
ListOfDateTime_template& datetime();
const ListOfDateTime_template& datetime() const;
ListOfGuid_template& guid();
const ListOfGuid_template& guid() const;
ListOfByteString_template& bytestring();
const ListOfByteString_template& bytestring() const;
ListOfXmlElement_template& xmlelement();
const ListOfXmlElement_template& xmlelement() const;
ListOfNodeId_template& nodeid();
const ListOfNodeId_template& nodeid() const;
ListOfExpandedNodeId_template& expandednodeid();
const ListOfExpandedNodeId_template& expandednodeid() const;
ListOfStatusCode_template& statuscode();
const ListOfStatusCode_template& statuscode() const;
ListOfQualifiedName_template& qualifiedname();
const ListOfQualifiedName_template& qualifiedname() const;
ListOfLocalizedText_template& localizedtext();
const ListOfLocalizedText_template& localizedtext() const;
ListOfExtensionObject_template& extensionobject();
const ListOfExtensionObject_template& extensionobject() const;
ListOfDataValue_template& datavalue();
const ListOfDataValue_template& datavalue() const;
ListOfVariant_template& listofvariant();
const ListOfVariant_template& listofvariant() const;
ListOfDiagnosticInfo_template& diagnosticinfo();
const ListOfDiagnosticInfo_template& diagnosticinfo() const;
boolean ischosen(VariantArrayValue::union_selection_type checked_selection) const;
void log() const;
void log_match(const VariantArrayValue& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfBoolean : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfBooleanArray *field_realArray;
};
void copy_value(const ListOfBoolean& other_value);

public:
ListOfBoolean();
ListOfBoolean(const ListOfBoolean& other_value);
~ListOfBoolean();
ListOfBoolean& operator=(const ListOfBoolean& other_value);
boolean operator==(const ListOfBoolean& other_value) const;
inline boolean operator!=(const ListOfBoolean& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfBooleanArray& realArray();
const ListOfBooleanArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBoolean_template : public Base_Template {
union {
struct {
ListOfBoolean::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfBooleanArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfBoolean_template *list_value;
} value_list;
};
void copy_value(const ListOfBoolean& other_value);

void copy_template(const ListOfBoolean_template& other_value);

public:
ListOfBoolean_template();
ListOfBoolean_template(template_sel other_value);
ListOfBoolean_template(const ListOfBoolean& other_value);
ListOfBoolean_template(const OPTIONAL<ListOfBoolean>& other_value);
ListOfBoolean_template(const ListOfBoolean_template& other_value);
~ListOfBoolean_template();
void clean_up();
ListOfBoolean_template& operator=(template_sel other_value);
ListOfBoolean_template& operator=(const ListOfBoolean& other_value);
ListOfBoolean_template& operator=(const OPTIONAL<ListOfBoolean>& other_value);
ListOfBoolean_template& operator=(const ListOfBoolean_template& other_value);
boolean match(const ListOfBoolean& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfBoolean valueof() const;
ListOfBoolean_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfBooleanArray_template& realArray();
const ListOfBooleanArray_template& realArray() const;
boolean ischosen(ListOfBoolean::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfBoolean& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfBooleanArray : public Base_Type {
  INTEGER field_arrayLength;
  BooleanArray field_arrayValues;
public:
  ListOfBooleanArray();
  ListOfBooleanArray(const INTEGER& par_arrayLength,
    const BooleanArray& par_arrayValues);
  ListOfBooleanArray(const ListOfBooleanArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfBooleanArray& operator=(const ListOfBooleanArray& other_value);
  boolean operator==(const ListOfBooleanArray& other_value) const;
  inline boolean operator!=(const ListOfBooleanArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline BooleanArray& arrayValues()
    {return field_arrayValues;}
  inline const BooleanArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBooleanArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfBooleanArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfBooleanArray& other_value);
void copy_template(const ListOfBooleanArray_template& other_value);

public:
ListOfBooleanArray_template();
ListOfBooleanArray_template(template_sel other_value);
ListOfBooleanArray_template(const ListOfBooleanArray& other_value);
ListOfBooleanArray_template(const OPTIONAL<ListOfBooleanArray>& other_value);
ListOfBooleanArray_template(const ListOfBooleanArray_template& other_value);
~ListOfBooleanArray_template();
ListOfBooleanArray_template& operator=(template_sel other_value);
ListOfBooleanArray_template& operator=(const ListOfBooleanArray& other_value);
ListOfBooleanArray_template& operator=(const OPTIONAL<ListOfBooleanArray>& other_value);
ListOfBooleanArray_template& operator=(const ListOfBooleanArray_template& other_value);
boolean match(const ListOfBooleanArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfBooleanArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfBooleanArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
BooleanArray_template& arrayValues();
const BooleanArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfBooleanArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfSByte : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfSByteArray *field_realArray;
};
void copy_value(const ListOfSByte& other_value);

public:
ListOfSByte();
ListOfSByte(const ListOfSByte& other_value);
~ListOfSByte();
ListOfSByte& operator=(const ListOfSByte& other_value);
boolean operator==(const ListOfSByte& other_value) const;
inline boolean operator!=(const ListOfSByte& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfSByteArray& realArray();
const ListOfSByteArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfSByte_template : public Base_Template {
union {
struct {
ListOfSByte::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfSByteArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfSByte_template *list_value;
} value_list;
};
void copy_value(const ListOfSByte& other_value);

void copy_template(const ListOfSByte_template& other_value);

public:
ListOfSByte_template();
ListOfSByte_template(template_sel other_value);
ListOfSByte_template(const ListOfSByte& other_value);
ListOfSByte_template(const OPTIONAL<ListOfSByte>& other_value);
ListOfSByte_template(const ListOfSByte_template& other_value);
~ListOfSByte_template();
void clean_up();
ListOfSByte_template& operator=(template_sel other_value);
ListOfSByte_template& operator=(const ListOfSByte& other_value);
ListOfSByte_template& operator=(const OPTIONAL<ListOfSByte>& other_value);
ListOfSByte_template& operator=(const ListOfSByte_template& other_value);
boolean match(const ListOfSByte& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfSByte valueof() const;
ListOfSByte_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfSByteArray_template& realArray();
const ListOfSByteArray_template& realArray() const;
boolean ischosen(ListOfSByte::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfSByte& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfSByteArray : public Base_Type {
  INTEGER field_arrayLength;
  SByteArray field_arrayValues;
public:
  ListOfSByteArray();
  ListOfSByteArray(const INTEGER& par_arrayLength,
    const SByteArray& par_arrayValues);
  ListOfSByteArray(const ListOfSByteArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfSByteArray& operator=(const ListOfSByteArray& other_value);
  boolean operator==(const ListOfSByteArray& other_value) const;
  inline boolean operator!=(const ListOfSByteArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline SByteArray& arrayValues()
    {return field_arrayValues;}
  inline const SByteArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfSByteArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfSByteArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfSByteArray& other_value);
void copy_template(const ListOfSByteArray_template& other_value);

public:
ListOfSByteArray_template();
ListOfSByteArray_template(template_sel other_value);
ListOfSByteArray_template(const ListOfSByteArray& other_value);
ListOfSByteArray_template(const OPTIONAL<ListOfSByteArray>& other_value);
ListOfSByteArray_template(const ListOfSByteArray_template& other_value);
~ListOfSByteArray_template();
ListOfSByteArray_template& operator=(template_sel other_value);
ListOfSByteArray_template& operator=(const ListOfSByteArray& other_value);
ListOfSByteArray_template& operator=(const OPTIONAL<ListOfSByteArray>& other_value);
ListOfSByteArray_template& operator=(const ListOfSByteArray_template& other_value);
boolean match(const ListOfSByteArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfSByteArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfSByteArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
SByteArray_template& arrayValues();
const SByteArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfSByteArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfInt16 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfInt16Array *field_realArray;
};
void copy_value(const ListOfInt16& other_value);

public:
ListOfInt16();
ListOfInt16(const ListOfInt16& other_value);
~ListOfInt16();
ListOfInt16& operator=(const ListOfInt16& other_value);
boolean operator==(const ListOfInt16& other_value) const;
inline boolean operator!=(const ListOfInt16& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfInt16Array& realArray();
const ListOfInt16Array& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfInt16_template : public Base_Template {
union {
struct {
ListOfInt16::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfInt16Array_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfInt16_template *list_value;
} value_list;
};
void copy_value(const ListOfInt16& other_value);

void copy_template(const ListOfInt16_template& other_value);

public:
ListOfInt16_template();
ListOfInt16_template(template_sel other_value);
ListOfInt16_template(const ListOfInt16& other_value);
ListOfInt16_template(const OPTIONAL<ListOfInt16>& other_value);
ListOfInt16_template(const ListOfInt16_template& other_value);
~ListOfInt16_template();
void clean_up();
ListOfInt16_template& operator=(template_sel other_value);
ListOfInt16_template& operator=(const ListOfInt16& other_value);
ListOfInt16_template& operator=(const OPTIONAL<ListOfInt16>& other_value);
ListOfInt16_template& operator=(const ListOfInt16_template& other_value);
boolean match(const ListOfInt16& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfInt16 valueof() const;
ListOfInt16_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfInt16Array_template& realArray();
const ListOfInt16Array_template& realArray() const;
boolean ischosen(ListOfInt16::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfInt16& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfInt16Array : public Base_Type {
  INTEGER field_arrayLength;
  Int16Array field_arrayValues;
public:
  ListOfInt16Array();
  ListOfInt16Array(const INTEGER& par_arrayLength,
    const Int16Array& par_arrayValues);
  ListOfInt16Array(const ListOfInt16Array& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfInt16Array& operator=(const ListOfInt16Array& other_value);
  boolean operator==(const ListOfInt16Array& other_value) const;
  inline boolean operator!=(const ListOfInt16Array& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline Int16Array& arrayValues()
    {return field_arrayValues;}
  inline const Int16Array& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfInt16Array_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfInt16Array_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfInt16Array& other_value);
void copy_template(const ListOfInt16Array_template& other_value);

public:
ListOfInt16Array_template();
ListOfInt16Array_template(template_sel other_value);
ListOfInt16Array_template(const ListOfInt16Array& other_value);
ListOfInt16Array_template(const OPTIONAL<ListOfInt16Array>& other_value);
ListOfInt16Array_template(const ListOfInt16Array_template& other_value);
~ListOfInt16Array_template();
ListOfInt16Array_template& operator=(template_sel other_value);
ListOfInt16Array_template& operator=(const ListOfInt16Array& other_value);
ListOfInt16Array_template& operator=(const OPTIONAL<ListOfInt16Array>& other_value);
ListOfInt16Array_template& operator=(const ListOfInt16Array_template& other_value);
boolean match(const ListOfInt16Array& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfInt16Array valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfInt16Array_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
Int16Array_template& arrayValues();
const Int16Array_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfInt16Array& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfUInt16 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfUInt16Array *field_realArray;
};
void copy_value(const ListOfUInt16& other_value);

public:
ListOfUInt16();
ListOfUInt16(const ListOfUInt16& other_value);
~ListOfUInt16();
ListOfUInt16& operator=(const ListOfUInt16& other_value);
boolean operator==(const ListOfUInt16& other_value) const;
inline boolean operator!=(const ListOfUInt16& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfUInt16Array& realArray();
const ListOfUInt16Array& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUInt16_template : public Base_Template {
union {
struct {
ListOfUInt16::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfUInt16Array_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfUInt16_template *list_value;
} value_list;
};
void copy_value(const ListOfUInt16& other_value);

void copy_template(const ListOfUInt16_template& other_value);

public:
ListOfUInt16_template();
ListOfUInt16_template(template_sel other_value);
ListOfUInt16_template(const ListOfUInt16& other_value);
ListOfUInt16_template(const OPTIONAL<ListOfUInt16>& other_value);
ListOfUInt16_template(const ListOfUInt16_template& other_value);
~ListOfUInt16_template();
void clean_up();
ListOfUInt16_template& operator=(template_sel other_value);
ListOfUInt16_template& operator=(const ListOfUInt16& other_value);
ListOfUInt16_template& operator=(const OPTIONAL<ListOfUInt16>& other_value);
ListOfUInt16_template& operator=(const ListOfUInt16_template& other_value);
boolean match(const ListOfUInt16& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfUInt16 valueof() const;
ListOfUInt16_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfUInt16Array_template& realArray();
const ListOfUInt16Array_template& realArray() const;
boolean ischosen(ListOfUInt16::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfUInt16& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfUInt16Array : public Base_Type {
  INTEGER field_arrayLength;
  UInt16Array field_arrayValues;
public:
  ListOfUInt16Array();
  ListOfUInt16Array(const INTEGER& par_arrayLength,
    const UInt16Array& par_arrayValues);
  ListOfUInt16Array(const ListOfUInt16Array& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfUInt16Array& operator=(const ListOfUInt16Array& other_value);
  boolean operator==(const ListOfUInt16Array& other_value) const;
  inline boolean operator!=(const ListOfUInt16Array& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline UInt16Array& arrayValues()
    {return field_arrayValues;}
  inline const UInt16Array& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUInt16Array_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfUInt16Array_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfUInt16Array& other_value);
void copy_template(const ListOfUInt16Array_template& other_value);

public:
ListOfUInt16Array_template();
ListOfUInt16Array_template(template_sel other_value);
ListOfUInt16Array_template(const ListOfUInt16Array& other_value);
ListOfUInt16Array_template(const OPTIONAL<ListOfUInt16Array>& other_value);
ListOfUInt16Array_template(const ListOfUInt16Array_template& other_value);
~ListOfUInt16Array_template();
ListOfUInt16Array_template& operator=(template_sel other_value);
ListOfUInt16Array_template& operator=(const ListOfUInt16Array& other_value);
ListOfUInt16Array_template& operator=(const OPTIONAL<ListOfUInt16Array>& other_value);
ListOfUInt16Array_template& operator=(const ListOfUInt16Array_template& other_value);
boolean match(const ListOfUInt16Array& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfUInt16Array valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfUInt16Array_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
UInt16Array_template& arrayValues();
const UInt16Array_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfUInt16Array& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfInt32 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfInt32Array *field_realArray;
};
void copy_value(const ListOfInt32& other_value);

public:
ListOfInt32();
ListOfInt32(const ListOfInt32& other_value);
~ListOfInt32();
ListOfInt32& operator=(const ListOfInt32& other_value);
boolean operator==(const ListOfInt32& other_value) const;
inline boolean operator!=(const ListOfInt32& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfInt32Array& realArray();
const ListOfInt32Array& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfInt32_template : public Base_Template {
union {
struct {
ListOfInt32::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfInt32Array_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfInt32_template *list_value;
} value_list;
};
void copy_value(const ListOfInt32& other_value);

void copy_template(const ListOfInt32_template& other_value);

public:
ListOfInt32_template();
ListOfInt32_template(template_sel other_value);
ListOfInt32_template(const ListOfInt32& other_value);
ListOfInt32_template(const OPTIONAL<ListOfInt32>& other_value);
ListOfInt32_template(const ListOfInt32_template& other_value);
~ListOfInt32_template();
void clean_up();
ListOfInt32_template& operator=(template_sel other_value);
ListOfInt32_template& operator=(const ListOfInt32& other_value);
ListOfInt32_template& operator=(const OPTIONAL<ListOfInt32>& other_value);
ListOfInt32_template& operator=(const ListOfInt32_template& other_value);
boolean match(const ListOfInt32& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfInt32 valueof() const;
ListOfInt32_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfInt32Array_template& realArray();
const ListOfInt32Array_template& realArray() const;
boolean ischosen(ListOfInt32::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfInt32& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfInt32Array : public Base_Type {
  INTEGER field_arrayLength;
  Int32Array field_arrayValues;
public:
  ListOfInt32Array();
  ListOfInt32Array(const INTEGER& par_arrayLength,
    const Int32Array& par_arrayValues);
  ListOfInt32Array(const ListOfInt32Array& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfInt32Array& operator=(const ListOfInt32Array& other_value);
  boolean operator==(const ListOfInt32Array& other_value) const;
  inline boolean operator!=(const ListOfInt32Array& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline Int32Array& arrayValues()
    {return field_arrayValues;}
  inline const Int32Array& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfInt32Array_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfInt32Array_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfInt32Array& other_value);
void copy_template(const ListOfInt32Array_template& other_value);

public:
ListOfInt32Array_template();
ListOfInt32Array_template(template_sel other_value);
ListOfInt32Array_template(const ListOfInt32Array& other_value);
ListOfInt32Array_template(const OPTIONAL<ListOfInt32Array>& other_value);
ListOfInt32Array_template(const ListOfInt32Array_template& other_value);
~ListOfInt32Array_template();
ListOfInt32Array_template& operator=(template_sel other_value);
ListOfInt32Array_template& operator=(const ListOfInt32Array& other_value);
ListOfInt32Array_template& operator=(const OPTIONAL<ListOfInt32Array>& other_value);
ListOfInt32Array_template& operator=(const ListOfInt32Array_template& other_value);
boolean match(const ListOfInt32Array& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfInt32Array valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfInt32Array_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
Int32Array_template& arrayValues();
const Int32Array_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfInt32Array& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfUInt32 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfUInt32Array *field_realArray;
};
void copy_value(const ListOfUInt32& other_value);

public:
ListOfUInt32();
ListOfUInt32(const ListOfUInt32& other_value);
~ListOfUInt32();
ListOfUInt32& operator=(const ListOfUInt32& other_value);
boolean operator==(const ListOfUInt32& other_value) const;
inline boolean operator!=(const ListOfUInt32& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfUInt32Array& realArray();
const ListOfUInt32Array& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUInt32_template : public Base_Template {
union {
struct {
ListOfUInt32::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfUInt32Array_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfUInt32_template *list_value;
} value_list;
};
void copy_value(const ListOfUInt32& other_value);

void copy_template(const ListOfUInt32_template& other_value);

public:
ListOfUInt32_template();
ListOfUInt32_template(template_sel other_value);
ListOfUInt32_template(const ListOfUInt32& other_value);
ListOfUInt32_template(const OPTIONAL<ListOfUInt32>& other_value);
ListOfUInt32_template(const ListOfUInt32_template& other_value);
~ListOfUInt32_template();
void clean_up();
ListOfUInt32_template& operator=(template_sel other_value);
ListOfUInt32_template& operator=(const ListOfUInt32& other_value);
ListOfUInt32_template& operator=(const OPTIONAL<ListOfUInt32>& other_value);
ListOfUInt32_template& operator=(const ListOfUInt32_template& other_value);
boolean match(const ListOfUInt32& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfUInt32 valueof() const;
ListOfUInt32_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfUInt32Array_template& realArray();
const ListOfUInt32Array_template& realArray() const;
boolean ischosen(ListOfUInt32::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfUInt32& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfUInt32Array : public Base_Type {
  INTEGER field_arrayLength;
  UInt32Array field_arrayValues;
public:
  ListOfUInt32Array();
  ListOfUInt32Array(const INTEGER& par_arrayLength,
    const UInt32Array& par_arrayValues);
  ListOfUInt32Array(const ListOfUInt32Array& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfUInt32Array& operator=(const ListOfUInt32Array& other_value);
  boolean operator==(const ListOfUInt32Array& other_value) const;
  inline boolean operator!=(const ListOfUInt32Array& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline UInt32Array& arrayValues()
    {return field_arrayValues;}
  inline const UInt32Array& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUInt32Array_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfUInt32Array_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfUInt32Array& other_value);
void copy_template(const ListOfUInt32Array_template& other_value);

public:
ListOfUInt32Array_template();
ListOfUInt32Array_template(template_sel other_value);
ListOfUInt32Array_template(const ListOfUInt32Array& other_value);
ListOfUInt32Array_template(const OPTIONAL<ListOfUInt32Array>& other_value);
ListOfUInt32Array_template(const ListOfUInt32Array_template& other_value);
~ListOfUInt32Array_template();
ListOfUInt32Array_template& operator=(template_sel other_value);
ListOfUInt32Array_template& operator=(const ListOfUInt32Array& other_value);
ListOfUInt32Array_template& operator=(const OPTIONAL<ListOfUInt32Array>& other_value);
ListOfUInt32Array_template& operator=(const ListOfUInt32Array_template& other_value);
boolean match(const ListOfUInt32Array& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfUInt32Array valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfUInt32Array_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
UInt32Array_template& arrayValues();
const UInt32Array_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfUInt32Array& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfInt64 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfInt64Array *field_realArray;
};
void copy_value(const ListOfInt64& other_value);

public:
ListOfInt64();
ListOfInt64(const ListOfInt64& other_value);
~ListOfInt64();
ListOfInt64& operator=(const ListOfInt64& other_value);
boolean operator==(const ListOfInt64& other_value) const;
inline boolean operator!=(const ListOfInt64& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfInt64Array& realArray();
const ListOfInt64Array& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfInt64_template : public Base_Template {
union {
struct {
ListOfInt64::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfInt64Array_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfInt64_template *list_value;
} value_list;
};
void copy_value(const ListOfInt64& other_value);

void copy_template(const ListOfInt64_template& other_value);

public:
ListOfInt64_template();
ListOfInt64_template(template_sel other_value);
ListOfInt64_template(const ListOfInt64& other_value);
ListOfInt64_template(const OPTIONAL<ListOfInt64>& other_value);
ListOfInt64_template(const ListOfInt64_template& other_value);
~ListOfInt64_template();
void clean_up();
ListOfInt64_template& operator=(template_sel other_value);
ListOfInt64_template& operator=(const ListOfInt64& other_value);
ListOfInt64_template& operator=(const OPTIONAL<ListOfInt64>& other_value);
ListOfInt64_template& operator=(const ListOfInt64_template& other_value);
boolean match(const ListOfInt64& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfInt64 valueof() const;
ListOfInt64_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfInt64Array_template& realArray();
const ListOfInt64Array_template& realArray() const;
boolean ischosen(ListOfInt64::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfInt64& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfInt64Array : public Base_Type {
  INTEGER field_arrayLength;
  Int64Array field_arrayValues;
public:
  ListOfInt64Array();
  ListOfInt64Array(const INTEGER& par_arrayLength,
    const Int64Array& par_arrayValues);
  ListOfInt64Array(const ListOfInt64Array& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfInt64Array& operator=(const ListOfInt64Array& other_value);
  boolean operator==(const ListOfInt64Array& other_value) const;
  inline boolean operator!=(const ListOfInt64Array& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline Int64Array& arrayValues()
    {return field_arrayValues;}
  inline const Int64Array& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfInt64Array_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfInt64Array_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfInt64Array& other_value);
void copy_template(const ListOfInt64Array_template& other_value);

public:
ListOfInt64Array_template();
ListOfInt64Array_template(template_sel other_value);
ListOfInt64Array_template(const ListOfInt64Array& other_value);
ListOfInt64Array_template(const OPTIONAL<ListOfInt64Array>& other_value);
ListOfInt64Array_template(const ListOfInt64Array_template& other_value);
~ListOfInt64Array_template();
ListOfInt64Array_template& operator=(template_sel other_value);
ListOfInt64Array_template& operator=(const ListOfInt64Array& other_value);
ListOfInt64Array_template& operator=(const OPTIONAL<ListOfInt64Array>& other_value);
ListOfInt64Array_template& operator=(const ListOfInt64Array_template& other_value);
boolean match(const ListOfInt64Array& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfInt64Array valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfInt64Array_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
Int64Array_template& arrayValues();
const Int64Array_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfInt64Array& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfUInt64 : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfUInt64Array *field_realArray;
};
void copy_value(const ListOfUInt64& other_value);

public:
ListOfUInt64();
ListOfUInt64(const ListOfUInt64& other_value);
~ListOfUInt64();
ListOfUInt64& operator=(const ListOfUInt64& other_value);
boolean operator==(const ListOfUInt64& other_value) const;
inline boolean operator!=(const ListOfUInt64& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfUInt64Array& realArray();
const ListOfUInt64Array& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUInt64_template : public Base_Template {
union {
struct {
ListOfUInt64::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfUInt64Array_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfUInt64_template *list_value;
} value_list;
};
void copy_value(const ListOfUInt64& other_value);

void copy_template(const ListOfUInt64_template& other_value);

public:
ListOfUInt64_template();
ListOfUInt64_template(template_sel other_value);
ListOfUInt64_template(const ListOfUInt64& other_value);
ListOfUInt64_template(const OPTIONAL<ListOfUInt64>& other_value);
ListOfUInt64_template(const ListOfUInt64_template& other_value);
~ListOfUInt64_template();
void clean_up();
ListOfUInt64_template& operator=(template_sel other_value);
ListOfUInt64_template& operator=(const ListOfUInt64& other_value);
ListOfUInt64_template& operator=(const OPTIONAL<ListOfUInt64>& other_value);
ListOfUInt64_template& operator=(const ListOfUInt64_template& other_value);
boolean match(const ListOfUInt64& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfUInt64 valueof() const;
ListOfUInt64_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfUInt64Array_template& realArray();
const ListOfUInt64Array_template& realArray() const;
boolean ischosen(ListOfUInt64::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfUInt64& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfUInt64Array : public Base_Type {
  INTEGER field_arrayLength;
  UInt64Array field_arrayValues;
public:
  ListOfUInt64Array();
  ListOfUInt64Array(const INTEGER& par_arrayLength,
    const UInt64Array& par_arrayValues);
  ListOfUInt64Array(const ListOfUInt64Array& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfUInt64Array& operator=(const ListOfUInt64Array& other_value);
  boolean operator==(const ListOfUInt64Array& other_value) const;
  inline boolean operator!=(const ListOfUInt64Array& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline UInt64Array& arrayValues()
    {return field_arrayValues;}
  inline const UInt64Array& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUInt64Array_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfUInt64Array_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfUInt64Array& other_value);
void copy_template(const ListOfUInt64Array_template& other_value);

public:
ListOfUInt64Array_template();
ListOfUInt64Array_template(template_sel other_value);
ListOfUInt64Array_template(const ListOfUInt64Array& other_value);
ListOfUInt64Array_template(const OPTIONAL<ListOfUInt64Array>& other_value);
ListOfUInt64Array_template(const ListOfUInt64Array_template& other_value);
~ListOfUInt64Array_template();
ListOfUInt64Array_template& operator=(template_sel other_value);
ListOfUInt64Array_template& operator=(const ListOfUInt64Array& other_value);
ListOfUInt64Array_template& operator=(const OPTIONAL<ListOfUInt64Array>& other_value);
ListOfUInt64Array_template& operator=(const ListOfUInt64Array_template& other_value);
boolean match(const ListOfUInt64Array& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfUInt64Array valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfUInt64Array_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
UInt64Array_template& arrayValues();
const UInt64Array_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfUInt64Array& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfFloat : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfFloatArray *field_realArray;
};
void copy_value(const ListOfFloat& other_value);

public:
ListOfFloat();
ListOfFloat(const ListOfFloat& other_value);
~ListOfFloat();
ListOfFloat& operator=(const ListOfFloat& other_value);
boolean operator==(const ListOfFloat& other_value) const;
inline boolean operator!=(const ListOfFloat& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfFloatArray& realArray();
const ListOfFloatArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfFloat_template : public Base_Template {
union {
struct {
ListOfFloat::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfFloatArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfFloat_template *list_value;
} value_list;
};
void copy_value(const ListOfFloat& other_value);

void copy_template(const ListOfFloat_template& other_value);

public:
ListOfFloat_template();
ListOfFloat_template(template_sel other_value);
ListOfFloat_template(const ListOfFloat& other_value);
ListOfFloat_template(const OPTIONAL<ListOfFloat>& other_value);
ListOfFloat_template(const ListOfFloat_template& other_value);
~ListOfFloat_template();
void clean_up();
ListOfFloat_template& operator=(template_sel other_value);
ListOfFloat_template& operator=(const ListOfFloat& other_value);
ListOfFloat_template& operator=(const OPTIONAL<ListOfFloat>& other_value);
ListOfFloat_template& operator=(const ListOfFloat_template& other_value);
boolean match(const ListOfFloat& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfFloat valueof() const;
ListOfFloat_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfFloatArray_template& realArray();
const ListOfFloatArray_template& realArray() const;
boolean ischosen(ListOfFloat::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfFloat& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfFloatArray : public Base_Type {
  INTEGER field_arrayLength;
  FloatArray field_arrayValues;
public:
  ListOfFloatArray();
  ListOfFloatArray(const INTEGER& par_arrayLength,
    const FloatArray& par_arrayValues);
  ListOfFloatArray(const ListOfFloatArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfFloatArray& operator=(const ListOfFloatArray& other_value);
  boolean operator==(const ListOfFloatArray& other_value) const;
  inline boolean operator!=(const ListOfFloatArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline FloatArray& arrayValues()
    {return field_arrayValues;}
  inline const FloatArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfFloatArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfFloatArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfFloatArray& other_value);
void copy_template(const ListOfFloatArray_template& other_value);

public:
ListOfFloatArray_template();
ListOfFloatArray_template(template_sel other_value);
ListOfFloatArray_template(const ListOfFloatArray& other_value);
ListOfFloatArray_template(const OPTIONAL<ListOfFloatArray>& other_value);
ListOfFloatArray_template(const ListOfFloatArray_template& other_value);
~ListOfFloatArray_template();
ListOfFloatArray_template& operator=(template_sel other_value);
ListOfFloatArray_template& operator=(const ListOfFloatArray& other_value);
ListOfFloatArray_template& operator=(const OPTIONAL<ListOfFloatArray>& other_value);
ListOfFloatArray_template& operator=(const ListOfFloatArray_template& other_value);
boolean match(const ListOfFloatArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfFloatArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfFloatArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
FloatArray_template& arrayValues();
const FloatArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfFloatArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfDouble : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfDoubleArray *field_realArray;
};
void copy_value(const ListOfDouble& other_value);

public:
ListOfDouble();
ListOfDouble(const ListOfDouble& other_value);
~ListOfDouble();
ListOfDouble& operator=(const ListOfDouble& other_value);
boolean operator==(const ListOfDouble& other_value) const;
inline boolean operator!=(const ListOfDouble& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfDoubleArray& realArray();
const ListOfDoubleArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDouble_template : public Base_Template {
union {
struct {
ListOfDouble::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfDoubleArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfDouble_template *list_value;
} value_list;
};
void copy_value(const ListOfDouble& other_value);

void copy_template(const ListOfDouble_template& other_value);

public:
ListOfDouble_template();
ListOfDouble_template(template_sel other_value);
ListOfDouble_template(const ListOfDouble& other_value);
ListOfDouble_template(const OPTIONAL<ListOfDouble>& other_value);
ListOfDouble_template(const ListOfDouble_template& other_value);
~ListOfDouble_template();
void clean_up();
ListOfDouble_template& operator=(template_sel other_value);
ListOfDouble_template& operator=(const ListOfDouble& other_value);
ListOfDouble_template& operator=(const OPTIONAL<ListOfDouble>& other_value);
ListOfDouble_template& operator=(const ListOfDouble_template& other_value);
boolean match(const ListOfDouble& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfDouble valueof() const;
ListOfDouble_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfDoubleArray_template& realArray();
const ListOfDoubleArray_template& realArray() const;
boolean ischosen(ListOfDouble::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfDouble& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfDoubleArray : public Base_Type {
  INTEGER field_arrayLength;
  DoubleArray field_arrayValues;
public:
  ListOfDoubleArray();
  ListOfDoubleArray(const INTEGER& par_arrayLength,
    const DoubleArray& par_arrayValues);
  ListOfDoubleArray(const ListOfDoubleArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfDoubleArray& operator=(const ListOfDoubleArray& other_value);
  boolean operator==(const ListOfDoubleArray& other_value) const;
  inline boolean operator!=(const ListOfDoubleArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline DoubleArray& arrayValues()
    {return field_arrayValues;}
  inline const DoubleArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDoubleArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfDoubleArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfDoubleArray& other_value);
void copy_template(const ListOfDoubleArray_template& other_value);

public:
ListOfDoubleArray_template();
ListOfDoubleArray_template(template_sel other_value);
ListOfDoubleArray_template(const ListOfDoubleArray& other_value);
ListOfDoubleArray_template(const OPTIONAL<ListOfDoubleArray>& other_value);
ListOfDoubleArray_template(const ListOfDoubleArray_template& other_value);
~ListOfDoubleArray_template();
ListOfDoubleArray_template& operator=(template_sel other_value);
ListOfDoubleArray_template& operator=(const ListOfDoubleArray& other_value);
ListOfDoubleArray_template& operator=(const OPTIONAL<ListOfDoubleArray>& other_value);
ListOfDoubleArray_template& operator=(const ListOfDoubleArray_template& other_value);
boolean match(const ListOfDoubleArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfDoubleArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfDoubleArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
DoubleArray_template& arrayValues();
const DoubleArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfDoubleArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfString : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfStringArray *field_realArray;
};
void copy_value(const ListOfString& other_value);

public:
ListOfString();
ListOfString(const ListOfString& other_value);
~ListOfString();
ListOfString& operator=(const ListOfString& other_value);
boolean operator==(const ListOfString& other_value) const;
inline boolean operator!=(const ListOfString& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfStringArray& realArray();
const ListOfStringArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfString_template : public Base_Template {
union {
struct {
ListOfString::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfStringArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfString_template *list_value;
} value_list;
};
void copy_value(const ListOfString& other_value);

void copy_template(const ListOfString_template& other_value);

public:
ListOfString_template();
ListOfString_template(template_sel other_value);
ListOfString_template(const ListOfString& other_value);
ListOfString_template(const OPTIONAL<ListOfString>& other_value);
ListOfString_template(const ListOfString_template& other_value);
~ListOfString_template();
void clean_up();
ListOfString_template& operator=(template_sel other_value);
ListOfString_template& operator=(const ListOfString& other_value);
ListOfString_template& operator=(const OPTIONAL<ListOfString>& other_value);
ListOfString_template& operator=(const ListOfString_template& other_value);
boolean match(const ListOfString& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfString valueof() const;
ListOfString_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfStringArray_template& realArray();
const ListOfStringArray_template& realArray() const;
boolean ischosen(ListOfString::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfString& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class StringArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
String **value_elements;
} *val_ptr;

static const String UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const StringArray& other_value);

public:
  typedef String of_type;
StringArray();
StringArray(null_type other_value);
StringArray(const StringArray& other_value);
~StringArray();

void clean_up();
StringArray& operator=(null_type other_value);
StringArray& operator=(const StringArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const StringArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const StringArray& other_value) const { return !(*this == other_value); }

String& operator[](int index_value);
String& operator[](const INTEGER& index_value);
const String& operator[](int index_value) const;
const String& operator[](const INTEGER& index_value) const;

StringArray operator<<=(int rotate_count) const;
StringArray operator<<=(const INTEGER& rotate_count) const;
StringArray operator>>=(int rotate_count) const;
StringArray operator>>=(const INTEGER& rotate_count) const;

StringArray operator+(const StringArray& other_value) const;

StringArray substr(int index, int returncount) const;

StringArray replace(int index, int len, const StringArray& repl) const;

StringArray replace(int index, int len, const StringArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class StringArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
String_template **value_elements;
} single_value;
struct {
unsigned int n_values;
StringArray_template *list_value;
} value_list;
};
void copy_value(const StringArray& other_value);
void copy_template(const StringArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
StringArray_template();
StringArray_template(template_sel other_value);
StringArray_template(null_type other_value);
StringArray_template(const StringArray& other_value);
StringArray_template(const OPTIONAL<StringArray>& other_value);
StringArray_template(const StringArray_template& other_value);
~StringArray_template();

void clean_up();
StringArray_template& operator=(template_sel other_value);
StringArray_template& operator=(null_type other_value);
StringArray_template& operator=(const StringArray& other_value);
StringArray_template& operator=(const OPTIONAL<StringArray>& other_value);
StringArray_template& operator=(const StringArray_template& other_value);

String_template& operator[](int index_value);
String_template& operator[](const INTEGER& index_value);
const String_template& operator[](int index_value) const;
const String_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const StringArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
StringArray valueof() const;
StringArray substr(int index, int returncount) const;

StringArray replace(int index, int len, const StringArray_template& repl) const;

StringArray replace(int index, int len, const StringArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
StringArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const StringArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfStringArray : public Base_Type {
  INTEGER field_arrayLength;
  StringArray field_arrayValues;
public:
  ListOfStringArray();
  ListOfStringArray(const INTEGER& par_arrayLength,
    const StringArray& par_arrayValues);
  ListOfStringArray(const ListOfStringArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfStringArray& operator=(const ListOfStringArray& other_value);
  boolean operator==(const ListOfStringArray& other_value) const;
  inline boolean operator!=(const ListOfStringArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline StringArray& arrayValues()
    {return field_arrayValues;}
  inline const StringArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfStringArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfStringArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfStringArray& other_value);
void copy_template(const ListOfStringArray_template& other_value);

public:
ListOfStringArray_template();
ListOfStringArray_template(template_sel other_value);
ListOfStringArray_template(const ListOfStringArray& other_value);
ListOfStringArray_template(const OPTIONAL<ListOfStringArray>& other_value);
ListOfStringArray_template(const ListOfStringArray_template& other_value);
~ListOfStringArray_template();
ListOfStringArray_template& operator=(template_sel other_value);
ListOfStringArray_template& operator=(const ListOfStringArray& other_value);
ListOfStringArray_template& operator=(const OPTIONAL<ListOfStringArray>& other_value);
ListOfStringArray_template& operator=(const ListOfStringArray_template& other_value);
boolean match(const ListOfStringArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfStringArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfStringArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
StringArray_template& arrayValues();
const StringArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfStringArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfDateTime : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfDateTimeArray *field_realArray;
};
void copy_value(const ListOfDateTime& other_value);

public:
ListOfDateTime();
ListOfDateTime(const ListOfDateTime& other_value);
~ListOfDateTime();
ListOfDateTime& operator=(const ListOfDateTime& other_value);
boolean operator==(const ListOfDateTime& other_value) const;
inline boolean operator!=(const ListOfDateTime& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfDateTimeArray& realArray();
const ListOfDateTimeArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDateTime_template : public Base_Template {
union {
struct {
ListOfDateTime::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfDateTimeArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfDateTime_template *list_value;
} value_list;
};
void copy_value(const ListOfDateTime& other_value);

void copy_template(const ListOfDateTime_template& other_value);

public:
ListOfDateTime_template();
ListOfDateTime_template(template_sel other_value);
ListOfDateTime_template(const ListOfDateTime& other_value);
ListOfDateTime_template(const OPTIONAL<ListOfDateTime>& other_value);
ListOfDateTime_template(const ListOfDateTime_template& other_value);
~ListOfDateTime_template();
void clean_up();
ListOfDateTime_template& operator=(template_sel other_value);
ListOfDateTime_template& operator=(const ListOfDateTime& other_value);
ListOfDateTime_template& operator=(const OPTIONAL<ListOfDateTime>& other_value);
ListOfDateTime_template& operator=(const ListOfDateTime_template& other_value);
boolean match(const ListOfDateTime& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfDateTime valueof() const;
ListOfDateTime_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfDateTimeArray_template& realArray();
const ListOfDateTimeArray_template& realArray() const;
boolean ischosen(ListOfDateTime::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfDateTime& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfDateTimeArray : public Base_Type {
  INTEGER field_arrayLength;
  DateTimeArray field_arrayValues;
public:
  ListOfDateTimeArray();
  ListOfDateTimeArray(const INTEGER& par_arrayLength,
    const DateTimeArray& par_arrayValues);
  ListOfDateTimeArray(const ListOfDateTimeArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfDateTimeArray& operator=(const ListOfDateTimeArray& other_value);
  boolean operator==(const ListOfDateTimeArray& other_value) const;
  inline boolean operator!=(const ListOfDateTimeArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline DateTimeArray& arrayValues()
    {return field_arrayValues;}
  inline const DateTimeArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDateTimeArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfDateTimeArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfDateTimeArray& other_value);
void copy_template(const ListOfDateTimeArray_template& other_value);

public:
ListOfDateTimeArray_template();
ListOfDateTimeArray_template(template_sel other_value);
ListOfDateTimeArray_template(const ListOfDateTimeArray& other_value);
ListOfDateTimeArray_template(const OPTIONAL<ListOfDateTimeArray>& other_value);
ListOfDateTimeArray_template(const ListOfDateTimeArray_template& other_value);
~ListOfDateTimeArray_template();
ListOfDateTimeArray_template& operator=(template_sel other_value);
ListOfDateTimeArray_template& operator=(const ListOfDateTimeArray& other_value);
ListOfDateTimeArray_template& operator=(const OPTIONAL<ListOfDateTimeArray>& other_value);
ListOfDateTimeArray_template& operator=(const ListOfDateTimeArray_template& other_value);
boolean match(const ListOfDateTimeArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfDateTimeArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfDateTimeArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
DateTimeArray_template& arrayValues();
const DateTimeArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfDateTimeArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfGuid : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfGuidArray *field_realArray;
};
void copy_value(const ListOfGuid& other_value);

public:
ListOfGuid();
ListOfGuid(const ListOfGuid& other_value);
~ListOfGuid();
ListOfGuid& operator=(const ListOfGuid& other_value);
boolean operator==(const ListOfGuid& other_value) const;
inline boolean operator!=(const ListOfGuid& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfGuidArray& realArray();
const ListOfGuidArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfGuid_template : public Base_Template {
union {
struct {
ListOfGuid::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfGuidArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfGuid_template *list_value;
} value_list;
};
void copy_value(const ListOfGuid& other_value);

void copy_template(const ListOfGuid_template& other_value);

public:
ListOfGuid_template();
ListOfGuid_template(template_sel other_value);
ListOfGuid_template(const ListOfGuid& other_value);
ListOfGuid_template(const OPTIONAL<ListOfGuid>& other_value);
ListOfGuid_template(const ListOfGuid_template& other_value);
~ListOfGuid_template();
void clean_up();
ListOfGuid_template& operator=(template_sel other_value);
ListOfGuid_template& operator=(const ListOfGuid& other_value);
ListOfGuid_template& operator=(const OPTIONAL<ListOfGuid>& other_value);
ListOfGuid_template& operator=(const ListOfGuid_template& other_value);
boolean match(const ListOfGuid& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfGuid valueof() const;
ListOfGuid_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfGuidArray_template& realArray();
const ListOfGuidArray_template& realArray() const;
boolean ischosen(ListOfGuid::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfGuid& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GuidArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Guid **value_elements;
} *val_ptr;

static const Guid UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const GuidArray& other_value);

public:
  typedef Guid of_type;
GuidArray();
GuidArray(null_type other_value);
GuidArray(const GuidArray& other_value);
~GuidArray();

void clean_up();
GuidArray& operator=(null_type other_value);
GuidArray& operator=(const GuidArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const GuidArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GuidArray& other_value) const { return !(*this == other_value); }

Guid& operator[](int index_value);
Guid& operator[](const INTEGER& index_value);
const Guid& operator[](int index_value) const;
const Guid& operator[](const INTEGER& index_value) const;

GuidArray operator<<=(int rotate_count) const;
GuidArray operator<<=(const INTEGER& rotate_count) const;
GuidArray operator>>=(int rotate_count) const;
GuidArray operator>>=(const INTEGER& rotate_count) const;

GuidArray operator+(const GuidArray& other_value) const;

GuidArray substr(int index, int returncount) const;

GuidArray replace(int index, int len, const GuidArray& repl) const;

GuidArray replace(int index, int len, const GuidArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GuidArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
Guid_template **value_elements;
} single_value;
struct {
unsigned int n_values;
GuidArray_template *list_value;
} value_list;
};
void copy_value(const GuidArray& other_value);
void copy_template(const GuidArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
GuidArray_template();
GuidArray_template(template_sel other_value);
GuidArray_template(null_type other_value);
GuidArray_template(const GuidArray& other_value);
GuidArray_template(const OPTIONAL<GuidArray>& other_value);
GuidArray_template(const GuidArray_template& other_value);
~GuidArray_template();

void clean_up();
GuidArray_template& operator=(template_sel other_value);
GuidArray_template& operator=(null_type other_value);
GuidArray_template& operator=(const GuidArray& other_value);
GuidArray_template& operator=(const OPTIONAL<GuidArray>& other_value);
GuidArray_template& operator=(const GuidArray_template& other_value);

Guid_template& operator[](int index_value);
Guid_template& operator[](const INTEGER& index_value);
const Guid_template& operator[](int index_value) const;
const Guid_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const GuidArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
GuidArray valueof() const;
GuidArray substr(int index, int returncount) const;

GuidArray replace(int index, int len, const GuidArray_template& repl) const;

GuidArray replace(int index, int len, const GuidArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
GuidArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GuidArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfGuidArray : public Base_Type {
  INTEGER field_arrayLength;
  GuidArray field_arrayValues;
public:
  ListOfGuidArray();
  ListOfGuidArray(const INTEGER& par_arrayLength,
    const GuidArray& par_arrayValues);
  ListOfGuidArray(const ListOfGuidArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfGuidArray& operator=(const ListOfGuidArray& other_value);
  boolean operator==(const ListOfGuidArray& other_value) const;
  inline boolean operator!=(const ListOfGuidArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline GuidArray& arrayValues()
    {return field_arrayValues;}
  inline const GuidArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfGuidArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfGuidArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfGuidArray& other_value);
void copy_template(const ListOfGuidArray_template& other_value);

public:
ListOfGuidArray_template();
ListOfGuidArray_template(template_sel other_value);
ListOfGuidArray_template(const ListOfGuidArray& other_value);
ListOfGuidArray_template(const OPTIONAL<ListOfGuidArray>& other_value);
ListOfGuidArray_template(const ListOfGuidArray_template& other_value);
~ListOfGuidArray_template();
ListOfGuidArray_template& operator=(template_sel other_value);
ListOfGuidArray_template& operator=(const ListOfGuidArray& other_value);
ListOfGuidArray_template& operator=(const OPTIONAL<ListOfGuidArray>& other_value);
ListOfGuidArray_template& operator=(const ListOfGuidArray_template& other_value);
boolean match(const ListOfGuidArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfGuidArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfGuidArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
GuidArray_template& arrayValues();
const GuidArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfGuidArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfByteString : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfByteStringArray *field_realArray;
};
void copy_value(const ListOfByteString& other_value);

public:
ListOfByteString();
ListOfByteString(const ListOfByteString& other_value);
~ListOfByteString();
ListOfByteString& operator=(const ListOfByteString& other_value);
boolean operator==(const ListOfByteString& other_value) const;
inline boolean operator!=(const ListOfByteString& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfByteStringArray& realArray();
const ListOfByteStringArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfByteString_template : public Base_Template {
union {
struct {
ListOfByteString::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfByteStringArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfByteString_template *list_value;
} value_list;
};
void copy_value(const ListOfByteString& other_value);

void copy_template(const ListOfByteString_template& other_value);

public:
ListOfByteString_template();
ListOfByteString_template(template_sel other_value);
ListOfByteString_template(const ListOfByteString& other_value);
ListOfByteString_template(const OPTIONAL<ListOfByteString>& other_value);
ListOfByteString_template(const ListOfByteString_template& other_value);
~ListOfByteString_template();
void clean_up();
ListOfByteString_template& operator=(template_sel other_value);
ListOfByteString_template& operator=(const ListOfByteString& other_value);
ListOfByteString_template& operator=(const OPTIONAL<ListOfByteString>& other_value);
ListOfByteString_template& operator=(const ListOfByteString_template& other_value);
boolean match(const ListOfByteString& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfByteString valueof() const;
ListOfByteString_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfByteStringArray_template& realArray();
const ListOfByteStringArray_template& realArray() const;
boolean ischosen(ListOfByteString::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfByteString& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ByteStringArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ByteString **value_elements;
} *val_ptr;

static const ByteString UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ByteStringArray& other_value);

public:
  typedef ByteString of_type;
ByteStringArray();
ByteStringArray(null_type other_value);
ByteStringArray(const ByteStringArray& other_value);
~ByteStringArray();

void clean_up();
ByteStringArray& operator=(null_type other_value);
ByteStringArray& operator=(const ByteStringArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ByteStringArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ByteStringArray& other_value) const { return !(*this == other_value); }

ByteString& operator[](int index_value);
ByteString& operator[](const INTEGER& index_value);
const ByteString& operator[](int index_value) const;
const ByteString& operator[](const INTEGER& index_value) const;

ByteStringArray operator<<=(int rotate_count) const;
ByteStringArray operator<<=(const INTEGER& rotate_count) const;
ByteStringArray operator>>=(int rotate_count) const;
ByteStringArray operator>>=(const INTEGER& rotate_count) const;

ByteStringArray operator+(const ByteStringArray& other_value) const;

ByteStringArray substr(int index, int returncount) const;

ByteStringArray replace(int index, int len, const ByteStringArray& repl) const;

ByteStringArray replace(int index, int len, const ByteStringArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ByteStringArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ByteString_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ByteStringArray_template *list_value;
} value_list;
};
void copy_value(const ByteStringArray& other_value);
void copy_template(const ByteStringArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ByteStringArray_template();
ByteStringArray_template(template_sel other_value);
ByteStringArray_template(null_type other_value);
ByteStringArray_template(const ByteStringArray& other_value);
ByteStringArray_template(const OPTIONAL<ByteStringArray>& other_value);
ByteStringArray_template(const ByteStringArray_template& other_value);
~ByteStringArray_template();

void clean_up();
ByteStringArray_template& operator=(template_sel other_value);
ByteStringArray_template& operator=(null_type other_value);
ByteStringArray_template& operator=(const ByteStringArray& other_value);
ByteStringArray_template& operator=(const OPTIONAL<ByteStringArray>& other_value);
ByteStringArray_template& operator=(const ByteStringArray_template& other_value);

ByteString_template& operator[](int index_value);
ByteString_template& operator[](const INTEGER& index_value);
const ByteString_template& operator[](int index_value) const;
const ByteString_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ByteStringArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ByteStringArray valueof() const;
ByteStringArray substr(int index, int returncount) const;

ByteStringArray replace(int index, int len, const ByteStringArray_template& repl) const;

ByteStringArray replace(int index, int len, const ByteStringArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ByteStringArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ByteStringArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfByteStringArray : public Base_Type {
  INTEGER field_arrayLength;
  ByteStringArray field_arrayValues;
public:
  ListOfByteStringArray();
  ListOfByteStringArray(const INTEGER& par_arrayLength,
    const ByteStringArray& par_arrayValues);
  ListOfByteStringArray(const ListOfByteStringArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfByteStringArray& operator=(const ListOfByteStringArray& other_value);
  boolean operator==(const ListOfByteStringArray& other_value) const;
  inline boolean operator!=(const ListOfByteStringArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ByteStringArray& arrayValues()
    {return field_arrayValues;}
  inline const ByteStringArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfByteStringArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfByteStringArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfByteStringArray& other_value);
void copy_template(const ListOfByteStringArray_template& other_value);

public:
ListOfByteStringArray_template();
ListOfByteStringArray_template(template_sel other_value);
ListOfByteStringArray_template(const ListOfByteStringArray& other_value);
ListOfByteStringArray_template(const OPTIONAL<ListOfByteStringArray>& other_value);
ListOfByteStringArray_template(const ListOfByteStringArray_template& other_value);
~ListOfByteStringArray_template();
ListOfByteStringArray_template& operator=(template_sel other_value);
ListOfByteStringArray_template& operator=(const ListOfByteStringArray& other_value);
ListOfByteStringArray_template& operator=(const OPTIONAL<ListOfByteStringArray>& other_value);
ListOfByteStringArray_template& operator=(const ListOfByteStringArray_template& other_value);
boolean match(const ListOfByteStringArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfByteStringArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfByteStringArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ByteStringArray_template& arrayValues();
const ByteStringArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfByteStringArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfXmlElement : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfXmlElementArray *field_realArray;
};
void copy_value(const ListOfXmlElement& other_value);

public:
ListOfXmlElement();
ListOfXmlElement(const ListOfXmlElement& other_value);
~ListOfXmlElement();
ListOfXmlElement& operator=(const ListOfXmlElement& other_value);
boolean operator==(const ListOfXmlElement& other_value) const;
inline boolean operator!=(const ListOfXmlElement& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfXmlElementArray& realArray();
const ListOfXmlElementArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfXmlElement_template : public Base_Template {
union {
struct {
ListOfXmlElement::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfXmlElementArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfXmlElement_template *list_value;
} value_list;
};
void copy_value(const ListOfXmlElement& other_value);

void copy_template(const ListOfXmlElement_template& other_value);

public:
ListOfXmlElement_template();
ListOfXmlElement_template(template_sel other_value);
ListOfXmlElement_template(const ListOfXmlElement& other_value);
ListOfXmlElement_template(const OPTIONAL<ListOfXmlElement>& other_value);
ListOfXmlElement_template(const ListOfXmlElement_template& other_value);
~ListOfXmlElement_template();
void clean_up();
ListOfXmlElement_template& operator=(template_sel other_value);
ListOfXmlElement_template& operator=(const ListOfXmlElement& other_value);
ListOfXmlElement_template& operator=(const OPTIONAL<ListOfXmlElement>& other_value);
ListOfXmlElement_template& operator=(const ListOfXmlElement_template& other_value);
boolean match(const ListOfXmlElement& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfXmlElement valueof() const;
ListOfXmlElement_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfXmlElementArray_template& realArray();
const ListOfXmlElementArray_template& realArray() const;
boolean ischosen(ListOfXmlElement::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfXmlElement& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class XmlElementArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ByteString **value_elements;
} *val_ptr;

static const ByteString UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const XmlElementArray& other_value);

public:
  typedef ByteString of_type;
XmlElementArray();
XmlElementArray(null_type other_value);
XmlElementArray(const XmlElementArray& other_value);
~XmlElementArray();

void clean_up();
XmlElementArray& operator=(null_type other_value);
XmlElementArray& operator=(const XmlElementArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const XmlElementArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const XmlElementArray& other_value) const { return !(*this == other_value); }

ByteString& operator[](int index_value);
ByteString& operator[](const INTEGER& index_value);
const ByteString& operator[](int index_value) const;
const ByteString& operator[](const INTEGER& index_value) const;

XmlElementArray operator<<=(int rotate_count) const;
XmlElementArray operator<<=(const INTEGER& rotate_count) const;
XmlElementArray operator>>=(int rotate_count) const;
XmlElementArray operator>>=(const INTEGER& rotate_count) const;

XmlElementArray operator+(const XmlElementArray& other_value) const;

XmlElementArray substr(int index, int returncount) const;

XmlElementArray replace(int index, int len, const XmlElementArray& repl) const;

XmlElementArray replace(int index, int len, const XmlElementArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class XmlElementArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ByteString_template **value_elements;
} single_value;
struct {
unsigned int n_values;
XmlElementArray_template *list_value;
} value_list;
};
void copy_value(const XmlElementArray& other_value);
void copy_template(const XmlElementArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
XmlElementArray_template();
XmlElementArray_template(template_sel other_value);
XmlElementArray_template(null_type other_value);
XmlElementArray_template(const XmlElementArray& other_value);
XmlElementArray_template(const OPTIONAL<XmlElementArray>& other_value);
XmlElementArray_template(const XmlElementArray_template& other_value);
~XmlElementArray_template();

void clean_up();
XmlElementArray_template& operator=(template_sel other_value);
XmlElementArray_template& operator=(null_type other_value);
XmlElementArray_template& operator=(const XmlElementArray& other_value);
XmlElementArray_template& operator=(const OPTIONAL<XmlElementArray>& other_value);
XmlElementArray_template& operator=(const XmlElementArray_template& other_value);

ByteString_template& operator[](int index_value);
ByteString_template& operator[](const INTEGER& index_value);
const ByteString_template& operator[](int index_value) const;
const ByteString_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const XmlElementArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
XmlElementArray valueof() const;
XmlElementArray substr(int index, int returncount) const;

XmlElementArray replace(int index, int len, const XmlElementArray_template& repl) const;

XmlElementArray replace(int index, int len, const XmlElementArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
XmlElementArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const XmlElementArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfXmlElementArray : public Base_Type {
  INTEGER field_arrayLength;
  XmlElementArray field_arrayValues;
public:
  ListOfXmlElementArray();
  ListOfXmlElementArray(const INTEGER& par_arrayLength,
    const XmlElementArray& par_arrayValues);
  ListOfXmlElementArray(const ListOfXmlElementArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfXmlElementArray& operator=(const ListOfXmlElementArray& other_value);
  boolean operator==(const ListOfXmlElementArray& other_value) const;
  inline boolean operator!=(const ListOfXmlElementArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline XmlElementArray& arrayValues()
    {return field_arrayValues;}
  inline const XmlElementArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfXmlElementArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfXmlElementArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfXmlElementArray& other_value);
void copy_template(const ListOfXmlElementArray_template& other_value);

public:
ListOfXmlElementArray_template();
ListOfXmlElementArray_template(template_sel other_value);
ListOfXmlElementArray_template(const ListOfXmlElementArray& other_value);
ListOfXmlElementArray_template(const OPTIONAL<ListOfXmlElementArray>& other_value);
ListOfXmlElementArray_template(const ListOfXmlElementArray_template& other_value);
~ListOfXmlElementArray_template();
ListOfXmlElementArray_template& operator=(template_sel other_value);
ListOfXmlElementArray_template& operator=(const ListOfXmlElementArray& other_value);
ListOfXmlElementArray_template& operator=(const OPTIONAL<ListOfXmlElementArray>& other_value);
ListOfXmlElementArray_template& operator=(const ListOfXmlElementArray_template& other_value);
boolean match(const ListOfXmlElementArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfXmlElementArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfXmlElementArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
XmlElementArray_template& arrayValues();
const XmlElementArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfXmlElementArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfNodeId : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfNodeIdArray *field_realArray;
};
void copy_value(const ListOfNodeId& other_value);

public:
ListOfNodeId();
ListOfNodeId(const ListOfNodeId& other_value);
~ListOfNodeId();
ListOfNodeId& operator=(const ListOfNodeId& other_value);
boolean operator==(const ListOfNodeId& other_value) const;
inline boolean operator!=(const ListOfNodeId& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfNodeIdArray& realArray();
const ListOfNodeIdArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfNodeId_template : public Base_Template {
union {
struct {
ListOfNodeId::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfNodeIdArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfNodeId_template *list_value;
} value_list;
};
void copy_value(const ListOfNodeId& other_value);

void copy_template(const ListOfNodeId_template& other_value);

public:
ListOfNodeId_template();
ListOfNodeId_template(template_sel other_value);
ListOfNodeId_template(const ListOfNodeId& other_value);
ListOfNodeId_template(const OPTIONAL<ListOfNodeId>& other_value);
ListOfNodeId_template(const ListOfNodeId_template& other_value);
~ListOfNodeId_template();
void clean_up();
ListOfNodeId_template& operator=(template_sel other_value);
ListOfNodeId_template& operator=(const ListOfNodeId& other_value);
ListOfNodeId_template& operator=(const OPTIONAL<ListOfNodeId>& other_value);
ListOfNodeId_template& operator=(const ListOfNodeId_template& other_value);
boolean match(const ListOfNodeId& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfNodeId valueof() const;
ListOfNodeId_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfNodeIdArray_template& realArray();
const ListOfNodeIdArray_template& realArray() const;
boolean ischosen(ListOfNodeId::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class NodeIdArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
NodeId **value_elements;
} *val_ptr;

static const NodeId UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const NodeIdArray& other_value);

public:
  typedef NodeId of_type;
NodeIdArray();
NodeIdArray(null_type other_value);
NodeIdArray(const NodeIdArray& other_value);
~NodeIdArray();

void clean_up();
NodeIdArray& operator=(null_type other_value);
NodeIdArray& operator=(const NodeIdArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const NodeIdArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const NodeIdArray& other_value) const { return !(*this == other_value); }

NodeId& operator[](int index_value);
NodeId& operator[](const INTEGER& index_value);
const NodeId& operator[](int index_value) const;
const NodeId& operator[](const INTEGER& index_value) const;

NodeIdArray operator<<=(int rotate_count) const;
NodeIdArray operator<<=(const INTEGER& rotate_count) const;
NodeIdArray operator>>=(int rotate_count) const;
NodeIdArray operator>>=(const INTEGER& rotate_count) const;

NodeIdArray operator+(const NodeIdArray& other_value) const;

NodeIdArray substr(int index, int returncount) const;

NodeIdArray replace(int index, int len, const NodeIdArray& repl) const;

NodeIdArray replace(int index, int len, const NodeIdArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NodeIdArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
NodeId_template **value_elements;
} single_value;
struct {
unsigned int n_values;
NodeIdArray_template *list_value;
} value_list;
};
void copy_value(const NodeIdArray& other_value);
void copy_template(const NodeIdArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
NodeIdArray_template();
NodeIdArray_template(template_sel other_value);
NodeIdArray_template(null_type other_value);
NodeIdArray_template(const NodeIdArray& other_value);
NodeIdArray_template(const OPTIONAL<NodeIdArray>& other_value);
NodeIdArray_template(const NodeIdArray_template& other_value);
~NodeIdArray_template();

void clean_up();
NodeIdArray_template& operator=(template_sel other_value);
NodeIdArray_template& operator=(null_type other_value);
NodeIdArray_template& operator=(const NodeIdArray& other_value);
NodeIdArray_template& operator=(const OPTIONAL<NodeIdArray>& other_value);
NodeIdArray_template& operator=(const NodeIdArray_template& other_value);

NodeId_template& operator[](int index_value);
NodeId_template& operator[](const INTEGER& index_value);
const NodeId_template& operator[](int index_value) const;
const NodeId_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const NodeIdArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
NodeIdArray valueof() const;
NodeIdArray substr(int index, int returncount) const;

NodeIdArray replace(int index, int len, const NodeIdArray_template& repl) const;

NodeIdArray replace(int index, int len, const NodeIdArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
NodeIdArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const NodeIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfNodeIdArray : public Base_Type {
  INTEGER field_arrayLength;
  NodeIdArray field_arrayValues;
public:
  ListOfNodeIdArray();
  ListOfNodeIdArray(const INTEGER& par_arrayLength,
    const NodeIdArray& par_arrayValues);
  ListOfNodeIdArray(const ListOfNodeIdArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfNodeIdArray& operator=(const ListOfNodeIdArray& other_value);
  boolean operator==(const ListOfNodeIdArray& other_value) const;
  inline boolean operator!=(const ListOfNodeIdArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline NodeIdArray& arrayValues()
    {return field_arrayValues;}
  inline const NodeIdArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfNodeIdArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfNodeIdArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfNodeIdArray& other_value);
void copy_template(const ListOfNodeIdArray_template& other_value);

public:
ListOfNodeIdArray_template();
ListOfNodeIdArray_template(template_sel other_value);
ListOfNodeIdArray_template(const ListOfNodeIdArray& other_value);
ListOfNodeIdArray_template(const OPTIONAL<ListOfNodeIdArray>& other_value);
ListOfNodeIdArray_template(const ListOfNodeIdArray_template& other_value);
~ListOfNodeIdArray_template();
ListOfNodeIdArray_template& operator=(template_sel other_value);
ListOfNodeIdArray_template& operator=(const ListOfNodeIdArray& other_value);
ListOfNodeIdArray_template& operator=(const OPTIONAL<ListOfNodeIdArray>& other_value);
ListOfNodeIdArray_template& operator=(const ListOfNodeIdArray_template& other_value);
boolean match(const ListOfNodeIdArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfNodeIdArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfNodeIdArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
NodeIdArray_template& arrayValues();
const NodeIdArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfNodeIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfExpandedNodeId : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfExpandedNodeIdArray *field_realArray;
};
void copy_value(const ListOfExpandedNodeId& other_value);

public:
ListOfExpandedNodeId();
ListOfExpandedNodeId(const ListOfExpandedNodeId& other_value);
~ListOfExpandedNodeId();
ListOfExpandedNodeId& operator=(const ListOfExpandedNodeId& other_value);
boolean operator==(const ListOfExpandedNodeId& other_value) const;
inline boolean operator!=(const ListOfExpandedNodeId& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfExpandedNodeIdArray& realArray();
const ListOfExpandedNodeIdArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfExpandedNodeId_template : public Base_Template {
union {
struct {
ListOfExpandedNodeId::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfExpandedNodeIdArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfExpandedNodeId_template *list_value;
} value_list;
};
void copy_value(const ListOfExpandedNodeId& other_value);

void copy_template(const ListOfExpandedNodeId_template& other_value);

public:
ListOfExpandedNodeId_template();
ListOfExpandedNodeId_template(template_sel other_value);
ListOfExpandedNodeId_template(const ListOfExpandedNodeId& other_value);
ListOfExpandedNodeId_template(const OPTIONAL<ListOfExpandedNodeId>& other_value);
ListOfExpandedNodeId_template(const ListOfExpandedNodeId_template& other_value);
~ListOfExpandedNodeId_template();
void clean_up();
ListOfExpandedNodeId_template& operator=(template_sel other_value);
ListOfExpandedNodeId_template& operator=(const ListOfExpandedNodeId& other_value);
ListOfExpandedNodeId_template& operator=(const OPTIONAL<ListOfExpandedNodeId>& other_value);
ListOfExpandedNodeId_template& operator=(const ListOfExpandedNodeId_template& other_value);
boolean match(const ListOfExpandedNodeId& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfExpandedNodeId valueof() const;
ListOfExpandedNodeId_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfExpandedNodeIdArray_template& realArray();
const ListOfExpandedNodeIdArray_template& realArray() const;
boolean ischosen(ListOfExpandedNodeId::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfExpandedNodeId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ExpandedNodeIdArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ExpandedNodeId **value_elements;
} *val_ptr;

static const ExpandedNodeId UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ExpandedNodeIdArray& other_value);

public:
  typedef ExpandedNodeId of_type;
ExpandedNodeIdArray();
ExpandedNodeIdArray(null_type other_value);
ExpandedNodeIdArray(const ExpandedNodeIdArray& other_value);
~ExpandedNodeIdArray();

void clean_up();
ExpandedNodeIdArray& operator=(null_type other_value);
ExpandedNodeIdArray& operator=(const ExpandedNodeIdArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ExpandedNodeIdArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ExpandedNodeIdArray& other_value) const { return !(*this == other_value); }

ExpandedNodeId& operator[](int index_value);
ExpandedNodeId& operator[](const INTEGER& index_value);
const ExpandedNodeId& operator[](int index_value) const;
const ExpandedNodeId& operator[](const INTEGER& index_value) const;

ExpandedNodeIdArray operator<<=(int rotate_count) const;
ExpandedNodeIdArray operator<<=(const INTEGER& rotate_count) const;
ExpandedNodeIdArray operator>>=(int rotate_count) const;
ExpandedNodeIdArray operator>>=(const INTEGER& rotate_count) const;

ExpandedNodeIdArray operator+(const ExpandedNodeIdArray& other_value) const;

ExpandedNodeIdArray substr(int index, int returncount) const;

ExpandedNodeIdArray replace(int index, int len, const ExpandedNodeIdArray& repl) const;

ExpandedNodeIdArray replace(int index, int len, const ExpandedNodeIdArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ExpandedNodeIdArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ExpandedNodeId_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ExpandedNodeIdArray_template *list_value;
} value_list;
};
void copy_value(const ExpandedNodeIdArray& other_value);
void copy_template(const ExpandedNodeIdArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ExpandedNodeIdArray_template();
ExpandedNodeIdArray_template(template_sel other_value);
ExpandedNodeIdArray_template(null_type other_value);
ExpandedNodeIdArray_template(const ExpandedNodeIdArray& other_value);
ExpandedNodeIdArray_template(const OPTIONAL<ExpandedNodeIdArray>& other_value);
ExpandedNodeIdArray_template(const ExpandedNodeIdArray_template& other_value);
~ExpandedNodeIdArray_template();

void clean_up();
ExpandedNodeIdArray_template& operator=(template_sel other_value);
ExpandedNodeIdArray_template& operator=(null_type other_value);
ExpandedNodeIdArray_template& operator=(const ExpandedNodeIdArray& other_value);
ExpandedNodeIdArray_template& operator=(const OPTIONAL<ExpandedNodeIdArray>& other_value);
ExpandedNodeIdArray_template& operator=(const ExpandedNodeIdArray_template& other_value);

ExpandedNodeId_template& operator[](int index_value);
ExpandedNodeId_template& operator[](const INTEGER& index_value);
const ExpandedNodeId_template& operator[](int index_value) const;
const ExpandedNodeId_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ExpandedNodeIdArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ExpandedNodeIdArray valueof() const;
ExpandedNodeIdArray substr(int index, int returncount) const;

ExpandedNodeIdArray replace(int index, int len, const ExpandedNodeIdArray_template& repl) const;

ExpandedNodeIdArray replace(int index, int len, const ExpandedNodeIdArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ExpandedNodeIdArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ExpandedNodeIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfExpandedNodeIdArray : public Base_Type {
  INTEGER field_arrayLength;
  ExpandedNodeIdArray field_arrayValues;
public:
  ListOfExpandedNodeIdArray();
  ListOfExpandedNodeIdArray(const INTEGER& par_arrayLength,
    const ExpandedNodeIdArray& par_arrayValues);
  ListOfExpandedNodeIdArray(const ListOfExpandedNodeIdArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfExpandedNodeIdArray& operator=(const ListOfExpandedNodeIdArray& other_value);
  boolean operator==(const ListOfExpandedNodeIdArray& other_value) const;
  inline boolean operator!=(const ListOfExpandedNodeIdArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ExpandedNodeIdArray& arrayValues()
    {return field_arrayValues;}
  inline const ExpandedNodeIdArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfExpandedNodeIdArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfExpandedNodeIdArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfExpandedNodeIdArray& other_value);
void copy_template(const ListOfExpandedNodeIdArray_template& other_value);

public:
ListOfExpandedNodeIdArray_template();
ListOfExpandedNodeIdArray_template(template_sel other_value);
ListOfExpandedNodeIdArray_template(const ListOfExpandedNodeIdArray& other_value);
ListOfExpandedNodeIdArray_template(const OPTIONAL<ListOfExpandedNodeIdArray>& other_value);
ListOfExpandedNodeIdArray_template(const ListOfExpandedNodeIdArray_template& other_value);
~ListOfExpandedNodeIdArray_template();
ListOfExpandedNodeIdArray_template& operator=(template_sel other_value);
ListOfExpandedNodeIdArray_template& operator=(const ListOfExpandedNodeIdArray& other_value);
ListOfExpandedNodeIdArray_template& operator=(const OPTIONAL<ListOfExpandedNodeIdArray>& other_value);
ListOfExpandedNodeIdArray_template& operator=(const ListOfExpandedNodeIdArray_template& other_value);
boolean match(const ListOfExpandedNodeIdArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfExpandedNodeIdArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfExpandedNodeIdArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ExpandedNodeIdArray_template& arrayValues();
const ExpandedNodeIdArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfExpandedNodeIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfStatusCode : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfStatusCodeArray *field_realArray;
};
void copy_value(const ListOfStatusCode& other_value);

public:
ListOfStatusCode();
ListOfStatusCode(const ListOfStatusCode& other_value);
~ListOfStatusCode();
ListOfStatusCode& operator=(const ListOfStatusCode& other_value);
boolean operator==(const ListOfStatusCode& other_value) const;
inline boolean operator!=(const ListOfStatusCode& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfStatusCodeArray& realArray();
const ListOfStatusCodeArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfStatusCode_template : public Base_Template {
union {
struct {
ListOfStatusCode::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfStatusCodeArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfStatusCode_template *list_value;
} value_list;
};
void copy_value(const ListOfStatusCode& other_value);

void copy_template(const ListOfStatusCode_template& other_value);

public:
ListOfStatusCode_template();
ListOfStatusCode_template(template_sel other_value);
ListOfStatusCode_template(const ListOfStatusCode& other_value);
ListOfStatusCode_template(const OPTIONAL<ListOfStatusCode>& other_value);
ListOfStatusCode_template(const ListOfStatusCode_template& other_value);
~ListOfStatusCode_template();
void clean_up();
ListOfStatusCode_template& operator=(template_sel other_value);
ListOfStatusCode_template& operator=(const ListOfStatusCode& other_value);
ListOfStatusCode_template& operator=(const OPTIONAL<ListOfStatusCode>& other_value);
ListOfStatusCode_template& operator=(const ListOfStatusCode_template& other_value);
boolean match(const ListOfStatusCode& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfStatusCode valueof() const;
ListOfStatusCode_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfStatusCodeArray_template& realArray();
const ListOfStatusCodeArray_template& realArray() const;
boolean ischosen(ListOfStatusCode::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfStatusCode& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfStatusCodeArray : public Base_Type {
  INTEGER field_arrayLength;
  StatusCodeArray field_arrayValues;
public:
  ListOfStatusCodeArray();
  ListOfStatusCodeArray(const INTEGER& par_arrayLength,
    const StatusCodeArray& par_arrayValues);
  ListOfStatusCodeArray(const ListOfStatusCodeArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfStatusCodeArray& operator=(const ListOfStatusCodeArray& other_value);
  boolean operator==(const ListOfStatusCodeArray& other_value) const;
  inline boolean operator!=(const ListOfStatusCodeArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline StatusCodeArray& arrayValues()
    {return field_arrayValues;}
  inline const StatusCodeArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfStatusCodeArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfStatusCodeArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfStatusCodeArray& other_value);
void copy_template(const ListOfStatusCodeArray_template& other_value);

public:
ListOfStatusCodeArray_template();
ListOfStatusCodeArray_template(template_sel other_value);
ListOfStatusCodeArray_template(const ListOfStatusCodeArray& other_value);
ListOfStatusCodeArray_template(const OPTIONAL<ListOfStatusCodeArray>& other_value);
ListOfStatusCodeArray_template(const ListOfStatusCodeArray_template& other_value);
~ListOfStatusCodeArray_template();
ListOfStatusCodeArray_template& operator=(template_sel other_value);
ListOfStatusCodeArray_template& operator=(const ListOfStatusCodeArray& other_value);
ListOfStatusCodeArray_template& operator=(const OPTIONAL<ListOfStatusCodeArray>& other_value);
ListOfStatusCodeArray_template& operator=(const ListOfStatusCodeArray_template& other_value);
boolean match(const ListOfStatusCodeArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfStatusCodeArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfStatusCodeArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
StatusCodeArray_template& arrayValues();
const StatusCodeArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfStatusCodeArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfQualifiedName : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfQualifiedNameArray *field_realArray;
};
void copy_value(const ListOfQualifiedName& other_value);

public:
ListOfQualifiedName();
ListOfQualifiedName(const ListOfQualifiedName& other_value);
~ListOfQualifiedName();
ListOfQualifiedName& operator=(const ListOfQualifiedName& other_value);
boolean operator==(const ListOfQualifiedName& other_value) const;
inline boolean operator!=(const ListOfQualifiedName& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfQualifiedNameArray& realArray();
const ListOfQualifiedNameArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfQualifiedName_template : public Base_Template {
union {
struct {
ListOfQualifiedName::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfQualifiedNameArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfQualifiedName_template *list_value;
} value_list;
};
void copy_value(const ListOfQualifiedName& other_value);

void copy_template(const ListOfQualifiedName_template& other_value);

public:
ListOfQualifiedName_template();
ListOfQualifiedName_template(template_sel other_value);
ListOfQualifiedName_template(const ListOfQualifiedName& other_value);
ListOfQualifiedName_template(const OPTIONAL<ListOfQualifiedName>& other_value);
ListOfQualifiedName_template(const ListOfQualifiedName_template& other_value);
~ListOfQualifiedName_template();
void clean_up();
ListOfQualifiedName_template& operator=(template_sel other_value);
ListOfQualifiedName_template& operator=(const ListOfQualifiedName& other_value);
ListOfQualifiedName_template& operator=(const OPTIONAL<ListOfQualifiedName>& other_value);
ListOfQualifiedName_template& operator=(const ListOfQualifiedName_template& other_value);
boolean match(const ListOfQualifiedName& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfQualifiedName valueof() const;
ListOfQualifiedName_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfQualifiedNameArray_template& realArray();
const ListOfQualifiedNameArray_template& realArray() const;
boolean ischosen(ListOfQualifiedName::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfQualifiedName& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class QualifiedNameArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
QualifiedName **value_elements;
} *val_ptr;

static const QualifiedName UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const QualifiedNameArray& other_value);

public:
  typedef QualifiedName of_type;
QualifiedNameArray();
QualifiedNameArray(null_type other_value);
QualifiedNameArray(const QualifiedNameArray& other_value);
~QualifiedNameArray();

void clean_up();
QualifiedNameArray& operator=(null_type other_value);
QualifiedNameArray& operator=(const QualifiedNameArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const QualifiedNameArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const QualifiedNameArray& other_value) const { return !(*this == other_value); }

QualifiedName& operator[](int index_value);
QualifiedName& operator[](const INTEGER& index_value);
const QualifiedName& operator[](int index_value) const;
const QualifiedName& operator[](const INTEGER& index_value) const;

QualifiedNameArray operator<<=(int rotate_count) const;
QualifiedNameArray operator<<=(const INTEGER& rotate_count) const;
QualifiedNameArray operator>>=(int rotate_count) const;
QualifiedNameArray operator>>=(const INTEGER& rotate_count) const;

QualifiedNameArray operator+(const QualifiedNameArray& other_value) const;

QualifiedNameArray substr(int index, int returncount) const;

QualifiedNameArray replace(int index, int len, const QualifiedNameArray& repl) const;

QualifiedNameArray replace(int index, int len, const QualifiedNameArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QualifiedNameArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
QualifiedName_template **value_elements;
} single_value;
struct {
unsigned int n_values;
QualifiedNameArray_template *list_value;
} value_list;
};
void copy_value(const QualifiedNameArray& other_value);
void copy_template(const QualifiedNameArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
QualifiedNameArray_template();
QualifiedNameArray_template(template_sel other_value);
QualifiedNameArray_template(null_type other_value);
QualifiedNameArray_template(const QualifiedNameArray& other_value);
QualifiedNameArray_template(const OPTIONAL<QualifiedNameArray>& other_value);
QualifiedNameArray_template(const QualifiedNameArray_template& other_value);
~QualifiedNameArray_template();

void clean_up();
QualifiedNameArray_template& operator=(template_sel other_value);
QualifiedNameArray_template& operator=(null_type other_value);
QualifiedNameArray_template& operator=(const QualifiedNameArray& other_value);
QualifiedNameArray_template& operator=(const OPTIONAL<QualifiedNameArray>& other_value);
QualifiedNameArray_template& operator=(const QualifiedNameArray_template& other_value);

QualifiedName_template& operator[](int index_value);
QualifiedName_template& operator[](const INTEGER& index_value);
const QualifiedName_template& operator[](int index_value) const;
const QualifiedName_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const QualifiedNameArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
QualifiedNameArray valueof() const;
QualifiedNameArray substr(int index, int returncount) const;

QualifiedNameArray replace(int index, int len, const QualifiedNameArray_template& repl) const;

QualifiedNameArray replace(int index, int len, const QualifiedNameArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
QualifiedNameArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const QualifiedNameArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfQualifiedNameArray : public Base_Type {
  INTEGER field_arrayLength;
  QualifiedNameArray field_arrayValues;
public:
  ListOfQualifiedNameArray();
  ListOfQualifiedNameArray(const INTEGER& par_arrayLength,
    const QualifiedNameArray& par_arrayValues);
  ListOfQualifiedNameArray(const ListOfQualifiedNameArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfQualifiedNameArray& operator=(const ListOfQualifiedNameArray& other_value);
  boolean operator==(const ListOfQualifiedNameArray& other_value) const;
  inline boolean operator!=(const ListOfQualifiedNameArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline QualifiedNameArray& arrayValues()
    {return field_arrayValues;}
  inline const QualifiedNameArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfQualifiedNameArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfQualifiedNameArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfQualifiedNameArray& other_value);
void copy_template(const ListOfQualifiedNameArray_template& other_value);

public:
ListOfQualifiedNameArray_template();
ListOfQualifiedNameArray_template(template_sel other_value);
ListOfQualifiedNameArray_template(const ListOfQualifiedNameArray& other_value);
ListOfQualifiedNameArray_template(const OPTIONAL<ListOfQualifiedNameArray>& other_value);
ListOfQualifiedNameArray_template(const ListOfQualifiedNameArray_template& other_value);
~ListOfQualifiedNameArray_template();
ListOfQualifiedNameArray_template& operator=(template_sel other_value);
ListOfQualifiedNameArray_template& operator=(const ListOfQualifiedNameArray& other_value);
ListOfQualifiedNameArray_template& operator=(const OPTIONAL<ListOfQualifiedNameArray>& other_value);
ListOfQualifiedNameArray_template& operator=(const ListOfQualifiedNameArray_template& other_value);
boolean match(const ListOfQualifiedNameArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfQualifiedNameArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfQualifiedNameArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
QualifiedNameArray_template& arrayValues();
const QualifiedNameArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfQualifiedNameArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfLocalizedText : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfLocalizedTextArray *field_realArray;
};
void copy_value(const ListOfLocalizedText& other_value);

public:
ListOfLocalizedText();
ListOfLocalizedText(const ListOfLocalizedText& other_value);
~ListOfLocalizedText();
ListOfLocalizedText& operator=(const ListOfLocalizedText& other_value);
boolean operator==(const ListOfLocalizedText& other_value) const;
inline boolean operator!=(const ListOfLocalizedText& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfLocalizedTextArray& realArray();
const ListOfLocalizedTextArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfLocalizedText_template : public Base_Template {
union {
struct {
ListOfLocalizedText::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfLocalizedTextArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfLocalizedText_template *list_value;
} value_list;
};
void copy_value(const ListOfLocalizedText& other_value);

void copy_template(const ListOfLocalizedText_template& other_value);

public:
ListOfLocalizedText_template();
ListOfLocalizedText_template(template_sel other_value);
ListOfLocalizedText_template(const ListOfLocalizedText& other_value);
ListOfLocalizedText_template(const OPTIONAL<ListOfLocalizedText>& other_value);
ListOfLocalizedText_template(const ListOfLocalizedText_template& other_value);
~ListOfLocalizedText_template();
void clean_up();
ListOfLocalizedText_template& operator=(template_sel other_value);
ListOfLocalizedText_template& operator=(const ListOfLocalizedText& other_value);
ListOfLocalizedText_template& operator=(const OPTIONAL<ListOfLocalizedText>& other_value);
ListOfLocalizedText_template& operator=(const ListOfLocalizedText_template& other_value);
boolean match(const ListOfLocalizedText& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfLocalizedText valueof() const;
ListOfLocalizedText_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfLocalizedTextArray_template& realArray();
const ListOfLocalizedTextArray_template& realArray() const;
boolean ischosen(ListOfLocalizedText::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfLocalizedText& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class LocalizedTextArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
LocalizedText **value_elements;
} *val_ptr;

static const LocalizedText UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const LocalizedTextArray& other_value);

public:
  typedef LocalizedText of_type;
LocalizedTextArray();
LocalizedTextArray(null_type other_value);
LocalizedTextArray(const LocalizedTextArray& other_value);
~LocalizedTextArray();

void clean_up();
LocalizedTextArray& operator=(null_type other_value);
LocalizedTextArray& operator=(const LocalizedTextArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const LocalizedTextArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const LocalizedTextArray& other_value) const { return !(*this == other_value); }

LocalizedText& operator[](int index_value);
LocalizedText& operator[](const INTEGER& index_value);
const LocalizedText& operator[](int index_value) const;
const LocalizedText& operator[](const INTEGER& index_value) const;

LocalizedTextArray operator<<=(int rotate_count) const;
LocalizedTextArray operator<<=(const INTEGER& rotate_count) const;
LocalizedTextArray operator>>=(int rotate_count) const;
LocalizedTextArray operator>>=(const INTEGER& rotate_count) const;

LocalizedTextArray operator+(const LocalizedTextArray& other_value) const;

LocalizedTextArray substr(int index, int returncount) const;

LocalizedTextArray replace(int index, int len, const LocalizedTextArray& repl) const;

LocalizedTextArray replace(int index, int len, const LocalizedTextArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class LocalizedTextArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
LocalizedText_template **value_elements;
} single_value;
struct {
unsigned int n_values;
LocalizedTextArray_template *list_value;
} value_list;
};
void copy_value(const LocalizedTextArray& other_value);
void copy_template(const LocalizedTextArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
LocalizedTextArray_template();
LocalizedTextArray_template(template_sel other_value);
LocalizedTextArray_template(null_type other_value);
LocalizedTextArray_template(const LocalizedTextArray& other_value);
LocalizedTextArray_template(const OPTIONAL<LocalizedTextArray>& other_value);
LocalizedTextArray_template(const LocalizedTextArray_template& other_value);
~LocalizedTextArray_template();

void clean_up();
LocalizedTextArray_template& operator=(template_sel other_value);
LocalizedTextArray_template& operator=(null_type other_value);
LocalizedTextArray_template& operator=(const LocalizedTextArray& other_value);
LocalizedTextArray_template& operator=(const OPTIONAL<LocalizedTextArray>& other_value);
LocalizedTextArray_template& operator=(const LocalizedTextArray_template& other_value);

LocalizedText_template& operator[](int index_value);
LocalizedText_template& operator[](const INTEGER& index_value);
const LocalizedText_template& operator[](int index_value) const;
const LocalizedText_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const LocalizedTextArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
LocalizedTextArray valueof() const;
LocalizedTextArray substr(int index, int returncount) const;

LocalizedTextArray replace(int index, int len, const LocalizedTextArray_template& repl) const;

LocalizedTextArray replace(int index, int len, const LocalizedTextArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
LocalizedTextArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const LocalizedTextArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfLocalizedTextArray : public Base_Type {
  INTEGER field_arrayLength;
  LocalizedTextArray field_arrayValues;
public:
  ListOfLocalizedTextArray();
  ListOfLocalizedTextArray(const INTEGER& par_arrayLength,
    const LocalizedTextArray& par_arrayValues);
  ListOfLocalizedTextArray(const ListOfLocalizedTextArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfLocalizedTextArray& operator=(const ListOfLocalizedTextArray& other_value);
  boolean operator==(const ListOfLocalizedTextArray& other_value) const;
  inline boolean operator!=(const ListOfLocalizedTextArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline LocalizedTextArray& arrayValues()
    {return field_arrayValues;}
  inline const LocalizedTextArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfLocalizedTextArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfLocalizedTextArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfLocalizedTextArray& other_value);
void copy_template(const ListOfLocalizedTextArray_template& other_value);

public:
ListOfLocalizedTextArray_template();
ListOfLocalizedTextArray_template(template_sel other_value);
ListOfLocalizedTextArray_template(const ListOfLocalizedTextArray& other_value);
ListOfLocalizedTextArray_template(const OPTIONAL<ListOfLocalizedTextArray>& other_value);
ListOfLocalizedTextArray_template(const ListOfLocalizedTextArray_template& other_value);
~ListOfLocalizedTextArray_template();
ListOfLocalizedTextArray_template& operator=(template_sel other_value);
ListOfLocalizedTextArray_template& operator=(const ListOfLocalizedTextArray& other_value);
ListOfLocalizedTextArray_template& operator=(const OPTIONAL<ListOfLocalizedTextArray>& other_value);
ListOfLocalizedTextArray_template& operator=(const ListOfLocalizedTextArray_template& other_value);
boolean match(const ListOfLocalizedTextArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfLocalizedTextArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfLocalizedTextArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
LocalizedTextArray_template& arrayValues();
const LocalizedTextArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfLocalizedTextArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfExtensionObject : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfExtensionObjectArray *field_realArray;
};
void copy_value(const ListOfExtensionObject& other_value);

public:
ListOfExtensionObject();
ListOfExtensionObject(const ListOfExtensionObject& other_value);
~ListOfExtensionObject();
ListOfExtensionObject& operator=(const ListOfExtensionObject& other_value);
boolean operator==(const ListOfExtensionObject& other_value) const;
inline boolean operator!=(const ListOfExtensionObject& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfExtensionObjectArray& realArray();
const ListOfExtensionObjectArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfExtensionObject_template : public Base_Template {
union {
struct {
ListOfExtensionObject::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfExtensionObjectArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfExtensionObject_template *list_value;
} value_list;
};
void copy_value(const ListOfExtensionObject& other_value);

void copy_template(const ListOfExtensionObject_template& other_value);

public:
ListOfExtensionObject_template();
ListOfExtensionObject_template(template_sel other_value);
ListOfExtensionObject_template(const ListOfExtensionObject& other_value);
ListOfExtensionObject_template(const OPTIONAL<ListOfExtensionObject>& other_value);
ListOfExtensionObject_template(const ListOfExtensionObject_template& other_value);
~ListOfExtensionObject_template();
void clean_up();
ListOfExtensionObject_template& operator=(template_sel other_value);
ListOfExtensionObject_template& operator=(const ListOfExtensionObject& other_value);
ListOfExtensionObject_template& operator=(const OPTIONAL<ListOfExtensionObject>& other_value);
ListOfExtensionObject_template& operator=(const ListOfExtensionObject_template& other_value);
boolean match(const ListOfExtensionObject& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfExtensionObject valueof() const;
ListOfExtensionObject_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfExtensionObjectArray_template& realArray();
const ListOfExtensionObjectArray_template& realArray() const;
boolean ischosen(ListOfExtensionObject::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfExtensionObject& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ExtensionObjectArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ExtensionObject **value_elements;
} *val_ptr;

static const ExtensionObject UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ExtensionObjectArray& other_value);

public:
  typedef ExtensionObject of_type;
ExtensionObjectArray();
ExtensionObjectArray(null_type other_value);
ExtensionObjectArray(const ExtensionObjectArray& other_value);
~ExtensionObjectArray();

void clean_up();
ExtensionObjectArray& operator=(null_type other_value);
ExtensionObjectArray& operator=(const ExtensionObjectArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ExtensionObjectArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ExtensionObjectArray& other_value) const { return !(*this == other_value); }

ExtensionObject& operator[](int index_value);
ExtensionObject& operator[](const INTEGER& index_value);
const ExtensionObject& operator[](int index_value) const;
const ExtensionObject& operator[](const INTEGER& index_value) const;

ExtensionObjectArray operator<<=(int rotate_count) const;
ExtensionObjectArray operator<<=(const INTEGER& rotate_count) const;
ExtensionObjectArray operator>>=(int rotate_count) const;
ExtensionObjectArray operator>>=(const INTEGER& rotate_count) const;

ExtensionObjectArray operator+(const ExtensionObjectArray& other_value) const;

ExtensionObjectArray substr(int index, int returncount) const;

ExtensionObjectArray replace(int index, int len, const ExtensionObjectArray& repl) const;

ExtensionObjectArray replace(int index, int len, const ExtensionObjectArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ExtensionObjectArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ExtensionObject_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ExtensionObjectArray_template *list_value;
} value_list;
};
void copy_value(const ExtensionObjectArray& other_value);
void copy_template(const ExtensionObjectArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ExtensionObjectArray_template();
ExtensionObjectArray_template(template_sel other_value);
ExtensionObjectArray_template(null_type other_value);
ExtensionObjectArray_template(const ExtensionObjectArray& other_value);
ExtensionObjectArray_template(const OPTIONAL<ExtensionObjectArray>& other_value);
ExtensionObjectArray_template(const ExtensionObjectArray_template& other_value);
~ExtensionObjectArray_template();

void clean_up();
ExtensionObjectArray_template& operator=(template_sel other_value);
ExtensionObjectArray_template& operator=(null_type other_value);
ExtensionObjectArray_template& operator=(const ExtensionObjectArray& other_value);
ExtensionObjectArray_template& operator=(const OPTIONAL<ExtensionObjectArray>& other_value);
ExtensionObjectArray_template& operator=(const ExtensionObjectArray_template& other_value);

ExtensionObject_template& operator[](int index_value);
ExtensionObject_template& operator[](const INTEGER& index_value);
const ExtensionObject_template& operator[](int index_value) const;
const ExtensionObject_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ExtensionObjectArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ExtensionObjectArray valueof() const;
ExtensionObjectArray substr(int index, int returncount) const;

ExtensionObjectArray replace(int index, int len, const ExtensionObjectArray_template& repl) const;

ExtensionObjectArray replace(int index, int len, const ExtensionObjectArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ExtensionObjectArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ExtensionObjectArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfExtensionObjectArray : public Base_Type {
  INTEGER field_arrayLength;
  ExtensionObjectArray field_arrayValues;
public:
  ListOfExtensionObjectArray();
  ListOfExtensionObjectArray(const INTEGER& par_arrayLength,
    const ExtensionObjectArray& par_arrayValues);
  ListOfExtensionObjectArray(const ListOfExtensionObjectArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfExtensionObjectArray& operator=(const ListOfExtensionObjectArray& other_value);
  boolean operator==(const ListOfExtensionObjectArray& other_value) const;
  inline boolean operator!=(const ListOfExtensionObjectArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ExtensionObjectArray& arrayValues()
    {return field_arrayValues;}
  inline const ExtensionObjectArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfExtensionObjectArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfExtensionObjectArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfExtensionObjectArray& other_value);
void copy_template(const ListOfExtensionObjectArray_template& other_value);

public:
ListOfExtensionObjectArray_template();
ListOfExtensionObjectArray_template(template_sel other_value);
ListOfExtensionObjectArray_template(const ListOfExtensionObjectArray& other_value);
ListOfExtensionObjectArray_template(const OPTIONAL<ListOfExtensionObjectArray>& other_value);
ListOfExtensionObjectArray_template(const ListOfExtensionObjectArray_template& other_value);
~ListOfExtensionObjectArray_template();
ListOfExtensionObjectArray_template& operator=(template_sel other_value);
ListOfExtensionObjectArray_template& operator=(const ListOfExtensionObjectArray& other_value);
ListOfExtensionObjectArray_template& operator=(const OPTIONAL<ListOfExtensionObjectArray>& other_value);
ListOfExtensionObjectArray_template& operator=(const ListOfExtensionObjectArray_template& other_value);
boolean match(const ListOfExtensionObjectArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfExtensionObjectArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfExtensionObjectArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ExtensionObjectArray_template& arrayValues();
const ExtensionObjectArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfExtensionObjectArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfDataValue : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfDataValueArray *field_realArray;
};
void copy_value(const ListOfDataValue& other_value);

public:
ListOfDataValue();
ListOfDataValue(const ListOfDataValue& other_value);
~ListOfDataValue();
ListOfDataValue& operator=(const ListOfDataValue& other_value);
boolean operator==(const ListOfDataValue& other_value) const;
inline boolean operator!=(const ListOfDataValue& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfDataValueArray& realArray();
const ListOfDataValueArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDataValue_template : public Base_Template {
union {
struct {
ListOfDataValue::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfDataValueArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfDataValue_template *list_value;
} value_list;
};
void copy_value(const ListOfDataValue& other_value);

void copy_template(const ListOfDataValue_template& other_value);

public:
ListOfDataValue_template();
ListOfDataValue_template(template_sel other_value);
ListOfDataValue_template(const ListOfDataValue& other_value);
ListOfDataValue_template(const OPTIONAL<ListOfDataValue>& other_value);
ListOfDataValue_template(const ListOfDataValue_template& other_value);
~ListOfDataValue_template();
void clean_up();
ListOfDataValue_template& operator=(template_sel other_value);
ListOfDataValue_template& operator=(const ListOfDataValue& other_value);
ListOfDataValue_template& operator=(const OPTIONAL<ListOfDataValue>& other_value);
ListOfDataValue_template& operator=(const ListOfDataValue_template& other_value);
boolean match(const ListOfDataValue& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfDataValue valueof() const;
ListOfDataValue_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfDataValueArray_template& realArray();
const ListOfDataValueArray_template& realArray() const;
boolean ischosen(ListOfDataValue::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfDataValue& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class DataValueArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
DataValue **value_elements;
} *val_ptr;

static const DataValue UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const DataValueArray& other_value);

public:
  typedef DataValue of_type;
DataValueArray();
DataValueArray(null_type other_value);
DataValueArray(const DataValueArray& other_value);
~DataValueArray();

void clean_up();
DataValueArray& operator=(null_type other_value);
DataValueArray& operator=(const DataValueArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const DataValueArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DataValueArray& other_value) const { return !(*this == other_value); }

DataValue& operator[](int index_value);
DataValue& operator[](const INTEGER& index_value);
const DataValue& operator[](int index_value) const;
const DataValue& operator[](const INTEGER& index_value) const;

DataValueArray operator<<=(int rotate_count) const;
DataValueArray operator<<=(const INTEGER& rotate_count) const;
DataValueArray operator>>=(int rotate_count) const;
DataValueArray operator>>=(const INTEGER& rotate_count) const;

DataValueArray operator+(const DataValueArray& other_value) const;

DataValueArray substr(int index, int returncount) const;

DataValueArray replace(int index, int len, const DataValueArray& repl) const;

DataValueArray replace(int index, int len, const DataValueArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DataValueArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
DataValue_template **value_elements;
} single_value;
struct {
unsigned int n_values;
DataValueArray_template *list_value;
} value_list;
};
void copy_value(const DataValueArray& other_value);
void copy_template(const DataValueArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
DataValueArray_template();
DataValueArray_template(template_sel other_value);
DataValueArray_template(null_type other_value);
DataValueArray_template(const DataValueArray& other_value);
DataValueArray_template(const OPTIONAL<DataValueArray>& other_value);
DataValueArray_template(const DataValueArray_template& other_value);
~DataValueArray_template();

void clean_up();
DataValueArray_template& operator=(template_sel other_value);
DataValueArray_template& operator=(null_type other_value);
DataValueArray_template& operator=(const DataValueArray& other_value);
DataValueArray_template& operator=(const OPTIONAL<DataValueArray>& other_value);
DataValueArray_template& operator=(const DataValueArray_template& other_value);

DataValue_template& operator[](int index_value);
DataValue_template& operator[](const INTEGER& index_value);
const DataValue_template& operator[](int index_value) const;
const DataValue_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const DataValueArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
DataValueArray valueof() const;
DataValueArray substr(int index, int returncount) const;

DataValueArray replace(int index, int len, const DataValueArray_template& repl) const;

DataValueArray replace(int index, int len, const DataValueArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
DataValueArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DataValueArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfDataValueArray : public Base_Type {
  INTEGER field_arrayLength;
  DataValueArray field_arrayValues;
public:
  ListOfDataValueArray();
  ListOfDataValueArray(const INTEGER& par_arrayLength,
    const DataValueArray& par_arrayValues);
  ListOfDataValueArray(const ListOfDataValueArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfDataValueArray& operator=(const ListOfDataValueArray& other_value);
  boolean operator==(const ListOfDataValueArray& other_value) const;
  inline boolean operator!=(const ListOfDataValueArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline DataValueArray& arrayValues()
    {return field_arrayValues;}
  inline const DataValueArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDataValueArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfDataValueArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfDataValueArray& other_value);
void copy_template(const ListOfDataValueArray_template& other_value);

public:
ListOfDataValueArray_template();
ListOfDataValueArray_template(template_sel other_value);
ListOfDataValueArray_template(const ListOfDataValueArray& other_value);
ListOfDataValueArray_template(const OPTIONAL<ListOfDataValueArray>& other_value);
ListOfDataValueArray_template(const ListOfDataValueArray_template& other_value);
~ListOfDataValueArray_template();
ListOfDataValueArray_template& operator=(template_sel other_value);
ListOfDataValueArray_template& operator=(const ListOfDataValueArray& other_value);
ListOfDataValueArray_template& operator=(const OPTIONAL<ListOfDataValueArray>& other_value);
ListOfDataValueArray_template& operator=(const ListOfDataValueArray_template& other_value);
boolean match(const ListOfDataValueArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfDataValueArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfDataValueArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
DataValueArray_template& arrayValues();
const DataValueArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfDataValueArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfDiagnosticInfo : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfDiagnosticInfoArray *field_realArray;
};
void copy_value(const ListOfDiagnosticInfo& other_value);

public:
ListOfDiagnosticInfo();
ListOfDiagnosticInfo(const ListOfDiagnosticInfo& other_value);
~ListOfDiagnosticInfo();
ListOfDiagnosticInfo& operator=(const ListOfDiagnosticInfo& other_value);
boolean operator==(const ListOfDiagnosticInfo& other_value) const;
inline boolean operator!=(const ListOfDiagnosticInfo& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfDiagnosticInfoArray& realArray();
const ListOfDiagnosticInfoArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDiagnosticInfo_template : public Base_Template {
union {
struct {
ListOfDiagnosticInfo::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfDiagnosticInfoArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfDiagnosticInfo_template *list_value;
} value_list;
};
void copy_value(const ListOfDiagnosticInfo& other_value);

void copy_template(const ListOfDiagnosticInfo_template& other_value);

public:
ListOfDiagnosticInfo_template();
ListOfDiagnosticInfo_template(template_sel other_value);
ListOfDiagnosticInfo_template(const ListOfDiagnosticInfo& other_value);
ListOfDiagnosticInfo_template(const OPTIONAL<ListOfDiagnosticInfo>& other_value);
ListOfDiagnosticInfo_template(const ListOfDiagnosticInfo_template& other_value);
~ListOfDiagnosticInfo_template();
void clean_up();
ListOfDiagnosticInfo_template& operator=(template_sel other_value);
ListOfDiagnosticInfo_template& operator=(const ListOfDiagnosticInfo& other_value);
ListOfDiagnosticInfo_template& operator=(const OPTIONAL<ListOfDiagnosticInfo>& other_value);
ListOfDiagnosticInfo_template& operator=(const ListOfDiagnosticInfo_template& other_value);
boolean match(const ListOfDiagnosticInfo& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfDiagnosticInfo valueof() const;
ListOfDiagnosticInfo_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfDiagnosticInfoArray_template& realArray();
const ListOfDiagnosticInfoArray_template& realArray() const;
boolean ischosen(ListOfDiagnosticInfo::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfDiagnosticInfo& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class DiagnosticInfoArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
DiagnosticInfo **value_elements;
} *val_ptr;

static const DiagnosticInfo UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const DiagnosticInfoArray& other_value);

public:
  typedef DiagnosticInfo of_type;
DiagnosticInfoArray();
DiagnosticInfoArray(null_type other_value);
DiagnosticInfoArray(const DiagnosticInfoArray& other_value);
~DiagnosticInfoArray();

void clean_up();
DiagnosticInfoArray& operator=(null_type other_value);
DiagnosticInfoArray& operator=(const DiagnosticInfoArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const DiagnosticInfoArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DiagnosticInfoArray& other_value) const { return !(*this == other_value); }

DiagnosticInfo& operator[](int index_value);
DiagnosticInfo& operator[](const INTEGER& index_value);
const DiagnosticInfo& operator[](int index_value) const;
const DiagnosticInfo& operator[](const INTEGER& index_value) const;

DiagnosticInfoArray operator<<=(int rotate_count) const;
DiagnosticInfoArray operator<<=(const INTEGER& rotate_count) const;
DiagnosticInfoArray operator>>=(int rotate_count) const;
DiagnosticInfoArray operator>>=(const INTEGER& rotate_count) const;

DiagnosticInfoArray operator+(const DiagnosticInfoArray& other_value) const;

DiagnosticInfoArray substr(int index, int returncount) const;

DiagnosticInfoArray replace(int index, int len, const DiagnosticInfoArray& repl) const;

DiagnosticInfoArray replace(int index, int len, const DiagnosticInfoArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DiagnosticInfoArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
DiagnosticInfo_template **value_elements;
} single_value;
struct {
unsigned int n_values;
DiagnosticInfoArray_template *list_value;
} value_list;
};
void copy_value(const DiagnosticInfoArray& other_value);
void copy_template(const DiagnosticInfoArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
DiagnosticInfoArray_template();
DiagnosticInfoArray_template(template_sel other_value);
DiagnosticInfoArray_template(null_type other_value);
DiagnosticInfoArray_template(const DiagnosticInfoArray& other_value);
DiagnosticInfoArray_template(const OPTIONAL<DiagnosticInfoArray>& other_value);
DiagnosticInfoArray_template(const DiagnosticInfoArray_template& other_value);
~DiagnosticInfoArray_template();

void clean_up();
DiagnosticInfoArray_template& operator=(template_sel other_value);
DiagnosticInfoArray_template& operator=(null_type other_value);
DiagnosticInfoArray_template& operator=(const DiagnosticInfoArray& other_value);
DiagnosticInfoArray_template& operator=(const OPTIONAL<DiagnosticInfoArray>& other_value);
DiagnosticInfoArray_template& operator=(const DiagnosticInfoArray_template& other_value);

DiagnosticInfo_template& operator[](int index_value);
DiagnosticInfo_template& operator[](const INTEGER& index_value);
const DiagnosticInfo_template& operator[](int index_value) const;
const DiagnosticInfo_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const DiagnosticInfoArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
DiagnosticInfoArray valueof() const;
DiagnosticInfoArray substr(int index, int returncount) const;

DiagnosticInfoArray replace(int index, int len, const DiagnosticInfoArray_template& repl) const;

DiagnosticInfoArray replace(int index, int len, const DiagnosticInfoArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
DiagnosticInfoArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DiagnosticInfoArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfDiagnosticInfoArray : public Base_Type {
  INTEGER field_arrayLength;
  DiagnosticInfoArray field_arrayValues;
public:
  ListOfDiagnosticInfoArray();
  ListOfDiagnosticInfoArray(const INTEGER& par_arrayLength,
    const DiagnosticInfoArray& par_arrayValues);
  ListOfDiagnosticInfoArray(const ListOfDiagnosticInfoArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfDiagnosticInfoArray& operator=(const ListOfDiagnosticInfoArray& other_value);
  boolean operator==(const ListOfDiagnosticInfoArray& other_value) const;
  inline boolean operator!=(const ListOfDiagnosticInfoArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline DiagnosticInfoArray& arrayValues()
    {return field_arrayValues;}
  inline const DiagnosticInfoArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDiagnosticInfoArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfDiagnosticInfoArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfDiagnosticInfoArray& other_value);
void copy_template(const ListOfDiagnosticInfoArray_template& other_value);

public:
ListOfDiagnosticInfoArray_template();
ListOfDiagnosticInfoArray_template(template_sel other_value);
ListOfDiagnosticInfoArray_template(const ListOfDiagnosticInfoArray& other_value);
ListOfDiagnosticInfoArray_template(const OPTIONAL<ListOfDiagnosticInfoArray>& other_value);
ListOfDiagnosticInfoArray_template(const ListOfDiagnosticInfoArray_template& other_value);
~ListOfDiagnosticInfoArray_template();
ListOfDiagnosticInfoArray_template& operator=(template_sel other_value);
ListOfDiagnosticInfoArray_template& operator=(const ListOfDiagnosticInfoArray& other_value);
ListOfDiagnosticInfoArray_template& operator=(const OPTIONAL<ListOfDiagnosticInfoArray>& other_value);
ListOfDiagnosticInfoArray_template& operator=(const ListOfDiagnosticInfoArray_template& other_value);
boolean match(const ListOfDiagnosticInfoArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfDiagnosticInfoArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfDiagnosticInfoArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
DiagnosticInfoArray_template& arrayValues();
const DiagnosticInfoArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfDiagnosticInfoArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LiteralOperand : public Base_Type {
  Variant field_Value;
public:
  LiteralOperand();
  LiteralOperand(const Variant& par_Value);
  LiteralOperand(const LiteralOperand& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  LiteralOperand& operator=(const LiteralOperand& other_value);
  boolean operator==(const LiteralOperand& other_value) const;
  inline boolean operator!=(const LiteralOperand& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline Variant& Value()
    {return field_Value;}
  inline const Variant& Value() const
    {return field_Value;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class LiteralOperand_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
LiteralOperand_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const LiteralOperand& other_value);
void copy_template(const LiteralOperand_template& other_value);

public:
LiteralOperand_template();
LiteralOperand_template(template_sel other_value);
LiteralOperand_template(const LiteralOperand& other_value);
LiteralOperand_template(const OPTIONAL<LiteralOperand>& other_value);
LiteralOperand_template(const LiteralOperand_template& other_value);
~LiteralOperand_template();
LiteralOperand_template& operator=(template_sel other_value);
LiteralOperand_template& operator=(const LiteralOperand& other_value);
LiteralOperand_template& operator=(const OPTIONAL<LiteralOperand>& other_value);
LiteralOperand_template& operator=(const LiteralOperand_template& other_value);
boolean match(const LiteralOperand& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
LiteralOperand valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
LiteralOperand_template& list_item(unsigned int list_index) const;
Variant_template& Value();
const Variant_template& Value() const;
int size_of() const;
void log() const;
void log_match(const LiteralOperand& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfRelativePathElement : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfRelativePathElementArray *field_realArray;
};
void copy_value(const ListOfRelativePathElement& other_value);

public:
ListOfRelativePathElement();
ListOfRelativePathElement(const ListOfRelativePathElement& other_value);
~ListOfRelativePathElement();
ListOfRelativePathElement& operator=(const ListOfRelativePathElement& other_value);
boolean operator==(const ListOfRelativePathElement& other_value) const;
inline boolean operator!=(const ListOfRelativePathElement& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfRelativePathElementArray& realArray();
const ListOfRelativePathElementArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfRelativePathElement_template : public Base_Template {
union {
struct {
ListOfRelativePathElement::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfRelativePathElementArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfRelativePathElement_template *list_value;
} value_list;
};
void copy_value(const ListOfRelativePathElement& other_value);

void copy_template(const ListOfRelativePathElement_template& other_value);

public:
ListOfRelativePathElement_template();
ListOfRelativePathElement_template(template_sel other_value);
ListOfRelativePathElement_template(const ListOfRelativePathElement& other_value);
ListOfRelativePathElement_template(const OPTIONAL<ListOfRelativePathElement>& other_value);
ListOfRelativePathElement_template(const ListOfRelativePathElement_template& other_value);
~ListOfRelativePathElement_template();
void clean_up();
ListOfRelativePathElement_template& operator=(template_sel other_value);
ListOfRelativePathElement_template& operator=(const ListOfRelativePathElement& other_value);
ListOfRelativePathElement_template& operator=(const OPTIONAL<ListOfRelativePathElement>& other_value);
ListOfRelativePathElement_template& operator=(const ListOfRelativePathElement_template& other_value);
boolean match(const ListOfRelativePathElement& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfRelativePathElement valueof() const;
ListOfRelativePathElement_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfRelativePathElementArray_template& realArray();
const ListOfRelativePathElementArray_template& realArray() const;
boolean ischosen(ListOfRelativePathElement::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfRelativePathElement& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class RelativePathElementArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
RelativePathElement **value_elements;
} *val_ptr;

static const RelativePathElement UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const RelativePathElementArray& other_value);

public:
  typedef RelativePathElement of_type;
RelativePathElementArray();
RelativePathElementArray(null_type other_value);
RelativePathElementArray(const RelativePathElementArray& other_value);
~RelativePathElementArray();

void clean_up();
RelativePathElementArray& operator=(null_type other_value);
RelativePathElementArray& operator=(const RelativePathElementArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const RelativePathElementArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const RelativePathElementArray& other_value) const { return !(*this == other_value); }

RelativePathElement& operator[](int index_value);
RelativePathElement& operator[](const INTEGER& index_value);
const RelativePathElement& operator[](int index_value) const;
const RelativePathElement& operator[](const INTEGER& index_value) const;

RelativePathElementArray operator<<=(int rotate_count) const;
RelativePathElementArray operator<<=(const INTEGER& rotate_count) const;
RelativePathElementArray operator>>=(int rotate_count) const;
RelativePathElementArray operator>>=(const INTEGER& rotate_count) const;

RelativePathElementArray operator+(const RelativePathElementArray& other_value) const;

RelativePathElementArray substr(int index, int returncount) const;

RelativePathElementArray replace(int index, int len, const RelativePathElementArray& repl) const;

RelativePathElementArray replace(int index, int len, const RelativePathElementArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RelativePathElementArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
RelativePathElement_template **value_elements;
} single_value;
struct {
unsigned int n_values;
RelativePathElementArray_template *list_value;
} value_list;
};
void copy_value(const RelativePathElementArray& other_value);
void copy_template(const RelativePathElementArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
RelativePathElementArray_template();
RelativePathElementArray_template(template_sel other_value);
RelativePathElementArray_template(null_type other_value);
RelativePathElementArray_template(const RelativePathElementArray& other_value);
RelativePathElementArray_template(const OPTIONAL<RelativePathElementArray>& other_value);
RelativePathElementArray_template(const RelativePathElementArray_template& other_value);
~RelativePathElementArray_template();

void clean_up();
RelativePathElementArray_template& operator=(template_sel other_value);
RelativePathElementArray_template& operator=(null_type other_value);
RelativePathElementArray_template& operator=(const RelativePathElementArray& other_value);
RelativePathElementArray_template& operator=(const OPTIONAL<RelativePathElementArray>& other_value);
RelativePathElementArray_template& operator=(const RelativePathElementArray_template& other_value);

RelativePathElement_template& operator[](int index_value);
RelativePathElement_template& operator[](const INTEGER& index_value);
const RelativePathElement_template& operator[](int index_value) const;
const RelativePathElement_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const RelativePathElementArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
RelativePathElementArray valueof() const;
RelativePathElementArray substr(int index, int returncount) const;

RelativePathElementArray replace(int index, int len, const RelativePathElementArray_template& repl) const;

RelativePathElementArray replace(int index, int len, const RelativePathElementArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
RelativePathElementArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const RelativePathElementArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class RelativePathElement : public Base_Type {
  NodeId field_referenceTypeId;
  INTEGER field_isInverse;
  INTEGER field_includeSubtypes;
  QualifiedName field_targetName;
public:
  RelativePathElement();
  RelativePathElement(const NodeId& par_referenceTypeId,
    const INTEGER& par_isInverse,
    const INTEGER& par_includeSubtypes,
    const QualifiedName& par_targetName);
  RelativePathElement(const RelativePathElement& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RelativePathElement& operator=(const RelativePathElement& other_value);
  boolean operator==(const RelativePathElement& other_value) const;
  inline boolean operator!=(const RelativePathElement& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& referenceTypeId()
    {return field_referenceTypeId;}
  inline const NodeId& referenceTypeId() const
    {return field_referenceTypeId;}
  inline INTEGER& isInverse()
    {return field_isInverse;}
  inline const INTEGER& isInverse() const
    {return field_isInverse;}
  inline INTEGER& includeSubtypes()
    {return field_includeSubtypes;}
  inline const INTEGER& includeSubtypes() const
    {return field_includeSubtypes;}
  inline QualifiedName& targetName()
    {return field_targetName;}
  inline const QualifiedName& targetName() const
    {return field_targetName;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RelativePathElement_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RelativePathElement_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RelativePathElement& other_value);
void copy_template(const RelativePathElement_template& other_value);

public:
RelativePathElement_template();
RelativePathElement_template(template_sel other_value);
RelativePathElement_template(const RelativePathElement& other_value);
RelativePathElement_template(const OPTIONAL<RelativePathElement>& other_value);
RelativePathElement_template(const RelativePathElement_template& other_value);
~RelativePathElement_template();
RelativePathElement_template& operator=(template_sel other_value);
RelativePathElement_template& operator=(const RelativePathElement& other_value);
RelativePathElement_template& operator=(const OPTIONAL<RelativePathElement>& other_value);
RelativePathElement_template& operator=(const RelativePathElement_template& other_value);
boolean match(const RelativePathElement& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RelativePathElement valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RelativePathElement_template& list_item(unsigned int list_index) const;
NodeId_template& referenceTypeId();
const NodeId_template& referenceTypeId() const;
INTEGER_template& isInverse();
const INTEGER_template& isInverse() const;
INTEGER_template& includeSubtypes();
const INTEGER_template& includeSubtypes() const;
QualifiedName_template& targetName();
const QualifiedName_template& targetName() const;
int size_of() const;
void log() const;
void log_match(const RelativePathElement& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfRelativePathElementArray : public Base_Type {
  INTEGER field_arrayLength;
  RelativePathElementArray field_arrayValues;
public:
  ListOfRelativePathElementArray();
  ListOfRelativePathElementArray(const INTEGER& par_arrayLength,
    const RelativePathElementArray& par_arrayValues);
  ListOfRelativePathElementArray(const ListOfRelativePathElementArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfRelativePathElementArray& operator=(const ListOfRelativePathElementArray& other_value);
  boolean operator==(const ListOfRelativePathElementArray& other_value) const;
  inline boolean operator!=(const ListOfRelativePathElementArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline RelativePathElementArray& arrayValues()
    {return field_arrayValues;}
  inline const RelativePathElementArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfRelativePathElementArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfRelativePathElementArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfRelativePathElementArray& other_value);
void copy_template(const ListOfRelativePathElementArray_template& other_value);

public:
ListOfRelativePathElementArray_template();
ListOfRelativePathElementArray_template(template_sel other_value);
ListOfRelativePathElementArray_template(const ListOfRelativePathElementArray& other_value);
ListOfRelativePathElementArray_template(const OPTIONAL<ListOfRelativePathElementArray>& other_value);
ListOfRelativePathElementArray_template(const ListOfRelativePathElementArray_template& other_value);
~ListOfRelativePathElementArray_template();
ListOfRelativePathElementArray_template& operator=(template_sel other_value);
ListOfRelativePathElementArray_template& operator=(const ListOfRelativePathElementArray& other_value);
ListOfRelativePathElementArray_template& operator=(const OPTIONAL<ListOfRelativePathElementArray>& other_value);
ListOfRelativePathElementArray_template& operator=(const ListOfRelativePathElementArray_template& other_value);
boolean match(const ListOfRelativePathElementArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfRelativePathElementArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfRelativePathElementArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
RelativePathElementArray_template& arrayValues();
const RelativePathElementArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfRelativePathElementArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RelativePath : public Base_Type {
  ListOfRelativePathElement field_elements;
public:
  RelativePath();
  RelativePath(const ListOfRelativePathElement& par_elements);
  RelativePath(const RelativePath& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RelativePath& operator=(const RelativePath& other_value);
  boolean operator==(const RelativePath& other_value) const;
  inline boolean operator!=(const RelativePath& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfRelativePathElement& elements()
    {return field_elements;}
  inline const ListOfRelativePathElement& elements() const
    {return field_elements;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RelativePath_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RelativePath_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RelativePath& other_value);
void copy_template(const RelativePath_template& other_value);

public:
RelativePath_template();
RelativePath_template(template_sel other_value);
RelativePath_template(const RelativePath& other_value);
RelativePath_template(const OPTIONAL<RelativePath>& other_value);
RelativePath_template(const RelativePath_template& other_value);
~RelativePath_template();
RelativePath_template& operator=(template_sel other_value);
RelativePath_template& operator=(const RelativePath& other_value);
RelativePath_template& operator=(const OPTIONAL<RelativePath>& other_value);
RelativePath_template& operator=(const RelativePath_template& other_value);
boolean match(const RelativePath& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RelativePath valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RelativePath_template& list_item(unsigned int list_index) const;
ListOfRelativePathElement_template& elements();
const ListOfRelativePathElement_template& elements() const;
int size_of() const;
void log() const;
void log_match(const RelativePath& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AttributeOperand : public Base_Type {
  NodeId field_nodeId;
  String field_alias;
  RelativePath field_browsePath;
  INTEGER field_attributeId;
  String field_indexRange;
public:
  AttributeOperand();
  AttributeOperand(const NodeId& par_nodeId,
    const String& par_alias,
    const RelativePath& par_browsePath,
    const INTEGER& par_attributeId,
    const String& par_indexRange);
  AttributeOperand(const AttributeOperand& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AttributeOperand& operator=(const AttributeOperand& other_value);
  boolean operator==(const AttributeOperand& other_value) const;
  inline boolean operator!=(const AttributeOperand& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline String& alias()
    {return field_alias;}
  inline const String& alias() const
    {return field_alias;}
  inline RelativePath& browsePath()
    {return field_browsePath;}
  inline const RelativePath& browsePath() const
    {return field_browsePath;}
  inline INTEGER& attributeId()
    {return field_attributeId;}
  inline const INTEGER& attributeId() const
    {return field_attributeId;}
  inline String& indexRange()
    {return field_indexRange;}
  inline const String& indexRange() const
    {return field_indexRange;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AttributeOperand_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AttributeOperand_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AttributeOperand& other_value);
void copy_template(const AttributeOperand_template& other_value);

public:
AttributeOperand_template();
AttributeOperand_template(template_sel other_value);
AttributeOperand_template(const AttributeOperand& other_value);
AttributeOperand_template(const OPTIONAL<AttributeOperand>& other_value);
AttributeOperand_template(const AttributeOperand_template& other_value);
~AttributeOperand_template();
AttributeOperand_template& operator=(template_sel other_value);
AttributeOperand_template& operator=(const AttributeOperand& other_value);
AttributeOperand_template& operator=(const OPTIONAL<AttributeOperand>& other_value);
AttributeOperand_template& operator=(const AttributeOperand_template& other_value);
boolean match(const AttributeOperand& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AttributeOperand valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AttributeOperand_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
String_template& alias();
const String_template& alias() const;
RelativePath_template& browsePath();
const RelativePath_template& browsePath() const;
INTEGER_template& attributeId();
const INTEGER_template& attributeId() const;
String_template& indexRange();
const String_template& indexRange() const;
int size_of() const;
void log() const;
void log_match(const AttributeOperand& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SimpleAttributeOperand : public Base_Type {
  NodeId field_typeId;
  ListOfQualifiedName field_browsePath;
  INTEGER field_attributeId;
  String field_indexRange;
public:
  SimpleAttributeOperand();
  SimpleAttributeOperand(const NodeId& par_typeId,
    const ListOfQualifiedName& par_browsePath,
    const INTEGER& par_attributeId,
    const String& par_indexRange);
  SimpleAttributeOperand(const SimpleAttributeOperand& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SimpleAttributeOperand& operator=(const SimpleAttributeOperand& other_value);
  boolean operator==(const SimpleAttributeOperand& other_value) const;
  inline boolean operator!=(const SimpleAttributeOperand& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& typeId()
    {return field_typeId;}
  inline const NodeId& typeId() const
    {return field_typeId;}
  inline ListOfQualifiedName& browsePath()
    {return field_browsePath;}
  inline const ListOfQualifiedName& browsePath() const
    {return field_browsePath;}
  inline INTEGER& attributeId()
    {return field_attributeId;}
  inline const INTEGER& attributeId() const
    {return field_attributeId;}
  inline String& indexRange()
    {return field_indexRange;}
  inline const String& indexRange() const
    {return field_indexRange;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SimpleAttributeOperand_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SimpleAttributeOperand_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SimpleAttributeOperand& other_value);
void copy_template(const SimpleAttributeOperand_template& other_value);

public:
SimpleAttributeOperand_template();
SimpleAttributeOperand_template(template_sel other_value);
SimpleAttributeOperand_template(const SimpleAttributeOperand& other_value);
SimpleAttributeOperand_template(const OPTIONAL<SimpleAttributeOperand>& other_value);
SimpleAttributeOperand_template(const SimpleAttributeOperand_template& other_value);
~SimpleAttributeOperand_template();
SimpleAttributeOperand_template& operator=(template_sel other_value);
SimpleAttributeOperand_template& operator=(const SimpleAttributeOperand& other_value);
SimpleAttributeOperand_template& operator=(const OPTIONAL<SimpleAttributeOperand>& other_value);
SimpleAttributeOperand_template& operator=(const SimpleAttributeOperand_template& other_value);
boolean match(const SimpleAttributeOperand& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SimpleAttributeOperand valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SimpleAttributeOperand_template& list_item(unsigned int list_index) const;
NodeId_template& typeId();
const NodeId_template& typeId() const;
ListOfQualifiedName_template& browsePath();
const ListOfQualifiedName_template& browsePath() const;
INTEGER_template& attributeId();
const INTEGER_template& attributeId() const;
String_template& indexRange();
const String_template& indexRange() const;
int size_of() const;
void log() const;
void log_match(const SimpleAttributeOperand& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DataChangeFilter : public Base_Type {
  DataChangeTrigger field_Trigger;
  INTEGER field_deadbandType;
  FLOAT field_deadbandValue;
public:
  DataChangeFilter();
  DataChangeFilter(const DataChangeTrigger& par_Trigger,
    const INTEGER& par_deadbandType,
    const FLOAT& par_deadbandValue);
  DataChangeFilter(const DataChangeFilter& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DataChangeFilter& operator=(const DataChangeFilter& other_value);
  boolean operator==(const DataChangeFilter& other_value) const;
  inline boolean operator!=(const DataChangeFilter& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline DataChangeTrigger& Trigger()
    {return field_Trigger;}
  inline const DataChangeTrigger& Trigger() const
    {return field_Trigger;}
  inline INTEGER& deadbandType()
    {return field_deadbandType;}
  inline const INTEGER& deadbandType() const
    {return field_deadbandType;}
  inline FLOAT& deadbandValue()
    {return field_deadbandValue;}
  inline const FLOAT& deadbandValue() const
    {return field_deadbandValue;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DataChangeFilter_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DataChangeFilter_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DataChangeFilter& other_value);
void copy_template(const DataChangeFilter_template& other_value);

public:
DataChangeFilter_template();
DataChangeFilter_template(template_sel other_value);
DataChangeFilter_template(const DataChangeFilter& other_value);
DataChangeFilter_template(const OPTIONAL<DataChangeFilter>& other_value);
DataChangeFilter_template(const DataChangeFilter_template& other_value);
~DataChangeFilter_template();
DataChangeFilter_template& operator=(template_sel other_value);
DataChangeFilter_template& operator=(const DataChangeFilter& other_value);
DataChangeFilter_template& operator=(const OPTIONAL<DataChangeFilter>& other_value);
DataChangeFilter_template& operator=(const DataChangeFilter_template& other_value);
boolean match(const DataChangeFilter& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DataChangeFilter valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DataChangeFilter_template& list_item(unsigned int list_index) const;
DataChangeTrigger_template& Trigger();
const DataChangeTrigger_template& Trigger() const;
INTEGER_template& deadbandType();
const INTEGER_template& deadbandType() const;
FLOAT_template& deadbandValue();
const FLOAT_template& deadbandValue() const;
int size_of() const;
void log() const;
void log_match(const DataChangeFilter& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfSimpleAttributeOperand : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfSimpleAttributeOperandArray *field_realArray;
};
void copy_value(const ListOfSimpleAttributeOperand& other_value);

public:
ListOfSimpleAttributeOperand();
ListOfSimpleAttributeOperand(const ListOfSimpleAttributeOperand& other_value);
~ListOfSimpleAttributeOperand();
ListOfSimpleAttributeOperand& operator=(const ListOfSimpleAttributeOperand& other_value);
boolean operator==(const ListOfSimpleAttributeOperand& other_value) const;
inline boolean operator!=(const ListOfSimpleAttributeOperand& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfSimpleAttributeOperandArray& realArray();
const ListOfSimpleAttributeOperandArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfSimpleAttributeOperand_template : public Base_Template {
union {
struct {
ListOfSimpleAttributeOperand::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfSimpleAttributeOperandArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfSimpleAttributeOperand_template *list_value;
} value_list;
};
void copy_value(const ListOfSimpleAttributeOperand& other_value);

void copy_template(const ListOfSimpleAttributeOperand_template& other_value);

public:
ListOfSimpleAttributeOperand_template();
ListOfSimpleAttributeOperand_template(template_sel other_value);
ListOfSimpleAttributeOperand_template(const ListOfSimpleAttributeOperand& other_value);
ListOfSimpleAttributeOperand_template(const OPTIONAL<ListOfSimpleAttributeOperand>& other_value);
ListOfSimpleAttributeOperand_template(const ListOfSimpleAttributeOperand_template& other_value);
~ListOfSimpleAttributeOperand_template();
void clean_up();
ListOfSimpleAttributeOperand_template& operator=(template_sel other_value);
ListOfSimpleAttributeOperand_template& operator=(const ListOfSimpleAttributeOperand& other_value);
ListOfSimpleAttributeOperand_template& operator=(const OPTIONAL<ListOfSimpleAttributeOperand>& other_value);
ListOfSimpleAttributeOperand_template& operator=(const ListOfSimpleAttributeOperand_template& other_value);
boolean match(const ListOfSimpleAttributeOperand& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfSimpleAttributeOperand valueof() const;
ListOfSimpleAttributeOperand_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfSimpleAttributeOperandArray_template& realArray();
const ListOfSimpleAttributeOperandArray_template& realArray() const;
boolean ischosen(ListOfSimpleAttributeOperand::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfSimpleAttributeOperand& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SimpleAttributeOperandArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
SimpleAttributeOperand **value_elements;
} *val_ptr;

static const SimpleAttributeOperand UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SimpleAttributeOperandArray& other_value);

public:
  typedef SimpleAttributeOperand of_type;
SimpleAttributeOperandArray();
SimpleAttributeOperandArray(null_type other_value);
SimpleAttributeOperandArray(const SimpleAttributeOperandArray& other_value);
~SimpleAttributeOperandArray();

void clean_up();
SimpleAttributeOperandArray& operator=(null_type other_value);
SimpleAttributeOperandArray& operator=(const SimpleAttributeOperandArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SimpleAttributeOperandArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SimpleAttributeOperandArray& other_value) const { return !(*this == other_value); }

SimpleAttributeOperand& operator[](int index_value);
SimpleAttributeOperand& operator[](const INTEGER& index_value);
const SimpleAttributeOperand& operator[](int index_value) const;
const SimpleAttributeOperand& operator[](const INTEGER& index_value) const;

SimpleAttributeOperandArray operator<<=(int rotate_count) const;
SimpleAttributeOperandArray operator<<=(const INTEGER& rotate_count) const;
SimpleAttributeOperandArray operator>>=(int rotate_count) const;
SimpleAttributeOperandArray operator>>=(const INTEGER& rotate_count) const;

SimpleAttributeOperandArray operator+(const SimpleAttributeOperandArray& other_value) const;

SimpleAttributeOperandArray substr(int index, int returncount) const;

SimpleAttributeOperandArray replace(int index, int len, const SimpleAttributeOperandArray& repl) const;

SimpleAttributeOperandArray replace(int index, int len, const SimpleAttributeOperandArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SimpleAttributeOperandArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
SimpleAttributeOperand_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SimpleAttributeOperandArray_template *list_value;
} value_list;
};
void copy_value(const SimpleAttributeOperandArray& other_value);
void copy_template(const SimpleAttributeOperandArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SimpleAttributeOperandArray_template();
SimpleAttributeOperandArray_template(template_sel other_value);
SimpleAttributeOperandArray_template(null_type other_value);
SimpleAttributeOperandArray_template(const SimpleAttributeOperandArray& other_value);
SimpleAttributeOperandArray_template(const OPTIONAL<SimpleAttributeOperandArray>& other_value);
SimpleAttributeOperandArray_template(const SimpleAttributeOperandArray_template& other_value);
~SimpleAttributeOperandArray_template();

void clean_up();
SimpleAttributeOperandArray_template& operator=(template_sel other_value);
SimpleAttributeOperandArray_template& operator=(null_type other_value);
SimpleAttributeOperandArray_template& operator=(const SimpleAttributeOperandArray& other_value);
SimpleAttributeOperandArray_template& operator=(const OPTIONAL<SimpleAttributeOperandArray>& other_value);
SimpleAttributeOperandArray_template& operator=(const SimpleAttributeOperandArray_template& other_value);

SimpleAttributeOperand_template& operator[](int index_value);
SimpleAttributeOperand_template& operator[](const INTEGER& index_value);
const SimpleAttributeOperand_template& operator[](int index_value) const;
const SimpleAttributeOperand_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SimpleAttributeOperandArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SimpleAttributeOperandArray valueof() const;
SimpleAttributeOperandArray substr(int index, int returncount) const;

SimpleAttributeOperandArray replace(int index, int len, const SimpleAttributeOperandArray_template& repl) const;

SimpleAttributeOperandArray replace(int index, int len, const SimpleAttributeOperandArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SimpleAttributeOperandArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SimpleAttributeOperandArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfSimpleAttributeOperandArray : public Base_Type {
  INTEGER field_arrayLength;
  SimpleAttributeOperandArray field_arrayValues;
public:
  ListOfSimpleAttributeOperandArray();
  ListOfSimpleAttributeOperandArray(const INTEGER& par_arrayLength,
    const SimpleAttributeOperandArray& par_arrayValues);
  ListOfSimpleAttributeOperandArray(const ListOfSimpleAttributeOperandArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfSimpleAttributeOperandArray& operator=(const ListOfSimpleAttributeOperandArray& other_value);
  boolean operator==(const ListOfSimpleAttributeOperandArray& other_value) const;
  inline boolean operator!=(const ListOfSimpleAttributeOperandArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline SimpleAttributeOperandArray& arrayValues()
    {return field_arrayValues;}
  inline const SimpleAttributeOperandArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfSimpleAttributeOperandArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfSimpleAttributeOperandArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfSimpleAttributeOperandArray& other_value);
void copy_template(const ListOfSimpleAttributeOperandArray_template& other_value);

public:
ListOfSimpleAttributeOperandArray_template();
ListOfSimpleAttributeOperandArray_template(template_sel other_value);
ListOfSimpleAttributeOperandArray_template(const ListOfSimpleAttributeOperandArray& other_value);
ListOfSimpleAttributeOperandArray_template(const OPTIONAL<ListOfSimpleAttributeOperandArray>& other_value);
ListOfSimpleAttributeOperandArray_template(const ListOfSimpleAttributeOperandArray_template& other_value);
~ListOfSimpleAttributeOperandArray_template();
ListOfSimpleAttributeOperandArray_template& operator=(template_sel other_value);
ListOfSimpleAttributeOperandArray_template& operator=(const ListOfSimpleAttributeOperandArray& other_value);
ListOfSimpleAttributeOperandArray_template& operator=(const OPTIONAL<ListOfSimpleAttributeOperandArray>& other_value);
ListOfSimpleAttributeOperandArray_template& operator=(const ListOfSimpleAttributeOperandArray_template& other_value);
boolean match(const ListOfSimpleAttributeOperandArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfSimpleAttributeOperandArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfSimpleAttributeOperandArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
SimpleAttributeOperandArray_template& arrayValues();
const SimpleAttributeOperandArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfSimpleAttributeOperandArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfContentFilterElement : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfContentFilterElementArray *field_realArray;
};
void copy_value(const ListOfContentFilterElement& other_value);

public:
ListOfContentFilterElement();
ListOfContentFilterElement(const ListOfContentFilterElement& other_value);
~ListOfContentFilterElement();
ListOfContentFilterElement& operator=(const ListOfContentFilterElement& other_value);
boolean operator==(const ListOfContentFilterElement& other_value) const;
inline boolean operator!=(const ListOfContentFilterElement& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfContentFilterElementArray& realArray();
const ListOfContentFilterElementArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfContentFilterElement_template : public Base_Template {
union {
struct {
ListOfContentFilterElement::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfContentFilterElementArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfContentFilterElement_template *list_value;
} value_list;
};
void copy_value(const ListOfContentFilterElement& other_value);

void copy_template(const ListOfContentFilterElement_template& other_value);

public:
ListOfContentFilterElement_template();
ListOfContentFilterElement_template(template_sel other_value);
ListOfContentFilterElement_template(const ListOfContentFilterElement& other_value);
ListOfContentFilterElement_template(const OPTIONAL<ListOfContentFilterElement>& other_value);
ListOfContentFilterElement_template(const ListOfContentFilterElement_template& other_value);
~ListOfContentFilterElement_template();
void clean_up();
ListOfContentFilterElement_template& operator=(template_sel other_value);
ListOfContentFilterElement_template& operator=(const ListOfContentFilterElement& other_value);
ListOfContentFilterElement_template& operator=(const OPTIONAL<ListOfContentFilterElement>& other_value);
ListOfContentFilterElement_template& operator=(const ListOfContentFilterElement_template& other_value);
boolean match(const ListOfContentFilterElement& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfContentFilterElement valueof() const;
ListOfContentFilterElement_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfContentFilterElementArray_template& realArray();
const ListOfContentFilterElementArray_template& realArray() const;
boolean ischosen(ListOfContentFilterElement::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfContentFilterElement& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ContentFilterElementArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ContentFilterElement **value_elements;
} *val_ptr;

static const ContentFilterElement UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ContentFilterElementArray& other_value);

public:
  typedef ContentFilterElement of_type;
ContentFilterElementArray();
ContentFilterElementArray(null_type other_value);
ContentFilterElementArray(const ContentFilterElementArray& other_value);
~ContentFilterElementArray();

void clean_up();
ContentFilterElementArray& operator=(null_type other_value);
ContentFilterElementArray& operator=(const ContentFilterElementArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ContentFilterElementArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ContentFilterElementArray& other_value) const { return !(*this == other_value); }

ContentFilterElement& operator[](int index_value);
ContentFilterElement& operator[](const INTEGER& index_value);
const ContentFilterElement& operator[](int index_value) const;
const ContentFilterElement& operator[](const INTEGER& index_value) const;

ContentFilterElementArray operator<<=(int rotate_count) const;
ContentFilterElementArray operator<<=(const INTEGER& rotate_count) const;
ContentFilterElementArray operator>>=(int rotate_count) const;
ContentFilterElementArray operator>>=(const INTEGER& rotate_count) const;

ContentFilterElementArray operator+(const ContentFilterElementArray& other_value) const;

ContentFilterElementArray substr(int index, int returncount) const;

ContentFilterElementArray replace(int index, int len, const ContentFilterElementArray& repl) const;

ContentFilterElementArray replace(int index, int len, const ContentFilterElementArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ContentFilterElementArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ContentFilterElement_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ContentFilterElementArray_template *list_value;
} value_list;
};
void copy_value(const ContentFilterElementArray& other_value);
void copy_template(const ContentFilterElementArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ContentFilterElementArray_template();
ContentFilterElementArray_template(template_sel other_value);
ContentFilterElementArray_template(null_type other_value);
ContentFilterElementArray_template(const ContentFilterElementArray& other_value);
ContentFilterElementArray_template(const OPTIONAL<ContentFilterElementArray>& other_value);
ContentFilterElementArray_template(const ContentFilterElementArray_template& other_value);
~ContentFilterElementArray_template();

void clean_up();
ContentFilterElementArray_template& operator=(template_sel other_value);
ContentFilterElementArray_template& operator=(null_type other_value);
ContentFilterElementArray_template& operator=(const ContentFilterElementArray& other_value);
ContentFilterElementArray_template& operator=(const OPTIONAL<ContentFilterElementArray>& other_value);
ContentFilterElementArray_template& operator=(const ContentFilterElementArray_template& other_value);

ContentFilterElement_template& operator[](int index_value);
ContentFilterElement_template& operator[](const INTEGER& index_value);
const ContentFilterElement_template& operator[](int index_value) const;
const ContentFilterElement_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ContentFilterElementArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ContentFilterElementArray valueof() const;
ContentFilterElementArray substr(int index, int returncount) const;

ContentFilterElementArray replace(int index, int len, const ContentFilterElementArray_template& repl) const;

ContentFilterElementArray replace(int index, int len, const ContentFilterElementArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ContentFilterElementArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ContentFilterElementArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfExtensibleParameter : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfExtensibleParameterArray *field_realArray;
};
void copy_value(const ListOfExtensibleParameter& other_value);

public:
ListOfExtensibleParameter();
ListOfExtensibleParameter(const ListOfExtensibleParameter& other_value);
~ListOfExtensibleParameter();
ListOfExtensibleParameter& operator=(const ListOfExtensibleParameter& other_value);
boolean operator==(const ListOfExtensibleParameter& other_value) const;
inline boolean operator!=(const ListOfExtensibleParameter& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfExtensibleParameterArray& realArray();
const ListOfExtensibleParameterArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfExtensibleParameter_template : public Base_Template {
union {
struct {
ListOfExtensibleParameter::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfExtensibleParameterArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfExtensibleParameter_template *list_value;
} value_list;
};
void copy_value(const ListOfExtensibleParameter& other_value);

void copy_template(const ListOfExtensibleParameter_template& other_value);

public:
ListOfExtensibleParameter_template();
ListOfExtensibleParameter_template(template_sel other_value);
ListOfExtensibleParameter_template(const ListOfExtensibleParameter& other_value);
ListOfExtensibleParameter_template(const OPTIONAL<ListOfExtensibleParameter>& other_value);
ListOfExtensibleParameter_template(const ListOfExtensibleParameter_template& other_value);
~ListOfExtensibleParameter_template();
void clean_up();
ListOfExtensibleParameter_template& operator=(template_sel other_value);
ListOfExtensibleParameter_template& operator=(const ListOfExtensibleParameter& other_value);
ListOfExtensibleParameter_template& operator=(const OPTIONAL<ListOfExtensibleParameter>& other_value);
ListOfExtensibleParameter_template& operator=(const ListOfExtensibleParameter_template& other_value);
boolean match(const ListOfExtensibleParameter& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfExtensibleParameter valueof() const;
ListOfExtensibleParameter_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfExtensibleParameterArray_template& realArray();
const ListOfExtensibleParameterArray_template& realArray() const;
boolean ischosen(ListOfExtensibleParameter::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfExtensibleParameter& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ExtensibleParameterArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ExtensibleParameter **value_elements;
} *val_ptr;

static const ExtensibleParameter UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ExtensibleParameterArray& other_value);

public:
  typedef ExtensibleParameter of_type;
ExtensibleParameterArray();
ExtensibleParameterArray(null_type other_value);
ExtensibleParameterArray(const ExtensibleParameterArray& other_value);
~ExtensibleParameterArray();

void clean_up();
ExtensibleParameterArray& operator=(null_type other_value);
ExtensibleParameterArray& operator=(const ExtensibleParameterArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ExtensibleParameterArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ExtensibleParameterArray& other_value) const { return !(*this == other_value); }

ExtensibleParameter& operator[](int index_value);
ExtensibleParameter& operator[](const INTEGER& index_value);
const ExtensibleParameter& operator[](int index_value) const;
const ExtensibleParameter& operator[](const INTEGER& index_value) const;

ExtensibleParameterArray operator<<=(int rotate_count) const;
ExtensibleParameterArray operator<<=(const INTEGER& rotate_count) const;
ExtensibleParameterArray operator>>=(int rotate_count) const;
ExtensibleParameterArray operator>>=(const INTEGER& rotate_count) const;

ExtensibleParameterArray operator+(const ExtensibleParameterArray& other_value) const;

ExtensibleParameterArray substr(int index, int returncount) const;

ExtensibleParameterArray replace(int index, int len, const ExtensibleParameterArray& repl) const;

ExtensibleParameterArray replace(int index, int len, const ExtensibleParameterArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ExtensibleParameterArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ExtensibleParameter_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ExtensibleParameterArray_template *list_value;
} value_list;
};
void copy_value(const ExtensibleParameterArray& other_value);
void copy_template(const ExtensibleParameterArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ExtensibleParameterArray_template();
ExtensibleParameterArray_template(template_sel other_value);
ExtensibleParameterArray_template(null_type other_value);
ExtensibleParameterArray_template(const ExtensibleParameterArray& other_value);
ExtensibleParameterArray_template(const OPTIONAL<ExtensibleParameterArray>& other_value);
ExtensibleParameterArray_template(const ExtensibleParameterArray_template& other_value);
~ExtensibleParameterArray_template();

void clean_up();
ExtensibleParameterArray_template& operator=(template_sel other_value);
ExtensibleParameterArray_template& operator=(null_type other_value);
ExtensibleParameterArray_template& operator=(const ExtensibleParameterArray& other_value);
ExtensibleParameterArray_template& operator=(const OPTIONAL<ExtensibleParameterArray>& other_value);
ExtensibleParameterArray_template& operator=(const ExtensibleParameterArray_template& other_value);

ExtensibleParameter_template& operator[](int index_value);
ExtensibleParameter_template& operator[](const INTEGER& index_value);
const ExtensibleParameter_template& operator[](int index_value) const;
const ExtensibleParameter_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ExtensibleParameterArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ExtensibleParameterArray valueof() const;
ExtensibleParameterArray substr(int index, int returncount) const;

ExtensibleParameterArray replace(int index, int len, const ExtensibleParameterArray_template& repl) const;

ExtensibleParameterArray replace(int index, int len, const ExtensibleParameterArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ExtensibleParameterArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ExtensibleParameterArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfExtensibleParameterArray : public Base_Type {
  INTEGER field_arrayLength;
  ExtensibleParameterArray field_arrayValues;
public:
  ListOfExtensibleParameterArray();
  ListOfExtensibleParameterArray(const INTEGER& par_arrayLength,
    const ExtensibleParameterArray& par_arrayValues);
  ListOfExtensibleParameterArray(const ListOfExtensibleParameterArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfExtensibleParameterArray& operator=(const ListOfExtensibleParameterArray& other_value);
  boolean operator==(const ListOfExtensibleParameterArray& other_value) const;
  inline boolean operator!=(const ListOfExtensibleParameterArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ExtensibleParameterArray& arrayValues()
    {return field_arrayValues;}
  inline const ExtensibleParameterArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfExtensibleParameterArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfExtensibleParameterArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfExtensibleParameterArray& other_value);
void copy_template(const ListOfExtensibleParameterArray_template& other_value);

public:
ListOfExtensibleParameterArray_template();
ListOfExtensibleParameterArray_template(template_sel other_value);
ListOfExtensibleParameterArray_template(const ListOfExtensibleParameterArray& other_value);
ListOfExtensibleParameterArray_template(const OPTIONAL<ListOfExtensibleParameterArray>& other_value);
ListOfExtensibleParameterArray_template(const ListOfExtensibleParameterArray_template& other_value);
~ListOfExtensibleParameterArray_template();
ListOfExtensibleParameterArray_template& operator=(template_sel other_value);
ListOfExtensibleParameterArray_template& operator=(const ListOfExtensibleParameterArray& other_value);
ListOfExtensibleParameterArray_template& operator=(const OPTIONAL<ListOfExtensibleParameterArray>& other_value);
ListOfExtensibleParameterArray_template& operator=(const ListOfExtensibleParameterArray_template& other_value);
boolean match(const ListOfExtensibleParameterArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfExtensibleParameterArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfExtensibleParameterArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ExtensibleParameterArray_template& arrayValues();
const ExtensibleParameterArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfExtensibleParameterArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ContentFilterElement : public Base_Type {
  FilterOperator field_filterOperator;
  ListOfExtensibleParameter field_filterOperands;
public:
  ContentFilterElement();
  ContentFilterElement(const FilterOperator& par_filterOperator,
    const ListOfExtensibleParameter& par_filterOperands);
  ContentFilterElement(const ContentFilterElement& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ContentFilterElement& operator=(const ContentFilterElement& other_value);
  boolean operator==(const ContentFilterElement& other_value) const;
  inline boolean operator!=(const ContentFilterElement& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline FilterOperator& filterOperator()
    {return field_filterOperator;}
  inline const FilterOperator& filterOperator() const
    {return field_filterOperator;}
  inline ListOfExtensibleParameter& filterOperands()
    {return field_filterOperands;}
  inline const ListOfExtensibleParameter& filterOperands() const
    {return field_filterOperands;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ContentFilterElement_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ContentFilterElement_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ContentFilterElement& other_value);
void copy_template(const ContentFilterElement_template& other_value);

public:
ContentFilterElement_template();
ContentFilterElement_template(template_sel other_value);
ContentFilterElement_template(const ContentFilterElement& other_value);
ContentFilterElement_template(const OPTIONAL<ContentFilterElement>& other_value);
ContentFilterElement_template(const ContentFilterElement_template& other_value);
~ContentFilterElement_template();
ContentFilterElement_template& operator=(template_sel other_value);
ContentFilterElement_template& operator=(const ContentFilterElement& other_value);
ContentFilterElement_template& operator=(const OPTIONAL<ContentFilterElement>& other_value);
ContentFilterElement_template& operator=(const ContentFilterElement_template& other_value);
boolean match(const ContentFilterElement& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ContentFilterElement valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ContentFilterElement_template& list_item(unsigned int list_index) const;
FilterOperator_template& filterOperator();
const FilterOperator_template& filterOperator() const;
ListOfExtensibleParameter_template& filterOperands();
const ListOfExtensibleParameter_template& filterOperands() const;
int size_of() const;
void log() const;
void log_match(const ContentFilterElement& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfContentFilterElementArray : public Base_Type {
  INTEGER field_arrayLength;
  ContentFilterElementArray field_arrayValues;
public:
  ListOfContentFilterElementArray();
  ListOfContentFilterElementArray(const INTEGER& par_arrayLength,
    const ContentFilterElementArray& par_arrayValues);
  ListOfContentFilterElementArray(const ListOfContentFilterElementArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfContentFilterElementArray& operator=(const ListOfContentFilterElementArray& other_value);
  boolean operator==(const ListOfContentFilterElementArray& other_value) const;
  inline boolean operator!=(const ListOfContentFilterElementArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ContentFilterElementArray& arrayValues()
    {return field_arrayValues;}
  inline const ContentFilterElementArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfContentFilterElementArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfContentFilterElementArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfContentFilterElementArray& other_value);
void copy_template(const ListOfContentFilterElementArray_template& other_value);

public:
ListOfContentFilterElementArray_template();
ListOfContentFilterElementArray_template(template_sel other_value);
ListOfContentFilterElementArray_template(const ListOfContentFilterElementArray& other_value);
ListOfContentFilterElementArray_template(const OPTIONAL<ListOfContentFilterElementArray>& other_value);
ListOfContentFilterElementArray_template(const ListOfContentFilterElementArray_template& other_value);
~ListOfContentFilterElementArray_template();
ListOfContentFilterElementArray_template& operator=(template_sel other_value);
ListOfContentFilterElementArray_template& operator=(const ListOfContentFilterElementArray& other_value);
ListOfContentFilterElementArray_template& operator=(const OPTIONAL<ListOfContentFilterElementArray>& other_value);
ListOfContentFilterElementArray_template& operator=(const ListOfContentFilterElementArray_template& other_value);
boolean match(const ListOfContentFilterElementArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfContentFilterElementArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfContentFilterElementArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ContentFilterElementArray_template& arrayValues();
const ContentFilterElementArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfContentFilterElementArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ContentFilter : public Base_Type {
  ListOfContentFilterElement field_elements;
public:
  ContentFilter();
  ContentFilter(const ListOfContentFilterElement& par_elements);
  ContentFilter(const ContentFilter& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ContentFilter& operator=(const ContentFilter& other_value);
  boolean operator==(const ContentFilter& other_value) const;
  inline boolean operator!=(const ContentFilter& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfContentFilterElement& elements()
    {return field_elements;}
  inline const ListOfContentFilterElement& elements() const
    {return field_elements;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ContentFilter_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ContentFilter_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ContentFilter& other_value);
void copy_template(const ContentFilter_template& other_value);

public:
ContentFilter_template();
ContentFilter_template(template_sel other_value);
ContentFilter_template(const ContentFilter& other_value);
ContentFilter_template(const OPTIONAL<ContentFilter>& other_value);
ContentFilter_template(const ContentFilter_template& other_value);
~ContentFilter_template();
ContentFilter_template& operator=(template_sel other_value);
ContentFilter_template& operator=(const ContentFilter& other_value);
ContentFilter_template& operator=(const OPTIONAL<ContentFilter>& other_value);
ContentFilter_template& operator=(const ContentFilter_template& other_value);
boolean match(const ContentFilter& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ContentFilter valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ContentFilter_template& list_item(unsigned int list_index) const;
ListOfContentFilterElement_template& elements();
const ListOfContentFilterElement_template& elements() const;
int size_of() const;
void log() const;
void log_match(const ContentFilter& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EventFilter : public Base_Type {
  ListOfSimpleAttributeOperand field_selectClauses;
  ContentFilter field_whereClause;
public:
  EventFilter();
  EventFilter(const ListOfSimpleAttributeOperand& par_selectClauses,
    const ContentFilter& par_whereClause);
  EventFilter(const EventFilter& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EventFilter& operator=(const EventFilter& other_value);
  boolean operator==(const EventFilter& other_value) const;
  inline boolean operator!=(const EventFilter& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfSimpleAttributeOperand& selectClauses()
    {return field_selectClauses;}
  inline const ListOfSimpleAttributeOperand& selectClauses() const
    {return field_selectClauses;}
  inline ContentFilter& whereClause()
    {return field_whereClause;}
  inline const ContentFilter& whereClause() const
    {return field_whereClause;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EventFilter_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EventFilter_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EventFilter& other_value);
void copy_template(const EventFilter_template& other_value);

public:
EventFilter_template();
EventFilter_template(template_sel other_value);
EventFilter_template(const EventFilter& other_value);
EventFilter_template(const OPTIONAL<EventFilter>& other_value);
EventFilter_template(const EventFilter_template& other_value);
~EventFilter_template();
EventFilter_template& operator=(template_sel other_value);
EventFilter_template& operator=(const EventFilter& other_value);
EventFilter_template& operator=(const OPTIONAL<EventFilter>& other_value);
EventFilter_template& operator=(const EventFilter_template& other_value);
boolean match(const EventFilter& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EventFilter valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EventFilter_template& list_item(unsigned int list_index) const;
ListOfSimpleAttributeOperand_template& selectClauses();
const ListOfSimpleAttributeOperand_template& selectClauses() const;
ContentFilter_template& whereClause();
const ContentFilter_template& whereClause() const;
int size_of() const;
void log() const;
void log_match(const EventFilter& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AggregateConfiguration : public Base_Type {
  INTEGER field_TreatUncertainAsBad;
  INTEGER field_useSeverCapabilitiesDefaults;
  INTEGER field_PercentDataBad;
  INTEGER field_PercentDataGood;
  INTEGER field_UseSlopedExtrapolation;
public:
  AggregateConfiguration();
  AggregateConfiguration(const INTEGER& par_TreatUncertainAsBad,
    const INTEGER& par_useSeverCapabilitiesDefaults,
    const INTEGER& par_PercentDataBad,
    const INTEGER& par_PercentDataGood,
    const INTEGER& par_UseSlopedExtrapolation);
  AggregateConfiguration(const AggregateConfiguration& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AggregateConfiguration& operator=(const AggregateConfiguration& other_value);
  boolean operator==(const AggregateConfiguration& other_value) const;
  inline boolean operator!=(const AggregateConfiguration& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& TreatUncertainAsBad()
    {return field_TreatUncertainAsBad;}
  inline const INTEGER& TreatUncertainAsBad() const
    {return field_TreatUncertainAsBad;}
  inline INTEGER& useSeverCapabilitiesDefaults()
    {return field_useSeverCapabilitiesDefaults;}
  inline const INTEGER& useSeverCapabilitiesDefaults() const
    {return field_useSeverCapabilitiesDefaults;}
  inline INTEGER& PercentDataBad()
    {return field_PercentDataBad;}
  inline const INTEGER& PercentDataBad() const
    {return field_PercentDataBad;}
  inline INTEGER& PercentDataGood()
    {return field_PercentDataGood;}
  inline const INTEGER& PercentDataGood() const
    {return field_PercentDataGood;}
  inline INTEGER& UseSlopedExtrapolation()
    {return field_UseSlopedExtrapolation;}
  inline const INTEGER& UseSlopedExtrapolation() const
    {return field_UseSlopedExtrapolation;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AggregateConfiguration_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AggregateConfiguration_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AggregateConfiguration& other_value);
void copy_template(const AggregateConfiguration_template& other_value);

public:
AggregateConfiguration_template();
AggregateConfiguration_template(template_sel other_value);
AggregateConfiguration_template(const AggregateConfiguration& other_value);
AggregateConfiguration_template(const OPTIONAL<AggregateConfiguration>& other_value);
AggregateConfiguration_template(const AggregateConfiguration_template& other_value);
~AggregateConfiguration_template();
AggregateConfiguration_template& operator=(template_sel other_value);
AggregateConfiguration_template& operator=(const AggregateConfiguration& other_value);
AggregateConfiguration_template& operator=(const OPTIONAL<AggregateConfiguration>& other_value);
AggregateConfiguration_template& operator=(const AggregateConfiguration_template& other_value);
boolean match(const AggregateConfiguration& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AggregateConfiguration valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AggregateConfiguration_template& list_item(unsigned int list_index) const;
INTEGER_template& TreatUncertainAsBad();
const INTEGER_template& TreatUncertainAsBad() const;
INTEGER_template& useSeverCapabilitiesDefaults();
const INTEGER_template& useSeverCapabilitiesDefaults() const;
INTEGER_template& PercentDataBad();
const INTEGER_template& PercentDataBad() const;
INTEGER_template& PercentDataGood();
const INTEGER_template& PercentDataGood() const;
INTEGER_template& UseSlopedExtrapolation();
const INTEGER_template& UseSlopedExtrapolation() const;
int size_of() const;
void log() const;
void log_match(const AggregateConfiguration& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AggregateFilter : public Base_Type {
  INTEGER field_startTime;
  NodeId field_aggregateType;
  FLOAT field_processingInterval;
  AggregateConfiguration field_aggregateConfiguration;
  INTEGER field_useServerCapabilitiesDefaults;
  INTEGER field_treatUncertainAsBad;
  INTEGER field_percentDataBad;
  INTEGER field_percentDataGood;
  INTEGER field_useSlopedExtrapolation;
public:
  AggregateFilter();
  AggregateFilter(const INTEGER& par_startTime,
    const NodeId& par_aggregateType,
    const FLOAT& par_processingInterval,
    const AggregateConfiguration& par_aggregateConfiguration,
    const INTEGER& par_useServerCapabilitiesDefaults,
    const INTEGER& par_treatUncertainAsBad,
    const INTEGER& par_percentDataBad,
    const INTEGER& par_percentDataGood,
    const INTEGER& par_useSlopedExtrapolation);
  AggregateFilter(const AggregateFilter& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AggregateFilter& operator=(const AggregateFilter& other_value);
  boolean operator==(const AggregateFilter& other_value) const;
  inline boolean operator!=(const AggregateFilter& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& startTime()
    {return field_startTime;}
  inline const INTEGER& startTime() const
    {return field_startTime;}
  inline NodeId& aggregateType()
    {return field_aggregateType;}
  inline const NodeId& aggregateType() const
    {return field_aggregateType;}
  inline FLOAT& processingInterval()
    {return field_processingInterval;}
  inline const FLOAT& processingInterval() const
    {return field_processingInterval;}
  inline AggregateConfiguration& aggregateConfiguration()
    {return field_aggregateConfiguration;}
  inline const AggregateConfiguration& aggregateConfiguration() const
    {return field_aggregateConfiguration;}
  inline INTEGER& useServerCapabilitiesDefaults()
    {return field_useServerCapabilitiesDefaults;}
  inline const INTEGER& useServerCapabilitiesDefaults() const
    {return field_useServerCapabilitiesDefaults;}
  inline INTEGER& treatUncertainAsBad()
    {return field_treatUncertainAsBad;}
  inline const INTEGER& treatUncertainAsBad() const
    {return field_treatUncertainAsBad;}
  inline INTEGER& percentDataBad()
    {return field_percentDataBad;}
  inline const INTEGER& percentDataBad() const
    {return field_percentDataBad;}
  inline INTEGER& percentDataGood()
    {return field_percentDataGood;}
  inline const INTEGER& percentDataGood() const
    {return field_percentDataGood;}
  inline INTEGER& useSlopedExtrapolation()
    {return field_useSlopedExtrapolation;}
  inline const INTEGER& useSlopedExtrapolation() const
    {return field_useSlopedExtrapolation;}
  inline int size_of() const
    {return 9;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AggregateFilter_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AggregateFilter_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AggregateFilter& other_value);
void copy_template(const AggregateFilter_template& other_value);

public:
AggregateFilter_template();
AggregateFilter_template(template_sel other_value);
AggregateFilter_template(const AggregateFilter& other_value);
AggregateFilter_template(const OPTIONAL<AggregateFilter>& other_value);
AggregateFilter_template(const AggregateFilter_template& other_value);
~AggregateFilter_template();
AggregateFilter_template& operator=(template_sel other_value);
AggregateFilter_template& operator=(const AggregateFilter& other_value);
AggregateFilter_template& operator=(const OPTIONAL<AggregateFilter>& other_value);
AggregateFilter_template& operator=(const AggregateFilter_template& other_value);
boolean match(const AggregateFilter& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AggregateFilter valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AggregateFilter_template& list_item(unsigned int list_index) const;
INTEGER_template& startTime();
const INTEGER_template& startTime() const;
NodeId_template& aggregateType();
const NodeId_template& aggregateType() const;
FLOAT_template& processingInterval();
const FLOAT_template& processingInterval() const;
AggregateConfiguration_template& aggregateConfiguration();
const AggregateConfiguration_template& aggregateConfiguration() const;
INTEGER_template& useServerCapabilitiesDefaults();
const INTEGER_template& useServerCapabilitiesDefaults() const;
INTEGER_template& treatUncertainAsBad();
const INTEGER_template& treatUncertainAsBad() const;
INTEGER_template& percentDataBad();
const INTEGER_template& percentDataBad() const;
INTEGER_template& percentDataGood();
const INTEGER_template& percentDataGood() const;
INTEGER_template& useSlopedExtrapolation();
const INTEGER_template& useSlopedExtrapolation() const;
int size_of() const;
void log() const;
void log_match(const AggregateFilter& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfContentFilterElementResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfContentFilterElementResultArray *field_realArray;
};
void copy_value(const ListOfContentFilterElementResult& other_value);

public:
ListOfContentFilterElementResult();
ListOfContentFilterElementResult(const ListOfContentFilterElementResult& other_value);
~ListOfContentFilterElementResult();
ListOfContentFilterElementResult& operator=(const ListOfContentFilterElementResult& other_value);
boolean operator==(const ListOfContentFilterElementResult& other_value) const;
inline boolean operator!=(const ListOfContentFilterElementResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfContentFilterElementResultArray& realArray();
const ListOfContentFilterElementResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfContentFilterElementResult_template : public Base_Template {
union {
struct {
ListOfContentFilterElementResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfContentFilterElementResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfContentFilterElementResult_template *list_value;
} value_list;
};
void copy_value(const ListOfContentFilterElementResult& other_value);

void copy_template(const ListOfContentFilterElementResult_template& other_value);

public:
ListOfContentFilterElementResult_template();
ListOfContentFilterElementResult_template(template_sel other_value);
ListOfContentFilterElementResult_template(const ListOfContentFilterElementResult& other_value);
ListOfContentFilterElementResult_template(const OPTIONAL<ListOfContentFilterElementResult>& other_value);
ListOfContentFilterElementResult_template(const ListOfContentFilterElementResult_template& other_value);
~ListOfContentFilterElementResult_template();
void clean_up();
ListOfContentFilterElementResult_template& operator=(template_sel other_value);
ListOfContentFilterElementResult_template& operator=(const ListOfContentFilterElementResult& other_value);
ListOfContentFilterElementResult_template& operator=(const OPTIONAL<ListOfContentFilterElementResult>& other_value);
ListOfContentFilterElementResult_template& operator=(const ListOfContentFilterElementResult_template& other_value);
boolean match(const ListOfContentFilterElementResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfContentFilterElementResult valueof() const;
ListOfContentFilterElementResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfContentFilterElementResultArray_template& realArray();
const ListOfContentFilterElementResultArray_template& realArray() const;
boolean ischosen(ListOfContentFilterElementResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfContentFilterElementResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ContentFilterElementResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ContentFilterElementResult **value_elements;
} *val_ptr;

static const ContentFilterElementResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ContentFilterElementResultArray& other_value);

public:
  typedef ContentFilterElementResult of_type;
ContentFilterElementResultArray();
ContentFilterElementResultArray(null_type other_value);
ContentFilterElementResultArray(const ContentFilterElementResultArray& other_value);
~ContentFilterElementResultArray();

void clean_up();
ContentFilterElementResultArray& operator=(null_type other_value);
ContentFilterElementResultArray& operator=(const ContentFilterElementResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ContentFilterElementResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ContentFilterElementResultArray& other_value) const { return !(*this == other_value); }

ContentFilterElementResult& operator[](int index_value);
ContentFilterElementResult& operator[](const INTEGER& index_value);
const ContentFilterElementResult& operator[](int index_value) const;
const ContentFilterElementResult& operator[](const INTEGER& index_value) const;

ContentFilterElementResultArray operator<<=(int rotate_count) const;
ContentFilterElementResultArray operator<<=(const INTEGER& rotate_count) const;
ContentFilterElementResultArray operator>>=(int rotate_count) const;
ContentFilterElementResultArray operator>>=(const INTEGER& rotate_count) const;

ContentFilterElementResultArray operator+(const ContentFilterElementResultArray& other_value) const;

ContentFilterElementResultArray substr(int index, int returncount) const;

ContentFilterElementResultArray replace(int index, int len, const ContentFilterElementResultArray& repl) const;

ContentFilterElementResultArray replace(int index, int len, const ContentFilterElementResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ContentFilterElementResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ContentFilterElementResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ContentFilterElementResultArray_template *list_value;
} value_list;
};
void copy_value(const ContentFilterElementResultArray& other_value);
void copy_template(const ContentFilterElementResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ContentFilterElementResultArray_template();
ContentFilterElementResultArray_template(template_sel other_value);
ContentFilterElementResultArray_template(null_type other_value);
ContentFilterElementResultArray_template(const ContentFilterElementResultArray& other_value);
ContentFilterElementResultArray_template(const OPTIONAL<ContentFilterElementResultArray>& other_value);
ContentFilterElementResultArray_template(const ContentFilterElementResultArray_template& other_value);
~ContentFilterElementResultArray_template();

void clean_up();
ContentFilterElementResultArray_template& operator=(template_sel other_value);
ContentFilterElementResultArray_template& operator=(null_type other_value);
ContentFilterElementResultArray_template& operator=(const ContentFilterElementResultArray& other_value);
ContentFilterElementResultArray_template& operator=(const OPTIONAL<ContentFilterElementResultArray>& other_value);
ContentFilterElementResultArray_template& operator=(const ContentFilterElementResultArray_template& other_value);

ContentFilterElementResult_template& operator[](int index_value);
ContentFilterElementResult_template& operator[](const INTEGER& index_value);
const ContentFilterElementResult_template& operator[](int index_value) const;
const ContentFilterElementResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ContentFilterElementResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ContentFilterElementResultArray valueof() const;
ContentFilterElementResultArray substr(int index, int returncount) const;

ContentFilterElementResultArray replace(int index, int len, const ContentFilterElementResultArray_template& repl) const;

ContentFilterElementResultArray replace(int index, int len, const ContentFilterElementResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ContentFilterElementResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ContentFilterElementResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ContentFilterElementResult : public Base_Type {
  INTEGER field_statusCode;
  ListOfStatusCode field_operandStatusCodes;
  ListOfDiagnosticInfo field_operandDiagnosticInfos;
public:
  ContentFilterElementResult();
  ContentFilterElementResult(const INTEGER& par_statusCode,
    const ListOfStatusCode& par_operandStatusCodes,
    const ListOfDiagnosticInfo& par_operandDiagnosticInfos);
  ContentFilterElementResult(const ContentFilterElementResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ContentFilterElementResult& operator=(const ContentFilterElementResult& other_value);
  boolean operator==(const ContentFilterElementResult& other_value) const;
  inline boolean operator!=(const ContentFilterElementResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline ListOfStatusCode& operandStatusCodes()
    {return field_operandStatusCodes;}
  inline const ListOfStatusCode& operandStatusCodes() const
    {return field_operandStatusCodes;}
  inline ListOfDiagnosticInfo& operandDiagnosticInfos()
    {return field_operandDiagnosticInfos;}
  inline const ListOfDiagnosticInfo& operandDiagnosticInfos() const
    {return field_operandDiagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ContentFilterElementResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ContentFilterElementResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ContentFilterElementResult& other_value);
void copy_template(const ContentFilterElementResult_template& other_value);

public:
ContentFilterElementResult_template();
ContentFilterElementResult_template(template_sel other_value);
ContentFilterElementResult_template(const ContentFilterElementResult& other_value);
ContentFilterElementResult_template(const OPTIONAL<ContentFilterElementResult>& other_value);
ContentFilterElementResult_template(const ContentFilterElementResult_template& other_value);
~ContentFilterElementResult_template();
ContentFilterElementResult_template& operator=(template_sel other_value);
ContentFilterElementResult_template& operator=(const ContentFilterElementResult& other_value);
ContentFilterElementResult_template& operator=(const OPTIONAL<ContentFilterElementResult>& other_value);
ContentFilterElementResult_template& operator=(const ContentFilterElementResult_template& other_value);
boolean match(const ContentFilterElementResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ContentFilterElementResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ContentFilterElementResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
ListOfStatusCode_template& operandStatusCodes();
const ListOfStatusCode_template& operandStatusCodes() const;
ListOfDiagnosticInfo_template& operandDiagnosticInfos();
const ListOfDiagnosticInfo_template& operandDiagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const ContentFilterElementResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfContentFilterElementResultArray : public Base_Type {
  INTEGER field_arrayLength;
  ContentFilterElementResultArray field_arrayValues;
public:
  ListOfContentFilterElementResultArray();
  ListOfContentFilterElementResultArray(const INTEGER& par_arrayLength,
    const ContentFilterElementResultArray& par_arrayValues);
  ListOfContentFilterElementResultArray(const ListOfContentFilterElementResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfContentFilterElementResultArray& operator=(const ListOfContentFilterElementResultArray& other_value);
  boolean operator==(const ListOfContentFilterElementResultArray& other_value) const;
  inline boolean operator!=(const ListOfContentFilterElementResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ContentFilterElementResultArray& arrayValues()
    {return field_arrayValues;}
  inline const ContentFilterElementResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfContentFilterElementResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfContentFilterElementResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfContentFilterElementResultArray& other_value);
void copy_template(const ListOfContentFilterElementResultArray_template& other_value);

public:
ListOfContentFilterElementResultArray_template();
ListOfContentFilterElementResultArray_template(template_sel other_value);
ListOfContentFilterElementResultArray_template(const ListOfContentFilterElementResultArray& other_value);
ListOfContentFilterElementResultArray_template(const OPTIONAL<ListOfContentFilterElementResultArray>& other_value);
ListOfContentFilterElementResultArray_template(const ListOfContentFilterElementResultArray_template& other_value);
~ListOfContentFilterElementResultArray_template();
ListOfContentFilterElementResultArray_template& operator=(template_sel other_value);
ListOfContentFilterElementResultArray_template& operator=(const ListOfContentFilterElementResultArray& other_value);
ListOfContentFilterElementResultArray_template& operator=(const OPTIONAL<ListOfContentFilterElementResultArray>& other_value);
ListOfContentFilterElementResultArray_template& operator=(const ListOfContentFilterElementResultArray_template& other_value);
boolean match(const ListOfContentFilterElementResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfContentFilterElementResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfContentFilterElementResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ContentFilterElementResultArray_template& arrayValues();
const ContentFilterElementResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfContentFilterElementResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ContentFilterResult : public Base_Type {
  ListOfContentFilterElementResult field_elementResults;
  ListOfDiagnosticInfo field_elementDiagnosticInfos;
public:
  ContentFilterResult();
  ContentFilterResult(const ListOfContentFilterElementResult& par_elementResults,
    const ListOfDiagnosticInfo& par_elementDiagnosticInfos);
  ContentFilterResult(const ContentFilterResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ContentFilterResult& operator=(const ContentFilterResult& other_value);
  boolean operator==(const ContentFilterResult& other_value) const;
  inline boolean operator!=(const ContentFilterResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfContentFilterElementResult& elementResults()
    {return field_elementResults;}
  inline const ListOfContentFilterElementResult& elementResults() const
    {return field_elementResults;}
  inline ListOfDiagnosticInfo& elementDiagnosticInfos()
    {return field_elementDiagnosticInfos;}
  inline const ListOfDiagnosticInfo& elementDiagnosticInfos() const
    {return field_elementDiagnosticInfos;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ContentFilterResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ContentFilterResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ContentFilterResult& other_value);
void copy_template(const ContentFilterResult_template& other_value);

public:
ContentFilterResult_template();
ContentFilterResult_template(template_sel other_value);
ContentFilterResult_template(const ContentFilterResult& other_value);
ContentFilterResult_template(const OPTIONAL<ContentFilterResult>& other_value);
ContentFilterResult_template(const ContentFilterResult_template& other_value);
~ContentFilterResult_template();
ContentFilterResult_template& operator=(template_sel other_value);
ContentFilterResult_template& operator=(const ContentFilterResult& other_value);
ContentFilterResult_template& operator=(const OPTIONAL<ContentFilterResult>& other_value);
ContentFilterResult_template& operator=(const ContentFilterResult_template& other_value);
boolean match(const ContentFilterResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ContentFilterResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ContentFilterResult_template& list_item(unsigned int list_index) const;
ListOfContentFilterElementResult_template& elementResults();
const ListOfContentFilterElementResult_template& elementResults() const;
ListOfDiagnosticInfo_template& elementDiagnosticInfos();
const ListOfDiagnosticInfo_template& elementDiagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const ContentFilterResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EventFilterResult : public Base_Type {
  ListOfStatusCode field_selectClauseResults;
  ListOfDiagnosticInfo field_selectClauseDiagnosticInfos;
  ContentFilterResult field_whereClauseResult;
public:
  EventFilterResult();
  EventFilterResult(const ListOfStatusCode& par_selectClauseResults,
    const ListOfDiagnosticInfo& par_selectClauseDiagnosticInfos,
    const ContentFilterResult& par_whereClauseResult);
  EventFilterResult(const EventFilterResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EventFilterResult& operator=(const EventFilterResult& other_value);
  boolean operator==(const EventFilterResult& other_value) const;
  inline boolean operator!=(const EventFilterResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfStatusCode& selectClauseResults()
    {return field_selectClauseResults;}
  inline const ListOfStatusCode& selectClauseResults() const
    {return field_selectClauseResults;}
  inline ListOfDiagnosticInfo& selectClauseDiagnosticInfos()
    {return field_selectClauseDiagnosticInfos;}
  inline const ListOfDiagnosticInfo& selectClauseDiagnosticInfos() const
    {return field_selectClauseDiagnosticInfos;}
  inline ContentFilterResult& whereClauseResult()
    {return field_whereClauseResult;}
  inline const ContentFilterResult& whereClauseResult() const
    {return field_whereClauseResult;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EventFilterResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EventFilterResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EventFilterResult& other_value);
void copy_template(const EventFilterResult_template& other_value);

public:
EventFilterResult_template();
EventFilterResult_template(template_sel other_value);
EventFilterResult_template(const EventFilterResult& other_value);
EventFilterResult_template(const OPTIONAL<EventFilterResult>& other_value);
EventFilterResult_template(const EventFilterResult_template& other_value);
~EventFilterResult_template();
EventFilterResult_template& operator=(template_sel other_value);
EventFilterResult_template& operator=(const EventFilterResult& other_value);
EventFilterResult_template& operator=(const OPTIONAL<EventFilterResult>& other_value);
EventFilterResult_template& operator=(const EventFilterResult_template& other_value);
boolean match(const EventFilterResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EventFilterResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EventFilterResult_template& list_item(unsigned int list_index) const;
ListOfStatusCode_template& selectClauseResults();
const ListOfStatusCode_template& selectClauseResults() const;
ListOfDiagnosticInfo_template& selectClauseDiagnosticInfos();
const ListOfDiagnosticInfo_template& selectClauseDiagnosticInfos() const;
ContentFilterResult_template& whereClauseResult();
const ContentFilterResult_template& whereClauseResult() const;
int size_of() const;
void log() const;
void log_match(const EventFilterResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AggregateFilterResult : public Base_Type {
  INTEGER field_revisedStartTime;
  FLOAT field_revisedProcessingInterval;
public:
  AggregateFilterResult();
  AggregateFilterResult(const INTEGER& par_revisedStartTime,
    const FLOAT& par_revisedProcessingInterval);
  AggregateFilterResult(const AggregateFilterResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AggregateFilterResult& operator=(const AggregateFilterResult& other_value);
  boolean operator==(const AggregateFilterResult& other_value) const;
  inline boolean operator!=(const AggregateFilterResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& revisedStartTime()
    {return field_revisedStartTime;}
  inline const INTEGER& revisedStartTime() const
    {return field_revisedStartTime;}
  inline FLOAT& revisedProcessingInterval()
    {return field_revisedProcessingInterval;}
  inline const FLOAT& revisedProcessingInterval() const
    {return field_revisedProcessingInterval;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AggregateFilterResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AggregateFilterResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AggregateFilterResult& other_value);
void copy_template(const AggregateFilterResult_template& other_value);

public:
AggregateFilterResult_template();
AggregateFilterResult_template(template_sel other_value);
AggregateFilterResult_template(const AggregateFilterResult& other_value);
AggregateFilterResult_template(const OPTIONAL<AggregateFilterResult>& other_value);
AggregateFilterResult_template(const AggregateFilterResult_template& other_value);
~AggregateFilterResult_template();
AggregateFilterResult_template& operator=(template_sel other_value);
AggregateFilterResult_template& operator=(const AggregateFilterResult& other_value);
AggregateFilterResult_template& operator=(const OPTIONAL<AggregateFilterResult>& other_value);
AggregateFilterResult_template& operator=(const AggregateFilterResult_template& other_value);
boolean match(const AggregateFilterResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AggregateFilterResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AggregateFilterResult_template& list_item(unsigned int list_index) const;
INTEGER_template& revisedStartTime();
const INTEGER_template& revisedStartTime() const;
FLOAT_template& revisedProcessingInterval();
const FLOAT_template& revisedProcessingInterval() const;
int size_of() const;
void log() const;
void log_match(const AggregateFilterResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ObjectAttributes : public Base_Type {
  INTEGER field_displayNameBit;
  INTEGER field_descriptionBit;
  INTEGER field_eventNotifierBit;
  INTEGER field_writeMaskBit;
  INTEGER field_userWriteMaskBit;
  ObjectAttributes_reserveBits field_reserveBits;
  OPTIONAL<LocalizedText> field_displayName;
  OPTIONAL<LocalizedText> field_description;
  OPTIONAL<INTEGER> field_eventNotifier;
  OPTIONAL<INTEGER> field_writeMask;
  OPTIONAL<INTEGER> field_userWriteMask;
public:
  ObjectAttributes();
  ObjectAttributes(const INTEGER& par_displayNameBit,
    const INTEGER& par_descriptionBit,
    const INTEGER& par_eventNotifierBit,
    const INTEGER& par_writeMaskBit,
    const INTEGER& par_userWriteMaskBit,
    const ObjectAttributes_reserveBits& par_reserveBits,
    const OPTIONAL<LocalizedText>& par_displayName,
    const OPTIONAL<LocalizedText>& par_description,
    const OPTIONAL<INTEGER>& par_eventNotifier,
    const OPTIONAL<INTEGER>& par_writeMask,
    const OPTIONAL<INTEGER>& par_userWriteMask);
  ObjectAttributes(const ObjectAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ObjectAttributes& operator=(const ObjectAttributes& other_value);
  boolean operator==(const ObjectAttributes& other_value) const;
  inline boolean operator!=(const ObjectAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& displayNameBit()
    {return field_displayNameBit;}
  inline const INTEGER& displayNameBit() const
    {return field_displayNameBit;}
  inline INTEGER& descriptionBit()
    {return field_descriptionBit;}
  inline const INTEGER& descriptionBit() const
    {return field_descriptionBit;}
  inline INTEGER& eventNotifierBit()
    {return field_eventNotifierBit;}
  inline const INTEGER& eventNotifierBit() const
    {return field_eventNotifierBit;}
  inline INTEGER& writeMaskBit()
    {return field_writeMaskBit;}
  inline const INTEGER& writeMaskBit() const
    {return field_writeMaskBit;}
  inline INTEGER& userWriteMaskBit()
    {return field_userWriteMaskBit;}
  inline const INTEGER& userWriteMaskBit() const
    {return field_userWriteMaskBit;}
  inline ObjectAttributes_reserveBits& reserveBits()
    {return field_reserveBits;}
  inline const ObjectAttributes_reserveBits& reserveBits() const
    {return field_reserveBits;}
  inline OPTIONAL<LocalizedText>& displayName()
    {return field_displayName;}
  inline const OPTIONAL<LocalizedText>& displayName() const
    {return field_displayName;}
  inline OPTIONAL<LocalizedText>& description()
    {return field_description;}
  inline const OPTIONAL<LocalizedText>& description() const
    {return field_description;}
  inline OPTIONAL<INTEGER>& eventNotifier()
    {return field_eventNotifier;}
  inline const OPTIONAL<INTEGER>& eventNotifier() const
    {return field_eventNotifier;}
  inline OPTIONAL<INTEGER>& writeMask()
    {return field_writeMask;}
  inline const OPTIONAL<INTEGER>& writeMask() const
    {return field_writeMask;}
  inline OPTIONAL<INTEGER>& userWriteMask()
    {return field_userWriteMask;}
  inline const OPTIONAL<INTEGER>& userWriteMask() const
    {return field_userWriteMask;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ObjectAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ObjectAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ObjectAttributes& other_value);
void copy_template(const ObjectAttributes_template& other_value);

public:
ObjectAttributes_template();
ObjectAttributes_template(template_sel other_value);
ObjectAttributes_template(const ObjectAttributes& other_value);
ObjectAttributes_template(const OPTIONAL<ObjectAttributes>& other_value);
ObjectAttributes_template(const ObjectAttributes_template& other_value);
~ObjectAttributes_template();
ObjectAttributes_template& operator=(template_sel other_value);
ObjectAttributes_template& operator=(const ObjectAttributes& other_value);
ObjectAttributes_template& operator=(const OPTIONAL<ObjectAttributes>& other_value);
ObjectAttributes_template& operator=(const ObjectAttributes_template& other_value);
boolean match(const ObjectAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ObjectAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ObjectAttributes_template& list_item(unsigned int list_index) const;
INTEGER_template& displayNameBit();
const INTEGER_template& displayNameBit() const;
INTEGER_template& descriptionBit();
const INTEGER_template& descriptionBit() const;
INTEGER_template& eventNotifierBit();
const INTEGER_template& eventNotifierBit() const;
INTEGER_template& writeMaskBit();
const INTEGER_template& writeMaskBit() const;
INTEGER_template& userWriteMaskBit();
const INTEGER_template& userWriteMaskBit() const;
ObjectAttributes_reserveBits_template& reserveBits();
const ObjectAttributes_reserveBits_template& reserveBits() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
INTEGER_template& eventNotifier();
const INTEGER_template& eventNotifier() const;
INTEGER_template& writeMask();
const INTEGER_template& writeMask() const;
INTEGER_template& userWriteMask();
const INTEGER_template& userWriteMask() const;
int size_of() const;
void log() const;
void log_match(const ObjectAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class VariableAttributes : public Base_Type {
  INTEGER field_displayNameBit;
  INTEGER field_descriptionBit;
  INTEGER field_ValueBit;
  INTEGER field_dataTypeBit;
  INTEGER field_valueRankBit;
  INTEGER field_arrayDimensionsBit;
  INTEGER field_accessLevelBit;
  INTEGER field_userAccessLevelBit;
  INTEGER field_minimumSamplingIntervalBit;
  INTEGER field_historizingBit;
  INTEGER field_writeMaskBit;
  INTEGER field_userWriteMaskBit;
  VariableAttributes_reserveBits field_reserveBits;
  OPTIONAL<LocalizedText> field_displayName;
  OPTIONAL<LocalizedText> field_description;
  OPTIONAL<INTEGER> field_Value;
  OPTIONAL<NodeId> field_dataType;
  OPTIONAL<INTEGER> field_valueRank;
  OPTIONAL<ListOfUInt32> field_arrayDimensions;
  OPTIONAL<INTEGER> field_accessLevel;
  OPTIONAL<INTEGER> field_userAccessLevel;
  OPTIONAL<FLOAT> field_minimumSamplingInterval;
  OPTIONAL<INTEGER> field_historizing;
  OPTIONAL<INTEGER> field_writeMask;
  OPTIONAL<INTEGER> field_userWriteMask;
public:
  VariableAttributes();
  VariableAttributes(const INTEGER& par_displayNameBit,
    const INTEGER& par_descriptionBit,
    const INTEGER& par_ValueBit,
    const INTEGER& par_dataTypeBit,
    const INTEGER& par_valueRankBit,
    const INTEGER& par_arrayDimensionsBit,
    const INTEGER& par_accessLevelBit,
    const INTEGER& par_userAccessLevelBit,
    const INTEGER& par_minimumSamplingIntervalBit,
    const INTEGER& par_historizingBit,
    const INTEGER& par_writeMaskBit,
    const INTEGER& par_userWriteMaskBit,
    const VariableAttributes_reserveBits& par_reserveBits,
    const OPTIONAL<LocalizedText>& par_displayName,
    const OPTIONAL<LocalizedText>& par_description,
    const OPTIONAL<INTEGER>& par_Value,
    const OPTIONAL<NodeId>& par_dataType,
    const OPTIONAL<INTEGER>& par_valueRank,
    const OPTIONAL<ListOfUInt32>& par_arrayDimensions,
    const OPTIONAL<INTEGER>& par_accessLevel,
    const OPTIONAL<INTEGER>& par_userAccessLevel,
    const OPTIONAL<FLOAT>& par_minimumSamplingInterval,
    const OPTIONAL<INTEGER>& par_historizing,
    const OPTIONAL<INTEGER>& par_writeMask,
    const OPTIONAL<INTEGER>& par_userWriteMask);
  VariableAttributes(const VariableAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  VariableAttributes& operator=(const VariableAttributes& other_value);
  boolean operator==(const VariableAttributes& other_value) const;
  inline boolean operator!=(const VariableAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& displayNameBit()
    {return field_displayNameBit;}
  inline const INTEGER& displayNameBit() const
    {return field_displayNameBit;}
  inline INTEGER& descriptionBit()
    {return field_descriptionBit;}
  inline const INTEGER& descriptionBit() const
    {return field_descriptionBit;}
  inline INTEGER& ValueBit()
    {return field_ValueBit;}
  inline const INTEGER& ValueBit() const
    {return field_ValueBit;}
  inline INTEGER& dataTypeBit()
    {return field_dataTypeBit;}
  inline const INTEGER& dataTypeBit() const
    {return field_dataTypeBit;}
  inline INTEGER& valueRankBit()
    {return field_valueRankBit;}
  inline const INTEGER& valueRankBit() const
    {return field_valueRankBit;}
  inline INTEGER& arrayDimensionsBit()
    {return field_arrayDimensionsBit;}
  inline const INTEGER& arrayDimensionsBit() const
    {return field_arrayDimensionsBit;}
  inline INTEGER& accessLevelBit()
    {return field_accessLevelBit;}
  inline const INTEGER& accessLevelBit() const
    {return field_accessLevelBit;}
  inline INTEGER& userAccessLevelBit()
    {return field_userAccessLevelBit;}
  inline const INTEGER& userAccessLevelBit() const
    {return field_userAccessLevelBit;}
  inline INTEGER& minimumSamplingIntervalBit()
    {return field_minimumSamplingIntervalBit;}
  inline const INTEGER& minimumSamplingIntervalBit() const
    {return field_minimumSamplingIntervalBit;}
  inline INTEGER& historizingBit()
    {return field_historizingBit;}
  inline const INTEGER& historizingBit() const
    {return field_historizingBit;}
  inline INTEGER& writeMaskBit()
    {return field_writeMaskBit;}
  inline const INTEGER& writeMaskBit() const
    {return field_writeMaskBit;}
  inline INTEGER& userWriteMaskBit()
    {return field_userWriteMaskBit;}
  inline const INTEGER& userWriteMaskBit() const
    {return field_userWriteMaskBit;}
  inline VariableAttributes_reserveBits& reserveBits()
    {return field_reserveBits;}
  inline const VariableAttributes_reserveBits& reserveBits() const
    {return field_reserveBits;}
  inline OPTIONAL<LocalizedText>& displayName()
    {return field_displayName;}
  inline const OPTIONAL<LocalizedText>& displayName() const
    {return field_displayName;}
  inline OPTIONAL<LocalizedText>& description()
    {return field_description;}
  inline const OPTIONAL<LocalizedText>& description() const
    {return field_description;}
  inline OPTIONAL<INTEGER>& Value()
    {return field_Value;}
  inline const OPTIONAL<INTEGER>& Value() const
    {return field_Value;}
  inline OPTIONAL<NodeId>& dataType()
    {return field_dataType;}
  inline const OPTIONAL<NodeId>& dataType() const
    {return field_dataType;}
  inline OPTIONAL<INTEGER>& valueRank()
    {return field_valueRank;}
  inline const OPTIONAL<INTEGER>& valueRank() const
    {return field_valueRank;}
  inline OPTIONAL<ListOfUInt32>& arrayDimensions()
    {return field_arrayDimensions;}
  inline const OPTIONAL<ListOfUInt32>& arrayDimensions() const
    {return field_arrayDimensions;}
  inline OPTIONAL<INTEGER>& accessLevel()
    {return field_accessLevel;}
  inline const OPTIONAL<INTEGER>& accessLevel() const
    {return field_accessLevel;}
  inline OPTIONAL<INTEGER>& userAccessLevel()
    {return field_userAccessLevel;}
  inline const OPTIONAL<INTEGER>& userAccessLevel() const
    {return field_userAccessLevel;}
  inline OPTIONAL<FLOAT>& minimumSamplingInterval()
    {return field_minimumSamplingInterval;}
  inline const OPTIONAL<FLOAT>& minimumSamplingInterval() const
    {return field_minimumSamplingInterval;}
  inline OPTIONAL<INTEGER>& historizing()
    {return field_historizing;}
  inline const OPTIONAL<INTEGER>& historizing() const
    {return field_historizing;}
  inline OPTIONAL<INTEGER>& writeMask()
    {return field_writeMask;}
  inline const OPTIONAL<INTEGER>& writeMask() const
    {return field_writeMask;}
  inline OPTIONAL<INTEGER>& userWriteMask()
    {return field_userWriteMask;}
  inline const OPTIONAL<INTEGER>& userWriteMask() const
    {return field_userWriteMask;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class VariableAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
VariableAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const VariableAttributes& other_value);
void copy_template(const VariableAttributes_template& other_value);

public:
VariableAttributes_template();
VariableAttributes_template(template_sel other_value);
VariableAttributes_template(const VariableAttributes& other_value);
VariableAttributes_template(const OPTIONAL<VariableAttributes>& other_value);
VariableAttributes_template(const VariableAttributes_template& other_value);
~VariableAttributes_template();
VariableAttributes_template& operator=(template_sel other_value);
VariableAttributes_template& operator=(const VariableAttributes& other_value);
VariableAttributes_template& operator=(const OPTIONAL<VariableAttributes>& other_value);
VariableAttributes_template& operator=(const VariableAttributes_template& other_value);
boolean match(const VariableAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
VariableAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
VariableAttributes_template& list_item(unsigned int list_index) const;
INTEGER_template& displayNameBit();
const INTEGER_template& displayNameBit() const;
INTEGER_template& descriptionBit();
const INTEGER_template& descriptionBit() const;
INTEGER_template& ValueBit();
const INTEGER_template& ValueBit() const;
INTEGER_template& dataTypeBit();
const INTEGER_template& dataTypeBit() const;
INTEGER_template& valueRankBit();
const INTEGER_template& valueRankBit() const;
INTEGER_template& arrayDimensionsBit();
const INTEGER_template& arrayDimensionsBit() const;
INTEGER_template& accessLevelBit();
const INTEGER_template& accessLevelBit() const;
INTEGER_template& userAccessLevelBit();
const INTEGER_template& userAccessLevelBit() const;
INTEGER_template& minimumSamplingIntervalBit();
const INTEGER_template& minimumSamplingIntervalBit() const;
INTEGER_template& historizingBit();
const INTEGER_template& historizingBit() const;
INTEGER_template& writeMaskBit();
const INTEGER_template& writeMaskBit() const;
INTEGER_template& userWriteMaskBit();
const INTEGER_template& userWriteMaskBit() const;
VariableAttributes_reserveBits_template& reserveBits();
const VariableAttributes_reserveBits_template& reserveBits() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
INTEGER_template& Value();
const INTEGER_template& Value() const;
NodeId_template& dataType();
const NodeId_template& dataType() const;
INTEGER_template& valueRank();
const INTEGER_template& valueRank() const;
ListOfUInt32_template& arrayDimensions();
const ListOfUInt32_template& arrayDimensions() const;
INTEGER_template& accessLevel();
const INTEGER_template& accessLevel() const;
INTEGER_template& userAccessLevel();
const INTEGER_template& userAccessLevel() const;
FLOAT_template& minimumSamplingInterval();
const FLOAT_template& minimumSamplingInterval() const;
INTEGER_template& historizing();
const INTEGER_template& historizing() const;
INTEGER_template& writeMask();
const INTEGER_template& writeMask() const;
INTEGER_template& userWriteMask();
const INTEGER_template& userWriteMask() const;
int size_of() const;
void log() const;
void log_match(const VariableAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MethodAttributes : public Base_Type {
  INTEGER field_displayNameBit;
  INTEGER field_descriptionBit;
  INTEGER field_executableBit;
  INTEGER field_userExecutableBit;
  INTEGER field_writeMaskBit;
  INTEGER field_userWriteMaskBit;
  MethodAttributes_reserveBits field_reserveBits;
  OPTIONAL<LocalizedText> field_displayName;
  OPTIONAL<LocalizedText> field_description;
  OPTIONAL<INTEGER> field_executable;
  OPTIONAL<INTEGER> field_userExecutable;
  OPTIONAL<INTEGER> field_writeMask;
  OPTIONAL<INTEGER> field_userWriteMask;
public:
  MethodAttributes();
  MethodAttributes(const INTEGER& par_displayNameBit,
    const INTEGER& par_descriptionBit,
    const INTEGER& par_executableBit,
    const INTEGER& par_userExecutableBit,
    const INTEGER& par_writeMaskBit,
    const INTEGER& par_userWriteMaskBit,
    const MethodAttributes_reserveBits& par_reserveBits,
    const OPTIONAL<LocalizedText>& par_displayName,
    const OPTIONAL<LocalizedText>& par_description,
    const OPTIONAL<INTEGER>& par_executable,
    const OPTIONAL<INTEGER>& par_userExecutable,
    const OPTIONAL<INTEGER>& par_writeMask,
    const OPTIONAL<INTEGER>& par_userWriteMask);
  MethodAttributes(const MethodAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MethodAttributes& operator=(const MethodAttributes& other_value);
  boolean operator==(const MethodAttributes& other_value) const;
  inline boolean operator!=(const MethodAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& displayNameBit()
    {return field_displayNameBit;}
  inline const INTEGER& displayNameBit() const
    {return field_displayNameBit;}
  inline INTEGER& descriptionBit()
    {return field_descriptionBit;}
  inline const INTEGER& descriptionBit() const
    {return field_descriptionBit;}
  inline INTEGER& executableBit()
    {return field_executableBit;}
  inline const INTEGER& executableBit() const
    {return field_executableBit;}
  inline INTEGER& userExecutableBit()
    {return field_userExecutableBit;}
  inline const INTEGER& userExecutableBit() const
    {return field_userExecutableBit;}
  inline INTEGER& writeMaskBit()
    {return field_writeMaskBit;}
  inline const INTEGER& writeMaskBit() const
    {return field_writeMaskBit;}
  inline INTEGER& userWriteMaskBit()
    {return field_userWriteMaskBit;}
  inline const INTEGER& userWriteMaskBit() const
    {return field_userWriteMaskBit;}
  inline MethodAttributes_reserveBits& reserveBits()
    {return field_reserveBits;}
  inline const MethodAttributes_reserveBits& reserveBits() const
    {return field_reserveBits;}
  inline OPTIONAL<LocalizedText>& displayName()
    {return field_displayName;}
  inline const OPTIONAL<LocalizedText>& displayName() const
    {return field_displayName;}
  inline OPTIONAL<LocalizedText>& description()
    {return field_description;}
  inline const OPTIONAL<LocalizedText>& description() const
    {return field_description;}
  inline OPTIONAL<INTEGER>& executable()
    {return field_executable;}
  inline const OPTIONAL<INTEGER>& executable() const
    {return field_executable;}
  inline OPTIONAL<INTEGER>& userExecutable()
    {return field_userExecutable;}
  inline const OPTIONAL<INTEGER>& userExecutable() const
    {return field_userExecutable;}
  inline OPTIONAL<INTEGER>& writeMask()
    {return field_writeMask;}
  inline const OPTIONAL<INTEGER>& writeMask() const
    {return field_writeMask;}
  inline OPTIONAL<INTEGER>& userWriteMask()
    {return field_userWriteMask;}
  inline const OPTIONAL<INTEGER>& userWriteMask() const
    {return field_userWriteMask;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MethodAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MethodAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MethodAttributes& other_value);
void copy_template(const MethodAttributes_template& other_value);

public:
MethodAttributes_template();
MethodAttributes_template(template_sel other_value);
MethodAttributes_template(const MethodAttributes& other_value);
MethodAttributes_template(const OPTIONAL<MethodAttributes>& other_value);
MethodAttributes_template(const MethodAttributes_template& other_value);
~MethodAttributes_template();
MethodAttributes_template& operator=(template_sel other_value);
MethodAttributes_template& operator=(const MethodAttributes& other_value);
MethodAttributes_template& operator=(const OPTIONAL<MethodAttributes>& other_value);
MethodAttributes_template& operator=(const MethodAttributes_template& other_value);
boolean match(const MethodAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MethodAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MethodAttributes_template& list_item(unsigned int list_index) const;
INTEGER_template& displayNameBit();
const INTEGER_template& displayNameBit() const;
INTEGER_template& descriptionBit();
const INTEGER_template& descriptionBit() const;
INTEGER_template& executableBit();
const INTEGER_template& executableBit() const;
INTEGER_template& userExecutableBit();
const INTEGER_template& userExecutableBit() const;
INTEGER_template& writeMaskBit();
const INTEGER_template& writeMaskBit() const;
INTEGER_template& userWriteMaskBit();
const INTEGER_template& userWriteMaskBit() const;
MethodAttributes_reserveBits_template& reserveBits();
const MethodAttributes_reserveBits_template& reserveBits() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
INTEGER_template& executable();
const INTEGER_template& executable() const;
INTEGER_template& userExecutable();
const INTEGER_template& userExecutable() const;
INTEGER_template& writeMask();
const INTEGER_template& writeMask() const;
INTEGER_template& userWriteMask();
const INTEGER_template& userWriteMask() const;
int size_of() const;
void log() const;
void log_match(const MethodAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ObjectTypeAttributes : public Base_Type {
  INTEGER field_displayNameBit;
  INTEGER field_descriptionBit;
  INTEGER field_isAbstractBit;
  INTEGER field_writeMaskBit;
  INTEGER field_userWriteMaskBit;
  ObjectTypeAttributes_reserveBits field_reserveBits;
  OPTIONAL<LocalizedText> field_displayName;
  OPTIONAL<LocalizedText> field_description;
  OPTIONAL<INTEGER> field_isAbstract;
  OPTIONAL<INTEGER> field_writeMask;
  OPTIONAL<INTEGER> field_userWriteMask;
public:
  ObjectTypeAttributes();
  ObjectTypeAttributes(const INTEGER& par_displayNameBit,
    const INTEGER& par_descriptionBit,
    const INTEGER& par_isAbstractBit,
    const INTEGER& par_writeMaskBit,
    const INTEGER& par_userWriteMaskBit,
    const ObjectTypeAttributes_reserveBits& par_reserveBits,
    const OPTIONAL<LocalizedText>& par_displayName,
    const OPTIONAL<LocalizedText>& par_description,
    const OPTIONAL<INTEGER>& par_isAbstract,
    const OPTIONAL<INTEGER>& par_writeMask,
    const OPTIONAL<INTEGER>& par_userWriteMask);
  ObjectTypeAttributes(const ObjectTypeAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ObjectTypeAttributes& operator=(const ObjectTypeAttributes& other_value);
  boolean operator==(const ObjectTypeAttributes& other_value) const;
  inline boolean operator!=(const ObjectTypeAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& displayNameBit()
    {return field_displayNameBit;}
  inline const INTEGER& displayNameBit() const
    {return field_displayNameBit;}
  inline INTEGER& descriptionBit()
    {return field_descriptionBit;}
  inline const INTEGER& descriptionBit() const
    {return field_descriptionBit;}
  inline INTEGER& isAbstractBit()
    {return field_isAbstractBit;}
  inline const INTEGER& isAbstractBit() const
    {return field_isAbstractBit;}
  inline INTEGER& writeMaskBit()
    {return field_writeMaskBit;}
  inline const INTEGER& writeMaskBit() const
    {return field_writeMaskBit;}
  inline INTEGER& userWriteMaskBit()
    {return field_userWriteMaskBit;}
  inline const INTEGER& userWriteMaskBit() const
    {return field_userWriteMaskBit;}
  inline ObjectTypeAttributes_reserveBits& reserveBits()
    {return field_reserveBits;}
  inline const ObjectTypeAttributes_reserveBits& reserveBits() const
    {return field_reserveBits;}
  inline OPTIONAL<LocalizedText>& displayName()
    {return field_displayName;}
  inline const OPTIONAL<LocalizedText>& displayName() const
    {return field_displayName;}
  inline OPTIONAL<LocalizedText>& description()
    {return field_description;}
  inline const OPTIONAL<LocalizedText>& description() const
    {return field_description;}
  inline OPTIONAL<INTEGER>& isAbstract()
    {return field_isAbstract;}
  inline const OPTIONAL<INTEGER>& isAbstract() const
    {return field_isAbstract;}
  inline OPTIONAL<INTEGER>& writeMask()
    {return field_writeMask;}
  inline const OPTIONAL<INTEGER>& writeMask() const
    {return field_writeMask;}
  inline OPTIONAL<INTEGER>& userWriteMask()
    {return field_userWriteMask;}
  inline const OPTIONAL<INTEGER>& userWriteMask() const
    {return field_userWriteMask;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ObjectTypeAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ObjectTypeAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ObjectTypeAttributes& other_value);
void copy_template(const ObjectTypeAttributes_template& other_value);

public:
ObjectTypeAttributes_template();
ObjectTypeAttributes_template(template_sel other_value);
ObjectTypeAttributes_template(const ObjectTypeAttributes& other_value);
ObjectTypeAttributes_template(const OPTIONAL<ObjectTypeAttributes>& other_value);
ObjectTypeAttributes_template(const ObjectTypeAttributes_template& other_value);
~ObjectTypeAttributes_template();
ObjectTypeAttributes_template& operator=(template_sel other_value);
ObjectTypeAttributes_template& operator=(const ObjectTypeAttributes& other_value);
ObjectTypeAttributes_template& operator=(const OPTIONAL<ObjectTypeAttributes>& other_value);
ObjectTypeAttributes_template& operator=(const ObjectTypeAttributes_template& other_value);
boolean match(const ObjectTypeAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ObjectTypeAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ObjectTypeAttributes_template& list_item(unsigned int list_index) const;
INTEGER_template& displayNameBit();
const INTEGER_template& displayNameBit() const;
INTEGER_template& descriptionBit();
const INTEGER_template& descriptionBit() const;
INTEGER_template& isAbstractBit();
const INTEGER_template& isAbstractBit() const;
INTEGER_template& writeMaskBit();
const INTEGER_template& writeMaskBit() const;
INTEGER_template& userWriteMaskBit();
const INTEGER_template& userWriteMaskBit() const;
ObjectTypeAttributes_reserveBits_template& reserveBits();
const ObjectTypeAttributes_reserveBits_template& reserveBits() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
INTEGER_template& isAbstract();
const INTEGER_template& isAbstract() const;
INTEGER_template& writeMask();
const INTEGER_template& writeMask() const;
INTEGER_template& userWriteMask();
const INTEGER_template& userWriteMask() const;
int size_of() const;
void log() const;
void log_match(const ObjectTypeAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class VariableTypeAttributes : public Base_Type {
  INTEGER field_displayNameBit;
  INTEGER field_descriptionBit;
  INTEGER field_ValueBit;
  INTEGER field_dataTypeBit;
  INTEGER field_valueRankBit;
  INTEGER field_arrayDimensionsBit;
  INTEGER field_isAbstractBit;
  INTEGER field_writeMaskBit;
  INTEGER field_userWriteMaskBit;
  VariableTypeAttributes_reserveBits field_reserveBits;
  OPTIONAL<LocalizedText> field_displayName;
  OPTIONAL<LocalizedText> field_description;
  OPTIONAL<INTEGER> field_Value;
  OPTIONAL<NodeId> field_dataType;
  OPTIONAL<INTEGER> field_valueRank;
  OPTIONAL<ListOfUInt32> field_arrayDimensions;
  OPTIONAL<INTEGER> field_isAbstract;
  OPTIONAL<INTEGER> field_writeMask;
  OPTIONAL<INTEGER> field_userWriteMask;
public:
  VariableTypeAttributes();
  VariableTypeAttributes(const INTEGER& par_displayNameBit,
    const INTEGER& par_descriptionBit,
    const INTEGER& par_ValueBit,
    const INTEGER& par_dataTypeBit,
    const INTEGER& par_valueRankBit,
    const INTEGER& par_arrayDimensionsBit,
    const INTEGER& par_isAbstractBit,
    const INTEGER& par_writeMaskBit,
    const INTEGER& par_userWriteMaskBit,
    const VariableTypeAttributes_reserveBits& par_reserveBits,
    const OPTIONAL<LocalizedText>& par_displayName,
    const OPTIONAL<LocalizedText>& par_description,
    const OPTIONAL<INTEGER>& par_Value,
    const OPTIONAL<NodeId>& par_dataType,
    const OPTIONAL<INTEGER>& par_valueRank,
    const OPTIONAL<ListOfUInt32>& par_arrayDimensions,
    const OPTIONAL<INTEGER>& par_isAbstract,
    const OPTIONAL<INTEGER>& par_writeMask,
    const OPTIONAL<INTEGER>& par_userWriteMask);
  VariableTypeAttributes(const VariableTypeAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  VariableTypeAttributes& operator=(const VariableTypeAttributes& other_value);
  boolean operator==(const VariableTypeAttributes& other_value) const;
  inline boolean operator!=(const VariableTypeAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& displayNameBit()
    {return field_displayNameBit;}
  inline const INTEGER& displayNameBit() const
    {return field_displayNameBit;}
  inline INTEGER& descriptionBit()
    {return field_descriptionBit;}
  inline const INTEGER& descriptionBit() const
    {return field_descriptionBit;}
  inline INTEGER& ValueBit()
    {return field_ValueBit;}
  inline const INTEGER& ValueBit() const
    {return field_ValueBit;}
  inline INTEGER& dataTypeBit()
    {return field_dataTypeBit;}
  inline const INTEGER& dataTypeBit() const
    {return field_dataTypeBit;}
  inline INTEGER& valueRankBit()
    {return field_valueRankBit;}
  inline const INTEGER& valueRankBit() const
    {return field_valueRankBit;}
  inline INTEGER& arrayDimensionsBit()
    {return field_arrayDimensionsBit;}
  inline const INTEGER& arrayDimensionsBit() const
    {return field_arrayDimensionsBit;}
  inline INTEGER& isAbstractBit()
    {return field_isAbstractBit;}
  inline const INTEGER& isAbstractBit() const
    {return field_isAbstractBit;}
  inline INTEGER& writeMaskBit()
    {return field_writeMaskBit;}
  inline const INTEGER& writeMaskBit() const
    {return field_writeMaskBit;}
  inline INTEGER& userWriteMaskBit()
    {return field_userWriteMaskBit;}
  inline const INTEGER& userWriteMaskBit() const
    {return field_userWriteMaskBit;}
  inline VariableTypeAttributes_reserveBits& reserveBits()
    {return field_reserveBits;}
  inline const VariableTypeAttributes_reserveBits& reserveBits() const
    {return field_reserveBits;}
  inline OPTIONAL<LocalizedText>& displayName()
    {return field_displayName;}
  inline const OPTIONAL<LocalizedText>& displayName() const
    {return field_displayName;}
  inline OPTIONAL<LocalizedText>& description()
    {return field_description;}
  inline const OPTIONAL<LocalizedText>& description() const
    {return field_description;}
  inline OPTIONAL<INTEGER>& Value()
    {return field_Value;}
  inline const OPTIONAL<INTEGER>& Value() const
    {return field_Value;}
  inline OPTIONAL<NodeId>& dataType()
    {return field_dataType;}
  inline const OPTIONAL<NodeId>& dataType() const
    {return field_dataType;}
  inline OPTIONAL<INTEGER>& valueRank()
    {return field_valueRank;}
  inline const OPTIONAL<INTEGER>& valueRank() const
    {return field_valueRank;}
  inline OPTIONAL<ListOfUInt32>& arrayDimensions()
    {return field_arrayDimensions;}
  inline const OPTIONAL<ListOfUInt32>& arrayDimensions() const
    {return field_arrayDimensions;}
  inline OPTIONAL<INTEGER>& isAbstract()
    {return field_isAbstract;}
  inline const OPTIONAL<INTEGER>& isAbstract() const
    {return field_isAbstract;}
  inline OPTIONAL<INTEGER>& writeMask()
    {return field_writeMask;}
  inline const OPTIONAL<INTEGER>& writeMask() const
    {return field_writeMask;}
  inline OPTIONAL<INTEGER>& userWriteMask()
    {return field_userWriteMask;}
  inline const OPTIONAL<INTEGER>& userWriteMask() const
    {return field_userWriteMask;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class VariableTypeAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
VariableTypeAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const VariableTypeAttributes& other_value);
void copy_template(const VariableTypeAttributes_template& other_value);

public:
VariableTypeAttributes_template();
VariableTypeAttributes_template(template_sel other_value);
VariableTypeAttributes_template(const VariableTypeAttributes& other_value);
VariableTypeAttributes_template(const OPTIONAL<VariableTypeAttributes>& other_value);
VariableTypeAttributes_template(const VariableTypeAttributes_template& other_value);
~VariableTypeAttributes_template();
VariableTypeAttributes_template& operator=(template_sel other_value);
VariableTypeAttributes_template& operator=(const VariableTypeAttributes& other_value);
VariableTypeAttributes_template& operator=(const OPTIONAL<VariableTypeAttributes>& other_value);
VariableTypeAttributes_template& operator=(const VariableTypeAttributes_template& other_value);
boolean match(const VariableTypeAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
VariableTypeAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
VariableTypeAttributes_template& list_item(unsigned int list_index) const;
INTEGER_template& displayNameBit();
const INTEGER_template& displayNameBit() const;
INTEGER_template& descriptionBit();
const INTEGER_template& descriptionBit() const;
INTEGER_template& ValueBit();
const INTEGER_template& ValueBit() const;
INTEGER_template& dataTypeBit();
const INTEGER_template& dataTypeBit() const;
INTEGER_template& valueRankBit();
const INTEGER_template& valueRankBit() const;
INTEGER_template& arrayDimensionsBit();
const INTEGER_template& arrayDimensionsBit() const;
INTEGER_template& isAbstractBit();
const INTEGER_template& isAbstractBit() const;
INTEGER_template& writeMaskBit();
const INTEGER_template& writeMaskBit() const;
INTEGER_template& userWriteMaskBit();
const INTEGER_template& userWriteMaskBit() const;
VariableTypeAttributes_reserveBits_template& reserveBits();
const VariableTypeAttributes_reserveBits_template& reserveBits() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
INTEGER_template& Value();
const INTEGER_template& Value() const;
NodeId_template& dataType();
const NodeId_template& dataType() const;
INTEGER_template& valueRank();
const INTEGER_template& valueRank() const;
ListOfUInt32_template& arrayDimensions();
const ListOfUInt32_template& arrayDimensions() const;
INTEGER_template& isAbstract();
const INTEGER_template& isAbstract() const;
INTEGER_template& writeMask();
const INTEGER_template& writeMask() const;
INTEGER_template& userWriteMask();
const INTEGER_template& userWriteMask() const;
int size_of() const;
void log() const;
void log_match(const VariableTypeAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReferenceTypeAttributes : public Base_Type {
  INTEGER field_displayNameBit;
  INTEGER field_descriptionBit;
  INTEGER field_isAbstractBit;
  INTEGER field_symmetricBit;
  INTEGER field_inverseNameBit;
  INTEGER field_writeMaskBit;
  INTEGER field_userWriteMaskBit;
  ReferenceTypeAttributes_reserveBits field_reserveBits;
  OPTIONAL<LocalizedText> field_displayName;
  OPTIONAL<LocalizedText> field_description;
  OPTIONAL<INTEGER> field_isAbstract;
  OPTIONAL<INTEGER> field_symmetric;
  OPTIONAL<LocalizedText> field_inverseName;
  OPTIONAL<INTEGER> field_writeMask;
  OPTIONAL<INTEGER> field_userWriteMask;
public:
  ReferenceTypeAttributes();
  ReferenceTypeAttributes(const INTEGER& par_displayNameBit,
    const INTEGER& par_descriptionBit,
    const INTEGER& par_isAbstractBit,
    const INTEGER& par_symmetricBit,
    const INTEGER& par_inverseNameBit,
    const INTEGER& par_writeMaskBit,
    const INTEGER& par_userWriteMaskBit,
    const ReferenceTypeAttributes_reserveBits& par_reserveBits,
    const OPTIONAL<LocalizedText>& par_displayName,
    const OPTIONAL<LocalizedText>& par_description,
    const OPTIONAL<INTEGER>& par_isAbstract,
    const OPTIONAL<INTEGER>& par_symmetric,
    const OPTIONAL<LocalizedText>& par_inverseName,
    const OPTIONAL<INTEGER>& par_writeMask,
    const OPTIONAL<INTEGER>& par_userWriteMask);
  ReferenceTypeAttributes(const ReferenceTypeAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReferenceTypeAttributes& operator=(const ReferenceTypeAttributes& other_value);
  boolean operator==(const ReferenceTypeAttributes& other_value) const;
  inline boolean operator!=(const ReferenceTypeAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& displayNameBit()
    {return field_displayNameBit;}
  inline const INTEGER& displayNameBit() const
    {return field_displayNameBit;}
  inline INTEGER& descriptionBit()
    {return field_descriptionBit;}
  inline const INTEGER& descriptionBit() const
    {return field_descriptionBit;}
  inline INTEGER& isAbstractBit()
    {return field_isAbstractBit;}
  inline const INTEGER& isAbstractBit() const
    {return field_isAbstractBit;}
  inline INTEGER& symmetricBit()
    {return field_symmetricBit;}
  inline const INTEGER& symmetricBit() const
    {return field_symmetricBit;}
  inline INTEGER& inverseNameBit()
    {return field_inverseNameBit;}
  inline const INTEGER& inverseNameBit() const
    {return field_inverseNameBit;}
  inline INTEGER& writeMaskBit()
    {return field_writeMaskBit;}
  inline const INTEGER& writeMaskBit() const
    {return field_writeMaskBit;}
  inline INTEGER& userWriteMaskBit()
    {return field_userWriteMaskBit;}
  inline const INTEGER& userWriteMaskBit() const
    {return field_userWriteMaskBit;}
  inline ReferenceTypeAttributes_reserveBits& reserveBits()
    {return field_reserveBits;}
  inline const ReferenceTypeAttributes_reserveBits& reserveBits() const
    {return field_reserveBits;}
  inline OPTIONAL<LocalizedText>& displayName()
    {return field_displayName;}
  inline const OPTIONAL<LocalizedText>& displayName() const
    {return field_displayName;}
  inline OPTIONAL<LocalizedText>& description()
    {return field_description;}
  inline const OPTIONAL<LocalizedText>& description() const
    {return field_description;}
  inline OPTIONAL<INTEGER>& isAbstract()
    {return field_isAbstract;}
  inline const OPTIONAL<INTEGER>& isAbstract() const
    {return field_isAbstract;}
  inline OPTIONAL<INTEGER>& symmetric()
    {return field_symmetric;}
  inline const OPTIONAL<INTEGER>& symmetric() const
    {return field_symmetric;}
  inline OPTIONAL<LocalizedText>& inverseName()
    {return field_inverseName;}
  inline const OPTIONAL<LocalizedText>& inverseName() const
    {return field_inverseName;}
  inline OPTIONAL<INTEGER>& writeMask()
    {return field_writeMask;}
  inline const OPTIONAL<INTEGER>& writeMask() const
    {return field_writeMask;}
  inline OPTIONAL<INTEGER>& userWriteMask()
    {return field_userWriteMask;}
  inline const OPTIONAL<INTEGER>& userWriteMask() const
    {return field_userWriteMask;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReferenceTypeAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReferenceTypeAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReferenceTypeAttributes& other_value);
void copy_template(const ReferenceTypeAttributes_template& other_value);

public:
ReferenceTypeAttributes_template();
ReferenceTypeAttributes_template(template_sel other_value);
ReferenceTypeAttributes_template(const ReferenceTypeAttributes& other_value);
ReferenceTypeAttributes_template(const OPTIONAL<ReferenceTypeAttributes>& other_value);
ReferenceTypeAttributes_template(const ReferenceTypeAttributes_template& other_value);
~ReferenceTypeAttributes_template();
ReferenceTypeAttributes_template& operator=(template_sel other_value);
ReferenceTypeAttributes_template& operator=(const ReferenceTypeAttributes& other_value);
ReferenceTypeAttributes_template& operator=(const OPTIONAL<ReferenceTypeAttributes>& other_value);
ReferenceTypeAttributes_template& operator=(const ReferenceTypeAttributes_template& other_value);
boolean match(const ReferenceTypeAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReferenceTypeAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReferenceTypeAttributes_template& list_item(unsigned int list_index) const;
INTEGER_template& displayNameBit();
const INTEGER_template& displayNameBit() const;
INTEGER_template& descriptionBit();
const INTEGER_template& descriptionBit() const;
INTEGER_template& isAbstractBit();
const INTEGER_template& isAbstractBit() const;
INTEGER_template& symmetricBit();
const INTEGER_template& symmetricBit() const;
INTEGER_template& inverseNameBit();
const INTEGER_template& inverseNameBit() const;
INTEGER_template& writeMaskBit();
const INTEGER_template& writeMaskBit() const;
INTEGER_template& userWriteMaskBit();
const INTEGER_template& userWriteMaskBit() const;
ReferenceTypeAttributes_reserveBits_template& reserveBits();
const ReferenceTypeAttributes_reserveBits_template& reserveBits() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
INTEGER_template& isAbstract();
const INTEGER_template& isAbstract() const;
INTEGER_template& symmetric();
const INTEGER_template& symmetric() const;
LocalizedText_template& inverseName();
const LocalizedText_template& inverseName() const;
INTEGER_template& writeMask();
const INTEGER_template& writeMask() const;
INTEGER_template& userWriteMask();
const INTEGER_template& userWriteMask() const;
int size_of() const;
void log() const;
void log_match(const ReferenceTypeAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DataTypeAttributes : public Base_Type {
  INTEGER field_displayNameBit;
  INTEGER field_descriptionBit;
  INTEGER field_isAbstractBit;
  INTEGER field_writeMaskBit;
  INTEGER field_userWriteMaskBit;
  DataTypeAttributes_reserveBits field_reserveBits;
  OPTIONAL<LocalizedText> field_displayName;
  OPTIONAL<LocalizedText> field_description;
  OPTIONAL<INTEGER> field_isAbstract;
  OPTIONAL<INTEGER> field_writeMask;
  OPTIONAL<INTEGER> field_userWriteMask;
public:
  DataTypeAttributes();
  DataTypeAttributes(const INTEGER& par_displayNameBit,
    const INTEGER& par_descriptionBit,
    const INTEGER& par_isAbstractBit,
    const INTEGER& par_writeMaskBit,
    const INTEGER& par_userWriteMaskBit,
    const DataTypeAttributes_reserveBits& par_reserveBits,
    const OPTIONAL<LocalizedText>& par_displayName,
    const OPTIONAL<LocalizedText>& par_description,
    const OPTIONAL<INTEGER>& par_isAbstract,
    const OPTIONAL<INTEGER>& par_writeMask,
    const OPTIONAL<INTEGER>& par_userWriteMask);
  DataTypeAttributes(const DataTypeAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DataTypeAttributes& operator=(const DataTypeAttributes& other_value);
  boolean operator==(const DataTypeAttributes& other_value) const;
  inline boolean operator!=(const DataTypeAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& displayNameBit()
    {return field_displayNameBit;}
  inline const INTEGER& displayNameBit() const
    {return field_displayNameBit;}
  inline INTEGER& descriptionBit()
    {return field_descriptionBit;}
  inline const INTEGER& descriptionBit() const
    {return field_descriptionBit;}
  inline INTEGER& isAbstractBit()
    {return field_isAbstractBit;}
  inline const INTEGER& isAbstractBit() const
    {return field_isAbstractBit;}
  inline INTEGER& writeMaskBit()
    {return field_writeMaskBit;}
  inline const INTEGER& writeMaskBit() const
    {return field_writeMaskBit;}
  inline INTEGER& userWriteMaskBit()
    {return field_userWriteMaskBit;}
  inline const INTEGER& userWriteMaskBit() const
    {return field_userWriteMaskBit;}
  inline DataTypeAttributes_reserveBits& reserveBits()
    {return field_reserveBits;}
  inline const DataTypeAttributes_reserveBits& reserveBits() const
    {return field_reserveBits;}
  inline OPTIONAL<LocalizedText>& displayName()
    {return field_displayName;}
  inline const OPTIONAL<LocalizedText>& displayName() const
    {return field_displayName;}
  inline OPTIONAL<LocalizedText>& description()
    {return field_description;}
  inline const OPTIONAL<LocalizedText>& description() const
    {return field_description;}
  inline OPTIONAL<INTEGER>& isAbstract()
    {return field_isAbstract;}
  inline const OPTIONAL<INTEGER>& isAbstract() const
    {return field_isAbstract;}
  inline OPTIONAL<INTEGER>& writeMask()
    {return field_writeMask;}
  inline const OPTIONAL<INTEGER>& writeMask() const
    {return field_writeMask;}
  inline OPTIONAL<INTEGER>& userWriteMask()
    {return field_userWriteMask;}
  inline const OPTIONAL<INTEGER>& userWriteMask() const
    {return field_userWriteMask;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DataTypeAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DataTypeAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DataTypeAttributes& other_value);
void copy_template(const DataTypeAttributes_template& other_value);

public:
DataTypeAttributes_template();
DataTypeAttributes_template(template_sel other_value);
DataTypeAttributes_template(const DataTypeAttributes& other_value);
DataTypeAttributes_template(const OPTIONAL<DataTypeAttributes>& other_value);
DataTypeAttributes_template(const DataTypeAttributes_template& other_value);
~DataTypeAttributes_template();
DataTypeAttributes_template& operator=(template_sel other_value);
DataTypeAttributes_template& operator=(const DataTypeAttributes& other_value);
DataTypeAttributes_template& operator=(const OPTIONAL<DataTypeAttributes>& other_value);
DataTypeAttributes_template& operator=(const DataTypeAttributes_template& other_value);
boolean match(const DataTypeAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DataTypeAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DataTypeAttributes_template& list_item(unsigned int list_index) const;
INTEGER_template& displayNameBit();
const INTEGER_template& displayNameBit() const;
INTEGER_template& descriptionBit();
const INTEGER_template& descriptionBit() const;
INTEGER_template& isAbstractBit();
const INTEGER_template& isAbstractBit() const;
INTEGER_template& writeMaskBit();
const INTEGER_template& writeMaskBit() const;
INTEGER_template& userWriteMaskBit();
const INTEGER_template& userWriteMaskBit() const;
DataTypeAttributes_reserveBits_template& reserveBits();
const DataTypeAttributes_reserveBits_template& reserveBits() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
INTEGER_template& isAbstract();
const INTEGER_template& isAbstract() const;
INTEGER_template& writeMask();
const INTEGER_template& writeMask() const;
INTEGER_template& userWriteMask();
const INTEGER_template& userWriteMask() const;
int size_of() const;
void log() const;
void log_match(const DataTypeAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ViewAttributes : public Base_Type {
  INTEGER field_displayNameBit;
  INTEGER field_descriptionBit;
  INTEGER field_containsNoLoopsBit;
  INTEGER field_eventNotifierBit;
  INTEGER field_writeMaskBit;
  INTEGER field_userWriteMaskBit;
  ViewAttributes_reserveBits field_reserveBits;
  OPTIONAL<LocalizedText> field_displayName;
  OPTIONAL<LocalizedText> field_description;
  OPTIONAL<INTEGER> field_containsNoLoops;
  OPTIONAL<INTEGER> field_eventNotifier;
  OPTIONAL<INTEGER> field_writeMask;
  OPTIONAL<INTEGER> field_userWriteMask;
public:
  ViewAttributes();
  ViewAttributes(const INTEGER& par_displayNameBit,
    const INTEGER& par_descriptionBit,
    const INTEGER& par_containsNoLoopsBit,
    const INTEGER& par_eventNotifierBit,
    const INTEGER& par_writeMaskBit,
    const INTEGER& par_userWriteMaskBit,
    const ViewAttributes_reserveBits& par_reserveBits,
    const OPTIONAL<LocalizedText>& par_displayName,
    const OPTIONAL<LocalizedText>& par_description,
    const OPTIONAL<INTEGER>& par_containsNoLoops,
    const OPTIONAL<INTEGER>& par_eventNotifier,
    const OPTIONAL<INTEGER>& par_writeMask,
    const OPTIONAL<INTEGER>& par_userWriteMask);
  ViewAttributes(const ViewAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ViewAttributes& operator=(const ViewAttributes& other_value);
  boolean operator==(const ViewAttributes& other_value) const;
  inline boolean operator!=(const ViewAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& displayNameBit()
    {return field_displayNameBit;}
  inline const INTEGER& displayNameBit() const
    {return field_displayNameBit;}
  inline INTEGER& descriptionBit()
    {return field_descriptionBit;}
  inline const INTEGER& descriptionBit() const
    {return field_descriptionBit;}
  inline INTEGER& containsNoLoopsBit()
    {return field_containsNoLoopsBit;}
  inline const INTEGER& containsNoLoopsBit() const
    {return field_containsNoLoopsBit;}
  inline INTEGER& eventNotifierBit()
    {return field_eventNotifierBit;}
  inline const INTEGER& eventNotifierBit() const
    {return field_eventNotifierBit;}
  inline INTEGER& writeMaskBit()
    {return field_writeMaskBit;}
  inline const INTEGER& writeMaskBit() const
    {return field_writeMaskBit;}
  inline INTEGER& userWriteMaskBit()
    {return field_userWriteMaskBit;}
  inline const INTEGER& userWriteMaskBit() const
    {return field_userWriteMaskBit;}
  inline ViewAttributes_reserveBits& reserveBits()
    {return field_reserveBits;}
  inline const ViewAttributes_reserveBits& reserveBits() const
    {return field_reserveBits;}
  inline OPTIONAL<LocalizedText>& displayName()
    {return field_displayName;}
  inline const OPTIONAL<LocalizedText>& displayName() const
    {return field_displayName;}
  inline OPTIONAL<LocalizedText>& description()
    {return field_description;}
  inline const OPTIONAL<LocalizedText>& description() const
    {return field_description;}
  inline OPTIONAL<INTEGER>& containsNoLoops()
    {return field_containsNoLoops;}
  inline const OPTIONAL<INTEGER>& containsNoLoops() const
    {return field_containsNoLoops;}
  inline OPTIONAL<INTEGER>& eventNotifier()
    {return field_eventNotifier;}
  inline const OPTIONAL<INTEGER>& eventNotifier() const
    {return field_eventNotifier;}
  inline OPTIONAL<INTEGER>& writeMask()
    {return field_writeMask;}
  inline const OPTIONAL<INTEGER>& writeMask() const
    {return field_writeMask;}
  inline OPTIONAL<INTEGER>& userWriteMask()
    {return field_userWriteMask;}
  inline const OPTIONAL<INTEGER>& userWriteMask() const
    {return field_userWriteMask;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ViewAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ViewAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ViewAttributes& other_value);
void copy_template(const ViewAttributes_template& other_value);

public:
ViewAttributes_template();
ViewAttributes_template(template_sel other_value);
ViewAttributes_template(const ViewAttributes& other_value);
ViewAttributes_template(const OPTIONAL<ViewAttributes>& other_value);
ViewAttributes_template(const ViewAttributes_template& other_value);
~ViewAttributes_template();
ViewAttributes_template& operator=(template_sel other_value);
ViewAttributes_template& operator=(const ViewAttributes& other_value);
ViewAttributes_template& operator=(const OPTIONAL<ViewAttributes>& other_value);
ViewAttributes_template& operator=(const ViewAttributes_template& other_value);
boolean match(const ViewAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ViewAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ViewAttributes_template& list_item(unsigned int list_index) const;
INTEGER_template& displayNameBit();
const INTEGER_template& displayNameBit() const;
INTEGER_template& descriptionBit();
const INTEGER_template& descriptionBit() const;
INTEGER_template& containsNoLoopsBit();
const INTEGER_template& containsNoLoopsBit() const;
INTEGER_template& eventNotifierBit();
const INTEGER_template& eventNotifierBit() const;
INTEGER_template& writeMaskBit();
const INTEGER_template& writeMaskBit() const;
INTEGER_template& userWriteMaskBit();
const INTEGER_template& userWriteMaskBit() const;
ViewAttributes_reserveBits_template& reserveBits();
const ViewAttributes_reserveBits_template& reserveBits() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
INTEGER_template& containsNoLoops();
const INTEGER_template& containsNoLoops() const;
INTEGER_template& eventNotifier();
const INTEGER_template& eventNotifier() const;
INTEGER_template& writeMask();
const INTEGER_template& writeMask() const;
INTEGER_template& userWriteMask();
const INTEGER_template& userWriteMask() const;
int size_of() const;
void log() const;
void log_match(const ViewAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfGenericAttributeValue : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfGenericAttributeValueArray *field_realArray;
};
void copy_value(const ListOfGenericAttributeValue& other_value);

public:
ListOfGenericAttributeValue();
ListOfGenericAttributeValue(const ListOfGenericAttributeValue& other_value);
~ListOfGenericAttributeValue();
ListOfGenericAttributeValue& operator=(const ListOfGenericAttributeValue& other_value);
boolean operator==(const ListOfGenericAttributeValue& other_value) const;
inline boolean operator!=(const ListOfGenericAttributeValue& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfGenericAttributeValueArray& realArray();
const ListOfGenericAttributeValueArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfGenericAttributeValue_template : public Base_Template {
union {
struct {
ListOfGenericAttributeValue::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfGenericAttributeValueArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfGenericAttributeValue_template *list_value;
} value_list;
};
void copy_value(const ListOfGenericAttributeValue& other_value);

void copy_template(const ListOfGenericAttributeValue_template& other_value);

public:
ListOfGenericAttributeValue_template();
ListOfGenericAttributeValue_template(template_sel other_value);
ListOfGenericAttributeValue_template(const ListOfGenericAttributeValue& other_value);
ListOfGenericAttributeValue_template(const OPTIONAL<ListOfGenericAttributeValue>& other_value);
ListOfGenericAttributeValue_template(const ListOfGenericAttributeValue_template& other_value);
~ListOfGenericAttributeValue_template();
void clean_up();
ListOfGenericAttributeValue_template& operator=(template_sel other_value);
ListOfGenericAttributeValue_template& operator=(const ListOfGenericAttributeValue& other_value);
ListOfGenericAttributeValue_template& operator=(const OPTIONAL<ListOfGenericAttributeValue>& other_value);
ListOfGenericAttributeValue_template& operator=(const ListOfGenericAttributeValue_template& other_value);
boolean match(const ListOfGenericAttributeValue& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfGenericAttributeValue valueof() const;
ListOfGenericAttributeValue_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfGenericAttributeValueArray_template& realArray();
const ListOfGenericAttributeValueArray_template& realArray() const;
boolean ischosen(ListOfGenericAttributeValue::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfGenericAttributeValue& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class GenericAttributeValueArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
GenericAttributeValue **value_elements;
} *val_ptr;

static const GenericAttributeValue UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const GenericAttributeValueArray& other_value);

public:
  typedef GenericAttributeValue of_type;
GenericAttributeValueArray();
GenericAttributeValueArray(null_type other_value);
GenericAttributeValueArray(const GenericAttributeValueArray& other_value);
~GenericAttributeValueArray();

void clean_up();
GenericAttributeValueArray& operator=(null_type other_value);
GenericAttributeValueArray& operator=(const GenericAttributeValueArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const GenericAttributeValueArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const GenericAttributeValueArray& other_value) const { return !(*this == other_value); }

GenericAttributeValue& operator[](int index_value);
GenericAttributeValue& operator[](const INTEGER& index_value);
const GenericAttributeValue& operator[](int index_value) const;
const GenericAttributeValue& operator[](const INTEGER& index_value) const;

GenericAttributeValueArray operator<<=(int rotate_count) const;
GenericAttributeValueArray operator<<=(const INTEGER& rotate_count) const;
GenericAttributeValueArray operator>>=(int rotate_count) const;
GenericAttributeValueArray operator>>=(const INTEGER& rotate_count) const;

GenericAttributeValueArray operator+(const GenericAttributeValueArray& other_value) const;

GenericAttributeValueArray substr(int index, int returncount) const;

GenericAttributeValueArray replace(int index, int len, const GenericAttributeValueArray& repl) const;

GenericAttributeValueArray replace(int index, int len, const GenericAttributeValueArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GenericAttributeValueArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
GenericAttributeValue_template **value_elements;
} single_value;
struct {
unsigned int n_values;
GenericAttributeValueArray_template *list_value;
} value_list;
};
void copy_value(const GenericAttributeValueArray& other_value);
void copy_template(const GenericAttributeValueArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
GenericAttributeValueArray_template();
GenericAttributeValueArray_template(template_sel other_value);
GenericAttributeValueArray_template(null_type other_value);
GenericAttributeValueArray_template(const GenericAttributeValueArray& other_value);
GenericAttributeValueArray_template(const OPTIONAL<GenericAttributeValueArray>& other_value);
GenericAttributeValueArray_template(const GenericAttributeValueArray_template& other_value);
~GenericAttributeValueArray_template();

void clean_up();
GenericAttributeValueArray_template& operator=(template_sel other_value);
GenericAttributeValueArray_template& operator=(null_type other_value);
GenericAttributeValueArray_template& operator=(const GenericAttributeValueArray& other_value);
GenericAttributeValueArray_template& operator=(const OPTIONAL<GenericAttributeValueArray>& other_value);
GenericAttributeValueArray_template& operator=(const GenericAttributeValueArray_template& other_value);

GenericAttributeValue_template& operator[](int index_value);
GenericAttributeValue_template& operator[](const INTEGER& index_value);
const GenericAttributeValue_template& operator[](int index_value) const;
const GenericAttributeValue_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const GenericAttributeValueArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
GenericAttributeValueArray valueof() const;
GenericAttributeValueArray substr(int index, int returncount) const;

GenericAttributeValueArray replace(int index, int len, const GenericAttributeValueArray_template& repl) const;

GenericAttributeValueArray replace(int index, int len, const GenericAttributeValueArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
GenericAttributeValueArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const GenericAttributeValueArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class GenericAttributeValue : public Base_Type {
  INTEGER field_attributeId;
  Variant field_Value;
public:
  GenericAttributeValue();
  GenericAttributeValue(const INTEGER& par_attributeId,
    const Variant& par_Value);
  GenericAttributeValue(const GenericAttributeValue& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenericAttributeValue& operator=(const GenericAttributeValue& other_value);
  boolean operator==(const GenericAttributeValue& other_value) const;
  inline boolean operator!=(const GenericAttributeValue& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& attributeId()
    {return field_attributeId;}
  inline const INTEGER& attributeId() const
    {return field_attributeId;}
  inline Variant& Value()
    {return field_Value;}
  inline const Variant& Value() const
    {return field_Value;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GenericAttributeValue_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenericAttributeValue_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenericAttributeValue& other_value);
void copy_template(const GenericAttributeValue_template& other_value);

public:
GenericAttributeValue_template();
GenericAttributeValue_template(template_sel other_value);
GenericAttributeValue_template(const GenericAttributeValue& other_value);
GenericAttributeValue_template(const OPTIONAL<GenericAttributeValue>& other_value);
GenericAttributeValue_template(const GenericAttributeValue_template& other_value);
~GenericAttributeValue_template();
GenericAttributeValue_template& operator=(template_sel other_value);
GenericAttributeValue_template& operator=(const GenericAttributeValue& other_value);
GenericAttributeValue_template& operator=(const OPTIONAL<GenericAttributeValue>& other_value);
GenericAttributeValue_template& operator=(const GenericAttributeValue_template& other_value);
boolean match(const GenericAttributeValue& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenericAttributeValue valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenericAttributeValue_template& list_item(unsigned int list_index) const;
INTEGER_template& attributeId();
const INTEGER_template& attributeId() const;
Variant_template& Value();
const Variant_template& Value() const;
int size_of() const;
void log() const;
void log_match(const GenericAttributeValue& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfGenericAttributeValueArray : public Base_Type {
  INTEGER field_arrayLength;
  GenericAttributeValueArray field_arrayValues;
public:
  ListOfGenericAttributeValueArray();
  ListOfGenericAttributeValueArray(const INTEGER& par_arrayLength,
    const GenericAttributeValueArray& par_arrayValues);
  ListOfGenericAttributeValueArray(const ListOfGenericAttributeValueArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfGenericAttributeValueArray& operator=(const ListOfGenericAttributeValueArray& other_value);
  boolean operator==(const ListOfGenericAttributeValueArray& other_value) const;
  inline boolean operator!=(const ListOfGenericAttributeValueArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline GenericAttributeValueArray& arrayValues()
    {return field_arrayValues;}
  inline const GenericAttributeValueArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfGenericAttributeValueArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfGenericAttributeValueArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfGenericAttributeValueArray& other_value);
void copy_template(const ListOfGenericAttributeValueArray_template& other_value);

public:
ListOfGenericAttributeValueArray_template();
ListOfGenericAttributeValueArray_template(template_sel other_value);
ListOfGenericAttributeValueArray_template(const ListOfGenericAttributeValueArray& other_value);
ListOfGenericAttributeValueArray_template(const OPTIONAL<ListOfGenericAttributeValueArray>& other_value);
ListOfGenericAttributeValueArray_template(const ListOfGenericAttributeValueArray_template& other_value);
~ListOfGenericAttributeValueArray_template();
ListOfGenericAttributeValueArray_template& operator=(template_sel other_value);
ListOfGenericAttributeValueArray_template& operator=(const ListOfGenericAttributeValueArray& other_value);
ListOfGenericAttributeValueArray_template& operator=(const OPTIONAL<ListOfGenericAttributeValueArray>& other_value);
ListOfGenericAttributeValueArray_template& operator=(const ListOfGenericAttributeValueArray_template& other_value);
boolean match(const ListOfGenericAttributeValueArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfGenericAttributeValueArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfGenericAttributeValueArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
GenericAttributeValueArray_template& arrayValues();
const GenericAttributeValueArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfGenericAttributeValueArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GenericAttributes : public Base_Type {
  ListOfGenericAttributeValue field_attributeValues;
public:
  GenericAttributes();
  GenericAttributes(const ListOfGenericAttributeValue& par_attributeValues);
  GenericAttributes(const GenericAttributes& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GenericAttributes& operator=(const GenericAttributes& other_value);
  boolean operator==(const GenericAttributes& other_value) const;
  inline boolean operator!=(const GenericAttributes& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfGenericAttributeValue& attributeValues()
    {return field_attributeValues;}
  inline const ListOfGenericAttributeValue& attributeValues() const
    {return field_attributeValues;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GenericAttributes_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GenericAttributes_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GenericAttributes& other_value);
void copy_template(const GenericAttributes_template& other_value);

public:
GenericAttributes_template();
GenericAttributes_template(template_sel other_value);
GenericAttributes_template(const GenericAttributes& other_value);
GenericAttributes_template(const OPTIONAL<GenericAttributes>& other_value);
GenericAttributes_template(const GenericAttributes_template& other_value);
~GenericAttributes_template();
GenericAttributes_template& operator=(template_sel other_value);
GenericAttributes_template& operator=(const GenericAttributes& other_value);
GenericAttributes_template& operator=(const OPTIONAL<GenericAttributes>& other_value);
GenericAttributes_template& operator=(const GenericAttributes_template& other_value);
boolean match(const GenericAttributes& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GenericAttributes valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GenericAttributes_template& list_item(unsigned int list_index) const;
ListOfGenericAttributeValue_template& attributeValues();
const ListOfGenericAttributeValue_template& attributeValues() const;
int size_of() const;
void log() const;
void log_match(const GenericAttributes& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UserNameIdentityToken : public Base_Type {
  String field_policyId;
  String field_userName;
  ByteString field_password;
  String field_encryptionAlgorithm;
public:
  UserNameIdentityToken();
  UserNameIdentityToken(const String& par_policyId,
    const String& par_userName,
    const ByteString& par_password,
    const String& par_encryptionAlgorithm);
  UserNameIdentityToken(const UserNameIdentityToken& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UserNameIdentityToken& operator=(const UserNameIdentityToken& other_value);
  boolean operator==(const UserNameIdentityToken& other_value) const;
  inline boolean operator!=(const UserNameIdentityToken& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& policyId()
    {return field_policyId;}
  inline const String& policyId() const
    {return field_policyId;}
  inline String& userName()
    {return field_userName;}
  inline const String& userName() const
    {return field_userName;}
  inline ByteString& password()
    {return field_password;}
  inline const ByteString& password() const
    {return field_password;}
  inline String& encryptionAlgorithm()
    {return field_encryptionAlgorithm;}
  inline const String& encryptionAlgorithm() const
    {return field_encryptionAlgorithm;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UserNameIdentityToken_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UserNameIdentityToken_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UserNameIdentityToken& other_value);
void copy_template(const UserNameIdentityToken_template& other_value);

public:
UserNameIdentityToken_template();
UserNameIdentityToken_template(template_sel other_value);
UserNameIdentityToken_template(const UserNameIdentityToken& other_value);
UserNameIdentityToken_template(const OPTIONAL<UserNameIdentityToken>& other_value);
UserNameIdentityToken_template(const UserNameIdentityToken_template& other_value);
~UserNameIdentityToken_template();
UserNameIdentityToken_template& operator=(template_sel other_value);
UserNameIdentityToken_template& operator=(const UserNameIdentityToken& other_value);
UserNameIdentityToken_template& operator=(const OPTIONAL<UserNameIdentityToken>& other_value);
UserNameIdentityToken_template& operator=(const UserNameIdentityToken_template& other_value);
boolean match(const UserNameIdentityToken& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UserNameIdentityToken valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UserNameIdentityToken_template& list_item(unsigned int list_index) const;
String_template& policyId();
const String_template& policyId() const;
String_template& userName();
const String_template& userName() const;
ByteString_template& password();
const ByteString_template& password() const;
String_template& encryptionAlgorithm();
const String_template& encryptionAlgorithm() const;
int size_of() const;
void log() const;
void log_match(const UserNameIdentityToken& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class X509IdentityToken : public Base_Type {
  String field_policyId;
  ByteString field_certificateData;
public:
  X509IdentityToken();
  X509IdentityToken(const String& par_policyId,
    const ByteString& par_certificateData);
  X509IdentityToken(const X509IdentityToken& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  X509IdentityToken& operator=(const X509IdentityToken& other_value);
  boolean operator==(const X509IdentityToken& other_value) const;
  inline boolean operator!=(const X509IdentityToken& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& policyId()
    {return field_policyId;}
  inline const String& policyId() const
    {return field_policyId;}
  inline ByteString& certificateData()
    {return field_certificateData;}
  inline const ByteString& certificateData() const
    {return field_certificateData;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class X509IdentityToken_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
X509IdentityToken_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const X509IdentityToken& other_value);
void copy_template(const X509IdentityToken_template& other_value);

public:
X509IdentityToken_template();
X509IdentityToken_template(template_sel other_value);
X509IdentityToken_template(const X509IdentityToken& other_value);
X509IdentityToken_template(const OPTIONAL<X509IdentityToken>& other_value);
X509IdentityToken_template(const X509IdentityToken_template& other_value);
~X509IdentityToken_template();
X509IdentityToken_template& operator=(template_sel other_value);
X509IdentityToken_template& operator=(const X509IdentityToken& other_value);
X509IdentityToken_template& operator=(const OPTIONAL<X509IdentityToken>& other_value);
X509IdentityToken_template& operator=(const X509IdentityToken_template& other_value);
boolean match(const X509IdentityToken& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
X509IdentityToken valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
X509IdentityToken_template& list_item(unsigned int list_index) const;
String_template& policyId();
const String_template& policyId() const;
ByteString_template& certificateData();
const ByteString_template& certificateData() const;
int size_of() const;
void log() const;
void log_match(const X509IdentityToken& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class IssuedIdentityToken : public Base_Type {
  String field_policyId;
  ByteString field_tokenData;
  String field_encryptionAlgorithm;
public:
  IssuedIdentityToken();
  IssuedIdentityToken(const String& par_policyId,
    const ByteString& par_tokenData,
    const String& par_encryptionAlgorithm);
  IssuedIdentityToken(const IssuedIdentityToken& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  IssuedIdentityToken& operator=(const IssuedIdentityToken& other_value);
  boolean operator==(const IssuedIdentityToken& other_value) const;
  inline boolean operator!=(const IssuedIdentityToken& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& policyId()
    {return field_policyId;}
  inline const String& policyId() const
    {return field_policyId;}
  inline ByteString& tokenData()
    {return field_tokenData;}
  inline const ByteString& tokenData() const
    {return field_tokenData;}
  inline String& encryptionAlgorithm()
    {return field_encryptionAlgorithm;}
  inline const String& encryptionAlgorithm() const
    {return field_encryptionAlgorithm;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class IssuedIdentityToken_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
IssuedIdentityToken_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const IssuedIdentityToken& other_value);
void copy_template(const IssuedIdentityToken_template& other_value);

public:
IssuedIdentityToken_template();
IssuedIdentityToken_template(template_sel other_value);
IssuedIdentityToken_template(const IssuedIdentityToken& other_value);
IssuedIdentityToken_template(const OPTIONAL<IssuedIdentityToken>& other_value);
IssuedIdentityToken_template(const IssuedIdentityToken_template& other_value);
~IssuedIdentityToken_template();
IssuedIdentityToken_template& operator=(template_sel other_value);
IssuedIdentityToken_template& operator=(const IssuedIdentityToken& other_value);
IssuedIdentityToken_template& operator=(const OPTIONAL<IssuedIdentityToken>& other_value);
IssuedIdentityToken_template& operator=(const IssuedIdentityToken_template& other_value);
boolean match(const IssuedIdentityToken& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
IssuedIdentityToken valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
IssuedIdentityToken_template& list_item(unsigned int list_index) const;
String_template& policyId();
const String_template& policyId() const;
ByteString_template& tokenData();
const ByteString_template& tokenData() const;
String_template& encryptionAlgorithm();
const String_template& encryptionAlgorithm() const;
int size_of() const;
void log() const;
void log_match(const IssuedIdentityToken& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AnonymousIdentityToken : public Base_Type {
  String field_policyId;
public:
  AnonymousIdentityToken();
  AnonymousIdentityToken(const String& par_policyId);
  AnonymousIdentityToken(const AnonymousIdentityToken& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AnonymousIdentityToken& operator=(const AnonymousIdentityToken& other_value);
  boolean operator==(const AnonymousIdentityToken& other_value) const;
  inline boolean operator!=(const AnonymousIdentityToken& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& policyId()
    {return field_policyId;}
  inline const String& policyId() const
    {return field_policyId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AnonymousIdentityToken_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AnonymousIdentityToken_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AnonymousIdentityToken& other_value);
void copy_template(const AnonymousIdentityToken_template& other_value);

public:
AnonymousIdentityToken_template();
AnonymousIdentityToken_template(template_sel other_value);
AnonymousIdentityToken_template(const AnonymousIdentityToken& other_value);
AnonymousIdentityToken_template(const OPTIONAL<AnonymousIdentityToken>& other_value);
AnonymousIdentityToken_template(const AnonymousIdentityToken_template& other_value);
~AnonymousIdentityToken_template();
AnonymousIdentityToken_template& operator=(template_sel other_value);
AnonymousIdentityToken_template& operator=(const AnonymousIdentityToken& other_value);
AnonymousIdentityToken_template& operator=(const OPTIONAL<AnonymousIdentityToken>& other_value);
AnonymousIdentityToken_template& operator=(const AnonymousIdentityToken_template& other_value);
boolean match(const AnonymousIdentityToken& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AnonymousIdentityToken valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AnonymousIdentityToken_template& list_item(unsigned int list_index) const;
String_template& policyId();
const String_template& policyId() const;
int size_of() const;
void log() const;
void log_match(const AnonymousIdentityToken& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MdnsDiscoveryConfiguration : public Base_Type {
  String field_mdnsServerName;
  ListOfString field_serverCapabilities;
public:
  MdnsDiscoveryConfiguration();
  MdnsDiscoveryConfiguration(const String& par_mdnsServerName,
    const ListOfString& par_serverCapabilities);
  MdnsDiscoveryConfiguration(const MdnsDiscoveryConfiguration& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MdnsDiscoveryConfiguration& operator=(const MdnsDiscoveryConfiguration& other_value);
  boolean operator==(const MdnsDiscoveryConfiguration& other_value) const;
  inline boolean operator!=(const MdnsDiscoveryConfiguration& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& mdnsServerName()
    {return field_mdnsServerName;}
  inline const String& mdnsServerName() const
    {return field_mdnsServerName;}
  inline ListOfString& serverCapabilities()
    {return field_serverCapabilities;}
  inline const ListOfString& serverCapabilities() const
    {return field_serverCapabilities;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MdnsDiscoveryConfiguration_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MdnsDiscoveryConfiguration_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MdnsDiscoveryConfiguration& other_value);
void copy_template(const MdnsDiscoveryConfiguration_template& other_value);

public:
MdnsDiscoveryConfiguration_template();
MdnsDiscoveryConfiguration_template(template_sel other_value);
MdnsDiscoveryConfiguration_template(const MdnsDiscoveryConfiguration& other_value);
MdnsDiscoveryConfiguration_template(const OPTIONAL<MdnsDiscoveryConfiguration>& other_value);
MdnsDiscoveryConfiguration_template(const MdnsDiscoveryConfiguration_template& other_value);
~MdnsDiscoveryConfiguration_template();
MdnsDiscoveryConfiguration_template& operator=(template_sel other_value);
MdnsDiscoveryConfiguration_template& operator=(const MdnsDiscoveryConfiguration& other_value);
MdnsDiscoveryConfiguration_template& operator=(const OPTIONAL<MdnsDiscoveryConfiguration>& other_value);
MdnsDiscoveryConfiguration_template& operator=(const MdnsDiscoveryConfiguration_template& other_value);
boolean match(const MdnsDiscoveryConfiguration& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MdnsDiscoveryConfiguration valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MdnsDiscoveryConfiguration_template& list_item(unsigned int list_index) const;
String_template& mdnsServerName();
const String_template& mdnsServerName() const;
ListOfString_template& serverCapabilities();
const ListOfString_template& serverCapabilities() const;
int size_of() const;
void log() const;
void log_match(const MdnsDiscoveryConfiguration& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReadEventDetails : public Base_Type {
  INTEGER field_numValuesPerNode;
  INTEGER field_startTime;
  INTEGER field_endTime;
  EventFilter field_Filter;
public:
  ReadEventDetails();
  ReadEventDetails(const INTEGER& par_numValuesPerNode,
    const INTEGER& par_startTime,
    const INTEGER& par_endTime,
    const EventFilter& par_Filter);
  ReadEventDetails(const ReadEventDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReadEventDetails& operator=(const ReadEventDetails& other_value);
  boolean operator==(const ReadEventDetails& other_value) const;
  inline boolean operator!=(const ReadEventDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& numValuesPerNode()
    {return field_numValuesPerNode;}
  inline const INTEGER& numValuesPerNode() const
    {return field_numValuesPerNode;}
  inline INTEGER& startTime()
    {return field_startTime;}
  inline const INTEGER& startTime() const
    {return field_startTime;}
  inline INTEGER& endTime()
    {return field_endTime;}
  inline const INTEGER& endTime() const
    {return field_endTime;}
  inline EventFilter& Filter()
    {return field_Filter;}
  inline const EventFilter& Filter() const
    {return field_Filter;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReadEventDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReadEventDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReadEventDetails& other_value);
void copy_template(const ReadEventDetails_template& other_value);

public:
ReadEventDetails_template();
ReadEventDetails_template(template_sel other_value);
ReadEventDetails_template(const ReadEventDetails& other_value);
ReadEventDetails_template(const OPTIONAL<ReadEventDetails>& other_value);
ReadEventDetails_template(const ReadEventDetails_template& other_value);
~ReadEventDetails_template();
ReadEventDetails_template& operator=(template_sel other_value);
ReadEventDetails_template& operator=(const ReadEventDetails& other_value);
ReadEventDetails_template& operator=(const OPTIONAL<ReadEventDetails>& other_value);
ReadEventDetails_template& operator=(const ReadEventDetails_template& other_value);
boolean match(const ReadEventDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReadEventDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReadEventDetails_template& list_item(unsigned int list_index) const;
INTEGER_template& numValuesPerNode();
const INTEGER_template& numValuesPerNode() const;
INTEGER_template& startTime();
const INTEGER_template& startTime() const;
INTEGER_template& endTime();
const INTEGER_template& endTime() const;
EventFilter_template& Filter();
const EventFilter_template& Filter() const;
int size_of() const;
void log() const;
void log_match(const ReadEventDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReadRawModifiedDetails : public Base_Type {
  INTEGER field_isReadModified;
  INTEGER field_startTime;
  INTEGER field_endTime;
  INTEGER field_numValuesPerNode;
  INTEGER field_returnBounds;
public:
  ReadRawModifiedDetails();
  ReadRawModifiedDetails(const INTEGER& par_isReadModified,
    const INTEGER& par_startTime,
    const INTEGER& par_endTime,
    const INTEGER& par_numValuesPerNode,
    const INTEGER& par_returnBounds);
  ReadRawModifiedDetails(const ReadRawModifiedDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReadRawModifiedDetails& operator=(const ReadRawModifiedDetails& other_value);
  boolean operator==(const ReadRawModifiedDetails& other_value) const;
  inline boolean operator!=(const ReadRawModifiedDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& isReadModified()
    {return field_isReadModified;}
  inline const INTEGER& isReadModified() const
    {return field_isReadModified;}
  inline INTEGER& startTime()
    {return field_startTime;}
  inline const INTEGER& startTime() const
    {return field_startTime;}
  inline INTEGER& endTime()
    {return field_endTime;}
  inline const INTEGER& endTime() const
    {return field_endTime;}
  inline INTEGER& numValuesPerNode()
    {return field_numValuesPerNode;}
  inline const INTEGER& numValuesPerNode() const
    {return field_numValuesPerNode;}
  inline INTEGER& returnBounds()
    {return field_returnBounds;}
  inline const INTEGER& returnBounds() const
    {return field_returnBounds;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReadRawModifiedDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReadRawModifiedDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReadRawModifiedDetails& other_value);
void copy_template(const ReadRawModifiedDetails_template& other_value);

public:
ReadRawModifiedDetails_template();
ReadRawModifiedDetails_template(template_sel other_value);
ReadRawModifiedDetails_template(const ReadRawModifiedDetails& other_value);
ReadRawModifiedDetails_template(const OPTIONAL<ReadRawModifiedDetails>& other_value);
ReadRawModifiedDetails_template(const ReadRawModifiedDetails_template& other_value);
~ReadRawModifiedDetails_template();
ReadRawModifiedDetails_template& operator=(template_sel other_value);
ReadRawModifiedDetails_template& operator=(const ReadRawModifiedDetails& other_value);
ReadRawModifiedDetails_template& operator=(const OPTIONAL<ReadRawModifiedDetails>& other_value);
ReadRawModifiedDetails_template& operator=(const ReadRawModifiedDetails_template& other_value);
boolean match(const ReadRawModifiedDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReadRawModifiedDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReadRawModifiedDetails_template& list_item(unsigned int list_index) const;
INTEGER_template& isReadModified();
const INTEGER_template& isReadModified() const;
INTEGER_template& startTime();
const INTEGER_template& startTime() const;
INTEGER_template& endTime();
const INTEGER_template& endTime() const;
INTEGER_template& numValuesPerNode();
const INTEGER_template& numValuesPerNode() const;
INTEGER_template& returnBounds();
const INTEGER_template& returnBounds() const;
int size_of() const;
void log() const;
void log_match(const ReadRawModifiedDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReadProcessedDetails : public Base_Type {
  INTEGER field_startTime;
  INTEGER field_endTime;
  FLOAT field_ProcessingInterval;
  ListOfNodeId field_aggregateType;
  AggregateConfiguration field_aggregateConfiguration;
public:
  ReadProcessedDetails();
  ReadProcessedDetails(const INTEGER& par_startTime,
    const INTEGER& par_endTime,
    const FLOAT& par_ProcessingInterval,
    const ListOfNodeId& par_aggregateType,
    const AggregateConfiguration& par_aggregateConfiguration);
  ReadProcessedDetails(const ReadProcessedDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReadProcessedDetails& operator=(const ReadProcessedDetails& other_value);
  boolean operator==(const ReadProcessedDetails& other_value) const;
  inline boolean operator!=(const ReadProcessedDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& startTime()
    {return field_startTime;}
  inline const INTEGER& startTime() const
    {return field_startTime;}
  inline INTEGER& endTime()
    {return field_endTime;}
  inline const INTEGER& endTime() const
    {return field_endTime;}
  inline FLOAT& ProcessingInterval()
    {return field_ProcessingInterval;}
  inline const FLOAT& ProcessingInterval() const
    {return field_ProcessingInterval;}
  inline ListOfNodeId& aggregateType()
    {return field_aggregateType;}
  inline const ListOfNodeId& aggregateType() const
    {return field_aggregateType;}
  inline AggregateConfiguration& aggregateConfiguration()
    {return field_aggregateConfiguration;}
  inline const AggregateConfiguration& aggregateConfiguration() const
    {return field_aggregateConfiguration;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReadProcessedDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReadProcessedDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReadProcessedDetails& other_value);
void copy_template(const ReadProcessedDetails_template& other_value);

public:
ReadProcessedDetails_template();
ReadProcessedDetails_template(template_sel other_value);
ReadProcessedDetails_template(const ReadProcessedDetails& other_value);
ReadProcessedDetails_template(const OPTIONAL<ReadProcessedDetails>& other_value);
ReadProcessedDetails_template(const ReadProcessedDetails_template& other_value);
~ReadProcessedDetails_template();
ReadProcessedDetails_template& operator=(template_sel other_value);
ReadProcessedDetails_template& operator=(const ReadProcessedDetails& other_value);
ReadProcessedDetails_template& operator=(const OPTIONAL<ReadProcessedDetails>& other_value);
ReadProcessedDetails_template& operator=(const ReadProcessedDetails_template& other_value);
boolean match(const ReadProcessedDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReadProcessedDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReadProcessedDetails_template& list_item(unsigned int list_index) const;
INTEGER_template& startTime();
const INTEGER_template& startTime() const;
INTEGER_template& endTime();
const INTEGER_template& endTime() const;
FLOAT_template& ProcessingInterval();
const FLOAT_template& ProcessingInterval() const;
ListOfNodeId_template& aggregateType();
const ListOfNodeId_template& aggregateType() const;
AggregateConfiguration_template& aggregateConfiguration();
const AggregateConfiguration_template& aggregateConfiguration() const;
int size_of() const;
void log() const;
void log_match(const ReadProcessedDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfUtcTime : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfUtcTimeArray *field_realArray;
};
void copy_value(const ListOfUtcTime& other_value);

public:
ListOfUtcTime();
ListOfUtcTime(const ListOfUtcTime& other_value);
~ListOfUtcTime();
ListOfUtcTime& operator=(const ListOfUtcTime& other_value);
boolean operator==(const ListOfUtcTime& other_value) const;
inline boolean operator!=(const ListOfUtcTime& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfUtcTimeArray& realArray();
const ListOfUtcTimeArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUtcTime_template : public Base_Template {
union {
struct {
ListOfUtcTime::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfUtcTimeArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfUtcTime_template *list_value;
} value_list;
};
void copy_value(const ListOfUtcTime& other_value);

void copy_template(const ListOfUtcTime_template& other_value);

public:
ListOfUtcTime_template();
ListOfUtcTime_template(template_sel other_value);
ListOfUtcTime_template(const ListOfUtcTime& other_value);
ListOfUtcTime_template(const OPTIONAL<ListOfUtcTime>& other_value);
ListOfUtcTime_template(const ListOfUtcTime_template& other_value);
~ListOfUtcTime_template();
void clean_up();
ListOfUtcTime_template& operator=(template_sel other_value);
ListOfUtcTime_template& operator=(const ListOfUtcTime& other_value);
ListOfUtcTime_template& operator=(const OPTIONAL<ListOfUtcTime>& other_value);
ListOfUtcTime_template& operator=(const ListOfUtcTime_template& other_value);
boolean match(const ListOfUtcTime& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfUtcTime valueof() const;
ListOfUtcTime_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfUtcTimeArray_template& realArray();
const ListOfUtcTimeArray_template& realArray() const;
boolean ischosen(ListOfUtcTime::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfUtcTime& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfUtcTimeArray : public Base_Type {
  INTEGER field_arrayLength;
  UtcTimeArray field_arrayValues;
public:
  ListOfUtcTimeArray();
  ListOfUtcTimeArray(const INTEGER& par_arrayLength,
    const UtcTimeArray& par_arrayValues);
  ListOfUtcTimeArray(const ListOfUtcTimeArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfUtcTimeArray& operator=(const ListOfUtcTimeArray& other_value);
  boolean operator==(const ListOfUtcTimeArray& other_value) const;
  inline boolean operator!=(const ListOfUtcTimeArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline UtcTimeArray& arrayValues()
    {return field_arrayValues;}
  inline const UtcTimeArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUtcTimeArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfUtcTimeArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfUtcTimeArray& other_value);
void copy_template(const ListOfUtcTimeArray_template& other_value);

public:
ListOfUtcTimeArray_template();
ListOfUtcTimeArray_template(template_sel other_value);
ListOfUtcTimeArray_template(const ListOfUtcTimeArray& other_value);
ListOfUtcTimeArray_template(const OPTIONAL<ListOfUtcTimeArray>& other_value);
ListOfUtcTimeArray_template(const ListOfUtcTimeArray_template& other_value);
~ListOfUtcTimeArray_template();
ListOfUtcTimeArray_template& operator=(template_sel other_value);
ListOfUtcTimeArray_template& operator=(const ListOfUtcTimeArray& other_value);
ListOfUtcTimeArray_template& operator=(const OPTIONAL<ListOfUtcTimeArray>& other_value);
ListOfUtcTimeArray_template& operator=(const ListOfUtcTimeArray_template& other_value);
boolean match(const ListOfUtcTimeArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfUtcTimeArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfUtcTimeArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
UtcTimeArray_template& arrayValues();
const UtcTimeArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfUtcTimeArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReadAtTimeDetails : public Base_Type {
  ListOfUtcTime field_reqTimes;
  INTEGER field_useSimpleBounds;
public:
  ReadAtTimeDetails();
  ReadAtTimeDetails(const ListOfUtcTime& par_reqTimes,
    const INTEGER& par_useSimpleBounds);
  ReadAtTimeDetails(const ReadAtTimeDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReadAtTimeDetails& operator=(const ReadAtTimeDetails& other_value);
  boolean operator==(const ReadAtTimeDetails& other_value) const;
  inline boolean operator!=(const ReadAtTimeDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfUtcTime& reqTimes()
    {return field_reqTimes;}
  inline const ListOfUtcTime& reqTimes() const
    {return field_reqTimes;}
  inline INTEGER& useSimpleBounds()
    {return field_useSimpleBounds;}
  inline const INTEGER& useSimpleBounds() const
    {return field_useSimpleBounds;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReadAtTimeDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReadAtTimeDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReadAtTimeDetails& other_value);
void copy_template(const ReadAtTimeDetails_template& other_value);

public:
ReadAtTimeDetails_template();
ReadAtTimeDetails_template(template_sel other_value);
ReadAtTimeDetails_template(const ReadAtTimeDetails& other_value);
ReadAtTimeDetails_template(const OPTIONAL<ReadAtTimeDetails>& other_value);
ReadAtTimeDetails_template(const ReadAtTimeDetails_template& other_value);
~ReadAtTimeDetails_template();
ReadAtTimeDetails_template& operator=(template_sel other_value);
ReadAtTimeDetails_template& operator=(const ReadAtTimeDetails& other_value);
ReadAtTimeDetails_template& operator=(const OPTIONAL<ReadAtTimeDetails>& other_value);
ReadAtTimeDetails_template& operator=(const ReadAtTimeDetails_template& other_value);
boolean match(const ReadAtTimeDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReadAtTimeDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReadAtTimeDetails_template& list_item(unsigned int list_index) const;
ListOfUtcTime_template& reqTimes();
const ListOfUtcTime_template& reqTimes() const;
INTEGER_template& useSimpleBounds();
const INTEGER_template& useSimpleBounds() const;
int size_of() const;
void log() const;
void log_match(const ReadAtTimeDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UpdateDataDetails : public Base_Type {
  NodeId field_nodeId;
  PerformUpdateType field_performInsertReplace;
  ListOfDataValue field_updateValues;
public:
  UpdateDataDetails();
  UpdateDataDetails(const NodeId& par_nodeId,
    const PerformUpdateType& par_performInsertReplace,
    const ListOfDataValue& par_updateValues);
  UpdateDataDetails(const UpdateDataDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UpdateDataDetails& operator=(const UpdateDataDetails& other_value);
  boolean operator==(const UpdateDataDetails& other_value) const;
  inline boolean operator!=(const UpdateDataDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline PerformUpdateType& performInsertReplace()
    {return field_performInsertReplace;}
  inline const PerformUpdateType& performInsertReplace() const
    {return field_performInsertReplace;}
  inline ListOfDataValue& updateValues()
    {return field_updateValues;}
  inline const ListOfDataValue& updateValues() const
    {return field_updateValues;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UpdateDataDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UpdateDataDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UpdateDataDetails& other_value);
void copy_template(const UpdateDataDetails_template& other_value);

public:
UpdateDataDetails_template();
UpdateDataDetails_template(template_sel other_value);
UpdateDataDetails_template(const UpdateDataDetails& other_value);
UpdateDataDetails_template(const OPTIONAL<UpdateDataDetails>& other_value);
UpdateDataDetails_template(const UpdateDataDetails_template& other_value);
~UpdateDataDetails_template();
UpdateDataDetails_template& operator=(template_sel other_value);
UpdateDataDetails_template& operator=(const UpdateDataDetails& other_value);
UpdateDataDetails_template& operator=(const OPTIONAL<UpdateDataDetails>& other_value);
UpdateDataDetails_template& operator=(const UpdateDataDetails_template& other_value);
boolean match(const UpdateDataDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UpdateDataDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UpdateDataDetails_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
PerformUpdateType_template& performInsertReplace();
const PerformUpdateType_template& performInsertReplace() const;
ListOfDataValue_template& updateValues();
const ListOfDataValue_template& updateValues() const;
int size_of() const;
void log() const;
void log_match(const UpdateDataDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UpdateStructureDataDetails : public Base_Type {
  NodeId field_nodeId;
  PerformUpdateTypeExtended field_performInsertReplace;
  ListOfDataValue field_updateValues;
public:
  UpdateStructureDataDetails();
  UpdateStructureDataDetails(const NodeId& par_nodeId,
    const PerformUpdateTypeExtended& par_performInsertReplace,
    const ListOfDataValue& par_updateValues);
  UpdateStructureDataDetails(const UpdateStructureDataDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UpdateStructureDataDetails& operator=(const UpdateStructureDataDetails& other_value);
  boolean operator==(const UpdateStructureDataDetails& other_value) const;
  inline boolean operator!=(const UpdateStructureDataDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline PerformUpdateTypeExtended& performInsertReplace()
    {return field_performInsertReplace;}
  inline const PerformUpdateTypeExtended& performInsertReplace() const
    {return field_performInsertReplace;}
  inline ListOfDataValue& updateValues()
    {return field_updateValues;}
  inline const ListOfDataValue& updateValues() const
    {return field_updateValues;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UpdateStructureDataDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UpdateStructureDataDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UpdateStructureDataDetails& other_value);
void copy_template(const UpdateStructureDataDetails_template& other_value);

public:
UpdateStructureDataDetails_template();
UpdateStructureDataDetails_template(template_sel other_value);
UpdateStructureDataDetails_template(const UpdateStructureDataDetails& other_value);
UpdateStructureDataDetails_template(const OPTIONAL<UpdateStructureDataDetails>& other_value);
UpdateStructureDataDetails_template(const UpdateStructureDataDetails_template& other_value);
~UpdateStructureDataDetails_template();
UpdateStructureDataDetails_template& operator=(template_sel other_value);
UpdateStructureDataDetails_template& operator=(const UpdateStructureDataDetails& other_value);
UpdateStructureDataDetails_template& operator=(const OPTIONAL<UpdateStructureDataDetails>& other_value);
UpdateStructureDataDetails_template& operator=(const UpdateStructureDataDetails_template& other_value);
boolean match(const UpdateStructureDataDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UpdateStructureDataDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UpdateStructureDataDetails_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
PerformUpdateTypeExtended_template& performInsertReplace();
const PerformUpdateTypeExtended_template& performInsertReplace() const;
ListOfDataValue_template& updateValues();
const ListOfDataValue_template& updateValues() const;
int size_of() const;
void log() const;
void log_match(const UpdateStructureDataDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UpdateEventDetails : public Base_Type {
  NodeId field_nodeId;
  PerformUpdateType field_performInsertReplace;
  EventFilter field_filter;
  ListOfDataValue field_updateValues;
public:
  UpdateEventDetails();
  UpdateEventDetails(const NodeId& par_nodeId,
    const PerformUpdateType& par_performInsertReplace,
    const EventFilter& par_filter,
    const ListOfDataValue& par_updateValues);
  UpdateEventDetails(const UpdateEventDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UpdateEventDetails& operator=(const UpdateEventDetails& other_value);
  boolean operator==(const UpdateEventDetails& other_value) const;
  inline boolean operator!=(const UpdateEventDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline PerformUpdateType& performInsertReplace()
    {return field_performInsertReplace;}
  inline const PerformUpdateType& performInsertReplace() const
    {return field_performInsertReplace;}
  inline EventFilter& filter()
    {return field_filter;}
  inline const EventFilter& filter() const
    {return field_filter;}
  inline ListOfDataValue& updateValues()
    {return field_updateValues;}
  inline const ListOfDataValue& updateValues() const
    {return field_updateValues;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UpdateEventDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UpdateEventDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UpdateEventDetails& other_value);
void copy_template(const UpdateEventDetails_template& other_value);

public:
UpdateEventDetails_template();
UpdateEventDetails_template(template_sel other_value);
UpdateEventDetails_template(const UpdateEventDetails& other_value);
UpdateEventDetails_template(const OPTIONAL<UpdateEventDetails>& other_value);
UpdateEventDetails_template(const UpdateEventDetails_template& other_value);
~UpdateEventDetails_template();
UpdateEventDetails_template& operator=(template_sel other_value);
UpdateEventDetails_template& operator=(const UpdateEventDetails& other_value);
UpdateEventDetails_template& operator=(const OPTIONAL<UpdateEventDetails>& other_value);
UpdateEventDetails_template& operator=(const UpdateEventDetails_template& other_value);
boolean match(const UpdateEventDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UpdateEventDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UpdateEventDetails_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
PerformUpdateType_template& performInsertReplace();
const PerformUpdateType_template& performInsertReplace() const;
EventFilter_template& filter();
const EventFilter_template& filter() const;
ListOfDataValue_template& updateValues();
const ListOfDataValue_template& updateValues() const;
int size_of() const;
void log() const;
void log_match(const UpdateEventDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteRawModifiedDetails : public Base_Type {
  NodeId field_nodeId;
  INTEGER field_isDeleteModified;
  INTEGER field_startTime;
  INTEGER field_endTime;
public:
  DeleteRawModifiedDetails();
  DeleteRawModifiedDetails(const NodeId& par_nodeId,
    const INTEGER& par_isDeleteModified,
    const INTEGER& par_startTime,
    const INTEGER& par_endTime);
  DeleteRawModifiedDetails(const DeleteRawModifiedDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteRawModifiedDetails& operator=(const DeleteRawModifiedDetails& other_value);
  boolean operator==(const DeleteRawModifiedDetails& other_value) const;
  inline boolean operator!=(const DeleteRawModifiedDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline INTEGER& isDeleteModified()
    {return field_isDeleteModified;}
  inline const INTEGER& isDeleteModified() const
    {return field_isDeleteModified;}
  inline INTEGER& startTime()
    {return field_startTime;}
  inline const INTEGER& startTime() const
    {return field_startTime;}
  inline INTEGER& endTime()
    {return field_endTime;}
  inline const INTEGER& endTime() const
    {return field_endTime;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteRawModifiedDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteRawModifiedDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteRawModifiedDetails& other_value);
void copy_template(const DeleteRawModifiedDetails_template& other_value);

public:
DeleteRawModifiedDetails_template();
DeleteRawModifiedDetails_template(template_sel other_value);
DeleteRawModifiedDetails_template(const DeleteRawModifiedDetails& other_value);
DeleteRawModifiedDetails_template(const OPTIONAL<DeleteRawModifiedDetails>& other_value);
DeleteRawModifiedDetails_template(const DeleteRawModifiedDetails_template& other_value);
~DeleteRawModifiedDetails_template();
DeleteRawModifiedDetails_template& operator=(template_sel other_value);
DeleteRawModifiedDetails_template& operator=(const DeleteRawModifiedDetails& other_value);
DeleteRawModifiedDetails_template& operator=(const OPTIONAL<DeleteRawModifiedDetails>& other_value);
DeleteRawModifiedDetails_template& operator=(const DeleteRawModifiedDetails_template& other_value);
boolean match(const DeleteRawModifiedDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteRawModifiedDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteRawModifiedDetails_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
INTEGER_template& isDeleteModified();
const INTEGER_template& isDeleteModified() const;
INTEGER_template& startTime();
const INTEGER_template& startTime() const;
INTEGER_template& endTime();
const INTEGER_template& endTime() const;
int size_of() const;
void log() const;
void log_match(const DeleteRawModifiedDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteAtTimeDetails : public Base_Type {
  NodeId field_nodeId;
  ListOfUtcTime field_reqTimes;
public:
  DeleteAtTimeDetails();
  DeleteAtTimeDetails(const NodeId& par_nodeId,
    const ListOfUtcTime& par_reqTimes);
  DeleteAtTimeDetails(const DeleteAtTimeDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteAtTimeDetails& operator=(const DeleteAtTimeDetails& other_value);
  boolean operator==(const DeleteAtTimeDetails& other_value) const;
  inline boolean operator!=(const DeleteAtTimeDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline ListOfUtcTime& reqTimes()
    {return field_reqTimes;}
  inline const ListOfUtcTime& reqTimes() const
    {return field_reqTimes;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteAtTimeDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteAtTimeDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteAtTimeDetails& other_value);
void copy_template(const DeleteAtTimeDetails_template& other_value);

public:
DeleteAtTimeDetails_template();
DeleteAtTimeDetails_template(template_sel other_value);
DeleteAtTimeDetails_template(const DeleteAtTimeDetails& other_value);
DeleteAtTimeDetails_template(const OPTIONAL<DeleteAtTimeDetails>& other_value);
DeleteAtTimeDetails_template(const DeleteAtTimeDetails_template& other_value);
~DeleteAtTimeDetails_template();
DeleteAtTimeDetails_template& operator=(template_sel other_value);
DeleteAtTimeDetails_template& operator=(const DeleteAtTimeDetails& other_value);
DeleteAtTimeDetails_template& operator=(const OPTIONAL<DeleteAtTimeDetails>& other_value);
DeleteAtTimeDetails_template& operator=(const DeleteAtTimeDetails_template& other_value);
boolean match(const DeleteAtTimeDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteAtTimeDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteAtTimeDetails_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
ListOfUtcTime_template& reqTimes();
const ListOfUtcTime_template& reqTimes() const;
int size_of() const;
void log() const;
void log_match(const DeleteAtTimeDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteEventDetails : public Base_Type {
  NodeId field_nodeId;
  ListOfByteString field_eventId;
public:
  DeleteEventDetails();
  DeleteEventDetails(const NodeId& par_nodeId,
    const ListOfByteString& par_eventId);
  DeleteEventDetails(const DeleteEventDetails& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteEventDetails& operator=(const DeleteEventDetails& other_value);
  boolean operator==(const DeleteEventDetails& other_value) const;
  inline boolean operator!=(const DeleteEventDetails& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline ListOfByteString& eventId()
    {return field_eventId;}
  inline const ListOfByteString& eventId() const
    {return field_eventId;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteEventDetails_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteEventDetails_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteEventDetails& other_value);
void copy_template(const DeleteEventDetails_template& other_value);

public:
DeleteEventDetails_template();
DeleteEventDetails_template(template_sel other_value);
DeleteEventDetails_template(const DeleteEventDetails& other_value);
DeleteEventDetails_template(const OPTIONAL<DeleteEventDetails>& other_value);
DeleteEventDetails_template(const DeleteEventDetails_template& other_value);
~DeleteEventDetails_template();
DeleteEventDetails_template& operator=(template_sel other_value);
DeleteEventDetails_template& operator=(const DeleteEventDetails& other_value);
DeleteEventDetails_template& operator=(const OPTIONAL<DeleteEventDetails>& other_value);
DeleteEventDetails_template& operator=(const DeleteEventDetails_template& other_value);
boolean match(const DeleteEventDetails& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteEventDetails valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteEventDetails_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
ListOfByteString_template& eventId();
const ListOfByteString_template& eventId() const;
int size_of() const;
void log() const;
void log_match(const DeleteEventDetails& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfMonitoredItemNotification : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfMonitoredItemNotificationArray *field_realArray;
};
void copy_value(const ListOfMonitoredItemNotification& other_value);

public:
ListOfMonitoredItemNotification();
ListOfMonitoredItemNotification(const ListOfMonitoredItemNotification& other_value);
~ListOfMonitoredItemNotification();
ListOfMonitoredItemNotification& operator=(const ListOfMonitoredItemNotification& other_value);
boolean operator==(const ListOfMonitoredItemNotification& other_value) const;
inline boolean operator!=(const ListOfMonitoredItemNotification& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfMonitoredItemNotificationArray& realArray();
const ListOfMonitoredItemNotificationArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemNotification_template : public Base_Template {
union {
struct {
ListOfMonitoredItemNotification::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfMonitoredItemNotificationArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemNotification_template *list_value;
} value_list;
};
void copy_value(const ListOfMonitoredItemNotification& other_value);

void copy_template(const ListOfMonitoredItemNotification_template& other_value);

public:
ListOfMonitoredItemNotification_template();
ListOfMonitoredItemNotification_template(template_sel other_value);
ListOfMonitoredItemNotification_template(const ListOfMonitoredItemNotification& other_value);
ListOfMonitoredItemNotification_template(const OPTIONAL<ListOfMonitoredItemNotification>& other_value);
ListOfMonitoredItemNotification_template(const ListOfMonitoredItemNotification_template& other_value);
~ListOfMonitoredItemNotification_template();
void clean_up();
ListOfMonitoredItemNotification_template& operator=(template_sel other_value);
ListOfMonitoredItemNotification_template& operator=(const ListOfMonitoredItemNotification& other_value);
ListOfMonitoredItemNotification_template& operator=(const OPTIONAL<ListOfMonitoredItemNotification>& other_value);
ListOfMonitoredItemNotification_template& operator=(const ListOfMonitoredItemNotification_template& other_value);
boolean match(const ListOfMonitoredItemNotification& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfMonitoredItemNotification valueof() const;
ListOfMonitoredItemNotification_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfMonitoredItemNotificationArray_template& realArray();
const ListOfMonitoredItemNotificationArray_template& realArray() const;
boolean ischosen(ListOfMonitoredItemNotification::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfMonitoredItemNotification& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MonitoredItemNotificationArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MonitoredItemNotification **value_elements;
} *val_ptr;

static const MonitoredItemNotification UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MonitoredItemNotificationArray& other_value);

public:
  typedef MonitoredItemNotification of_type;
MonitoredItemNotificationArray();
MonitoredItemNotificationArray(null_type other_value);
MonitoredItemNotificationArray(const MonitoredItemNotificationArray& other_value);
~MonitoredItemNotificationArray();

void clean_up();
MonitoredItemNotificationArray& operator=(null_type other_value);
MonitoredItemNotificationArray& operator=(const MonitoredItemNotificationArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MonitoredItemNotificationArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MonitoredItemNotificationArray& other_value) const { return !(*this == other_value); }

MonitoredItemNotification& operator[](int index_value);
MonitoredItemNotification& operator[](const INTEGER& index_value);
const MonitoredItemNotification& operator[](int index_value) const;
const MonitoredItemNotification& operator[](const INTEGER& index_value) const;

MonitoredItemNotificationArray operator<<=(int rotate_count) const;
MonitoredItemNotificationArray operator<<=(const INTEGER& rotate_count) const;
MonitoredItemNotificationArray operator>>=(int rotate_count) const;
MonitoredItemNotificationArray operator>>=(const INTEGER& rotate_count) const;

MonitoredItemNotificationArray operator+(const MonitoredItemNotificationArray& other_value) const;

MonitoredItemNotificationArray substr(int index, int returncount) const;

MonitoredItemNotificationArray replace(int index, int len, const MonitoredItemNotificationArray& repl) const;

MonitoredItemNotificationArray replace(int index, int len, const MonitoredItemNotificationArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemNotificationArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
MonitoredItemNotification_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MonitoredItemNotificationArray_template *list_value;
} value_list;
};
void copy_value(const MonitoredItemNotificationArray& other_value);
void copy_template(const MonitoredItemNotificationArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MonitoredItemNotificationArray_template();
MonitoredItemNotificationArray_template(template_sel other_value);
MonitoredItemNotificationArray_template(null_type other_value);
MonitoredItemNotificationArray_template(const MonitoredItemNotificationArray& other_value);
MonitoredItemNotificationArray_template(const OPTIONAL<MonitoredItemNotificationArray>& other_value);
MonitoredItemNotificationArray_template(const MonitoredItemNotificationArray_template& other_value);
~MonitoredItemNotificationArray_template();

void clean_up();
MonitoredItemNotificationArray_template& operator=(template_sel other_value);
MonitoredItemNotificationArray_template& operator=(null_type other_value);
MonitoredItemNotificationArray_template& operator=(const MonitoredItemNotificationArray& other_value);
MonitoredItemNotificationArray_template& operator=(const OPTIONAL<MonitoredItemNotificationArray>& other_value);
MonitoredItemNotificationArray_template& operator=(const MonitoredItemNotificationArray_template& other_value);

MonitoredItemNotification_template& operator[](int index_value);
MonitoredItemNotification_template& operator[](const INTEGER& index_value);
const MonitoredItemNotification_template& operator[](int index_value) const;
const MonitoredItemNotification_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MonitoredItemNotificationArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MonitoredItemNotificationArray valueof() const;
MonitoredItemNotificationArray substr(int index, int returncount) const;

MonitoredItemNotificationArray replace(int index, int len, const MonitoredItemNotificationArray_template& repl) const;

MonitoredItemNotificationArray replace(int index, int len, const MonitoredItemNotificationArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemNotificationArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MonitoredItemNotificationArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class MonitoredItemNotification : public Base_Type {
  INTEGER field_clientHandle;
  DataValue field_Value;
public:
  MonitoredItemNotification();
  MonitoredItemNotification(const INTEGER& par_clientHandle,
    const DataValue& par_Value);
  MonitoredItemNotification(const MonitoredItemNotification& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MonitoredItemNotification& operator=(const MonitoredItemNotification& other_value);
  boolean operator==(const MonitoredItemNotification& other_value) const;
  inline boolean operator!=(const MonitoredItemNotification& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientHandle()
    {return field_clientHandle;}
  inline const INTEGER& clientHandle() const
    {return field_clientHandle;}
  inline DataValue& Value()
    {return field_Value;}
  inline const DataValue& Value() const
    {return field_Value;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemNotification_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MonitoredItemNotification_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MonitoredItemNotification& other_value);
void copy_template(const MonitoredItemNotification_template& other_value);

public:
MonitoredItemNotification_template();
MonitoredItemNotification_template(template_sel other_value);
MonitoredItemNotification_template(const MonitoredItemNotification& other_value);
MonitoredItemNotification_template(const OPTIONAL<MonitoredItemNotification>& other_value);
MonitoredItemNotification_template(const MonitoredItemNotification_template& other_value);
~MonitoredItemNotification_template();
MonitoredItemNotification_template& operator=(template_sel other_value);
MonitoredItemNotification_template& operator=(const MonitoredItemNotification& other_value);
MonitoredItemNotification_template& operator=(const OPTIONAL<MonitoredItemNotification>& other_value);
MonitoredItemNotification_template& operator=(const MonitoredItemNotification_template& other_value);
boolean match(const MonitoredItemNotification& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MonitoredItemNotification valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemNotification_template& list_item(unsigned int list_index) const;
INTEGER_template& clientHandle();
const INTEGER_template& clientHandle() const;
DataValue_template& Value();
const DataValue_template& Value() const;
int size_of() const;
void log() const;
void log_match(const MonitoredItemNotification& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfMonitoredItemNotificationArray : public Base_Type {
  INTEGER field_arrayLength;
  MonitoredItemNotificationArray field_arrayValues;
public:
  ListOfMonitoredItemNotificationArray();
  ListOfMonitoredItemNotificationArray(const INTEGER& par_arrayLength,
    const MonitoredItemNotificationArray& par_arrayValues);
  ListOfMonitoredItemNotificationArray(const ListOfMonitoredItemNotificationArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfMonitoredItemNotificationArray& operator=(const ListOfMonitoredItemNotificationArray& other_value);
  boolean operator==(const ListOfMonitoredItemNotificationArray& other_value) const;
  inline boolean operator!=(const ListOfMonitoredItemNotificationArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline MonitoredItemNotificationArray& arrayValues()
    {return field_arrayValues;}
  inline const MonitoredItemNotificationArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemNotificationArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemNotificationArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfMonitoredItemNotificationArray& other_value);
void copy_template(const ListOfMonitoredItemNotificationArray_template& other_value);

public:
ListOfMonitoredItemNotificationArray_template();
ListOfMonitoredItemNotificationArray_template(template_sel other_value);
ListOfMonitoredItemNotificationArray_template(const ListOfMonitoredItemNotificationArray& other_value);
ListOfMonitoredItemNotificationArray_template(const OPTIONAL<ListOfMonitoredItemNotificationArray>& other_value);
ListOfMonitoredItemNotificationArray_template(const ListOfMonitoredItemNotificationArray_template& other_value);
~ListOfMonitoredItemNotificationArray_template();
ListOfMonitoredItemNotificationArray_template& operator=(template_sel other_value);
ListOfMonitoredItemNotificationArray_template& operator=(const ListOfMonitoredItemNotificationArray& other_value);
ListOfMonitoredItemNotificationArray_template& operator=(const OPTIONAL<ListOfMonitoredItemNotificationArray>& other_value);
ListOfMonitoredItemNotificationArray_template& operator=(const ListOfMonitoredItemNotificationArray_template& other_value);
boolean match(const ListOfMonitoredItemNotificationArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfMonitoredItemNotificationArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfMonitoredItemNotificationArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
MonitoredItemNotificationArray_template& arrayValues();
const MonitoredItemNotificationArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfMonitoredItemNotificationArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DataChangeNotification : public Base_Type {
  ListOfMonitoredItemNotification field_monitoredItems;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  DataChangeNotification();
  DataChangeNotification(const ListOfMonitoredItemNotification& par_monitoredItems,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  DataChangeNotification(const DataChangeNotification& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DataChangeNotification& operator=(const DataChangeNotification& other_value);
  boolean operator==(const DataChangeNotification& other_value) const;
  inline boolean operator!=(const DataChangeNotification& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfMonitoredItemNotification& monitoredItems()
    {return field_monitoredItems;}
  inline const ListOfMonitoredItemNotification& monitoredItems() const
    {return field_monitoredItems;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DataChangeNotification_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DataChangeNotification_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DataChangeNotification& other_value);
void copy_template(const DataChangeNotification_template& other_value);

public:
DataChangeNotification_template();
DataChangeNotification_template(template_sel other_value);
DataChangeNotification_template(const DataChangeNotification& other_value);
DataChangeNotification_template(const OPTIONAL<DataChangeNotification>& other_value);
DataChangeNotification_template(const DataChangeNotification_template& other_value);
~DataChangeNotification_template();
DataChangeNotification_template& operator=(template_sel other_value);
DataChangeNotification_template& operator=(const DataChangeNotification& other_value);
DataChangeNotification_template& operator=(const OPTIONAL<DataChangeNotification>& other_value);
DataChangeNotification_template& operator=(const DataChangeNotification_template& other_value);
boolean match(const DataChangeNotification& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DataChangeNotification valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DataChangeNotification_template& list_item(unsigned int list_index) const;
ListOfMonitoredItemNotification_template& monitoredItems();
const ListOfMonitoredItemNotification_template& monitoredItems() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const DataChangeNotification& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfEventFieldList : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfEventFieldListArray *field_realArray;
};
void copy_value(const ListOfEventFieldList& other_value);

public:
ListOfEventFieldList();
ListOfEventFieldList(const ListOfEventFieldList& other_value);
~ListOfEventFieldList();
ListOfEventFieldList& operator=(const ListOfEventFieldList& other_value);
boolean operator==(const ListOfEventFieldList& other_value) const;
inline boolean operator!=(const ListOfEventFieldList& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfEventFieldListArray& realArray();
const ListOfEventFieldListArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfEventFieldList_template : public Base_Template {
union {
struct {
ListOfEventFieldList::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfEventFieldListArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfEventFieldList_template *list_value;
} value_list;
};
void copy_value(const ListOfEventFieldList& other_value);

void copy_template(const ListOfEventFieldList_template& other_value);

public:
ListOfEventFieldList_template();
ListOfEventFieldList_template(template_sel other_value);
ListOfEventFieldList_template(const ListOfEventFieldList& other_value);
ListOfEventFieldList_template(const OPTIONAL<ListOfEventFieldList>& other_value);
ListOfEventFieldList_template(const ListOfEventFieldList_template& other_value);
~ListOfEventFieldList_template();
void clean_up();
ListOfEventFieldList_template& operator=(template_sel other_value);
ListOfEventFieldList_template& operator=(const ListOfEventFieldList& other_value);
ListOfEventFieldList_template& operator=(const OPTIONAL<ListOfEventFieldList>& other_value);
ListOfEventFieldList_template& operator=(const ListOfEventFieldList_template& other_value);
boolean match(const ListOfEventFieldList& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfEventFieldList valueof() const;
ListOfEventFieldList_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfEventFieldListArray_template& realArray();
const ListOfEventFieldListArray_template& realArray() const;
boolean ischosen(ListOfEventFieldList::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfEventFieldList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EventFieldListArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
EventFieldList **value_elements;
} *val_ptr;

static const EventFieldList UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const EventFieldListArray& other_value);

public:
  typedef EventFieldList of_type;
EventFieldListArray();
EventFieldListArray(null_type other_value);
EventFieldListArray(const EventFieldListArray& other_value);
~EventFieldListArray();

void clean_up();
EventFieldListArray& operator=(null_type other_value);
EventFieldListArray& operator=(const EventFieldListArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const EventFieldListArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const EventFieldListArray& other_value) const { return !(*this == other_value); }

EventFieldList& operator[](int index_value);
EventFieldList& operator[](const INTEGER& index_value);
const EventFieldList& operator[](int index_value) const;
const EventFieldList& operator[](const INTEGER& index_value) const;

EventFieldListArray operator<<=(int rotate_count) const;
EventFieldListArray operator<<=(const INTEGER& rotate_count) const;
EventFieldListArray operator>>=(int rotate_count) const;
EventFieldListArray operator>>=(const INTEGER& rotate_count) const;

EventFieldListArray operator+(const EventFieldListArray& other_value) const;

EventFieldListArray substr(int index, int returncount) const;

EventFieldListArray replace(int index, int len, const EventFieldListArray& repl) const;

EventFieldListArray replace(int index, int len, const EventFieldListArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EventFieldListArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
EventFieldList_template **value_elements;
} single_value;
struct {
unsigned int n_values;
EventFieldListArray_template *list_value;
} value_list;
};
void copy_value(const EventFieldListArray& other_value);
void copy_template(const EventFieldListArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
EventFieldListArray_template();
EventFieldListArray_template(template_sel other_value);
EventFieldListArray_template(null_type other_value);
EventFieldListArray_template(const EventFieldListArray& other_value);
EventFieldListArray_template(const OPTIONAL<EventFieldListArray>& other_value);
EventFieldListArray_template(const EventFieldListArray_template& other_value);
~EventFieldListArray_template();

void clean_up();
EventFieldListArray_template& operator=(template_sel other_value);
EventFieldListArray_template& operator=(null_type other_value);
EventFieldListArray_template& operator=(const EventFieldListArray& other_value);
EventFieldListArray_template& operator=(const OPTIONAL<EventFieldListArray>& other_value);
EventFieldListArray_template& operator=(const EventFieldListArray_template& other_value);

EventFieldList_template& operator[](int index_value);
EventFieldList_template& operator[](const INTEGER& index_value);
const EventFieldList_template& operator[](int index_value) const;
const EventFieldList_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const EventFieldListArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
EventFieldListArray valueof() const;
EventFieldListArray substr(int index, int returncount) const;

EventFieldListArray replace(int index, int len, const EventFieldListArray_template& repl) const;

EventFieldListArray replace(int index, int len, const EventFieldListArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
EventFieldListArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const EventFieldListArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfBaseDataType : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Variant **value_elements;
} *val_ptr;

static const Variant UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ListOfBaseDataType& other_value);

public:
  typedef Variant of_type;
ListOfBaseDataType();
ListOfBaseDataType(null_type other_value);
ListOfBaseDataType(const ListOfBaseDataType& other_value);
~ListOfBaseDataType();

void clean_up();
ListOfBaseDataType& operator=(null_type other_value);
ListOfBaseDataType& operator=(const ListOfBaseDataType& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ListOfBaseDataType& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ListOfBaseDataType& other_value) const { return !(*this == other_value); }

Variant& operator[](int index_value);
Variant& operator[](const INTEGER& index_value);
const Variant& operator[](int index_value) const;
const Variant& operator[](const INTEGER& index_value) const;

ListOfBaseDataType operator<<=(int rotate_count) const;
ListOfBaseDataType operator<<=(const INTEGER& rotate_count) const;
ListOfBaseDataType operator>>=(int rotate_count) const;
ListOfBaseDataType operator>>=(const INTEGER& rotate_count) const;

ListOfBaseDataType operator+(const ListOfBaseDataType& other_value) const;

ListOfBaseDataType substr(int index, int returncount) const;

ListOfBaseDataType replace(int index, int len, const ListOfBaseDataType& repl) const;

ListOfBaseDataType replace(int index, int len, const ListOfBaseDataType_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBaseDataType_template : public Record_Of_Template {
union {
struct {
int n_elements;
Variant_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ListOfBaseDataType_template *list_value;
} value_list;
};
void copy_value(const ListOfBaseDataType& other_value);
void copy_template(const ListOfBaseDataType_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ListOfBaseDataType_template();
ListOfBaseDataType_template(template_sel other_value);
ListOfBaseDataType_template(null_type other_value);
ListOfBaseDataType_template(const ListOfBaseDataType& other_value);
ListOfBaseDataType_template(const OPTIONAL<ListOfBaseDataType>& other_value);
ListOfBaseDataType_template(const ListOfBaseDataType_template& other_value);
~ListOfBaseDataType_template();

void clean_up();
ListOfBaseDataType_template& operator=(template_sel other_value);
ListOfBaseDataType_template& operator=(null_type other_value);
ListOfBaseDataType_template& operator=(const ListOfBaseDataType& other_value);
ListOfBaseDataType_template& operator=(const OPTIONAL<ListOfBaseDataType>& other_value);
ListOfBaseDataType_template& operator=(const ListOfBaseDataType_template& other_value);

Variant_template& operator[](int index_value);
Variant_template& operator[](const INTEGER& index_value);
const Variant_template& operator[](int index_value) const;
const Variant_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ListOfBaseDataType& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ListOfBaseDataType valueof() const;
ListOfBaseDataType substr(int index, int returncount) const;

ListOfBaseDataType replace(int index, int len, const ListOfBaseDataType_template& repl) const;

ListOfBaseDataType replace(int index, int len, const ListOfBaseDataType& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ListOfBaseDataType_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ListOfBaseDataType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class EventFieldList : public Base_Type {
  INTEGER field_clientHandle;
  ListOfBaseDataType field_eventFields;
public:
  EventFieldList();
  EventFieldList(const INTEGER& par_clientHandle,
    const ListOfBaseDataType& par_eventFields);
  EventFieldList(const EventFieldList& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EventFieldList& operator=(const EventFieldList& other_value);
  boolean operator==(const EventFieldList& other_value) const;
  inline boolean operator!=(const EventFieldList& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientHandle()
    {return field_clientHandle;}
  inline const INTEGER& clientHandle() const
    {return field_clientHandle;}
  inline ListOfBaseDataType& eventFields()
    {return field_eventFields;}
  inline const ListOfBaseDataType& eventFields() const
    {return field_eventFields;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EventFieldList_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EventFieldList_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EventFieldList& other_value);
void copy_template(const EventFieldList_template& other_value);

public:
EventFieldList_template();
EventFieldList_template(template_sel other_value);
EventFieldList_template(const EventFieldList& other_value);
EventFieldList_template(const OPTIONAL<EventFieldList>& other_value);
EventFieldList_template(const EventFieldList_template& other_value);
~EventFieldList_template();
EventFieldList_template& operator=(template_sel other_value);
EventFieldList_template& operator=(const EventFieldList& other_value);
EventFieldList_template& operator=(const OPTIONAL<EventFieldList>& other_value);
EventFieldList_template& operator=(const EventFieldList_template& other_value);
boolean match(const EventFieldList& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EventFieldList valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EventFieldList_template& list_item(unsigned int list_index) const;
INTEGER_template& clientHandle();
const INTEGER_template& clientHandle() const;
ListOfBaseDataType_template& eventFields();
const ListOfBaseDataType_template& eventFields() const;
int size_of() const;
void log() const;
void log_match(const EventFieldList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfEventFieldListArray : public Base_Type {
  INTEGER field_arrayLength;
  EventFieldListArray field_arrayValues;
public:
  ListOfEventFieldListArray();
  ListOfEventFieldListArray(const INTEGER& par_arrayLength,
    const EventFieldListArray& par_arrayValues);
  ListOfEventFieldListArray(const ListOfEventFieldListArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfEventFieldListArray& operator=(const ListOfEventFieldListArray& other_value);
  boolean operator==(const ListOfEventFieldListArray& other_value) const;
  inline boolean operator!=(const ListOfEventFieldListArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline EventFieldListArray& arrayValues()
    {return field_arrayValues;}
  inline const EventFieldListArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfEventFieldListArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfEventFieldListArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfEventFieldListArray& other_value);
void copy_template(const ListOfEventFieldListArray_template& other_value);

public:
ListOfEventFieldListArray_template();
ListOfEventFieldListArray_template(template_sel other_value);
ListOfEventFieldListArray_template(const ListOfEventFieldListArray& other_value);
ListOfEventFieldListArray_template(const OPTIONAL<ListOfEventFieldListArray>& other_value);
ListOfEventFieldListArray_template(const ListOfEventFieldListArray_template& other_value);
~ListOfEventFieldListArray_template();
ListOfEventFieldListArray_template& operator=(template_sel other_value);
ListOfEventFieldListArray_template& operator=(const ListOfEventFieldListArray& other_value);
ListOfEventFieldListArray_template& operator=(const OPTIONAL<ListOfEventFieldListArray>& other_value);
ListOfEventFieldListArray_template& operator=(const ListOfEventFieldListArray_template& other_value);
boolean match(const ListOfEventFieldListArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfEventFieldListArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfEventFieldListArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
EventFieldListArray_template& arrayValues();
const EventFieldListArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfEventFieldListArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EventNotificationList : public Base_Type {
  ListOfEventFieldList field_events;
public:
  EventNotificationList();
  EventNotificationList(const ListOfEventFieldList& par_events);
  EventNotificationList(const EventNotificationList& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EventNotificationList& operator=(const EventNotificationList& other_value);
  boolean operator==(const EventNotificationList& other_value) const;
  inline boolean operator!=(const EventNotificationList& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfEventFieldList& events()
    {return field_events;}
  inline const ListOfEventFieldList& events() const
    {return field_events;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EventNotificationList_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EventNotificationList_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EventNotificationList& other_value);
void copy_template(const EventNotificationList_template& other_value);

public:
EventNotificationList_template();
EventNotificationList_template(template_sel other_value);
EventNotificationList_template(const EventNotificationList& other_value);
EventNotificationList_template(const OPTIONAL<EventNotificationList>& other_value);
EventNotificationList_template(const EventNotificationList_template& other_value);
~EventNotificationList_template();
EventNotificationList_template& operator=(template_sel other_value);
EventNotificationList_template& operator=(const EventNotificationList& other_value);
EventNotificationList_template& operator=(const OPTIONAL<EventNotificationList>& other_value);
EventNotificationList_template& operator=(const EventNotificationList_template& other_value);
boolean match(const EventNotificationList& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EventNotificationList valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EventNotificationList_template& list_item(unsigned int list_index) const;
ListOfEventFieldList_template& events();
const ListOfEventFieldList_template& events() const;
int size_of() const;
void log() const;
void log_match(const EventNotificationList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class StatusChangeNotification : public Base_Type {
  INTEGER field_status;
  DiagnosticInfo field_diagnosticInfo;
public:
  StatusChangeNotification();
  StatusChangeNotification(const INTEGER& par_status,
    const DiagnosticInfo& par_diagnosticInfo);
  StatusChangeNotification(const StatusChangeNotification& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  StatusChangeNotification& operator=(const StatusChangeNotification& other_value);
  boolean operator==(const StatusChangeNotification& other_value) const;
  inline boolean operator!=(const StatusChangeNotification& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& status()
    {return field_status;}
  inline const INTEGER& status() const
    {return field_status;}
  inline DiagnosticInfo& diagnosticInfo()
    {return field_diagnosticInfo;}
  inline const DiagnosticInfo& diagnosticInfo() const
    {return field_diagnosticInfo;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class StatusChangeNotification_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
StatusChangeNotification_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const StatusChangeNotification& other_value);
void copy_template(const StatusChangeNotification_template& other_value);

public:
StatusChangeNotification_template();
StatusChangeNotification_template(template_sel other_value);
StatusChangeNotification_template(const StatusChangeNotification& other_value);
StatusChangeNotification_template(const OPTIONAL<StatusChangeNotification>& other_value);
StatusChangeNotification_template(const StatusChangeNotification_template& other_value);
~StatusChangeNotification_template();
StatusChangeNotification_template& operator=(template_sel other_value);
StatusChangeNotification_template& operator=(const StatusChangeNotification& other_value);
StatusChangeNotification_template& operator=(const OPTIONAL<StatusChangeNotification>& other_value);
StatusChangeNotification_template& operator=(const StatusChangeNotification_template& other_value);
boolean match(const StatusChangeNotification& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
StatusChangeNotification valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
StatusChangeNotification_template& list_item(unsigned int list_index) const;
INTEGER_template& status();
const INTEGER_template& status() const;
DiagnosticInfo_template& diagnosticInfo();
const DiagnosticInfo_template& diagnosticInfo() const;
int size_of() const;
void log() const;
void log_match(const StatusChangeNotification& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Decimal : public Base_Type {
  NodeId field_typeId;
  INTEGER field_decimalLength;
  INTEGER field_scale;
  INTEGER field_decimalValue;
public:
  Decimal();
  Decimal(const NodeId& par_typeId,
    const INTEGER& par_decimalLength,
    const INTEGER& par_scale,
    const INTEGER& par_decimalValue);
  Decimal(const Decimal& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Decimal& operator=(const Decimal& other_value);
  boolean operator==(const Decimal& other_value) const;
  inline boolean operator!=(const Decimal& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& typeId()
    {return field_typeId;}
  inline const NodeId& typeId() const
    {return field_typeId;}
  inline INTEGER& decimalLength()
    {return field_decimalLength;}
  inline const INTEGER& decimalLength() const
    {return field_decimalLength;}
  inline INTEGER& scale()
    {return field_scale;}
  inline const INTEGER& scale() const
    {return field_scale;}
  inline INTEGER& decimalValue()
    {return field_decimalValue;}
  inline const INTEGER& decimalValue() const
    {return field_decimalValue;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class Decimal_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Decimal_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Decimal& other_value);
void copy_template(const Decimal_template& other_value);

public:
Decimal_template();
Decimal_template(template_sel other_value);
Decimal_template(const Decimal& other_value);
Decimal_template(const OPTIONAL<Decimal>& other_value);
Decimal_template(const Decimal_template& other_value);
~Decimal_template();
Decimal_template& operator=(template_sel other_value);
Decimal_template& operator=(const Decimal& other_value);
Decimal_template& operator=(const OPTIONAL<Decimal>& other_value);
Decimal_template& operator=(const Decimal_template& other_value);
boolean match(const Decimal& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Decimal valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Decimal_template& list_item(unsigned int list_index) const;
NodeId_template& typeId();
const NodeId_template& typeId() const;
INTEGER_template& decimalLength();
const INTEGER_template& decimalLength() const;
INTEGER_template& scale();
const INTEGER_template& scale() const;
INTEGER_template& decimalValue();
const INTEGER_template& decimalValue() const;
int size_of() const;
void log() const;
void log_match(const Decimal& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TimeZoneDataType {
  INTEGER field_offset;
  INTEGER field_daylightSavingInOffset;
public:
  TimeZoneDataType();
  TimeZoneDataType(const INTEGER& par_offset,
    const INTEGER& par_daylightSavingInOffset);
  TimeZoneDataType(const TimeZoneDataType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TimeZoneDataType& operator=(const TimeZoneDataType& other_value);
  boolean operator==(const TimeZoneDataType& other_value) const;
  inline boolean operator!=(const TimeZoneDataType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& offset()
    {return field_offset;}
  inline const INTEGER& offset() const
    {return field_offset;}
  inline INTEGER& daylightSavingInOffset()
    {return field_daylightSavingInOffset;}
  inline const INTEGER& daylightSavingInOffset() const
    {return field_daylightSavingInOffset;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class TimeZoneDataType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TimeZoneDataType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TimeZoneDataType& other_value);
void copy_template(const TimeZoneDataType_template& other_value);

public:
TimeZoneDataType_template();
TimeZoneDataType_template(template_sel other_value);
TimeZoneDataType_template(const TimeZoneDataType& other_value);
TimeZoneDataType_template(const OPTIONAL<TimeZoneDataType>& other_value);
TimeZoneDataType_template(const TimeZoneDataType_template& other_value);
~TimeZoneDataType_template();
TimeZoneDataType_template& operator=(template_sel other_value);
TimeZoneDataType_template& operator=(const TimeZoneDataType& other_value);
TimeZoneDataType_template& operator=(const OPTIONAL<TimeZoneDataType>& other_value);
TimeZoneDataType_template& operator=(const TimeZoneDataType_template& other_value);
boolean match(const TimeZoneDataType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TimeZoneDataType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TimeZoneDataType_template& list_item(unsigned int list_index) const;
INTEGER_template& offset();
const INTEGER_template& offset() const;
INTEGER_template& daylightSavingInOffset();
const INTEGER_template& daylightSavingInOffset() const;
int size_of() const;
void log() const;
void log_match(const TimeZoneDataType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class Argument {
  String field_name;
  NodeId field_dataType;
  INTEGER field_valueRank;
  ListOfUInt32 field_arrayDimensions;
  LocalizedText field_description;
public:
  Argument();
  Argument(const String& par_name,
    const NodeId& par_dataType,
    const INTEGER& par_valueRank,
    const ListOfUInt32& par_arrayDimensions,
    const LocalizedText& par_description);
  Argument(const Argument& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  Argument& operator=(const Argument& other_value);
  boolean operator==(const Argument& other_value) const;
  inline boolean operator!=(const Argument& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& name()
    {return field_name;}
  inline const String& name() const
    {return field_name;}
  inline NodeId& dataType()
    {return field_dataType;}
  inline const NodeId& dataType() const
    {return field_dataType;}
  inline INTEGER& valueRank()
    {return field_valueRank;}
  inline const INTEGER& valueRank() const
    {return field_valueRank;}
  inline ListOfUInt32& arrayDimensions()
    {return field_arrayDimensions;}
  inline const ListOfUInt32& arrayDimensions() const
    {return field_arrayDimensions;}
  inline LocalizedText& description()
    {return field_description;}
  inline const LocalizedText& description() const
    {return field_description;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class Argument_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
Argument_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const Argument& other_value);
void copy_template(const Argument_template& other_value);

public:
Argument_template();
Argument_template(template_sel other_value);
Argument_template(const Argument& other_value);
Argument_template(const OPTIONAL<Argument>& other_value);
Argument_template(const Argument_template& other_value);
~Argument_template();
Argument_template& operator=(template_sel other_value);
Argument_template& operator=(const Argument& other_value);
Argument_template& operator=(const OPTIONAL<Argument>& other_value);
Argument_template& operator=(const Argument_template& other_value);
boolean match(const Argument& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
Argument valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
Argument_template& list_item(unsigned int list_index) const;
String_template& name();
const String_template& name() const;
NodeId_template& dataType();
const NodeId_template& dataType() const;
INTEGER_template& valueRank();
const INTEGER_template& valueRank() const;
ListOfUInt32_template& arrayDimensions();
const ListOfUInt32_template& arrayDimensions() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
int size_of() const;
void log() const;
void log_match(const Argument& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EnumValueType : public Base_Type {
  INTEGER field_Value;
  LocalizedText field_displayName;
  LocalizedText field_description;
public:
  EnumValueType();
  EnumValueType(const INTEGER& par_Value,
    const LocalizedText& par_displayName,
    const LocalizedText& par_description);
  EnumValueType(const EnumValueType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EnumValueType& operator=(const EnumValueType& other_value);
  boolean operator==(const EnumValueType& other_value) const;
  inline boolean operator!=(const EnumValueType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& Value()
    {return field_Value;}
  inline const INTEGER& Value() const
    {return field_Value;}
  inline LocalizedText& displayName()
    {return field_displayName;}
  inline const LocalizedText& displayName() const
    {return field_displayName;}
  inline LocalizedText& description()
    {return field_description;}
  inline const LocalizedText& description() const
    {return field_description;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EnumValueType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EnumValueType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EnumValueType& other_value);
void copy_template(const EnumValueType_template& other_value);

public:
EnumValueType_template();
EnumValueType_template(template_sel other_value);
EnumValueType_template(const EnumValueType& other_value);
EnumValueType_template(const OPTIONAL<EnumValueType>& other_value);
EnumValueType_template(const EnumValueType_template& other_value);
~EnumValueType_template();
EnumValueType_template& operator=(template_sel other_value);
EnumValueType_template& operator=(const EnumValueType& other_value);
EnumValueType_template& operator=(const OPTIONAL<EnumValueType>& other_value);
EnumValueType_template& operator=(const EnumValueType_template& other_value);
boolean match(const EnumValueType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EnumValueType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EnumValueType_template& list_item(unsigned int list_index) const;
INTEGER_template& Value();
const INTEGER_template& Value() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
int size_of() const;
void log() const;
void log_match(const EnumValueType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class OptionSet {
  ByteString field_Value;
  ByteString field_validBits;
public:
  OptionSet();
  OptionSet(const ByteString& par_Value,
    const ByteString& par_validBits);
  OptionSet(const OptionSet& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  OptionSet& operator=(const OptionSet& other_value);
  boolean operator==(const OptionSet& other_value) const;
  inline boolean operator!=(const OptionSet& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ByteString& Value()
    {return field_Value;}
  inline const ByteString& Value() const
    {return field_Value;}
  inline ByteString& validBits()
    {return field_validBits;}
  inline const ByteString& validBits() const
    {return field_validBits;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class OptionSet_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
OptionSet_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const OptionSet& other_value);
void copy_template(const OptionSet_template& other_value);

public:
OptionSet_template();
OptionSet_template(template_sel other_value);
OptionSet_template(const OptionSet& other_value);
OptionSet_template(const OPTIONAL<OptionSet>& other_value);
OptionSet_template(const OptionSet_template& other_value);
~OptionSet_template();
OptionSet_template& operator=(template_sel other_value);
OptionSet_template& operator=(const OptionSet& other_value);
OptionSet_template& operator=(const OPTIONAL<OptionSet>& other_value);
OptionSet_template& operator=(const OptionSet_template& other_value);
boolean match(const OptionSet& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
OptionSet valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
OptionSet_template& list_item(unsigned int list_index) const;
ByteString_template& Value();
const ByteString_template& Value() const;
ByteString_template& validBits();
const ByteString_template& validBits() const;
int size_of() const;
void log() const;
void log_match(const OptionSet& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfStructureField : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfStructureFieldArray *field_realArray;
};
void copy_value(const ListOfStructureField& other_value);

public:
ListOfStructureField();
ListOfStructureField(const ListOfStructureField& other_value);
~ListOfStructureField();
ListOfStructureField& operator=(const ListOfStructureField& other_value);
boolean operator==(const ListOfStructureField& other_value) const;
inline boolean operator!=(const ListOfStructureField& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfStructureFieldArray& realArray();
const ListOfStructureFieldArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ListOfStructureField_template : public Base_Template {
union {
struct {
ListOfStructureField::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfStructureFieldArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfStructureField_template *list_value;
} value_list;
};
void copy_value(const ListOfStructureField& other_value);

void copy_template(const ListOfStructureField_template& other_value);

public:
ListOfStructureField_template();
ListOfStructureField_template(template_sel other_value);
ListOfStructureField_template(const ListOfStructureField& other_value);
ListOfStructureField_template(const OPTIONAL<ListOfStructureField>& other_value);
ListOfStructureField_template(const ListOfStructureField_template& other_value);
~ListOfStructureField_template();
void clean_up();
ListOfStructureField_template& operator=(template_sel other_value);
ListOfStructureField_template& operator=(const ListOfStructureField& other_value);
ListOfStructureField_template& operator=(const OPTIONAL<ListOfStructureField>& other_value);
ListOfStructureField_template& operator=(const ListOfStructureField_template& other_value);
boolean match(const ListOfStructureField& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfStructureField valueof() const;
ListOfStructureField_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfStructureFieldArray_template& realArray();
const ListOfStructureFieldArray_template& realArray() const;
boolean ischosen(ListOfStructureField::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfStructureField& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class StructureFieldArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
StructureField **value_elements;
} *val_ptr;

static const StructureField UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const StructureFieldArray& other_value);

public:
  typedef StructureField of_type;
StructureFieldArray();
StructureFieldArray(null_type other_value);
StructureFieldArray(const StructureFieldArray& other_value);
~StructureFieldArray();

void clean_up();
StructureFieldArray& operator=(null_type other_value);
StructureFieldArray& operator=(const StructureFieldArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const StructureFieldArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const StructureFieldArray& other_value) const { return !(*this == other_value); }

StructureField& operator[](int index_value);
StructureField& operator[](const INTEGER& index_value);
const StructureField& operator[](int index_value) const;
const StructureField& operator[](const INTEGER& index_value) const;

StructureFieldArray operator<<=(int rotate_count) const;
StructureFieldArray operator<<=(const INTEGER& rotate_count) const;
StructureFieldArray operator>>=(int rotate_count) const;
StructureFieldArray operator>>=(const INTEGER& rotate_count) const;

StructureFieldArray operator+(const StructureFieldArray& other_value) const;

StructureFieldArray substr(int index, int returncount) const;

StructureFieldArray replace(int index, int len, const StructureFieldArray& repl) const;

StructureFieldArray replace(int index, int len, const StructureFieldArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class StructureFieldArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
StructureField_template **value_elements;
} single_value;
struct {
unsigned int n_values;
StructureFieldArray_template *list_value;
} value_list;
};
void copy_value(const StructureFieldArray& other_value);
void copy_template(const StructureFieldArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
StructureFieldArray_template();
StructureFieldArray_template(template_sel other_value);
StructureFieldArray_template(null_type other_value);
StructureFieldArray_template(const StructureFieldArray& other_value);
StructureFieldArray_template(const OPTIONAL<StructureFieldArray>& other_value);
StructureFieldArray_template(const StructureFieldArray_template& other_value);
~StructureFieldArray_template();

void clean_up();
StructureFieldArray_template& operator=(template_sel other_value);
StructureFieldArray_template& operator=(null_type other_value);
StructureFieldArray_template& operator=(const StructureFieldArray& other_value);
StructureFieldArray_template& operator=(const OPTIONAL<StructureFieldArray>& other_value);
StructureFieldArray_template& operator=(const StructureFieldArray_template& other_value);

StructureField_template& operator[](int index_value);
StructureField_template& operator[](const INTEGER& index_value);
const StructureField_template& operator[](int index_value) const;
const StructureField_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const StructureFieldArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
StructureFieldArray valueof() const;
StructureFieldArray substr(int index, int returncount) const;

StructureFieldArray replace(int index, int len, const StructureFieldArray_template& repl) const;

StructureFieldArray replace(int index, int len, const StructureFieldArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
StructureFieldArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const StructureFieldArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class StructureField : public Base_Type {
  String field_name;
  LocalizedText field_description;
  NodeId field_dataType;
  INTEGER field_valueRank;
  INTEGER field_isOptional;
public:
  StructureField();
  StructureField(const String& par_name,
    const LocalizedText& par_description,
    const NodeId& par_dataType,
    const INTEGER& par_valueRank,
    const INTEGER& par_isOptional);
  StructureField(const StructureField& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  StructureField& operator=(const StructureField& other_value);
  boolean operator==(const StructureField& other_value) const;
  inline boolean operator!=(const StructureField& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& name()
    {return field_name;}
  inline const String& name() const
    {return field_name;}
  inline LocalizedText& description()
    {return field_description;}
  inline const LocalizedText& description() const
    {return field_description;}
  inline NodeId& dataType()
    {return field_dataType;}
  inline const NodeId& dataType() const
    {return field_dataType;}
  inline INTEGER& valueRank()
    {return field_valueRank;}
  inline const INTEGER& valueRank() const
    {return field_valueRank;}
  inline INTEGER& isOptional()
    {return field_isOptional;}
  inline const INTEGER& isOptional() const
    {return field_isOptional;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class StructureField_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
StructureField_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const StructureField& other_value);
void copy_template(const StructureField_template& other_value);

public:
StructureField_template();
StructureField_template(template_sel other_value);
StructureField_template(const StructureField& other_value);
StructureField_template(const OPTIONAL<StructureField>& other_value);
StructureField_template(const StructureField_template& other_value);
~StructureField_template();
StructureField_template& operator=(template_sel other_value);
StructureField_template& operator=(const StructureField& other_value);
StructureField_template& operator=(const OPTIONAL<StructureField>& other_value);
StructureField_template& operator=(const StructureField_template& other_value);
boolean match(const StructureField& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
StructureField valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
StructureField_template& list_item(unsigned int list_index) const;
String_template& name();
const String_template& name() const;
LocalizedText_template& description();
const LocalizedText_template& description() const;
NodeId_template& dataType();
const NodeId_template& dataType() const;
INTEGER_template& valueRank();
const INTEGER_template& valueRank() const;
INTEGER_template& isOptional();
const INTEGER_template& isOptional() const;
int size_of() const;
void log() const;
void log_match(const StructureField& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfStructureFieldArray : public Base_Type {
  INTEGER field_arrayLength;
  StructureFieldArray field_arrayValues;
public:
  ListOfStructureFieldArray();
  ListOfStructureFieldArray(const INTEGER& par_arrayLength,
    const StructureFieldArray& par_arrayValues);
  ListOfStructureFieldArray(const ListOfStructureFieldArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfStructureFieldArray& operator=(const ListOfStructureFieldArray& other_value);
  boolean operator==(const ListOfStructureFieldArray& other_value) const;
  inline boolean operator!=(const ListOfStructureFieldArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline StructureFieldArray& arrayValues()
    {return field_arrayValues;}
  inline const StructureFieldArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfStructureFieldArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfStructureFieldArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfStructureFieldArray& other_value);
void copy_template(const ListOfStructureFieldArray_template& other_value);

public:
ListOfStructureFieldArray_template();
ListOfStructureFieldArray_template(template_sel other_value);
ListOfStructureFieldArray_template(const ListOfStructureFieldArray& other_value);
ListOfStructureFieldArray_template(const OPTIONAL<ListOfStructureFieldArray>& other_value);
ListOfStructureFieldArray_template(const ListOfStructureFieldArray_template& other_value);
~ListOfStructureFieldArray_template();
ListOfStructureFieldArray_template& operator=(template_sel other_value);
ListOfStructureFieldArray_template& operator=(const ListOfStructureFieldArray& other_value);
ListOfStructureFieldArray_template& operator=(const OPTIONAL<ListOfStructureFieldArray>& other_value);
ListOfStructureFieldArray_template& operator=(const ListOfStructureFieldArray_template& other_value);
boolean match(const ListOfStructureFieldArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfStructureFieldArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfStructureFieldArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
StructureFieldArray_template& arrayValues();
const StructureFieldArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfStructureFieldArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class StructureDefinition {
  NodeId field_defaultEncodingId;
  NodeId field_baseDataType;
  StructureType field_structureType;
  ListOfStructureField field_fields;
public:
  StructureDefinition();
  StructureDefinition(const NodeId& par_defaultEncodingId,
    const NodeId& par_baseDataType,
    const StructureType& par_structureType,
    const ListOfStructureField& par_fields);
  StructureDefinition(const StructureDefinition& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  StructureDefinition& operator=(const StructureDefinition& other_value);
  boolean operator==(const StructureDefinition& other_value) const;
  inline boolean operator!=(const StructureDefinition& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& defaultEncodingId()
    {return field_defaultEncodingId;}
  inline const NodeId& defaultEncodingId() const
    {return field_defaultEncodingId;}
  inline NodeId& baseDataType()
    {return field_baseDataType;}
  inline const NodeId& baseDataType() const
    {return field_baseDataType;}
  inline StructureType& structureType()
    {return field_structureType;}
  inline const StructureType& structureType() const
    {return field_structureType;}
  inline ListOfStructureField& fields()
    {return field_fields;}
  inline const ListOfStructureField& fields() const
    {return field_fields;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class StructureDefinition_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
StructureDefinition_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const StructureDefinition& other_value);
void copy_template(const StructureDefinition_template& other_value);

public:
StructureDefinition_template();
StructureDefinition_template(template_sel other_value);
StructureDefinition_template(const StructureDefinition& other_value);
StructureDefinition_template(const OPTIONAL<StructureDefinition>& other_value);
StructureDefinition_template(const StructureDefinition_template& other_value);
~StructureDefinition_template();
StructureDefinition_template& operator=(template_sel other_value);
StructureDefinition_template& operator=(const StructureDefinition& other_value);
StructureDefinition_template& operator=(const OPTIONAL<StructureDefinition>& other_value);
StructureDefinition_template& operator=(const StructureDefinition_template& other_value);
boolean match(const StructureDefinition& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
StructureDefinition valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
StructureDefinition_template& list_item(unsigned int list_index) const;
NodeId_template& defaultEncodingId();
const NodeId_template& defaultEncodingId() const;
NodeId_template& baseDataType();
const NodeId_template& baseDataType() const;
StructureType_template& structureType();
const StructureType_template& structureType() const;
ListOfStructureField_template& fields();
const ListOfStructureField_template& fields() const;
int size_of() const;
void log() const;
void log_match(const StructureDefinition& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfEnumField : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfEnumFieldArray *field_realArray;
};
void copy_value(const ListOfEnumField& other_value);

public:
ListOfEnumField();
ListOfEnumField(const ListOfEnumField& other_value);
~ListOfEnumField();
ListOfEnumField& operator=(const ListOfEnumField& other_value);
boolean operator==(const ListOfEnumField& other_value) const;
inline boolean operator!=(const ListOfEnumField& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfEnumFieldArray& realArray();
const ListOfEnumFieldArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ListOfEnumField_template : public Base_Template {
union {
struct {
ListOfEnumField::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfEnumFieldArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfEnumField_template *list_value;
} value_list;
};
void copy_value(const ListOfEnumField& other_value);

void copy_template(const ListOfEnumField_template& other_value);

public:
ListOfEnumField_template();
ListOfEnumField_template(template_sel other_value);
ListOfEnumField_template(const ListOfEnumField& other_value);
ListOfEnumField_template(const OPTIONAL<ListOfEnumField>& other_value);
ListOfEnumField_template(const ListOfEnumField_template& other_value);
~ListOfEnumField_template();
void clean_up();
ListOfEnumField_template& operator=(template_sel other_value);
ListOfEnumField_template& operator=(const ListOfEnumField& other_value);
ListOfEnumField_template& operator=(const OPTIONAL<ListOfEnumField>& other_value);
ListOfEnumField_template& operator=(const ListOfEnumField_template& other_value);
boolean match(const ListOfEnumField& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfEnumField valueof() const;
ListOfEnumField_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfEnumFieldArray_template& realArray();
const ListOfEnumFieldArray_template& realArray() const;
boolean ischosen(ListOfEnumField::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfEnumField& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class EnumFieldArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
EnumField **value_elements;
} *val_ptr;

static const EnumField UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const EnumFieldArray& other_value);

public:
  typedef EnumField of_type;
EnumFieldArray();
EnumFieldArray(null_type other_value);
EnumFieldArray(const EnumFieldArray& other_value);
~EnumFieldArray();

void clean_up();
EnumFieldArray& operator=(null_type other_value);
EnumFieldArray& operator=(const EnumFieldArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const EnumFieldArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const EnumFieldArray& other_value) const { return !(*this == other_value); }

EnumField& operator[](int index_value);
EnumField& operator[](const INTEGER& index_value);
const EnumField& operator[](int index_value) const;
const EnumField& operator[](const INTEGER& index_value) const;

EnumFieldArray operator<<=(int rotate_count) const;
EnumFieldArray operator<<=(const INTEGER& rotate_count) const;
EnumFieldArray operator>>=(int rotate_count) const;
EnumFieldArray operator>>=(const INTEGER& rotate_count) const;

EnumFieldArray operator+(const EnumFieldArray& other_value) const;

EnumFieldArray substr(int index, int returncount) const;

EnumFieldArray replace(int index, int len, const EnumFieldArray& repl) const;

EnumFieldArray replace(int index, int len, const EnumFieldArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EnumFieldArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
EnumField_template **value_elements;
} single_value;
struct {
unsigned int n_values;
EnumFieldArray_template *list_value;
} value_list;
};
void copy_value(const EnumFieldArray& other_value);
void copy_template(const EnumFieldArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
EnumFieldArray_template();
EnumFieldArray_template(template_sel other_value);
EnumFieldArray_template(null_type other_value);
EnumFieldArray_template(const EnumFieldArray& other_value);
EnumFieldArray_template(const OPTIONAL<EnumFieldArray>& other_value);
EnumFieldArray_template(const EnumFieldArray_template& other_value);
~EnumFieldArray_template();

void clean_up();
EnumFieldArray_template& operator=(template_sel other_value);
EnumFieldArray_template& operator=(null_type other_value);
EnumFieldArray_template& operator=(const EnumFieldArray& other_value);
EnumFieldArray_template& operator=(const OPTIONAL<EnumFieldArray>& other_value);
EnumFieldArray_template& operator=(const EnumFieldArray_template& other_value);

EnumField_template& operator[](int index_value);
EnumField_template& operator[](const INTEGER& index_value);
const EnumField_template& operator[](int index_value) const;
const EnumField_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const EnumFieldArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
EnumFieldArray valueof() const;
EnumFieldArray substr(int index, int returncount) const;

EnumFieldArray replace(int index, int len, const EnumFieldArray_template& repl) const;

EnumFieldArray replace(int index, int len, const EnumFieldArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
EnumFieldArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const EnumFieldArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class EnumField : public Base_Type {
  String field_name;
public:
  EnumField();
  EnumField(const String& par_name);
  EnumField(const EnumField& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EnumField& operator=(const EnumField& other_value);
  boolean operator==(const EnumField& other_value) const;
  inline boolean operator!=(const EnumField& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& name()
    {return field_name;}
  inline const String& name() const
    {return field_name;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EnumField_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EnumField_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EnumField& other_value);
void copy_template(const EnumField_template& other_value);

public:
EnumField_template();
EnumField_template(template_sel other_value);
EnumField_template(const EnumField& other_value);
EnumField_template(const OPTIONAL<EnumField>& other_value);
EnumField_template(const EnumField_template& other_value);
~EnumField_template();
EnumField_template& operator=(template_sel other_value);
EnumField_template& operator=(const EnumField& other_value);
EnumField_template& operator=(const OPTIONAL<EnumField>& other_value);
EnumField_template& operator=(const EnumField_template& other_value);
boolean match(const EnumField& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EnumField valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EnumField_template& list_item(unsigned int list_index) const;
String_template& name();
const String_template& name() const;
int size_of() const;
void log() const;
void log_match(const EnumField& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfEnumFieldArray : public Base_Type {
  INTEGER field_arrayLength;
  EnumFieldArray field_arrayValues;
public:
  ListOfEnumFieldArray();
  ListOfEnumFieldArray(const INTEGER& par_arrayLength,
    const EnumFieldArray& par_arrayValues);
  ListOfEnumFieldArray(const ListOfEnumFieldArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfEnumFieldArray& operator=(const ListOfEnumFieldArray& other_value);
  boolean operator==(const ListOfEnumFieldArray& other_value) const;
  inline boolean operator!=(const ListOfEnumFieldArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline EnumFieldArray& arrayValues()
    {return field_arrayValues;}
  inline const EnumFieldArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfEnumFieldArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfEnumFieldArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfEnumFieldArray& other_value);
void copy_template(const ListOfEnumFieldArray_template& other_value);

public:
ListOfEnumFieldArray_template();
ListOfEnumFieldArray_template(template_sel other_value);
ListOfEnumFieldArray_template(const ListOfEnumFieldArray& other_value);
ListOfEnumFieldArray_template(const OPTIONAL<ListOfEnumFieldArray>& other_value);
ListOfEnumFieldArray_template(const ListOfEnumFieldArray_template& other_value);
~ListOfEnumFieldArray_template();
ListOfEnumFieldArray_template& operator=(template_sel other_value);
ListOfEnumFieldArray_template& operator=(const ListOfEnumFieldArray& other_value);
ListOfEnumFieldArray_template& operator=(const OPTIONAL<ListOfEnumFieldArray>& other_value);
ListOfEnumFieldArray_template& operator=(const ListOfEnumFieldArray_template& other_value);
boolean match(const ListOfEnumFieldArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfEnumFieldArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfEnumFieldArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
EnumFieldArray_template& arrayValues();
const EnumFieldArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfEnumFieldArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EnumDefinition {
  ListOfEnumField field_fields;
public:
  EnumDefinition();
  EnumDefinition(const ListOfEnumField& par_fields);
  EnumDefinition(const EnumDefinition& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EnumDefinition& operator=(const EnumDefinition& other_value);
  boolean operator==(const EnumDefinition& other_value) const;
  inline boolean operator!=(const EnumDefinition& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfEnumField& fields()
    {return field_fields;}
  inline const ListOfEnumField& fields() const
    {return field_fields;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class EnumDefinition_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EnumDefinition_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EnumDefinition& other_value);
void copy_template(const EnumDefinition_template& other_value);

public:
EnumDefinition_template();
EnumDefinition_template(template_sel other_value);
EnumDefinition_template(const EnumDefinition& other_value);
EnumDefinition_template(const OPTIONAL<EnumDefinition>& other_value);
EnumDefinition_template(const EnumDefinition_template& other_value);
~EnumDefinition_template();
EnumDefinition_template& operator=(template_sel other_value);
EnumDefinition_template& operator=(const EnumDefinition& other_value);
EnumDefinition_template& operator=(const OPTIONAL<EnumDefinition>& other_value);
EnumDefinition_template& operator=(const EnumDefinition_template& other_value);
boolean match(const EnumDefinition& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EnumDefinition valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EnumDefinition_template& list_item(unsigned int list_index) const;
ListOfEnumField_template& fields();
const ListOfEnumField_template& fields() const;
int size_of() const;
void log() const;
void log_match(const EnumDefinition& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class LocaleIdArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
String **value_elements;
} *val_ptr;

static const String UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const LocaleIdArray& other_value);

public:
  typedef String of_type;
LocaleIdArray();
LocaleIdArray(null_type other_value);
LocaleIdArray(const LocaleIdArray& other_value);
~LocaleIdArray();

void clean_up();
LocaleIdArray& operator=(null_type other_value);
LocaleIdArray& operator=(const LocaleIdArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const LocaleIdArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const LocaleIdArray& other_value) const { return !(*this == other_value); }

String& operator[](int index_value);
String& operator[](const INTEGER& index_value);
const String& operator[](int index_value) const;
const String& operator[](const INTEGER& index_value) const;

LocaleIdArray operator<<=(int rotate_count) const;
LocaleIdArray operator<<=(const INTEGER& rotate_count) const;
LocaleIdArray operator>>=(int rotate_count) const;
LocaleIdArray operator>>=(const INTEGER& rotate_count) const;

LocaleIdArray operator+(const LocaleIdArray& other_value) const;

LocaleIdArray substr(int index, int returncount) const;

LocaleIdArray replace(int index, int len, const LocaleIdArray& repl) const;

LocaleIdArray replace(int index, int len, const LocaleIdArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class LocaleIdArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
String_template **value_elements;
} single_value;
struct {
unsigned int n_values;
LocaleIdArray_template *list_value;
} value_list;
};
void copy_value(const LocaleIdArray& other_value);
void copy_template(const LocaleIdArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
LocaleIdArray_template();
LocaleIdArray_template(template_sel other_value);
LocaleIdArray_template(null_type other_value);
LocaleIdArray_template(const LocaleIdArray& other_value);
LocaleIdArray_template(const OPTIONAL<LocaleIdArray>& other_value);
LocaleIdArray_template(const LocaleIdArray_template& other_value);
~LocaleIdArray_template();

void clean_up();
LocaleIdArray_template& operator=(template_sel other_value);
LocaleIdArray_template& operator=(null_type other_value);
LocaleIdArray_template& operator=(const LocaleIdArray& other_value);
LocaleIdArray_template& operator=(const OPTIONAL<LocaleIdArray>& other_value);
LocaleIdArray_template& operator=(const LocaleIdArray_template& other_value);

String_template& operator[](int index_value);
String_template& operator[](const INTEGER& index_value);
const String_template& operator[](int index_value) const;
const String_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const LocaleIdArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
LocaleIdArray valueof() const;
LocaleIdArray substr(int index, int returncount) const;

LocaleIdArray replace(int index, int len, const LocaleIdArray_template& repl) const;

LocaleIdArray replace(int index, int len, const LocaleIdArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
LocaleIdArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const LocaleIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ContinuationPointArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ByteString **value_elements;
} *val_ptr;

static const ByteString UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ContinuationPointArray& other_value);

public:
  typedef ByteString of_type;
ContinuationPointArray();
ContinuationPointArray(null_type other_value);
ContinuationPointArray(const ContinuationPointArray& other_value);
~ContinuationPointArray();

void clean_up();
ContinuationPointArray& operator=(null_type other_value);
ContinuationPointArray& operator=(const ContinuationPointArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ContinuationPointArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ContinuationPointArray& other_value) const { return !(*this == other_value); }

ByteString& operator[](int index_value);
ByteString& operator[](const INTEGER& index_value);
const ByteString& operator[](int index_value) const;
const ByteString& operator[](const INTEGER& index_value) const;

ContinuationPointArray operator<<=(int rotate_count) const;
ContinuationPointArray operator<<=(const INTEGER& rotate_count) const;
ContinuationPointArray operator>>=(int rotate_count) const;
ContinuationPointArray operator>>=(const INTEGER& rotate_count) const;

ContinuationPointArray operator+(const ContinuationPointArray& other_value) const;

ContinuationPointArray substr(int index, int returncount) const;

ContinuationPointArray replace(int index, int len, const ContinuationPointArray& repl) const;

ContinuationPointArray replace(int index, int len, const ContinuationPointArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ContinuationPointArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ByteString_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ContinuationPointArray_template *list_value;
} value_list;
};
void copy_value(const ContinuationPointArray& other_value);
void copy_template(const ContinuationPointArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ContinuationPointArray_template();
ContinuationPointArray_template(template_sel other_value);
ContinuationPointArray_template(null_type other_value);
ContinuationPointArray_template(const ContinuationPointArray& other_value);
ContinuationPointArray_template(const OPTIONAL<ContinuationPointArray>& other_value);
ContinuationPointArray_template(const ContinuationPointArray_template& other_value);
~ContinuationPointArray_template();

void clean_up();
ContinuationPointArray_template& operator=(template_sel other_value);
ContinuationPointArray_template& operator=(null_type other_value);
ContinuationPointArray_template& operator=(const ContinuationPointArray& other_value);
ContinuationPointArray_template& operator=(const OPTIONAL<ContinuationPointArray>& other_value);
ContinuationPointArray_template& operator=(const ContinuationPointArray_template& other_value);

ByteString_template& operator[](int index_value);
ByteString_template& operator[](const INTEGER& index_value);
const ByteString_template& operator[](int index_value) const;
const ByteString_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ContinuationPointArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ContinuationPointArray valueof() const;
ContinuationPointArray substr(int index, int returncount) const;

ContinuationPointArray replace(int index, int len, const ContinuationPointArray_template& repl) const;

ContinuationPointArray replace(int index, int len, const ContinuationPointArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ContinuationPointArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ContinuationPointArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class DecimalArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
Decimal **value_elements;
} *val_ptr;

static const Decimal UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const DecimalArray& other_value);

public:
  typedef Decimal of_type;
DecimalArray();
DecimalArray(null_type other_value);
DecimalArray(const DecimalArray& other_value);
~DecimalArray();

void clean_up();
DecimalArray& operator=(null_type other_value);
DecimalArray& operator=(const DecimalArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const DecimalArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DecimalArray& other_value) const { return !(*this == other_value); }

Decimal& operator[](int index_value);
Decimal& operator[](const INTEGER& index_value);
const Decimal& operator[](int index_value) const;
const Decimal& operator[](const INTEGER& index_value) const;

DecimalArray operator<<=(int rotate_count) const;
DecimalArray operator<<=(const INTEGER& rotate_count) const;
DecimalArray operator>>=(int rotate_count) const;
DecimalArray operator>>=(const INTEGER& rotate_count) const;

DecimalArray operator+(const DecimalArray& other_value) const;

DecimalArray substr(int index, int returncount) const;

DecimalArray replace(int index, int len, const DecimalArray& repl) const;

DecimalArray replace(int index, int len, const DecimalArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DecimalArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
Decimal_template **value_elements;
} single_value;
struct {
unsigned int n_values;
DecimalArray_template *list_value;
} value_list;
};
void copy_value(const DecimalArray& other_value);
void copy_template(const DecimalArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
DecimalArray_template();
DecimalArray_template(template_sel other_value);
DecimalArray_template(null_type other_value);
DecimalArray_template(const DecimalArray& other_value);
DecimalArray_template(const OPTIONAL<DecimalArray>& other_value);
DecimalArray_template(const DecimalArray_template& other_value);
~DecimalArray_template();

void clean_up();
DecimalArray_template& operator=(template_sel other_value);
DecimalArray_template& operator=(null_type other_value);
DecimalArray_template& operator=(const DecimalArray& other_value);
DecimalArray_template& operator=(const OPTIONAL<DecimalArray>& other_value);
DecimalArray_template& operator=(const DecimalArray_template& other_value);

Decimal_template& operator[](int index_value);
Decimal_template& operator[](const INTEGER& index_value);
const Decimal_template& operator[](int index_value) const;
const Decimal_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const DecimalArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
DecimalArray valueof() const;
DecimalArray substr(int index, int returncount) const;

DecimalArray replace(int index, int len, const DecimalArray_template& repl) const;

DecimalArray replace(int index, int len, const DecimalArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
DecimalArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DecimalArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class EnumValueTypeArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
EnumValueType **value_elements;
} *val_ptr;

static const EnumValueType UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const EnumValueTypeArray& other_value);

public:
  typedef EnumValueType of_type;
EnumValueTypeArray();
EnumValueTypeArray(null_type other_value);
EnumValueTypeArray(const EnumValueTypeArray& other_value);
~EnumValueTypeArray();

void clean_up();
EnumValueTypeArray& operator=(null_type other_value);
EnumValueTypeArray& operator=(const EnumValueTypeArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const EnumValueTypeArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const EnumValueTypeArray& other_value) const { return !(*this == other_value); }

EnumValueType& operator[](int index_value);
EnumValueType& operator[](const INTEGER& index_value);
const EnumValueType& operator[](int index_value) const;
const EnumValueType& operator[](const INTEGER& index_value) const;

EnumValueTypeArray operator<<=(int rotate_count) const;
EnumValueTypeArray operator<<=(const INTEGER& rotate_count) const;
EnumValueTypeArray operator>>=(int rotate_count) const;
EnumValueTypeArray operator>>=(const INTEGER& rotate_count) const;

EnumValueTypeArray operator+(const EnumValueTypeArray& other_value) const;

EnumValueTypeArray substr(int index, int returncount) const;

EnumValueTypeArray replace(int index, int len, const EnumValueTypeArray& repl) const;

EnumValueTypeArray replace(int index, int len, const EnumValueTypeArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EnumValueTypeArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
EnumValueType_template **value_elements;
} single_value;
struct {
unsigned int n_values;
EnumValueTypeArray_template *list_value;
} value_list;
};
void copy_value(const EnumValueTypeArray& other_value);
void copy_template(const EnumValueTypeArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
EnumValueTypeArray_template();
EnumValueTypeArray_template(template_sel other_value);
EnumValueTypeArray_template(null_type other_value);
EnumValueTypeArray_template(const EnumValueTypeArray& other_value);
EnumValueTypeArray_template(const OPTIONAL<EnumValueTypeArray>& other_value);
EnumValueTypeArray_template(const EnumValueTypeArray_template& other_value);
~EnumValueTypeArray_template();

void clean_up();
EnumValueTypeArray_template& operator=(template_sel other_value);
EnumValueTypeArray_template& operator=(null_type other_value);
EnumValueTypeArray_template& operator=(const EnumValueTypeArray& other_value);
EnumValueTypeArray_template& operator=(const OPTIONAL<EnumValueTypeArray>& other_value);
EnumValueTypeArray_template& operator=(const EnumValueTypeArray_template& other_value);

EnumValueType_template& operator[](int index_value);
EnumValueType_template& operator[](const INTEGER& index_value);
const EnumValueType_template& operator[](int index_value) const;
const EnumValueType_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const EnumValueTypeArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
EnumValueTypeArray valueof() const;
EnumValueTypeArray substr(int index, int returncount) const;

EnumValueTypeArray replace(int index, int len, const EnumValueTypeArray_template& repl) const;

EnumValueTypeArray replace(int index, int len, const EnumValueTypeArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
EnumValueTypeArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const EnumValueTypeArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ApplicationDescriptionArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ApplicationDescription **value_elements;
} *val_ptr;

static const ApplicationDescription UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ApplicationDescriptionArray& other_value);

public:
  typedef ApplicationDescription of_type;
ApplicationDescriptionArray();
ApplicationDescriptionArray(null_type other_value);
ApplicationDescriptionArray(const ApplicationDescriptionArray& other_value);
~ApplicationDescriptionArray();

void clean_up();
ApplicationDescriptionArray& operator=(null_type other_value);
ApplicationDescriptionArray& operator=(const ApplicationDescriptionArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ApplicationDescriptionArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ApplicationDescriptionArray& other_value) const { return !(*this == other_value); }

ApplicationDescription& operator[](int index_value);
ApplicationDescription& operator[](const INTEGER& index_value);
const ApplicationDescription& operator[](int index_value) const;
const ApplicationDescription& operator[](const INTEGER& index_value) const;

ApplicationDescriptionArray operator<<=(int rotate_count) const;
ApplicationDescriptionArray operator<<=(const INTEGER& rotate_count) const;
ApplicationDescriptionArray operator>>=(int rotate_count) const;
ApplicationDescriptionArray operator>>=(const INTEGER& rotate_count) const;

ApplicationDescriptionArray operator+(const ApplicationDescriptionArray& other_value) const;

ApplicationDescriptionArray substr(int index, int returncount) const;

ApplicationDescriptionArray replace(int index, int len, const ApplicationDescriptionArray& repl) const;

ApplicationDescriptionArray replace(int index, int len, const ApplicationDescriptionArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ApplicationDescriptionArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ApplicationDescription_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ApplicationDescriptionArray_template *list_value;
} value_list;
};
void copy_value(const ApplicationDescriptionArray& other_value);
void copy_template(const ApplicationDescriptionArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ApplicationDescriptionArray_template();
ApplicationDescriptionArray_template(template_sel other_value);
ApplicationDescriptionArray_template(null_type other_value);
ApplicationDescriptionArray_template(const ApplicationDescriptionArray& other_value);
ApplicationDescriptionArray_template(const OPTIONAL<ApplicationDescriptionArray>& other_value);
ApplicationDescriptionArray_template(const ApplicationDescriptionArray_template& other_value);
~ApplicationDescriptionArray_template();

void clean_up();
ApplicationDescriptionArray_template& operator=(template_sel other_value);
ApplicationDescriptionArray_template& operator=(null_type other_value);
ApplicationDescriptionArray_template& operator=(const ApplicationDescriptionArray& other_value);
ApplicationDescriptionArray_template& operator=(const OPTIONAL<ApplicationDescriptionArray>& other_value);
ApplicationDescriptionArray_template& operator=(const ApplicationDescriptionArray_template& other_value);

ApplicationDescription_template& operator[](int index_value);
ApplicationDescription_template& operator[](const INTEGER& index_value);
const ApplicationDescription_template& operator[](int index_value) const;
const ApplicationDescription_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ApplicationDescriptionArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ApplicationDescriptionArray valueof() const;
ApplicationDescriptionArray substr(int index, int returncount) const;

ApplicationDescriptionArray replace(int index, int len, const ApplicationDescriptionArray_template& repl) const;

ApplicationDescriptionArray replace(int index, int len, const ApplicationDescriptionArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ApplicationDescriptionArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ApplicationDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ApplicationDescription : public Base_Type {
  String field_applicationUri;
  String field_productUri;
  LocalizedText field_applicationName;
  ApplicationType field_applicationType;
  String field_gatewayServerUri;
  String field_discoveryProfileUri;
  ListOfString field_discoveryUrls;
public:
  ApplicationDescription();
  ApplicationDescription(const String& par_applicationUri,
    const String& par_productUri,
    const LocalizedText& par_applicationName,
    const ApplicationType& par_applicationType,
    const String& par_gatewayServerUri,
    const String& par_discoveryProfileUri,
    const ListOfString& par_discoveryUrls);
  ApplicationDescription(const ApplicationDescription& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ApplicationDescription& operator=(const ApplicationDescription& other_value);
  boolean operator==(const ApplicationDescription& other_value) const;
  inline boolean operator!=(const ApplicationDescription& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& applicationUri()
    {return field_applicationUri;}
  inline const String& applicationUri() const
    {return field_applicationUri;}
  inline String& productUri()
    {return field_productUri;}
  inline const String& productUri() const
    {return field_productUri;}
  inline LocalizedText& applicationName()
    {return field_applicationName;}
  inline const LocalizedText& applicationName() const
    {return field_applicationName;}
  inline ApplicationType& applicationType()
    {return field_applicationType;}
  inline const ApplicationType& applicationType() const
    {return field_applicationType;}
  inline String& gatewayServerUri()
    {return field_gatewayServerUri;}
  inline const String& gatewayServerUri() const
    {return field_gatewayServerUri;}
  inline String& discoveryProfileUri()
    {return field_discoveryProfileUri;}
  inline const String& discoveryProfileUri() const
    {return field_discoveryProfileUri;}
  inline ListOfString& discoveryUrls()
    {return field_discoveryUrls;}
  inline const ListOfString& discoveryUrls() const
    {return field_discoveryUrls;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ApplicationDescription_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ApplicationDescription_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ApplicationDescription& other_value);
void copy_template(const ApplicationDescription_template& other_value);

public:
ApplicationDescription_template();
ApplicationDescription_template(template_sel other_value);
ApplicationDescription_template(const ApplicationDescription& other_value);
ApplicationDescription_template(const OPTIONAL<ApplicationDescription>& other_value);
ApplicationDescription_template(const ApplicationDescription_template& other_value);
~ApplicationDescription_template();
ApplicationDescription_template& operator=(template_sel other_value);
ApplicationDescription_template& operator=(const ApplicationDescription& other_value);
ApplicationDescription_template& operator=(const OPTIONAL<ApplicationDescription>& other_value);
ApplicationDescription_template& operator=(const ApplicationDescription_template& other_value);
boolean match(const ApplicationDescription& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ApplicationDescription valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ApplicationDescription_template& list_item(unsigned int list_index) const;
String_template& applicationUri();
const String_template& applicationUri() const;
String_template& productUri();
const String_template& productUri() const;
LocalizedText_template& applicationName();
const LocalizedText_template& applicationName() const;
ApplicationType_template& applicationType();
const ApplicationType_template& applicationType() const;
String_template& gatewayServerUri();
const String_template& gatewayServerUri() const;
String_template& discoveryProfileUri();
const String_template& discoveryProfileUri() const;
ListOfString_template& discoveryUrls();
const ListOfString_template& discoveryUrls() const;
int size_of() const;
void log() const;
void log_match(const ApplicationDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowseResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BrowseResult **value_elements;
} *val_ptr;

static const BrowseResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const BrowseResultArray& other_value);

public:
  typedef BrowseResult of_type;
BrowseResultArray();
BrowseResultArray(null_type other_value);
BrowseResultArray(const BrowseResultArray& other_value);
~BrowseResultArray();

void clean_up();
BrowseResultArray& operator=(null_type other_value);
BrowseResultArray& operator=(const BrowseResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const BrowseResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const BrowseResultArray& other_value) const { return !(*this == other_value); }

BrowseResult& operator[](int index_value);
BrowseResult& operator[](const INTEGER& index_value);
const BrowseResult& operator[](int index_value) const;
const BrowseResult& operator[](const INTEGER& index_value) const;

BrowseResultArray operator<<=(int rotate_count) const;
BrowseResultArray operator<<=(const INTEGER& rotate_count) const;
BrowseResultArray operator>>=(int rotate_count) const;
BrowseResultArray operator>>=(const INTEGER& rotate_count) const;

BrowseResultArray operator+(const BrowseResultArray& other_value) const;

BrowseResultArray substr(int index, int returncount) const;

BrowseResultArray replace(int index, int len, const BrowseResultArray& repl) const;

BrowseResultArray replace(int index, int len, const BrowseResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
BrowseResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
BrowseResultArray_template *list_value;
} value_list;
};
void copy_value(const BrowseResultArray& other_value);
void copy_template(const BrowseResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
BrowseResultArray_template();
BrowseResultArray_template(template_sel other_value);
BrowseResultArray_template(null_type other_value);
BrowseResultArray_template(const BrowseResultArray& other_value);
BrowseResultArray_template(const OPTIONAL<BrowseResultArray>& other_value);
BrowseResultArray_template(const BrowseResultArray_template& other_value);
~BrowseResultArray_template();

void clean_up();
BrowseResultArray_template& operator=(template_sel other_value);
BrowseResultArray_template& operator=(null_type other_value);
BrowseResultArray_template& operator=(const BrowseResultArray& other_value);
BrowseResultArray_template& operator=(const OPTIONAL<BrowseResultArray>& other_value);
BrowseResultArray_template& operator=(const BrowseResultArray_template& other_value);

BrowseResult_template& operator[](int index_value);
BrowseResult_template& operator[](const INTEGER& index_value);
const BrowseResult_template& operator[](int index_value) const;
const BrowseResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const BrowseResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
BrowseResultArray valueof() const;
BrowseResultArray substr(int index, int returncount) const;

BrowseResultArray replace(int index, int len, const BrowseResultArray_template& repl) const;

BrowseResultArray replace(int index, int len, const BrowseResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
BrowseResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const BrowseResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfReferenceDescription : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfReferenceDescriptionArray *field_realArray;
};
void copy_value(const ListOfReferenceDescription& other_value);

public:
ListOfReferenceDescription();
ListOfReferenceDescription(const ListOfReferenceDescription& other_value);
~ListOfReferenceDescription();
ListOfReferenceDescription& operator=(const ListOfReferenceDescription& other_value);
boolean operator==(const ListOfReferenceDescription& other_value) const;
inline boolean operator!=(const ListOfReferenceDescription& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfReferenceDescriptionArray& realArray();
const ListOfReferenceDescriptionArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfReferenceDescription_template : public Base_Template {
union {
struct {
ListOfReferenceDescription::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfReferenceDescriptionArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfReferenceDescription_template *list_value;
} value_list;
};
void copy_value(const ListOfReferenceDescription& other_value);

void copy_template(const ListOfReferenceDescription_template& other_value);

public:
ListOfReferenceDescription_template();
ListOfReferenceDescription_template(template_sel other_value);
ListOfReferenceDescription_template(const ListOfReferenceDescription& other_value);
ListOfReferenceDescription_template(const OPTIONAL<ListOfReferenceDescription>& other_value);
ListOfReferenceDescription_template(const ListOfReferenceDescription_template& other_value);
~ListOfReferenceDescription_template();
void clean_up();
ListOfReferenceDescription_template& operator=(template_sel other_value);
ListOfReferenceDescription_template& operator=(const ListOfReferenceDescription& other_value);
ListOfReferenceDescription_template& operator=(const OPTIONAL<ListOfReferenceDescription>& other_value);
ListOfReferenceDescription_template& operator=(const ListOfReferenceDescription_template& other_value);
boolean match(const ListOfReferenceDescription& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfReferenceDescription valueof() const;
ListOfReferenceDescription_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfReferenceDescriptionArray_template& realArray();
const ListOfReferenceDescriptionArray_template& realArray() const;
boolean ischosen(ListOfReferenceDescription::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfReferenceDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ReferenceDescriptionArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ReferenceDescription **value_elements;
} *val_ptr;

static const ReferenceDescription UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ReferenceDescriptionArray& other_value);

public:
  typedef ReferenceDescription of_type;
ReferenceDescriptionArray();
ReferenceDescriptionArray(null_type other_value);
ReferenceDescriptionArray(const ReferenceDescriptionArray& other_value);
~ReferenceDescriptionArray();

void clean_up();
ReferenceDescriptionArray& operator=(null_type other_value);
ReferenceDescriptionArray& operator=(const ReferenceDescriptionArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ReferenceDescriptionArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ReferenceDescriptionArray& other_value) const { return !(*this == other_value); }

ReferenceDescription& operator[](int index_value);
ReferenceDescription& operator[](const INTEGER& index_value);
const ReferenceDescription& operator[](int index_value) const;
const ReferenceDescription& operator[](const INTEGER& index_value) const;

ReferenceDescriptionArray operator<<=(int rotate_count) const;
ReferenceDescriptionArray operator<<=(const INTEGER& rotate_count) const;
ReferenceDescriptionArray operator>>=(int rotate_count) const;
ReferenceDescriptionArray operator>>=(const INTEGER& rotate_count) const;

ReferenceDescriptionArray operator+(const ReferenceDescriptionArray& other_value) const;

ReferenceDescriptionArray substr(int index, int returncount) const;

ReferenceDescriptionArray replace(int index, int len, const ReferenceDescriptionArray& repl) const;

ReferenceDescriptionArray replace(int index, int len, const ReferenceDescriptionArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReferenceDescriptionArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ReferenceDescription_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ReferenceDescriptionArray_template *list_value;
} value_list;
};
void copy_value(const ReferenceDescriptionArray& other_value);
void copy_template(const ReferenceDescriptionArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ReferenceDescriptionArray_template();
ReferenceDescriptionArray_template(template_sel other_value);
ReferenceDescriptionArray_template(null_type other_value);
ReferenceDescriptionArray_template(const ReferenceDescriptionArray& other_value);
ReferenceDescriptionArray_template(const OPTIONAL<ReferenceDescriptionArray>& other_value);
ReferenceDescriptionArray_template(const ReferenceDescriptionArray_template& other_value);
~ReferenceDescriptionArray_template();

void clean_up();
ReferenceDescriptionArray_template& operator=(template_sel other_value);
ReferenceDescriptionArray_template& operator=(null_type other_value);
ReferenceDescriptionArray_template& operator=(const ReferenceDescriptionArray& other_value);
ReferenceDescriptionArray_template& operator=(const OPTIONAL<ReferenceDescriptionArray>& other_value);
ReferenceDescriptionArray_template& operator=(const ReferenceDescriptionArray_template& other_value);

ReferenceDescription_template& operator[](int index_value);
ReferenceDescription_template& operator[](const INTEGER& index_value);
const ReferenceDescription_template& operator[](int index_value) const;
const ReferenceDescription_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ReferenceDescriptionArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ReferenceDescriptionArray valueof() const;
ReferenceDescriptionArray substr(int index, int returncount) const;

ReferenceDescriptionArray replace(int index, int len, const ReferenceDescriptionArray_template& repl) const;

ReferenceDescriptionArray replace(int index, int len, const ReferenceDescriptionArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ReferenceDescriptionArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ReferenceDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ReferenceDescription : public Base_Type {
  NodeId field_referenceTypeId;
  INTEGER field_isForward;
  ExpandedNodeId field_nodeId;
  QualifiedName field_browseName;
  LocalizedText field_displayName;
  NodeClass field_nodeClass;
  ExpandedNodeId field_typeDefinition;
public:
  ReferenceDescription();
  ReferenceDescription(const NodeId& par_referenceTypeId,
    const INTEGER& par_isForward,
    const ExpandedNodeId& par_nodeId,
    const QualifiedName& par_browseName,
    const LocalizedText& par_displayName,
    const NodeClass& par_nodeClass,
    const ExpandedNodeId& par_typeDefinition);
  ReferenceDescription(const ReferenceDescription& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReferenceDescription& operator=(const ReferenceDescription& other_value);
  boolean operator==(const ReferenceDescription& other_value) const;
  inline boolean operator!=(const ReferenceDescription& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& referenceTypeId()
    {return field_referenceTypeId;}
  inline const NodeId& referenceTypeId() const
    {return field_referenceTypeId;}
  inline INTEGER& isForward()
    {return field_isForward;}
  inline const INTEGER& isForward() const
    {return field_isForward;}
  inline ExpandedNodeId& nodeId()
    {return field_nodeId;}
  inline const ExpandedNodeId& nodeId() const
    {return field_nodeId;}
  inline QualifiedName& browseName()
    {return field_browseName;}
  inline const QualifiedName& browseName() const
    {return field_browseName;}
  inline LocalizedText& displayName()
    {return field_displayName;}
  inline const LocalizedText& displayName() const
    {return field_displayName;}
  inline NodeClass& nodeClass()
    {return field_nodeClass;}
  inline const NodeClass& nodeClass() const
    {return field_nodeClass;}
  inline ExpandedNodeId& typeDefinition()
    {return field_typeDefinition;}
  inline const ExpandedNodeId& typeDefinition() const
    {return field_typeDefinition;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReferenceDescription_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReferenceDescription_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReferenceDescription& other_value);
void copy_template(const ReferenceDescription_template& other_value);

public:
ReferenceDescription_template();
ReferenceDescription_template(template_sel other_value);
ReferenceDescription_template(const ReferenceDescription& other_value);
ReferenceDescription_template(const OPTIONAL<ReferenceDescription>& other_value);
ReferenceDescription_template(const ReferenceDescription_template& other_value);
~ReferenceDescription_template();
ReferenceDescription_template& operator=(template_sel other_value);
ReferenceDescription_template& operator=(const ReferenceDescription& other_value);
ReferenceDescription_template& operator=(const OPTIONAL<ReferenceDescription>& other_value);
ReferenceDescription_template& operator=(const ReferenceDescription_template& other_value);
boolean match(const ReferenceDescription& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReferenceDescription valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReferenceDescription_template& list_item(unsigned int list_index) const;
NodeId_template& referenceTypeId();
const NodeId_template& referenceTypeId() const;
INTEGER_template& isForward();
const INTEGER_template& isForward() const;
ExpandedNodeId_template& nodeId();
const ExpandedNodeId_template& nodeId() const;
QualifiedName_template& browseName();
const QualifiedName_template& browseName() const;
LocalizedText_template& displayName();
const LocalizedText_template& displayName() const;
NodeClass_template& nodeClass();
const NodeClass_template& nodeClass() const;
ExpandedNodeId_template& typeDefinition();
const ExpandedNodeId_template& typeDefinition() const;
int size_of() const;
void log() const;
void log_match(const ReferenceDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfReferenceDescriptionArray : public Base_Type {
  INTEGER field_arrayLength;
  ReferenceDescriptionArray field_arrayValues;
public:
  ListOfReferenceDescriptionArray();
  ListOfReferenceDescriptionArray(const INTEGER& par_arrayLength,
    const ReferenceDescriptionArray& par_arrayValues);
  ListOfReferenceDescriptionArray(const ListOfReferenceDescriptionArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfReferenceDescriptionArray& operator=(const ListOfReferenceDescriptionArray& other_value);
  boolean operator==(const ListOfReferenceDescriptionArray& other_value) const;
  inline boolean operator!=(const ListOfReferenceDescriptionArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ReferenceDescriptionArray& arrayValues()
    {return field_arrayValues;}
  inline const ReferenceDescriptionArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfReferenceDescriptionArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfReferenceDescriptionArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfReferenceDescriptionArray& other_value);
void copy_template(const ListOfReferenceDescriptionArray_template& other_value);

public:
ListOfReferenceDescriptionArray_template();
ListOfReferenceDescriptionArray_template(template_sel other_value);
ListOfReferenceDescriptionArray_template(const ListOfReferenceDescriptionArray& other_value);
ListOfReferenceDescriptionArray_template(const OPTIONAL<ListOfReferenceDescriptionArray>& other_value);
ListOfReferenceDescriptionArray_template(const ListOfReferenceDescriptionArray_template& other_value);
~ListOfReferenceDescriptionArray_template();
ListOfReferenceDescriptionArray_template& operator=(template_sel other_value);
ListOfReferenceDescriptionArray_template& operator=(const ListOfReferenceDescriptionArray& other_value);
ListOfReferenceDescriptionArray_template& operator=(const OPTIONAL<ListOfReferenceDescriptionArray>& other_value);
ListOfReferenceDescriptionArray_template& operator=(const ListOfReferenceDescriptionArray_template& other_value);
boolean match(const ListOfReferenceDescriptionArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfReferenceDescriptionArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfReferenceDescriptionArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ReferenceDescriptionArray_template& arrayValues();
const ReferenceDescriptionArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfReferenceDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowseResult : public Base_Type {
  INTEGER field_statusCode;
  ByteString field_continuationPoint;
  ListOfReferenceDescription field_References;
public:
  BrowseResult();
  BrowseResult(const INTEGER& par_statusCode,
    const ByteString& par_continuationPoint,
    const ListOfReferenceDescription& par_References);
  BrowseResult(const BrowseResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowseResult& operator=(const BrowseResult& other_value);
  boolean operator==(const BrowseResult& other_value) const;
  inline boolean operator!=(const BrowseResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline ByteString& continuationPoint()
    {return field_continuationPoint;}
  inline const ByteString& continuationPoint() const
    {return field_continuationPoint;}
  inline ListOfReferenceDescription& References()
    {return field_References;}
  inline const ListOfReferenceDescription& References() const
    {return field_References;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowseResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowseResult& other_value);
void copy_template(const BrowseResult_template& other_value);

public:
BrowseResult_template();
BrowseResult_template(template_sel other_value);
BrowseResult_template(const BrowseResult& other_value);
BrowseResult_template(const OPTIONAL<BrowseResult>& other_value);
BrowseResult_template(const BrowseResult_template& other_value);
~BrowseResult_template();
BrowseResult_template& operator=(template_sel other_value);
BrowseResult_template& operator=(const BrowseResult& other_value);
BrowseResult_template& operator=(const OPTIONAL<BrowseResult>& other_value);
BrowseResult_template& operator=(const BrowseResult_template& other_value);
boolean match(const BrowseResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowseResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowseResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
ByteString_template& continuationPoint();
const ByteString_template& continuationPoint() const;
ListOfReferenceDescription_template& References();
const ListOfReferenceDescription_template& References() const;
int size_of() const;
void log() const;
void log_match(const BrowseResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EndpointDescriptionArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
EndpointDescription **value_elements;
} *val_ptr;

static const EndpointDescription UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const EndpointDescriptionArray& other_value);

public:
  typedef EndpointDescription of_type;
EndpointDescriptionArray();
EndpointDescriptionArray(null_type other_value);
EndpointDescriptionArray(const EndpointDescriptionArray& other_value);
~EndpointDescriptionArray();

void clean_up();
EndpointDescriptionArray& operator=(null_type other_value);
EndpointDescriptionArray& operator=(const EndpointDescriptionArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const EndpointDescriptionArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const EndpointDescriptionArray& other_value) const { return !(*this == other_value); }

EndpointDescription& operator[](int index_value);
EndpointDescription& operator[](const INTEGER& index_value);
const EndpointDescription& operator[](int index_value) const;
const EndpointDescription& operator[](const INTEGER& index_value) const;

EndpointDescriptionArray operator<<=(int rotate_count) const;
EndpointDescriptionArray operator<<=(const INTEGER& rotate_count) const;
EndpointDescriptionArray operator>>=(int rotate_count) const;
EndpointDescriptionArray operator>>=(const INTEGER& rotate_count) const;

EndpointDescriptionArray operator+(const EndpointDescriptionArray& other_value) const;

EndpointDescriptionArray substr(int index, int returncount) const;

EndpointDescriptionArray replace(int index, int len, const EndpointDescriptionArray& repl) const;

EndpointDescriptionArray replace(int index, int len, const EndpointDescriptionArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EndpointDescriptionArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
EndpointDescription_template **value_elements;
} single_value;
struct {
unsigned int n_values;
EndpointDescriptionArray_template *list_value;
} value_list;
};
void copy_value(const EndpointDescriptionArray& other_value);
void copy_template(const EndpointDescriptionArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
EndpointDescriptionArray_template();
EndpointDescriptionArray_template(template_sel other_value);
EndpointDescriptionArray_template(null_type other_value);
EndpointDescriptionArray_template(const EndpointDescriptionArray& other_value);
EndpointDescriptionArray_template(const OPTIONAL<EndpointDescriptionArray>& other_value);
EndpointDescriptionArray_template(const EndpointDescriptionArray_template& other_value);
~EndpointDescriptionArray_template();

void clean_up();
EndpointDescriptionArray_template& operator=(template_sel other_value);
EndpointDescriptionArray_template& operator=(null_type other_value);
EndpointDescriptionArray_template& operator=(const EndpointDescriptionArray& other_value);
EndpointDescriptionArray_template& operator=(const OPTIONAL<EndpointDescriptionArray>& other_value);
EndpointDescriptionArray_template& operator=(const EndpointDescriptionArray_template& other_value);

EndpointDescription_template& operator[](int index_value);
EndpointDescription_template& operator[](const INTEGER& index_value);
const EndpointDescription_template& operator[](int index_value) const;
const EndpointDescription_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const EndpointDescriptionArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
EndpointDescriptionArray valueof() const;
EndpointDescriptionArray substr(int index, int returncount) const;

EndpointDescriptionArray replace(int index, int len, const EndpointDescriptionArray_template& repl) const;

EndpointDescriptionArray replace(int index, int len, const EndpointDescriptionArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
EndpointDescriptionArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const EndpointDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfUserTokenPolicy : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfUserTokenPolicyArray *field_realArray;
};
void copy_value(const ListOfUserTokenPolicy& other_value);

public:
ListOfUserTokenPolicy();
ListOfUserTokenPolicy(const ListOfUserTokenPolicy& other_value);
~ListOfUserTokenPolicy();
ListOfUserTokenPolicy& operator=(const ListOfUserTokenPolicy& other_value);
boolean operator==(const ListOfUserTokenPolicy& other_value) const;
inline boolean operator!=(const ListOfUserTokenPolicy& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfUserTokenPolicyArray& realArray();
const ListOfUserTokenPolicyArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUserTokenPolicy_template : public Base_Template {
union {
struct {
ListOfUserTokenPolicy::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfUserTokenPolicyArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfUserTokenPolicy_template *list_value;
} value_list;
};
void copy_value(const ListOfUserTokenPolicy& other_value);

void copy_template(const ListOfUserTokenPolicy_template& other_value);

public:
ListOfUserTokenPolicy_template();
ListOfUserTokenPolicy_template(template_sel other_value);
ListOfUserTokenPolicy_template(const ListOfUserTokenPolicy& other_value);
ListOfUserTokenPolicy_template(const OPTIONAL<ListOfUserTokenPolicy>& other_value);
ListOfUserTokenPolicy_template(const ListOfUserTokenPolicy_template& other_value);
~ListOfUserTokenPolicy_template();
void clean_up();
ListOfUserTokenPolicy_template& operator=(template_sel other_value);
ListOfUserTokenPolicy_template& operator=(const ListOfUserTokenPolicy& other_value);
ListOfUserTokenPolicy_template& operator=(const OPTIONAL<ListOfUserTokenPolicy>& other_value);
ListOfUserTokenPolicy_template& operator=(const ListOfUserTokenPolicy_template& other_value);
boolean match(const ListOfUserTokenPolicy& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfUserTokenPolicy valueof() const;
ListOfUserTokenPolicy_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfUserTokenPolicyArray_template& realArray();
const ListOfUserTokenPolicyArray_template& realArray() const;
boolean ischosen(ListOfUserTokenPolicy::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfUserTokenPolicy& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class UserTokenPolicyArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
UserTokenPolicy **value_elements;
} *val_ptr;

static const UserTokenPolicy UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const UserTokenPolicyArray& other_value);

public:
  typedef UserTokenPolicy of_type;
UserTokenPolicyArray();
UserTokenPolicyArray(null_type other_value);
UserTokenPolicyArray(const UserTokenPolicyArray& other_value);
~UserTokenPolicyArray();

void clean_up();
UserTokenPolicyArray& operator=(null_type other_value);
UserTokenPolicyArray& operator=(const UserTokenPolicyArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const UserTokenPolicyArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const UserTokenPolicyArray& other_value) const { return !(*this == other_value); }

UserTokenPolicy& operator[](int index_value);
UserTokenPolicy& operator[](const INTEGER& index_value);
const UserTokenPolicy& operator[](int index_value) const;
const UserTokenPolicy& operator[](const INTEGER& index_value) const;

UserTokenPolicyArray operator<<=(int rotate_count) const;
UserTokenPolicyArray operator<<=(const INTEGER& rotate_count) const;
UserTokenPolicyArray operator>>=(int rotate_count) const;
UserTokenPolicyArray operator>>=(const INTEGER& rotate_count) const;

UserTokenPolicyArray operator+(const UserTokenPolicyArray& other_value) const;

UserTokenPolicyArray substr(int index, int returncount) const;

UserTokenPolicyArray replace(int index, int len, const UserTokenPolicyArray& repl) const;

UserTokenPolicyArray replace(int index, int len, const UserTokenPolicyArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UserTokenPolicyArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
UserTokenPolicy_template **value_elements;
} single_value;
struct {
unsigned int n_values;
UserTokenPolicyArray_template *list_value;
} value_list;
};
void copy_value(const UserTokenPolicyArray& other_value);
void copy_template(const UserTokenPolicyArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
UserTokenPolicyArray_template();
UserTokenPolicyArray_template(template_sel other_value);
UserTokenPolicyArray_template(null_type other_value);
UserTokenPolicyArray_template(const UserTokenPolicyArray& other_value);
UserTokenPolicyArray_template(const OPTIONAL<UserTokenPolicyArray>& other_value);
UserTokenPolicyArray_template(const UserTokenPolicyArray_template& other_value);
~UserTokenPolicyArray_template();

void clean_up();
UserTokenPolicyArray_template& operator=(template_sel other_value);
UserTokenPolicyArray_template& operator=(null_type other_value);
UserTokenPolicyArray_template& operator=(const UserTokenPolicyArray& other_value);
UserTokenPolicyArray_template& operator=(const OPTIONAL<UserTokenPolicyArray>& other_value);
UserTokenPolicyArray_template& operator=(const UserTokenPolicyArray_template& other_value);

UserTokenPolicy_template& operator[](int index_value);
UserTokenPolicy_template& operator[](const INTEGER& index_value);
const UserTokenPolicy_template& operator[](int index_value) const;
const UserTokenPolicy_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const UserTokenPolicyArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
UserTokenPolicyArray valueof() const;
UserTokenPolicyArray substr(int index, int returncount) const;

UserTokenPolicyArray replace(int index, int len, const UserTokenPolicyArray_template& repl) const;

UserTokenPolicyArray replace(int index, int len, const UserTokenPolicyArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
UserTokenPolicyArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const UserTokenPolicyArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class UserTokenPolicy : public Base_Type {
  String field_policyId;
  UserIdentityTokenType field_tokenType;
  String field_issuedTokenType;
  String field_issuerEndpointUrl;
  String field_securityPolicyUri;
public:
  UserTokenPolicy();
  UserTokenPolicy(const String& par_policyId,
    const UserIdentityTokenType& par_tokenType,
    const String& par_issuedTokenType,
    const String& par_issuerEndpointUrl,
    const String& par_securityPolicyUri);
  UserTokenPolicy(const UserTokenPolicy& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UserTokenPolicy& operator=(const UserTokenPolicy& other_value);
  boolean operator==(const UserTokenPolicy& other_value) const;
  inline boolean operator!=(const UserTokenPolicy& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& policyId()
    {return field_policyId;}
  inline const String& policyId() const
    {return field_policyId;}
  inline UserIdentityTokenType& tokenType()
    {return field_tokenType;}
  inline const UserIdentityTokenType& tokenType() const
    {return field_tokenType;}
  inline String& issuedTokenType()
    {return field_issuedTokenType;}
  inline const String& issuedTokenType() const
    {return field_issuedTokenType;}
  inline String& issuerEndpointUrl()
    {return field_issuerEndpointUrl;}
  inline const String& issuerEndpointUrl() const
    {return field_issuerEndpointUrl;}
  inline String& securityPolicyUri()
    {return field_securityPolicyUri;}
  inline const String& securityPolicyUri() const
    {return field_securityPolicyUri;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UserTokenPolicy_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UserTokenPolicy_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UserTokenPolicy& other_value);
void copy_template(const UserTokenPolicy_template& other_value);

public:
UserTokenPolicy_template();
UserTokenPolicy_template(template_sel other_value);
UserTokenPolicy_template(const UserTokenPolicy& other_value);
UserTokenPolicy_template(const OPTIONAL<UserTokenPolicy>& other_value);
UserTokenPolicy_template(const UserTokenPolicy_template& other_value);
~UserTokenPolicy_template();
UserTokenPolicy_template& operator=(template_sel other_value);
UserTokenPolicy_template& operator=(const UserTokenPolicy& other_value);
UserTokenPolicy_template& operator=(const OPTIONAL<UserTokenPolicy>& other_value);
UserTokenPolicy_template& operator=(const UserTokenPolicy_template& other_value);
boolean match(const UserTokenPolicy& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UserTokenPolicy valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UserTokenPolicy_template& list_item(unsigned int list_index) const;
String_template& policyId();
const String_template& policyId() const;
UserIdentityTokenType_template& tokenType();
const UserIdentityTokenType_template& tokenType() const;
String_template& issuedTokenType();
const String_template& issuedTokenType() const;
String_template& issuerEndpointUrl();
const String_template& issuerEndpointUrl() const;
String_template& securityPolicyUri();
const String_template& securityPolicyUri() const;
int size_of() const;
void log() const;
void log_match(const UserTokenPolicy& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfUserTokenPolicyArray : public Base_Type {
  INTEGER field_arrayLength;
  UserTokenPolicyArray field_arrayValues;
public:
  ListOfUserTokenPolicyArray();
  ListOfUserTokenPolicyArray(const INTEGER& par_arrayLength,
    const UserTokenPolicyArray& par_arrayValues);
  ListOfUserTokenPolicyArray(const ListOfUserTokenPolicyArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfUserTokenPolicyArray& operator=(const ListOfUserTokenPolicyArray& other_value);
  boolean operator==(const ListOfUserTokenPolicyArray& other_value) const;
  inline boolean operator!=(const ListOfUserTokenPolicyArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline UserTokenPolicyArray& arrayValues()
    {return field_arrayValues;}
  inline const UserTokenPolicyArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfUserTokenPolicyArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfUserTokenPolicyArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfUserTokenPolicyArray& other_value);
void copy_template(const ListOfUserTokenPolicyArray_template& other_value);

public:
ListOfUserTokenPolicyArray_template();
ListOfUserTokenPolicyArray_template(template_sel other_value);
ListOfUserTokenPolicyArray_template(const ListOfUserTokenPolicyArray& other_value);
ListOfUserTokenPolicyArray_template(const OPTIONAL<ListOfUserTokenPolicyArray>& other_value);
ListOfUserTokenPolicyArray_template(const ListOfUserTokenPolicyArray_template& other_value);
~ListOfUserTokenPolicyArray_template();
ListOfUserTokenPolicyArray_template& operator=(template_sel other_value);
ListOfUserTokenPolicyArray_template& operator=(const ListOfUserTokenPolicyArray& other_value);
ListOfUserTokenPolicyArray_template& operator=(const OPTIONAL<ListOfUserTokenPolicyArray>& other_value);
ListOfUserTokenPolicyArray_template& operator=(const ListOfUserTokenPolicyArray_template& other_value);
boolean match(const ListOfUserTokenPolicyArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfUserTokenPolicyArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfUserTokenPolicyArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
UserTokenPolicyArray_template& arrayValues();
const UserTokenPolicyArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfUserTokenPolicyArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EndpointDescription : public Base_Type {
  String field_endpointUrl;
  ApplicationDescription field_server;
  ByteString field_serverCertificate;
  MessageSecurityMode field_securityMode;
  String field_securityPolicyUri;
  ListOfUserTokenPolicy field_userIdentityTokens;
  String field_transportProfileUri;
  INTEGER field_securityLevel;
public:
  EndpointDescription();
  EndpointDescription(const String& par_endpointUrl,
    const ApplicationDescription& par_server,
    const ByteString& par_serverCertificate,
    const MessageSecurityMode& par_securityMode,
    const String& par_securityPolicyUri,
    const ListOfUserTokenPolicy& par_userIdentityTokens,
    const String& par_transportProfileUri,
    const INTEGER& par_securityLevel);
  EndpointDescription(const EndpointDescription& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EndpointDescription& operator=(const EndpointDescription& other_value);
  boolean operator==(const EndpointDescription& other_value) const;
  inline boolean operator!=(const EndpointDescription& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& endpointUrl()
    {return field_endpointUrl;}
  inline const String& endpointUrl() const
    {return field_endpointUrl;}
  inline ApplicationDescription& server()
    {return field_server;}
  inline const ApplicationDescription& server() const
    {return field_server;}
  inline ByteString& serverCertificate()
    {return field_serverCertificate;}
  inline const ByteString& serverCertificate() const
    {return field_serverCertificate;}
  inline MessageSecurityMode& securityMode()
    {return field_securityMode;}
  inline const MessageSecurityMode& securityMode() const
    {return field_securityMode;}
  inline String& securityPolicyUri()
    {return field_securityPolicyUri;}
  inline const String& securityPolicyUri() const
    {return field_securityPolicyUri;}
  inline ListOfUserTokenPolicy& userIdentityTokens()
    {return field_userIdentityTokens;}
  inline const ListOfUserTokenPolicy& userIdentityTokens() const
    {return field_userIdentityTokens;}
  inline String& transportProfileUri()
    {return field_transportProfileUri;}
  inline const String& transportProfileUri() const
    {return field_transportProfileUri;}
  inline INTEGER& securityLevel()
    {return field_securityLevel;}
  inline const INTEGER& securityLevel() const
    {return field_securityLevel;}
  inline int size_of() const
    {return 8;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class EndpointDescription_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EndpointDescription_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EndpointDescription& other_value);
void copy_template(const EndpointDescription_template& other_value);

public:
EndpointDescription_template();
EndpointDescription_template(template_sel other_value);
EndpointDescription_template(const EndpointDescription& other_value);
EndpointDescription_template(const OPTIONAL<EndpointDescription>& other_value);
EndpointDescription_template(const EndpointDescription_template& other_value);
~EndpointDescription_template();
EndpointDescription_template& operator=(template_sel other_value);
EndpointDescription_template& operator=(const EndpointDescription& other_value);
EndpointDescription_template& operator=(const OPTIONAL<EndpointDescription>& other_value);
EndpointDescription_template& operator=(const EndpointDescription_template& other_value);
boolean match(const EndpointDescription& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EndpointDescription valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EndpointDescription_template& list_item(unsigned int list_index) const;
String_template& endpointUrl();
const String_template& endpointUrl() const;
ApplicationDescription_template& server();
const ApplicationDescription_template& server() const;
ByteString_template& serverCertificate();
const ByteString_template& serverCertificate() const;
MessageSecurityMode_template& securityMode();
const MessageSecurityMode_template& securityMode() const;
String_template& securityPolicyUri();
const String_template& securityPolicyUri() const;
ListOfUserTokenPolicy_template& userIdentityTokens();
const ListOfUserTokenPolicy_template& userIdentityTokens() const;
String_template& transportProfileUri();
const String_template& transportProfileUri() const;
INTEGER_template& securityLevel();
const INTEGER_template& securityLevel() const;
int size_of() const;
void log() const;
void log_match(const EndpointDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MonitoringParametersArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MonitoringParameters **value_elements;
} *val_ptr;

static const MonitoringParameters UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MonitoringParametersArray& other_value);

public:
  typedef MonitoringParameters of_type;
MonitoringParametersArray();
MonitoringParametersArray(null_type other_value);
MonitoringParametersArray(const MonitoringParametersArray& other_value);
~MonitoringParametersArray();

void clean_up();
MonitoringParametersArray& operator=(null_type other_value);
MonitoringParametersArray& operator=(const MonitoringParametersArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MonitoringParametersArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MonitoringParametersArray& other_value) const { return !(*this == other_value); }

MonitoringParameters& operator[](int index_value);
MonitoringParameters& operator[](const INTEGER& index_value);
const MonitoringParameters& operator[](int index_value) const;
const MonitoringParameters& operator[](const INTEGER& index_value) const;

MonitoringParametersArray operator<<=(int rotate_count) const;
MonitoringParametersArray operator<<=(const INTEGER& rotate_count) const;
MonitoringParametersArray operator>>=(int rotate_count) const;
MonitoringParametersArray operator>>=(const INTEGER& rotate_count) const;

MonitoringParametersArray operator+(const MonitoringParametersArray& other_value) const;

MonitoringParametersArray substr(int index, int returncount) const;

MonitoringParametersArray replace(int index, int len, const MonitoringParametersArray& repl) const;

MonitoringParametersArray replace(int index, int len, const MonitoringParametersArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoringParametersArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
MonitoringParameters_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MonitoringParametersArray_template *list_value;
} value_list;
};
void copy_value(const MonitoringParametersArray& other_value);
void copy_template(const MonitoringParametersArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MonitoringParametersArray_template();
MonitoringParametersArray_template(template_sel other_value);
MonitoringParametersArray_template(null_type other_value);
MonitoringParametersArray_template(const MonitoringParametersArray& other_value);
MonitoringParametersArray_template(const OPTIONAL<MonitoringParametersArray>& other_value);
MonitoringParametersArray_template(const MonitoringParametersArray_template& other_value);
~MonitoringParametersArray_template();

void clean_up();
MonitoringParametersArray_template& operator=(template_sel other_value);
MonitoringParametersArray_template& operator=(null_type other_value);
MonitoringParametersArray_template& operator=(const MonitoringParametersArray& other_value);
MonitoringParametersArray_template& operator=(const OPTIONAL<MonitoringParametersArray>& other_value);
MonitoringParametersArray_template& operator=(const MonitoringParametersArray_template& other_value);

MonitoringParameters_template& operator[](int index_value);
MonitoringParameters_template& operator[](const INTEGER& index_value);
const MonitoringParameters_template& operator[](int index_value) const;
const MonitoringParameters_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MonitoringParametersArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MonitoringParametersArray valueof() const;
MonitoringParametersArray substr(int index, int returncount) const;

MonitoringParametersArray replace(int index, int len, const MonitoringParametersArray_template& repl) const;

MonitoringParametersArray replace(int index, int len, const MonitoringParametersArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MonitoringParametersArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MonitoringParametersArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class MonitoringParameters : public Base_Type {
  INTEGER field_clientHandle;
  FLOAT field_samplingInterval;
  ExtensibleParameter field_filter;
  INTEGER field_queueSize;
  INTEGER field_discardOldest;
public:
  MonitoringParameters();
  MonitoringParameters(const INTEGER& par_clientHandle,
    const FLOAT& par_samplingInterval,
    const ExtensibleParameter& par_filter,
    const INTEGER& par_queueSize,
    const INTEGER& par_discardOldest);
  MonitoringParameters(const MonitoringParameters& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MonitoringParameters& operator=(const MonitoringParameters& other_value);
  boolean operator==(const MonitoringParameters& other_value) const;
  inline boolean operator!=(const MonitoringParameters& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& clientHandle()
    {return field_clientHandle;}
  inline const INTEGER& clientHandle() const
    {return field_clientHandle;}
  inline FLOAT& samplingInterval()
    {return field_samplingInterval;}
  inline const FLOAT& samplingInterval() const
    {return field_samplingInterval;}
  inline ExtensibleParameter& filter()
    {return field_filter;}
  inline const ExtensibleParameter& filter() const
    {return field_filter;}
  inline INTEGER& queueSize()
    {return field_queueSize;}
  inline const INTEGER& queueSize() const
    {return field_queueSize;}
  inline INTEGER& discardOldest()
    {return field_discardOldest;}
  inline const INTEGER& discardOldest() const
    {return field_discardOldest;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoringParameters_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MonitoringParameters_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MonitoringParameters& other_value);
void copy_template(const MonitoringParameters_template& other_value);

public:
MonitoringParameters_template();
MonitoringParameters_template(template_sel other_value);
MonitoringParameters_template(const MonitoringParameters& other_value);
MonitoringParameters_template(const OPTIONAL<MonitoringParameters>& other_value);
MonitoringParameters_template(const MonitoringParameters_template& other_value);
~MonitoringParameters_template();
MonitoringParameters_template& operator=(template_sel other_value);
MonitoringParameters_template& operator=(const MonitoringParameters& other_value);
MonitoringParameters_template& operator=(const OPTIONAL<MonitoringParameters>& other_value);
MonitoringParameters_template& operator=(const MonitoringParameters_template& other_value);
boolean match(const MonitoringParameters& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MonitoringParameters valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MonitoringParameters_template& list_item(unsigned int list_index) const;
INTEGER_template& clientHandle();
const INTEGER_template& clientHandle() const;
FLOAT_template& samplingInterval();
const FLOAT_template& samplingInterval() const;
ExtensibleParameter_template& filter();
const ExtensibleParameter_template& filter() const;
INTEGER_template& queueSize();
const INTEGER_template& queueSize() const;
INTEGER_template& discardOldest();
const INTEGER_template& discardOldest() const;
int size_of() const;
void log() const;
void log_match(const MonitoringParameters& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class QueryDataSetArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
QueryDataSet **value_elements;
} *val_ptr;

static const QueryDataSet UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const QueryDataSetArray& other_value);

public:
  typedef QueryDataSet of_type;
QueryDataSetArray();
QueryDataSetArray(null_type other_value);
QueryDataSetArray(const QueryDataSetArray& other_value);
~QueryDataSetArray();

void clean_up();
QueryDataSetArray& operator=(null_type other_value);
QueryDataSetArray& operator=(const QueryDataSetArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const QueryDataSetArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const QueryDataSetArray& other_value) const { return !(*this == other_value); }

QueryDataSet& operator[](int index_value);
QueryDataSet& operator[](const INTEGER& index_value);
const QueryDataSet& operator[](int index_value) const;
const QueryDataSet& operator[](const INTEGER& index_value) const;

QueryDataSetArray operator<<=(int rotate_count) const;
QueryDataSetArray operator<<=(const INTEGER& rotate_count) const;
QueryDataSetArray operator>>=(int rotate_count) const;
QueryDataSetArray operator>>=(const INTEGER& rotate_count) const;

QueryDataSetArray operator+(const QueryDataSetArray& other_value) const;

QueryDataSetArray substr(int index, int returncount) const;

QueryDataSetArray replace(int index, int len, const QueryDataSetArray& repl) const;

QueryDataSetArray replace(int index, int len, const QueryDataSetArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QueryDataSetArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
QueryDataSet_template **value_elements;
} single_value;
struct {
unsigned int n_values;
QueryDataSetArray_template *list_value;
} value_list;
};
void copy_value(const QueryDataSetArray& other_value);
void copy_template(const QueryDataSetArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
QueryDataSetArray_template();
QueryDataSetArray_template(template_sel other_value);
QueryDataSetArray_template(null_type other_value);
QueryDataSetArray_template(const QueryDataSetArray& other_value);
QueryDataSetArray_template(const OPTIONAL<QueryDataSetArray>& other_value);
QueryDataSetArray_template(const QueryDataSetArray_template& other_value);
~QueryDataSetArray_template();

void clean_up();
QueryDataSetArray_template& operator=(template_sel other_value);
QueryDataSetArray_template& operator=(null_type other_value);
QueryDataSetArray_template& operator=(const QueryDataSetArray& other_value);
QueryDataSetArray_template& operator=(const OPTIONAL<QueryDataSetArray>& other_value);
QueryDataSetArray_template& operator=(const QueryDataSetArray_template& other_value);

QueryDataSet_template& operator[](int index_value);
QueryDataSet_template& operator[](const INTEGER& index_value);
const QueryDataSet_template& operator[](int index_value) const;
const QueryDataSet_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const QueryDataSetArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
QueryDataSetArray valueof() const;
QueryDataSetArray substr(int index, int returncount) const;

QueryDataSetArray replace(int index, int len, const QueryDataSetArray_template& repl) const;

QueryDataSetArray replace(int index, int len, const QueryDataSetArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
QueryDataSetArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const QueryDataSetArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class QueryDataSet : public Base_Type {
  ExpandedNodeId field_nodeId;
  ExpandedNodeId field_typeDefinitionNode;
  ListOfBaseDataType field_values;
public:
  QueryDataSet();
  QueryDataSet(const ExpandedNodeId& par_nodeId,
    const ExpandedNodeId& par_typeDefinitionNode,
    const ListOfBaseDataType& par_values);
  QueryDataSet(const QueryDataSet& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QueryDataSet& operator=(const QueryDataSet& other_value);
  boolean operator==(const QueryDataSet& other_value) const;
  inline boolean operator!=(const QueryDataSet& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ExpandedNodeId& nodeId()
    {return field_nodeId;}
  inline const ExpandedNodeId& nodeId() const
    {return field_nodeId;}
  inline ExpandedNodeId& typeDefinitionNode()
    {return field_typeDefinitionNode;}
  inline const ExpandedNodeId& typeDefinitionNode() const
    {return field_typeDefinitionNode;}
  inline ListOfBaseDataType& values()
    {return field_values;}
  inline const ListOfBaseDataType& values() const
    {return field_values;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QueryDataSet_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QueryDataSet_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QueryDataSet& other_value);
void copy_template(const QueryDataSet_template& other_value);

public:
QueryDataSet_template();
QueryDataSet_template(template_sel other_value);
QueryDataSet_template(const QueryDataSet& other_value);
QueryDataSet_template(const OPTIONAL<QueryDataSet>& other_value);
QueryDataSet_template(const QueryDataSet_template& other_value);
~QueryDataSet_template();
QueryDataSet_template& operator=(template_sel other_value);
QueryDataSet_template& operator=(const QueryDataSet& other_value);
QueryDataSet_template& operator=(const OPTIONAL<QueryDataSet>& other_value);
QueryDataSet_template& operator=(const QueryDataSet_template& other_value);
boolean match(const QueryDataSet& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QueryDataSet valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QueryDataSet_template& list_item(unsigned int list_index) const;
ExpandedNodeId_template& nodeId();
const ExpandedNodeId_template& nodeId() const;
ExpandedNodeId_template& typeDefinitionNode();
const ExpandedNodeId_template& typeDefinitionNode() const;
ListOfBaseDataType_template& values();
const ListOfBaseDataType_template& values() const;
int size_of() const;
void log() const;
void log_match(const QueryDataSet& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReadValueIdArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ReadValueId **value_elements;
} *val_ptr;

static const ReadValueId UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ReadValueIdArray& other_value);

public:
  typedef ReadValueId of_type;
ReadValueIdArray();
ReadValueIdArray(null_type other_value);
ReadValueIdArray(const ReadValueIdArray& other_value);
~ReadValueIdArray();

void clean_up();
ReadValueIdArray& operator=(null_type other_value);
ReadValueIdArray& operator=(const ReadValueIdArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ReadValueIdArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ReadValueIdArray& other_value) const { return !(*this == other_value); }

ReadValueId& operator[](int index_value);
ReadValueId& operator[](const INTEGER& index_value);
const ReadValueId& operator[](int index_value) const;
const ReadValueId& operator[](const INTEGER& index_value) const;

ReadValueIdArray operator<<=(int rotate_count) const;
ReadValueIdArray operator<<=(const INTEGER& rotate_count) const;
ReadValueIdArray operator>>=(int rotate_count) const;
ReadValueIdArray operator>>=(const INTEGER& rotate_count) const;

ReadValueIdArray operator+(const ReadValueIdArray& other_value) const;

ReadValueIdArray substr(int index, int returncount) const;

ReadValueIdArray replace(int index, int len, const ReadValueIdArray& repl) const;

ReadValueIdArray replace(int index, int len, const ReadValueIdArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReadValueIdArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ReadValueId_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ReadValueIdArray_template *list_value;
} value_list;
};
void copy_value(const ReadValueIdArray& other_value);
void copy_template(const ReadValueIdArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ReadValueIdArray_template();
ReadValueIdArray_template(template_sel other_value);
ReadValueIdArray_template(null_type other_value);
ReadValueIdArray_template(const ReadValueIdArray& other_value);
ReadValueIdArray_template(const OPTIONAL<ReadValueIdArray>& other_value);
ReadValueIdArray_template(const ReadValueIdArray_template& other_value);
~ReadValueIdArray_template();

void clean_up();
ReadValueIdArray_template& operator=(template_sel other_value);
ReadValueIdArray_template& operator=(null_type other_value);
ReadValueIdArray_template& operator=(const ReadValueIdArray& other_value);
ReadValueIdArray_template& operator=(const OPTIONAL<ReadValueIdArray>& other_value);
ReadValueIdArray_template& operator=(const ReadValueIdArray_template& other_value);

ReadValueId_template& operator[](int index_value);
ReadValueId_template& operator[](const INTEGER& index_value);
const ReadValueId_template& operator[](int index_value) const;
const ReadValueId_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ReadValueIdArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ReadValueIdArray valueof() const;
ReadValueIdArray substr(int index, int returncount) const;

ReadValueIdArray replace(int index, int len, const ReadValueIdArray_template& repl) const;

ReadValueIdArray replace(int index, int len, const ReadValueIdArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ReadValueIdArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ReadValueIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ReadValueId : public Base_Type {
  NodeId field_nodeId;
  INTEGER field_attributeId;
  String field_indexRange;
  QualifiedName field_dataEncoding;
public:
  ReadValueId();
  ReadValueId(const NodeId& par_nodeId,
    const INTEGER& par_attributeId,
    const String& par_indexRange,
    const QualifiedName& par_dataEncoding);
  ReadValueId(const ReadValueId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReadValueId& operator=(const ReadValueId& other_value);
  boolean operator==(const ReadValueId& other_value) const;
  inline boolean operator!=(const ReadValueId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline INTEGER& attributeId()
    {return field_attributeId;}
  inline const INTEGER& attributeId() const
    {return field_attributeId;}
  inline String& indexRange()
    {return field_indexRange;}
  inline const String& indexRange() const
    {return field_indexRange;}
  inline QualifiedName& dataEncoding()
    {return field_dataEncoding;}
  inline const QualifiedName& dataEncoding() const
    {return field_dataEncoding;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReadValueId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReadValueId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReadValueId& other_value);
void copy_template(const ReadValueId_template& other_value);

public:
ReadValueId_template();
ReadValueId_template(template_sel other_value);
ReadValueId_template(const ReadValueId& other_value);
ReadValueId_template(const OPTIONAL<ReadValueId>& other_value);
ReadValueId_template(const ReadValueId_template& other_value);
~ReadValueId_template();
ReadValueId_template& operator=(template_sel other_value);
ReadValueId_template& operator=(const ReadValueId& other_value);
ReadValueId_template& operator=(const OPTIONAL<ReadValueId>& other_value);
ReadValueId_template& operator=(const ReadValueId_template& other_value);
boolean match(const ReadValueId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReadValueId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReadValueId_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
INTEGER_template& attributeId();
const INTEGER_template& attributeId() const;
String_template& indexRange();
const String_template& indexRange() const;
QualifiedName_template& dataEncoding();
const QualifiedName_template& dataEncoding() const;
int size_of() const;
void log() const;
void log_match(const ReadValueId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ApplicationInstanceCertificateArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ApplicationInstanceCertificate **value_elements;
} *val_ptr;

static const ApplicationInstanceCertificate UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ApplicationInstanceCertificateArray& other_value);

public:
  typedef ApplicationInstanceCertificate of_type;
ApplicationInstanceCertificateArray();
ApplicationInstanceCertificateArray(null_type other_value);
ApplicationInstanceCertificateArray(const ApplicationInstanceCertificateArray& other_value);
~ApplicationInstanceCertificateArray();

void clean_up();
ApplicationInstanceCertificateArray& operator=(null_type other_value);
ApplicationInstanceCertificateArray& operator=(const ApplicationInstanceCertificateArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ApplicationInstanceCertificateArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ApplicationInstanceCertificateArray& other_value) const { return !(*this == other_value); }

ApplicationInstanceCertificate& operator[](int index_value);
ApplicationInstanceCertificate& operator[](const INTEGER& index_value);
const ApplicationInstanceCertificate& operator[](int index_value) const;
const ApplicationInstanceCertificate& operator[](const INTEGER& index_value) const;

ApplicationInstanceCertificateArray operator<<=(int rotate_count) const;
ApplicationInstanceCertificateArray operator<<=(const INTEGER& rotate_count) const;
ApplicationInstanceCertificateArray operator>>=(int rotate_count) const;
ApplicationInstanceCertificateArray operator>>=(const INTEGER& rotate_count) const;

ApplicationInstanceCertificateArray operator+(const ApplicationInstanceCertificateArray& other_value) const;

ApplicationInstanceCertificateArray substr(int index, int returncount) const;

ApplicationInstanceCertificateArray replace(int index, int len, const ApplicationInstanceCertificateArray& repl) const;

ApplicationInstanceCertificateArray replace(int index, int len, const ApplicationInstanceCertificateArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ApplicationInstanceCertificateArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ApplicationInstanceCertificate_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ApplicationInstanceCertificateArray_template *list_value;
} value_list;
};
void copy_value(const ApplicationInstanceCertificateArray& other_value);
void copy_template(const ApplicationInstanceCertificateArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ApplicationInstanceCertificateArray_template();
ApplicationInstanceCertificateArray_template(template_sel other_value);
ApplicationInstanceCertificateArray_template(null_type other_value);
ApplicationInstanceCertificateArray_template(const ApplicationInstanceCertificateArray& other_value);
ApplicationInstanceCertificateArray_template(const OPTIONAL<ApplicationInstanceCertificateArray>& other_value);
ApplicationInstanceCertificateArray_template(const ApplicationInstanceCertificateArray_template& other_value);
~ApplicationInstanceCertificateArray_template();

void clean_up();
ApplicationInstanceCertificateArray_template& operator=(template_sel other_value);
ApplicationInstanceCertificateArray_template& operator=(null_type other_value);
ApplicationInstanceCertificateArray_template& operator=(const ApplicationInstanceCertificateArray& other_value);
ApplicationInstanceCertificateArray_template& operator=(const OPTIONAL<ApplicationInstanceCertificateArray>& other_value);
ApplicationInstanceCertificateArray_template& operator=(const ApplicationInstanceCertificateArray_template& other_value);

ApplicationInstanceCertificate_template& operator[](int index_value);
ApplicationInstanceCertificate_template& operator[](const INTEGER& index_value);
const ApplicationInstanceCertificate_template& operator[](int index_value) const;
const ApplicationInstanceCertificate_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ApplicationInstanceCertificateArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ApplicationInstanceCertificateArray valueof() const;
ApplicationInstanceCertificateArray substr(int index, int returncount) const;

ApplicationInstanceCertificateArray replace(int index, int len, const ApplicationInstanceCertificateArray_template& repl) const;

ApplicationInstanceCertificateArray replace(int index, int len, const ApplicationInstanceCertificateArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ApplicationInstanceCertificateArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ApplicationInstanceCertificateArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ApplicationInstanceIssuerIdentifier : public Base_Type {
  String field_productName;
  String field_organisation;
public:
  ApplicationInstanceIssuerIdentifier();
  ApplicationInstanceIssuerIdentifier(const String& par_productName,
    const String& par_organisation);
  ApplicationInstanceIssuerIdentifier(const ApplicationInstanceIssuerIdentifier& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ApplicationInstanceIssuerIdentifier& operator=(const ApplicationInstanceIssuerIdentifier& other_value);
  boolean operator==(const ApplicationInstanceIssuerIdentifier& other_value) const;
  inline boolean operator!=(const ApplicationInstanceIssuerIdentifier& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& productName()
    {return field_productName;}
  inline const String& productName() const
    {return field_productName;}
  inline String& organisation()
    {return field_organisation;}
  inline const String& organisation() const
    {return field_organisation;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ApplicationInstanceIssuerIdentifier_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ApplicationInstanceIssuerIdentifier_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ApplicationInstanceIssuerIdentifier& other_value);
void copy_template(const ApplicationInstanceIssuerIdentifier_template& other_value);

public:
ApplicationInstanceIssuerIdentifier_template();
ApplicationInstanceIssuerIdentifier_template(template_sel other_value);
ApplicationInstanceIssuerIdentifier_template(const ApplicationInstanceIssuerIdentifier& other_value);
ApplicationInstanceIssuerIdentifier_template(const OPTIONAL<ApplicationInstanceIssuerIdentifier>& other_value);
ApplicationInstanceIssuerIdentifier_template(const ApplicationInstanceIssuerIdentifier_template& other_value);
~ApplicationInstanceIssuerIdentifier_template();
ApplicationInstanceIssuerIdentifier_template& operator=(template_sel other_value);
ApplicationInstanceIssuerIdentifier_template& operator=(const ApplicationInstanceIssuerIdentifier& other_value);
ApplicationInstanceIssuerIdentifier_template& operator=(const OPTIONAL<ApplicationInstanceIssuerIdentifier>& other_value);
ApplicationInstanceIssuerIdentifier_template& operator=(const ApplicationInstanceIssuerIdentifier_template& other_value);
boolean match(const ApplicationInstanceIssuerIdentifier& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ApplicationInstanceIssuerIdentifier valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ApplicationInstanceIssuerIdentifier_template& list_item(unsigned int list_index) const;
String_template& productName();
const String_template& productName() const;
String_template& organisation();
const String_template& organisation() const;
int size_of() const;
void log() const;
void log_match(const ApplicationInstanceIssuerIdentifier& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ApplicationInstanceSubjectIdentifier : public Base_Type {
  String field_name;
public:
  ApplicationInstanceSubjectIdentifier();
  ApplicationInstanceSubjectIdentifier(const String& par_name);
  ApplicationInstanceSubjectIdentifier(const ApplicationInstanceSubjectIdentifier& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ApplicationInstanceSubjectIdentifier& operator=(const ApplicationInstanceSubjectIdentifier& other_value);
  boolean operator==(const ApplicationInstanceSubjectIdentifier& other_value) const;
  inline boolean operator!=(const ApplicationInstanceSubjectIdentifier& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& name()
    {return field_name;}
  inline const String& name() const
    {return field_name;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ApplicationInstanceSubjectIdentifier_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ApplicationInstanceSubjectIdentifier_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ApplicationInstanceSubjectIdentifier& other_value);
void copy_template(const ApplicationInstanceSubjectIdentifier_template& other_value);

public:
ApplicationInstanceSubjectIdentifier_template();
ApplicationInstanceSubjectIdentifier_template(template_sel other_value);
ApplicationInstanceSubjectIdentifier_template(const ApplicationInstanceSubjectIdentifier& other_value);
ApplicationInstanceSubjectIdentifier_template(const OPTIONAL<ApplicationInstanceSubjectIdentifier>& other_value);
ApplicationInstanceSubjectIdentifier_template(const ApplicationInstanceSubjectIdentifier_template& other_value);
~ApplicationInstanceSubjectIdentifier_template();
ApplicationInstanceSubjectIdentifier_template& operator=(template_sel other_value);
ApplicationInstanceSubjectIdentifier_template& operator=(const ApplicationInstanceSubjectIdentifier& other_value);
ApplicationInstanceSubjectIdentifier_template& operator=(const OPTIONAL<ApplicationInstanceSubjectIdentifier>& other_value);
ApplicationInstanceSubjectIdentifier_template& operator=(const ApplicationInstanceSubjectIdentifier_template& other_value);
boolean match(const ApplicationInstanceSubjectIdentifier& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ApplicationInstanceSubjectIdentifier valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ApplicationInstanceSubjectIdentifier_template& list_item(unsigned int list_index) const;
String_template& name();
const String_template& name() const;
int size_of() const;
void log() const;
void log_match(const ApplicationInstanceSubjectIdentifier& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ApplicationInstanceCertificate : public Base_Type {
  String field_version;
  ByteString field_serialNumber;
  String field_signatureAlgorithm;
  ByteString field_Signature;
  ApplicationInstanceIssuerIdentifier field_issuer;
  INTEGER field_validFrom;
  INTEGER field_validTo;
  ApplicationInstanceSubjectIdentifier field_subject;
  String field_applicationUri;
  ListOfString field_hostnames;
  ByteString field_publicKey;
  ListOfString field_keyUsage;
public:
  ApplicationInstanceCertificate();
  ApplicationInstanceCertificate(const String& par_version,
    const ByteString& par_serialNumber,
    const String& par_signatureAlgorithm,
    const ByteString& par_Signature,
    const ApplicationInstanceIssuerIdentifier& par_issuer,
    const INTEGER& par_validFrom,
    const INTEGER& par_validTo,
    const ApplicationInstanceSubjectIdentifier& par_subject,
    const String& par_applicationUri,
    const ListOfString& par_hostnames,
    const ByteString& par_publicKey,
    const ListOfString& par_keyUsage);
  ApplicationInstanceCertificate(const ApplicationInstanceCertificate& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ApplicationInstanceCertificate& operator=(const ApplicationInstanceCertificate& other_value);
  boolean operator==(const ApplicationInstanceCertificate& other_value) const;
  inline boolean operator!=(const ApplicationInstanceCertificate& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& version()
    {return field_version;}
  inline const String& version() const
    {return field_version;}
  inline ByteString& serialNumber()
    {return field_serialNumber;}
  inline const ByteString& serialNumber() const
    {return field_serialNumber;}
  inline String& signatureAlgorithm()
    {return field_signatureAlgorithm;}
  inline const String& signatureAlgorithm() const
    {return field_signatureAlgorithm;}
  inline ByteString& Signature()
    {return field_Signature;}
  inline const ByteString& Signature() const
    {return field_Signature;}
  inline ApplicationInstanceIssuerIdentifier& issuer()
    {return field_issuer;}
  inline const ApplicationInstanceIssuerIdentifier& issuer() const
    {return field_issuer;}
  inline INTEGER& validFrom()
    {return field_validFrom;}
  inline const INTEGER& validFrom() const
    {return field_validFrom;}
  inline INTEGER& validTo()
    {return field_validTo;}
  inline const INTEGER& validTo() const
    {return field_validTo;}
  inline ApplicationInstanceSubjectIdentifier& subject()
    {return field_subject;}
  inline const ApplicationInstanceSubjectIdentifier& subject() const
    {return field_subject;}
  inline String& applicationUri()
    {return field_applicationUri;}
  inline const String& applicationUri() const
    {return field_applicationUri;}
  inline ListOfString& hostnames()
    {return field_hostnames;}
  inline const ListOfString& hostnames() const
    {return field_hostnames;}
  inline ByteString& publicKey()
    {return field_publicKey;}
  inline const ByteString& publicKey() const
    {return field_publicKey;}
  inline ListOfString& keyUsage()
    {return field_keyUsage;}
  inline const ListOfString& keyUsage() const
    {return field_keyUsage;}
  inline int size_of() const
    {return 12;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ApplicationInstanceCertificate_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ApplicationInstanceCertificate_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ApplicationInstanceCertificate& other_value);
void copy_template(const ApplicationInstanceCertificate_template& other_value);

public:
ApplicationInstanceCertificate_template();
ApplicationInstanceCertificate_template(template_sel other_value);
ApplicationInstanceCertificate_template(const ApplicationInstanceCertificate& other_value);
ApplicationInstanceCertificate_template(const OPTIONAL<ApplicationInstanceCertificate>& other_value);
ApplicationInstanceCertificate_template(const ApplicationInstanceCertificate_template& other_value);
~ApplicationInstanceCertificate_template();
ApplicationInstanceCertificate_template& operator=(template_sel other_value);
ApplicationInstanceCertificate_template& operator=(const ApplicationInstanceCertificate& other_value);
ApplicationInstanceCertificate_template& operator=(const OPTIONAL<ApplicationInstanceCertificate>& other_value);
ApplicationInstanceCertificate_template& operator=(const ApplicationInstanceCertificate_template& other_value);
boolean match(const ApplicationInstanceCertificate& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ApplicationInstanceCertificate valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ApplicationInstanceCertificate_template& list_item(unsigned int list_index) const;
String_template& version();
const String_template& version() const;
ByteString_template& serialNumber();
const ByteString_template& serialNumber() const;
String_template& signatureAlgorithm();
const String_template& signatureAlgorithm() const;
ByteString_template& Signature();
const ByteString_template& Signature() const;
ApplicationInstanceIssuerIdentifier_template& issuer();
const ApplicationInstanceIssuerIdentifier_template& issuer() const;
INTEGER_template& validFrom();
const INTEGER_template& validFrom() const;
INTEGER_template& validTo();
const INTEGER_template& validTo() const;
ApplicationInstanceSubjectIdentifier_template& subject();
const ApplicationInstanceSubjectIdentifier_template& subject() const;
String_template& applicationUri();
const String_template& applicationUri() const;
ListOfString_template& hostnames();
const ListOfString_template& hostnames() const;
ByteString_template& publicKey();
const ByteString_template& publicKey() const;
ListOfString_template& keyUsage();
const ListOfString_template& keyUsage() const;
int size_of() const;
void log() const;
void log_match(const ApplicationInstanceCertificate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ChannelSecurityTokenArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ChannelSecurityToken **value_elements;
} *val_ptr;

static const ChannelSecurityToken UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ChannelSecurityTokenArray& other_value);

public:
  typedef ChannelSecurityToken of_type;
ChannelSecurityTokenArray();
ChannelSecurityTokenArray(null_type other_value);
ChannelSecurityTokenArray(const ChannelSecurityTokenArray& other_value);
~ChannelSecurityTokenArray();

void clean_up();
ChannelSecurityTokenArray& operator=(null_type other_value);
ChannelSecurityTokenArray& operator=(const ChannelSecurityTokenArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ChannelSecurityTokenArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ChannelSecurityTokenArray& other_value) const { return !(*this == other_value); }

ChannelSecurityToken& operator[](int index_value);
ChannelSecurityToken& operator[](const INTEGER& index_value);
const ChannelSecurityToken& operator[](int index_value) const;
const ChannelSecurityToken& operator[](const INTEGER& index_value) const;

ChannelSecurityTokenArray operator<<=(int rotate_count) const;
ChannelSecurityTokenArray operator<<=(const INTEGER& rotate_count) const;
ChannelSecurityTokenArray operator>>=(int rotate_count) const;
ChannelSecurityTokenArray operator>>=(const INTEGER& rotate_count) const;

ChannelSecurityTokenArray operator+(const ChannelSecurityTokenArray& other_value) const;

ChannelSecurityTokenArray substr(int index, int returncount) const;

ChannelSecurityTokenArray replace(int index, int len, const ChannelSecurityTokenArray& repl) const;

ChannelSecurityTokenArray replace(int index, int len, const ChannelSecurityTokenArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ChannelSecurityTokenArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ChannelSecurityToken_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ChannelSecurityTokenArray_template *list_value;
} value_list;
};
void copy_value(const ChannelSecurityTokenArray& other_value);
void copy_template(const ChannelSecurityTokenArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ChannelSecurityTokenArray_template();
ChannelSecurityTokenArray_template(template_sel other_value);
ChannelSecurityTokenArray_template(null_type other_value);
ChannelSecurityTokenArray_template(const ChannelSecurityTokenArray& other_value);
ChannelSecurityTokenArray_template(const OPTIONAL<ChannelSecurityTokenArray>& other_value);
ChannelSecurityTokenArray_template(const ChannelSecurityTokenArray_template& other_value);
~ChannelSecurityTokenArray_template();

void clean_up();
ChannelSecurityTokenArray_template& operator=(template_sel other_value);
ChannelSecurityTokenArray_template& operator=(null_type other_value);
ChannelSecurityTokenArray_template& operator=(const ChannelSecurityTokenArray& other_value);
ChannelSecurityTokenArray_template& operator=(const OPTIONAL<ChannelSecurityTokenArray>& other_value);
ChannelSecurityTokenArray_template& operator=(const ChannelSecurityTokenArray_template& other_value);

ChannelSecurityToken_template& operator[](int index_value);
ChannelSecurityToken_template& operator[](const INTEGER& index_value);
const ChannelSecurityToken_template& operator[](int index_value) const;
const ChannelSecurityToken_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ChannelSecurityTokenArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ChannelSecurityTokenArray valueof() const;
ChannelSecurityTokenArray substr(int index, int returncount) const;

ChannelSecurityTokenArray replace(int index, int len, const ChannelSecurityTokenArray_template& repl) const;

ChannelSecurityTokenArray replace(int index, int len, const ChannelSecurityTokenArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ChannelSecurityTokenArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ChannelSecurityTokenArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ChannelSecurityToken : public Base_Type {
  INTEGER field_channelId;
  INTEGER field_tokenId;
  INTEGER field_createdAt;
  INTEGER field_revisedLifetime;
public:
  ChannelSecurityToken();
  ChannelSecurityToken(const INTEGER& par_channelId,
    const INTEGER& par_tokenId,
    const INTEGER& par_createdAt,
    const INTEGER& par_revisedLifetime);
  ChannelSecurityToken(const ChannelSecurityToken& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ChannelSecurityToken& operator=(const ChannelSecurityToken& other_value);
  boolean operator==(const ChannelSecurityToken& other_value) const;
  inline boolean operator!=(const ChannelSecurityToken& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& channelId()
    {return field_channelId;}
  inline const INTEGER& channelId() const
    {return field_channelId;}
  inline INTEGER& tokenId()
    {return field_tokenId;}
  inline const INTEGER& tokenId() const
    {return field_tokenId;}
  inline INTEGER& createdAt()
    {return field_createdAt;}
  inline const INTEGER& createdAt() const
    {return field_createdAt;}
  inline INTEGER& revisedLifetime()
    {return field_revisedLifetime;}
  inline const INTEGER& revisedLifetime() const
    {return field_revisedLifetime;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ChannelSecurityToken_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ChannelSecurityToken_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ChannelSecurityToken& other_value);
void copy_template(const ChannelSecurityToken_template& other_value);

public:
ChannelSecurityToken_template();
ChannelSecurityToken_template(template_sel other_value);
ChannelSecurityToken_template(const ChannelSecurityToken& other_value);
ChannelSecurityToken_template(const OPTIONAL<ChannelSecurityToken>& other_value);
ChannelSecurityToken_template(const ChannelSecurityToken_template& other_value);
~ChannelSecurityToken_template();
ChannelSecurityToken_template& operator=(template_sel other_value);
ChannelSecurityToken_template& operator=(const ChannelSecurityToken& other_value);
ChannelSecurityToken_template& operator=(const OPTIONAL<ChannelSecurityToken>& other_value);
ChannelSecurityToken_template& operator=(const ChannelSecurityToken_template& other_value);
boolean match(const ChannelSecurityToken& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ChannelSecurityToken valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ChannelSecurityToken_template& list_item(unsigned int list_index) const;
INTEGER_template& channelId();
const INTEGER_template& channelId() const;
INTEGER_template& tokenId();
const INTEGER_template& tokenId() const;
INTEGER_template& createdAt();
const INTEGER_template& createdAt() const;
INTEGER_template& revisedLifetime();
const INTEGER_template& revisedLifetime() const;
int size_of() const;
void log() const;
void log_match(const ChannelSecurityToken& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ServerOnNetworkArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ServerOnNetwork **value_elements;
} *val_ptr;

static const ServerOnNetwork UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ServerOnNetworkArray& other_value);

public:
  typedef ServerOnNetwork of_type;
ServerOnNetworkArray();
ServerOnNetworkArray(null_type other_value);
ServerOnNetworkArray(const ServerOnNetworkArray& other_value);
~ServerOnNetworkArray();

void clean_up();
ServerOnNetworkArray& operator=(null_type other_value);
ServerOnNetworkArray& operator=(const ServerOnNetworkArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ServerOnNetworkArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ServerOnNetworkArray& other_value) const { return !(*this == other_value); }

ServerOnNetwork& operator[](int index_value);
ServerOnNetwork& operator[](const INTEGER& index_value);
const ServerOnNetwork& operator[](int index_value) const;
const ServerOnNetwork& operator[](const INTEGER& index_value) const;

ServerOnNetworkArray operator<<=(int rotate_count) const;
ServerOnNetworkArray operator<<=(const INTEGER& rotate_count) const;
ServerOnNetworkArray operator>>=(int rotate_count) const;
ServerOnNetworkArray operator>>=(const INTEGER& rotate_count) const;

ServerOnNetworkArray operator+(const ServerOnNetworkArray& other_value) const;

ServerOnNetworkArray substr(int index, int returncount) const;

ServerOnNetworkArray replace(int index, int len, const ServerOnNetworkArray& repl) const;

ServerOnNetworkArray replace(int index, int len, const ServerOnNetworkArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ServerOnNetworkArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ServerOnNetwork_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ServerOnNetworkArray_template *list_value;
} value_list;
};
void copy_value(const ServerOnNetworkArray& other_value);
void copy_template(const ServerOnNetworkArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ServerOnNetworkArray_template();
ServerOnNetworkArray_template(template_sel other_value);
ServerOnNetworkArray_template(null_type other_value);
ServerOnNetworkArray_template(const ServerOnNetworkArray& other_value);
ServerOnNetworkArray_template(const OPTIONAL<ServerOnNetworkArray>& other_value);
ServerOnNetworkArray_template(const ServerOnNetworkArray_template& other_value);
~ServerOnNetworkArray_template();

void clean_up();
ServerOnNetworkArray_template& operator=(template_sel other_value);
ServerOnNetworkArray_template& operator=(null_type other_value);
ServerOnNetworkArray_template& operator=(const ServerOnNetworkArray& other_value);
ServerOnNetworkArray_template& operator=(const OPTIONAL<ServerOnNetworkArray>& other_value);
ServerOnNetworkArray_template& operator=(const ServerOnNetworkArray_template& other_value);

ServerOnNetwork_template& operator[](int index_value);
ServerOnNetwork_template& operator[](const INTEGER& index_value);
const ServerOnNetwork_template& operator[](int index_value) const;
const ServerOnNetwork_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ServerOnNetworkArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ServerOnNetworkArray valueof() const;
ServerOnNetworkArray substr(int index, int returncount) const;

ServerOnNetworkArray replace(int index, int len, const ServerOnNetworkArray_template& repl) const;

ServerOnNetworkArray replace(int index, int len, const ServerOnNetworkArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ServerOnNetworkArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ServerOnNetworkArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ServerOnNetwork : public Base_Type {
  INTEGER field_recordId;
  String field_serverName;
  String field_discoveryUrl;
  ListOfString field_serverCapabilities;
public:
  ServerOnNetwork();
  ServerOnNetwork(const INTEGER& par_recordId,
    const String& par_serverName,
    const String& par_discoveryUrl,
    const ListOfString& par_serverCapabilities);
  ServerOnNetwork(const ServerOnNetwork& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ServerOnNetwork& operator=(const ServerOnNetwork& other_value);
  boolean operator==(const ServerOnNetwork& other_value) const;
  inline boolean operator!=(const ServerOnNetwork& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& recordId()
    {return field_recordId;}
  inline const INTEGER& recordId() const
    {return field_recordId;}
  inline String& serverName()
    {return field_serverName;}
  inline const String& serverName() const
    {return field_serverName;}
  inline String& discoveryUrl()
    {return field_discoveryUrl;}
  inline const String& discoveryUrl() const
    {return field_discoveryUrl;}
  inline ListOfString& serverCapabilities()
    {return field_serverCapabilities;}
  inline const ListOfString& serverCapabilities() const
    {return field_serverCapabilities;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ServerOnNetwork_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ServerOnNetwork_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ServerOnNetwork& other_value);
void copy_template(const ServerOnNetwork_template& other_value);

public:
ServerOnNetwork_template();
ServerOnNetwork_template(template_sel other_value);
ServerOnNetwork_template(const ServerOnNetwork& other_value);
ServerOnNetwork_template(const OPTIONAL<ServerOnNetwork>& other_value);
ServerOnNetwork_template(const ServerOnNetwork_template& other_value);
~ServerOnNetwork_template();
ServerOnNetwork_template& operator=(template_sel other_value);
ServerOnNetwork_template& operator=(const ServerOnNetwork& other_value);
ServerOnNetwork_template& operator=(const OPTIONAL<ServerOnNetwork>& other_value);
ServerOnNetwork_template& operator=(const ServerOnNetwork_template& other_value);
boolean match(const ServerOnNetwork& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ServerOnNetwork valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ServerOnNetwork_template& list_item(unsigned int list_index) const;
INTEGER_template& recordId();
const INTEGER_template& recordId() const;
String_template& serverName();
const String_template& serverName() const;
String_template& discoveryUrl();
const String_template& discoveryUrl() const;
ListOfString_template& serverCapabilities();
const ListOfString_template& serverCapabilities() const;
int size_of() const;
void log() const;
void log_match(const ServerOnNetwork& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AddNodesItemArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
AddNodesItem **value_elements;
} *val_ptr;

static const AddNodesItem UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const AddNodesItemArray& other_value);

public:
  typedef AddNodesItem of_type;
AddNodesItemArray();
AddNodesItemArray(null_type other_value);
AddNodesItemArray(const AddNodesItemArray& other_value);
~AddNodesItemArray();

void clean_up();
AddNodesItemArray& operator=(null_type other_value);
AddNodesItemArray& operator=(const AddNodesItemArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const AddNodesItemArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AddNodesItemArray& other_value) const { return !(*this == other_value); }

AddNodesItem& operator[](int index_value);
AddNodesItem& operator[](const INTEGER& index_value);
const AddNodesItem& operator[](int index_value) const;
const AddNodesItem& operator[](const INTEGER& index_value) const;

AddNodesItemArray operator<<=(int rotate_count) const;
AddNodesItemArray operator<<=(const INTEGER& rotate_count) const;
AddNodesItemArray operator>>=(int rotate_count) const;
AddNodesItemArray operator>>=(const INTEGER& rotate_count) const;

AddNodesItemArray operator+(const AddNodesItemArray& other_value) const;

AddNodesItemArray substr(int index, int returncount) const;

AddNodesItemArray replace(int index, int len, const AddNodesItemArray& repl) const;

AddNodesItemArray replace(int index, int len, const AddNodesItemArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddNodesItemArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
AddNodesItem_template **value_elements;
} single_value;
struct {
unsigned int n_values;
AddNodesItemArray_template *list_value;
} value_list;
};
void copy_value(const AddNodesItemArray& other_value);
void copy_template(const AddNodesItemArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
AddNodesItemArray_template();
AddNodesItemArray_template(template_sel other_value);
AddNodesItemArray_template(null_type other_value);
AddNodesItemArray_template(const AddNodesItemArray& other_value);
AddNodesItemArray_template(const OPTIONAL<AddNodesItemArray>& other_value);
AddNodesItemArray_template(const AddNodesItemArray_template& other_value);
~AddNodesItemArray_template();

void clean_up();
AddNodesItemArray_template& operator=(template_sel other_value);
AddNodesItemArray_template& operator=(null_type other_value);
AddNodesItemArray_template& operator=(const AddNodesItemArray& other_value);
AddNodesItemArray_template& operator=(const OPTIONAL<AddNodesItemArray>& other_value);
AddNodesItemArray_template& operator=(const AddNodesItemArray_template& other_value);

AddNodesItem_template& operator[](int index_value);
AddNodesItem_template& operator[](const INTEGER& index_value);
const AddNodesItem_template& operator[](int index_value) const;
const AddNodesItem_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const AddNodesItemArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
AddNodesItemArray valueof() const;
AddNodesItemArray substr(int index, int returncount) const;

AddNodesItemArray replace(int index, int len, const AddNodesItemArray_template& repl) const;

AddNodesItemArray replace(int index, int len, const AddNodesItemArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
AddNodesItemArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const AddNodesItemArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class AddNodesItem : public Base_Type {
  ExpandedNodeId field_parentNodeId;
  NodeId field_referenceTypeId;
  QualifiedName field_browseName;
  NodeClass field_nodeClass;
  ExtensibleParameter field_nodeAttributes;
  ExpandedNodeId field_typeDefinition;
public:
  AddNodesItem();
  AddNodesItem(const ExpandedNodeId& par_parentNodeId,
    const NodeId& par_referenceTypeId,
    const QualifiedName& par_browseName,
    const NodeClass& par_nodeClass,
    const ExtensibleParameter& par_nodeAttributes,
    const ExpandedNodeId& par_typeDefinition);
  AddNodesItem(const AddNodesItem& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AddNodesItem& operator=(const AddNodesItem& other_value);
  boolean operator==(const AddNodesItem& other_value) const;
  inline boolean operator!=(const AddNodesItem& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ExpandedNodeId& parentNodeId()
    {return field_parentNodeId;}
  inline const ExpandedNodeId& parentNodeId() const
    {return field_parentNodeId;}
  inline NodeId& referenceTypeId()
    {return field_referenceTypeId;}
  inline const NodeId& referenceTypeId() const
    {return field_referenceTypeId;}
  inline QualifiedName& browseName()
    {return field_browseName;}
  inline const QualifiedName& browseName() const
    {return field_browseName;}
  inline NodeClass& nodeClass()
    {return field_nodeClass;}
  inline const NodeClass& nodeClass() const
    {return field_nodeClass;}
  inline ExtensibleParameter& nodeAttributes()
    {return field_nodeAttributes;}
  inline const ExtensibleParameter& nodeAttributes() const
    {return field_nodeAttributes;}
  inline ExpandedNodeId& typeDefinition()
    {return field_typeDefinition;}
  inline const ExpandedNodeId& typeDefinition() const
    {return field_typeDefinition;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddNodesItem_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AddNodesItem_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AddNodesItem& other_value);
void copy_template(const AddNodesItem_template& other_value);

public:
AddNodesItem_template();
AddNodesItem_template(template_sel other_value);
AddNodesItem_template(const AddNodesItem& other_value);
AddNodesItem_template(const OPTIONAL<AddNodesItem>& other_value);
AddNodesItem_template(const AddNodesItem_template& other_value);
~AddNodesItem_template();
AddNodesItem_template& operator=(template_sel other_value);
AddNodesItem_template& operator=(const AddNodesItem& other_value);
AddNodesItem_template& operator=(const OPTIONAL<AddNodesItem>& other_value);
AddNodesItem_template& operator=(const AddNodesItem_template& other_value);
boolean match(const AddNodesItem& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AddNodesItem valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AddNodesItem_template& list_item(unsigned int list_index) const;
ExpandedNodeId_template& parentNodeId();
const ExpandedNodeId_template& parentNodeId() const;
NodeId_template& referenceTypeId();
const NodeId_template& referenceTypeId() const;
QualifiedName_template& browseName();
const QualifiedName_template& browseName() const;
NodeClass_template& nodeClass();
const NodeClass_template& nodeClass() const;
ExtensibleParameter_template& nodeAttributes();
const ExtensibleParameter_template& nodeAttributes() const;
ExpandedNodeId_template& typeDefinition();
const ExpandedNodeId_template& typeDefinition() const;
int size_of() const;
void log() const;
void log_match(const AddNodesItem& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AddNodesResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
AddNodesResult **value_elements;
} *val_ptr;

static const AddNodesResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const AddNodesResultArray& other_value);

public:
  typedef AddNodesResult of_type;
AddNodesResultArray();
AddNodesResultArray(null_type other_value);
AddNodesResultArray(const AddNodesResultArray& other_value);
~AddNodesResultArray();

void clean_up();
AddNodesResultArray& operator=(null_type other_value);
AddNodesResultArray& operator=(const AddNodesResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const AddNodesResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AddNodesResultArray& other_value) const { return !(*this == other_value); }

AddNodesResult& operator[](int index_value);
AddNodesResult& operator[](const INTEGER& index_value);
const AddNodesResult& operator[](int index_value) const;
const AddNodesResult& operator[](const INTEGER& index_value) const;

AddNodesResultArray operator<<=(int rotate_count) const;
AddNodesResultArray operator<<=(const INTEGER& rotate_count) const;
AddNodesResultArray operator>>=(int rotate_count) const;
AddNodesResultArray operator>>=(const INTEGER& rotate_count) const;

AddNodesResultArray operator+(const AddNodesResultArray& other_value) const;

AddNodesResultArray substr(int index, int returncount) const;

AddNodesResultArray replace(int index, int len, const AddNodesResultArray& repl) const;

AddNodesResultArray replace(int index, int len, const AddNodesResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddNodesResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
AddNodesResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
AddNodesResultArray_template *list_value;
} value_list;
};
void copy_value(const AddNodesResultArray& other_value);
void copy_template(const AddNodesResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
AddNodesResultArray_template();
AddNodesResultArray_template(template_sel other_value);
AddNodesResultArray_template(null_type other_value);
AddNodesResultArray_template(const AddNodesResultArray& other_value);
AddNodesResultArray_template(const OPTIONAL<AddNodesResultArray>& other_value);
AddNodesResultArray_template(const AddNodesResultArray_template& other_value);
~AddNodesResultArray_template();

void clean_up();
AddNodesResultArray_template& operator=(template_sel other_value);
AddNodesResultArray_template& operator=(null_type other_value);
AddNodesResultArray_template& operator=(const AddNodesResultArray& other_value);
AddNodesResultArray_template& operator=(const OPTIONAL<AddNodesResultArray>& other_value);
AddNodesResultArray_template& operator=(const AddNodesResultArray_template& other_value);

AddNodesResult_template& operator[](int index_value);
AddNodesResult_template& operator[](const INTEGER& index_value);
const AddNodesResult_template& operator[](int index_value) const;
const AddNodesResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const AddNodesResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
AddNodesResultArray valueof() const;
AddNodesResultArray substr(int index, int returncount) const;

AddNodesResultArray replace(int index, int len, const AddNodesResultArray_template& repl) const;

AddNodesResultArray replace(int index, int len, const AddNodesResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
AddNodesResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const AddNodesResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class AddNodesResult : public Base_Type {
  INTEGER field_statusCode;
  NodeId field_addedNodeId;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  AddNodesResult();
  AddNodesResult(const INTEGER& par_statusCode,
    const NodeId& par_addedNodeId,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  AddNodesResult(const AddNodesResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AddNodesResult& operator=(const AddNodesResult& other_value);
  boolean operator==(const AddNodesResult& other_value) const;
  inline boolean operator!=(const AddNodesResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline NodeId& addedNodeId()
    {return field_addedNodeId;}
  inline const NodeId& addedNodeId() const
    {return field_addedNodeId;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddNodesResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AddNodesResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AddNodesResult& other_value);
void copy_template(const AddNodesResult_template& other_value);

public:
AddNodesResult_template();
AddNodesResult_template(template_sel other_value);
AddNodesResult_template(const AddNodesResult& other_value);
AddNodesResult_template(const OPTIONAL<AddNodesResult>& other_value);
AddNodesResult_template(const AddNodesResult_template& other_value);
~AddNodesResult_template();
AddNodesResult_template& operator=(template_sel other_value);
AddNodesResult_template& operator=(const AddNodesResult& other_value);
AddNodesResult_template& operator=(const OPTIONAL<AddNodesResult>& other_value);
AddNodesResult_template& operator=(const AddNodesResult_template& other_value);
boolean match(const AddNodesResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AddNodesResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AddNodesResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
NodeId_template& addedNodeId();
const NodeId_template& addedNodeId() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const AddNodesResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AddReferencesItemArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
AddReferencesItem **value_elements;
} *val_ptr;

static const AddReferencesItem UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const AddReferencesItemArray& other_value);

public:
  typedef AddReferencesItem of_type;
AddReferencesItemArray();
AddReferencesItemArray(null_type other_value);
AddReferencesItemArray(const AddReferencesItemArray& other_value);
~AddReferencesItemArray();

void clean_up();
AddReferencesItemArray& operator=(null_type other_value);
AddReferencesItemArray& operator=(const AddReferencesItemArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const AddReferencesItemArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const AddReferencesItemArray& other_value) const { return !(*this == other_value); }

AddReferencesItem& operator[](int index_value);
AddReferencesItem& operator[](const INTEGER& index_value);
const AddReferencesItem& operator[](int index_value) const;
const AddReferencesItem& operator[](const INTEGER& index_value) const;

AddReferencesItemArray operator<<=(int rotate_count) const;
AddReferencesItemArray operator<<=(const INTEGER& rotate_count) const;
AddReferencesItemArray operator>>=(int rotate_count) const;
AddReferencesItemArray operator>>=(const INTEGER& rotate_count) const;

AddReferencesItemArray operator+(const AddReferencesItemArray& other_value) const;

AddReferencesItemArray substr(int index, int returncount) const;

AddReferencesItemArray replace(int index, int len, const AddReferencesItemArray& repl) const;

AddReferencesItemArray replace(int index, int len, const AddReferencesItemArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddReferencesItemArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
AddReferencesItem_template **value_elements;
} single_value;
struct {
unsigned int n_values;
AddReferencesItemArray_template *list_value;
} value_list;
};
void copy_value(const AddReferencesItemArray& other_value);
void copy_template(const AddReferencesItemArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
AddReferencesItemArray_template();
AddReferencesItemArray_template(template_sel other_value);
AddReferencesItemArray_template(null_type other_value);
AddReferencesItemArray_template(const AddReferencesItemArray& other_value);
AddReferencesItemArray_template(const OPTIONAL<AddReferencesItemArray>& other_value);
AddReferencesItemArray_template(const AddReferencesItemArray_template& other_value);
~AddReferencesItemArray_template();

void clean_up();
AddReferencesItemArray_template& operator=(template_sel other_value);
AddReferencesItemArray_template& operator=(null_type other_value);
AddReferencesItemArray_template& operator=(const AddReferencesItemArray& other_value);
AddReferencesItemArray_template& operator=(const OPTIONAL<AddReferencesItemArray>& other_value);
AddReferencesItemArray_template& operator=(const AddReferencesItemArray_template& other_value);

AddReferencesItem_template& operator[](int index_value);
AddReferencesItem_template& operator[](const INTEGER& index_value);
const AddReferencesItem_template& operator[](int index_value) const;
const AddReferencesItem_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const AddReferencesItemArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
AddReferencesItemArray valueof() const;
AddReferencesItemArray substr(int index, int returncount) const;

AddReferencesItemArray replace(int index, int len, const AddReferencesItemArray_template& repl) const;

AddReferencesItemArray replace(int index, int len, const AddReferencesItemArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
AddReferencesItemArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const AddReferencesItemArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class AddReferencesItem : public Base_Type {
  NodeId field_sourceNodeId;
  NodeId field_referenceTypeId;
  INTEGER field_isForward;
  String field_targetServerUri;
  ExpandedNodeId field_targetNodeId;
  NodeClass field_targetNodeClass;
public:
  AddReferencesItem();
  AddReferencesItem(const NodeId& par_sourceNodeId,
    const NodeId& par_referenceTypeId,
    const INTEGER& par_isForward,
    const String& par_targetServerUri,
    const ExpandedNodeId& par_targetNodeId,
    const NodeClass& par_targetNodeClass);
  AddReferencesItem(const AddReferencesItem& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AddReferencesItem& operator=(const AddReferencesItem& other_value);
  boolean operator==(const AddReferencesItem& other_value) const;
  inline boolean operator!=(const AddReferencesItem& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& sourceNodeId()
    {return field_sourceNodeId;}
  inline const NodeId& sourceNodeId() const
    {return field_sourceNodeId;}
  inline NodeId& referenceTypeId()
    {return field_referenceTypeId;}
  inline const NodeId& referenceTypeId() const
    {return field_referenceTypeId;}
  inline INTEGER& isForward()
    {return field_isForward;}
  inline const INTEGER& isForward() const
    {return field_isForward;}
  inline String& targetServerUri()
    {return field_targetServerUri;}
  inline const String& targetServerUri() const
    {return field_targetServerUri;}
  inline ExpandedNodeId& targetNodeId()
    {return field_targetNodeId;}
  inline const ExpandedNodeId& targetNodeId() const
    {return field_targetNodeId;}
  inline NodeClass& targetNodeClass()
    {return field_targetNodeClass;}
  inline const NodeClass& targetNodeClass() const
    {return field_targetNodeClass;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddReferencesItem_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AddReferencesItem_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AddReferencesItem& other_value);
void copy_template(const AddReferencesItem_template& other_value);

public:
AddReferencesItem_template();
AddReferencesItem_template(template_sel other_value);
AddReferencesItem_template(const AddReferencesItem& other_value);
AddReferencesItem_template(const OPTIONAL<AddReferencesItem>& other_value);
AddReferencesItem_template(const AddReferencesItem_template& other_value);
~AddReferencesItem_template();
AddReferencesItem_template& operator=(template_sel other_value);
AddReferencesItem_template& operator=(const AddReferencesItem& other_value);
AddReferencesItem_template& operator=(const OPTIONAL<AddReferencesItem>& other_value);
AddReferencesItem_template& operator=(const AddReferencesItem_template& other_value);
boolean match(const AddReferencesItem& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AddReferencesItem valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AddReferencesItem_template& list_item(unsigned int list_index) const;
NodeId_template& sourceNodeId();
const NodeId_template& sourceNodeId() const;
NodeId_template& referenceTypeId();
const NodeId_template& referenceTypeId() const;
INTEGER_template& isForward();
const INTEGER_template& isForward() const;
String_template& targetServerUri();
const String_template& targetServerUri() const;
ExpandedNodeId_template& targetNodeId();
const ExpandedNodeId_template& targetNodeId() const;
NodeClass_template& targetNodeClass();
const NodeClass_template& targetNodeClass() const;
int size_of() const;
void log() const;
void log_match(const AddReferencesItem& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteNodesItemArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
DeleteNodesItem **value_elements;
} *val_ptr;

static const DeleteNodesItem UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const DeleteNodesItemArray& other_value);

public:
  typedef DeleteNodesItem of_type;
DeleteNodesItemArray();
DeleteNodesItemArray(null_type other_value);
DeleteNodesItemArray(const DeleteNodesItemArray& other_value);
~DeleteNodesItemArray();

void clean_up();
DeleteNodesItemArray& operator=(null_type other_value);
DeleteNodesItemArray& operator=(const DeleteNodesItemArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const DeleteNodesItemArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DeleteNodesItemArray& other_value) const { return !(*this == other_value); }

DeleteNodesItem& operator[](int index_value);
DeleteNodesItem& operator[](const INTEGER& index_value);
const DeleteNodesItem& operator[](int index_value) const;
const DeleteNodesItem& operator[](const INTEGER& index_value) const;

DeleteNodesItemArray operator<<=(int rotate_count) const;
DeleteNodesItemArray operator<<=(const INTEGER& rotate_count) const;
DeleteNodesItemArray operator>>=(int rotate_count) const;
DeleteNodesItemArray operator>>=(const INTEGER& rotate_count) const;

DeleteNodesItemArray operator+(const DeleteNodesItemArray& other_value) const;

DeleteNodesItemArray substr(int index, int returncount) const;

DeleteNodesItemArray replace(int index, int len, const DeleteNodesItemArray& repl) const;

DeleteNodesItemArray replace(int index, int len, const DeleteNodesItemArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteNodesItemArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
DeleteNodesItem_template **value_elements;
} single_value;
struct {
unsigned int n_values;
DeleteNodesItemArray_template *list_value;
} value_list;
};
void copy_value(const DeleteNodesItemArray& other_value);
void copy_template(const DeleteNodesItemArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
DeleteNodesItemArray_template();
DeleteNodesItemArray_template(template_sel other_value);
DeleteNodesItemArray_template(null_type other_value);
DeleteNodesItemArray_template(const DeleteNodesItemArray& other_value);
DeleteNodesItemArray_template(const OPTIONAL<DeleteNodesItemArray>& other_value);
DeleteNodesItemArray_template(const DeleteNodesItemArray_template& other_value);
~DeleteNodesItemArray_template();

void clean_up();
DeleteNodesItemArray_template& operator=(template_sel other_value);
DeleteNodesItemArray_template& operator=(null_type other_value);
DeleteNodesItemArray_template& operator=(const DeleteNodesItemArray& other_value);
DeleteNodesItemArray_template& operator=(const OPTIONAL<DeleteNodesItemArray>& other_value);
DeleteNodesItemArray_template& operator=(const DeleteNodesItemArray_template& other_value);

DeleteNodesItem_template& operator[](int index_value);
DeleteNodesItem_template& operator[](const INTEGER& index_value);
const DeleteNodesItem_template& operator[](int index_value) const;
const DeleteNodesItem_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const DeleteNodesItemArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
DeleteNodesItemArray valueof() const;
DeleteNodesItemArray substr(int index, int returncount) const;

DeleteNodesItemArray replace(int index, int len, const DeleteNodesItemArray_template& repl) const;

DeleteNodesItemArray replace(int index, int len, const DeleteNodesItemArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
DeleteNodesItemArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DeleteNodesItemArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class DeleteNodesItem : public Base_Type {
  NodeId field_nodeId;
  INTEGER field_deleteTargetReferences;
public:
  DeleteNodesItem();
  DeleteNodesItem(const NodeId& par_nodeId,
    const INTEGER& par_deleteTargetReferences);
  DeleteNodesItem(const DeleteNodesItem& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteNodesItem& operator=(const DeleteNodesItem& other_value);
  boolean operator==(const DeleteNodesItem& other_value) const;
  inline boolean operator!=(const DeleteNodesItem& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline INTEGER& deleteTargetReferences()
    {return field_deleteTargetReferences;}
  inline const INTEGER& deleteTargetReferences() const
    {return field_deleteTargetReferences;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteNodesItem_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteNodesItem_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteNodesItem& other_value);
void copy_template(const DeleteNodesItem_template& other_value);

public:
DeleteNodesItem_template();
DeleteNodesItem_template(template_sel other_value);
DeleteNodesItem_template(const DeleteNodesItem& other_value);
DeleteNodesItem_template(const OPTIONAL<DeleteNodesItem>& other_value);
DeleteNodesItem_template(const DeleteNodesItem_template& other_value);
~DeleteNodesItem_template();
DeleteNodesItem_template& operator=(template_sel other_value);
DeleteNodesItem_template& operator=(const DeleteNodesItem& other_value);
DeleteNodesItem_template& operator=(const OPTIONAL<DeleteNodesItem>& other_value);
DeleteNodesItem_template& operator=(const DeleteNodesItem_template& other_value);
boolean match(const DeleteNodesItem& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteNodesItem valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteNodesItem_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
INTEGER_template& deleteTargetReferences();
const INTEGER_template& deleteTargetReferences() const;
int size_of() const;
void log() const;
void log_match(const DeleteNodesItem& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteReferencesItemArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
DeleteReferencesItem **value_elements;
} *val_ptr;

static const DeleteReferencesItem UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const DeleteReferencesItemArray& other_value);

public:
  typedef DeleteReferencesItem of_type;
DeleteReferencesItemArray();
DeleteReferencesItemArray(null_type other_value);
DeleteReferencesItemArray(const DeleteReferencesItemArray& other_value);
~DeleteReferencesItemArray();

void clean_up();
DeleteReferencesItemArray& operator=(null_type other_value);
DeleteReferencesItemArray& operator=(const DeleteReferencesItemArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const DeleteReferencesItemArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const DeleteReferencesItemArray& other_value) const { return !(*this == other_value); }

DeleteReferencesItem& operator[](int index_value);
DeleteReferencesItem& operator[](const INTEGER& index_value);
const DeleteReferencesItem& operator[](int index_value) const;
const DeleteReferencesItem& operator[](const INTEGER& index_value) const;

DeleteReferencesItemArray operator<<=(int rotate_count) const;
DeleteReferencesItemArray operator<<=(const INTEGER& rotate_count) const;
DeleteReferencesItemArray operator>>=(int rotate_count) const;
DeleteReferencesItemArray operator>>=(const INTEGER& rotate_count) const;

DeleteReferencesItemArray operator+(const DeleteReferencesItemArray& other_value) const;

DeleteReferencesItemArray substr(int index, int returncount) const;

DeleteReferencesItemArray replace(int index, int len, const DeleteReferencesItemArray& repl) const;

DeleteReferencesItemArray replace(int index, int len, const DeleteReferencesItemArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteReferencesItemArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
DeleteReferencesItem_template **value_elements;
} single_value;
struct {
unsigned int n_values;
DeleteReferencesItemArray_template *list_value;
} value_list;
};
void copy_value(const DeleteReferencesItemArray& other_value);
void copy_template(const DeleteReferencesItemArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
DeleteReferencesItemArray_template();
DeleteReferencesItemArray_template(template_sel other_value);
DeleteReferencesItemArray_template(null_type other_value);
DeleteReferencesItemArray_template(const DeleteReferencesItemArray& other_value);
DeleteReferencesItemArray_template(const OPTIONAL<DeleteReferencesItemArray>& other_value);
DeleteReferencesItemArray_template(const DeleteReferencesItemArray_template& other_value);
~DeleteReferencesItemArray_template();

void clean_up();
DeleteReferencesItemArray_template& operator=(template_sel other_value);
DeleteReferencesItemArray_template& operator=(null_type other_value);
DeleteReferencesItemArray_template& operator=(const DeleteReferencesItemArray& other_value);
DeleteReferencesItemArray_template& operator=(const OPTIONAL<DeleteReferencesItemArray>& other_value);
DeleteReferencesItemArray_template& operator=(const DeleteReferencesItemArray_template& other_value);

DeleteReferencesItem_template& operator[](int index_value);
DeleteReferencesItem_template& operator[](const INTEGER& index_value);
const DeleteReferencesItem_template& operator[](int index_value) const;
const DeleteReferencesItem_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const DeleteReferencesItemArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
DeleteReferencesItemArray valueof() const;
DeleteReferencesItemArray substr(int index, int returncount) const;

DeleteReferencesItemArray replace(int index, int len, const DeleteReferencesItemArray_template& repl) const;

DeleteReferencesItemArray replace(int index, int len, const DeleteReferencesItemArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
DeleteReferencesItemArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const DeleteReferencesItemArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class DeleteReferencesItem : public Base_Type {
  NodeId field_sourceNodeId;
  NodeId field_referenceTypeId;
  INTEGER field_isForward;
  ExpandedNodeId field_targetNodeId;
  INTEGER field_deleteBidirectional;
public:
  DeleteReferencesItem();
  DeleteReferencesItem(const NodeId& par_sourceNodeId,
    const NodeId& par_referenceTypeId,
    const INTEGER& par_isForward,
    const ExpandedNodeId& par_targetNodeId,
    const INTEGER& par_deleteBidirectional);
  DeleteReferencesItem(const DeleteReferencesItem& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteReferencesItem& operator=(const DeleteReferencesItem& other_value);
  boolean operator==(const DeleteReferencesItem& other_value) const;
  inline boolean operator!=(const DeleteReferencesItem& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& sourceNodeId()
    {return field_sourceNodeId;}
  inline const NodeId& sourceNodeId() const
    {return field_sourceNodeId;}
  inline NodeId& referenceTypeId()
    {return field_referenceTypeId;}
  inline const NodeId& referenceTypeId() const
    {return field_referenceTypeId;}
  inline INTEGER& isForward()
    {return field_isForward;}
  inline const INTEGER& isForward() const
    {return field_isForward;}
  inline ExpandedNodeId& targetNodeId()
    {return field_targetNodeId;}
  inline const ExpandedNodeId& targetNodeId() const
    {return field_targetNodeId;}
  inline INTEGER& deleteBidirectional()
    {return field_deleteBidirectional;}
  inline const INTEGER& deleteBidirectional() const
    {return field_deleteBidirectional;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteReferencesItem_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteReferencesItem_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteReferencesItem& other_value);
void copy_template(const DeleteReferencesItem_template& other_value);

public:
DeleteReferencesItem_template();
DeleteReferencesItem_template(template_sel other_value);
DeleteReferencesItem_template(const DeleteReferencesItem& other_value);
DeleteReferencesItem_template(const OPTIONAL<DeleteReferencesItem>& other_value);
DeleteReferencesItem_template(const DeleteReferencesItem_template& other_value);
~DeleteReferencesItem_template();
DeleteReferencesItem_template& operator=(template_sel other_value);
DeleteReferencesItem_template& operator=(const DeleteReferencesItem& other_value);
DeleteReferencesItem_template& operator=(const OPTIONAL<DeleteReferencesItem>& other_value);
DeleteReferencesItem_template& operator=(const DeleteReferencesItem_template& other_value);
boolean match(const DeleteReferencesItem& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteReferencesItem valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteReferencesItem_template& list_item(unsigned int list_index) const;
NodeId_template& sourceNodeId();
const NodeId_template& sourceNodeId() const;
NodeId_template& referenceTypeId();
const NodeId_template& referenceTypeId() const;
INTEGER_template& isForward();
const INTEGER_template& isForward() const;
ExpandedNodeId_template& targetNodeId();
const ExpandedNodeId_template& targetNodeId() const;
INTEGER_template& deleteBidirectional();
const INTEGER_template& deleteBidirectional() const;
int size_of() const;
void log() const;
void log_match(const DeleteReferencesItem& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SignedSoftwareCertificateArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
SignedSoftwareCertificate **value_elements;
} *val_ptr;

static const SignedSoftwareCertificate UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SignedSoftwareCertificateArray& other_value);

public:
  typedef SignedSoftwareCertificate of_type;
SignedSoftwareCertificateArray();
SignedSoftwareCertificateArray(null_type other_value);
SignedSoftwareCertificateArray(const SignedSoftwareCertificateArray& other_value);
~SignedSoftwareCertificateArray();

void clean_up();
SignedSoftwareCertificateArray& operator=(null_type other_value);
SignedSoftwareCertificateArray& operator=(const SignedSoftwareCertificateArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SignedSoftwareCertificateArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SignedSoftwareCertificateArray& other_value) const { return !(*this == other_value); }

SignedSoftwareCertificate& operator[](int index_value);
SignedSoftwareCertificate& operator[](const INTEGER& index_value);
const SignedSoftwareCertificate& operator[](int index_value) const;
const SignedSoftwareCertificate& operator[](const INTEGER& index_value) const;

SignedSoftwareCertificateArray operator<<=(int rotate_count) const;
SignedSoftwareCertificateArray operator<<=(const INTEGER& rotate_count) const;
SignedSoftwareCertificateArray operator>>=(int rotate_count) const;
SignedSoftwareCertificateArray operator>>=(const INTEGER& rotate_count) const;

SignedSoftwareCertificateArray operator+(const SignedSoftwareCertificateArray& other_value) const;

SignedSoftwareCertificateArray substr(int index, int returncount) const;

SignedSoftwareCertificateArray replace(int index, int len, const SignedSoftwareCertificateArray& repl) const;

SignedSoftwareCertificateArray replace(int index, int len, const SignedSoftwareCertificateArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SignedSoftwareCertificateArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
SignedSoftwareCertificate_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SignedSoftwareCertificateArray_template *list_value;
} value_list;
};
void copy_value(const SignedSoftwareCertificateArray& other_value);
void copy_template(const SignedSoftwareCertificateArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SignedSoftwareCertificateArray_template();
SignedSoftwareCertificateArray_template(template_sel other_value);
SignedSoftwareCertificateArray_template(null_type other_value);
SignedSoftwareCertificateArray_template(const SignedSoftwareCertificateArray& other_value);
SignedSoftwareCertificateArray_template(const OPTIONAL<SignedSoftwareCertificateArray>& other_value);
SignedSoftwareCertificateArray_template(const SignedSoftwareCertificateArray_template& other_value);
~SignedSoftwareCertificateArray_template();

void clean_up();
SignedSoftwareCertificateArray_template& operator=(template_sel other_value);
SignedSoftwareCertificateArray_template& operator=(null_type other_value);
SignedSoftwareCertificateArray_template& operator=(const SignedSoftwareCertificateArray& other_value);
SignedSoftwareCertificateArray_template& operator=(const OPTIONAL<SignedSoftwareCertificateArray>& other_value);
SignedSoftwareCertificateArray_template& operator=(const SignedSoftwareCertificateArray_template& other_value);

SignedSoftwareCertificate_template& operator[](int index_value);
SignedSoftwareCertificate_template& operator[](const INTEGER& index_value);
const SignedSoftwareCertificate_template& operator[](int index_value) const;
const SignedSoftwareCertificate_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SignedSoftwareCertificateArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SignedSoftwareCertificateArray valueof() const;
SignedSoftwareCertificateArray substr(int index, int returncount) const;

SignedSoftwareCertificateArray replace(int index, int len, const SignedSoftwareCertificateArray_template& repl) const;

SignedSoftwareCertificateArray replace(int index, int len, const SignedSoftwareCertificateArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SignedSoftwareCertificateArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SignedSoftwareCertificateArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class SignedSoftwareCertificate : public Base_Type {
  ByteString field_certificateData;
  ByteString field_Signature;
public:
  SignedSoftwareCertificate();
  SignedSoftwareCertificate(const ByteString& par_certificateData,
    const ByteString& par_Signature);
  SignedSoftwareCertificate(const SignedSoftwareCertificate& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SignedSoftwareCertificate& operator=(const SignedSoftwareCertificate& other_value);
  boolean operator==(const SignedSoftwareCertificate& other_value) const;
  inline boolean operator!=(const SignedSoftwareCertificate& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ByteString& certificateData()
    {return field_certificateData;}
  inline const ByteString& certificateData() const
    {return field_certificateData;}
  inline ByteString& Signature()
    {return field_Signature;}
  inline const ByteString& Signature() const
    {return field_Signature;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SignedSoftwareCertificate_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SignedSoftwareCertificate_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SignedSoftwareCertificate& other_value);
void copy_template(const SignedSoftwareCertificate_template& other_value);

public:
SignedSoftwareCertificate_template();
SignedSoftwareCertificate_template(template_sel other_value);
SignedSoftwareCertificate_template(const SignedSoftwareCertificate& other_value);
SignedSoftwareCertificate_template(const OPTIONAL<SignedSoftwareCertificate>& other_value);
SignedSoftwareCertificate_template(const SignedSoftwareCertificate_template& other_value);
~SignedSoftwareCertificate_template();
SignedSoftwareCertificate_template& operator=(template_sel other_value);
SignedSoftwareCertificate_template& operator=(const SignedSoftwareCertificate& other_value);
SignedSoftwareCertificate_template& operator=(const OPTIONAL<SignedSoftwareCertificate>& other_value);
SignedSoftwareCertificate_template& operator=(const SignedSoftwareCertificate_template& other_value);
boolean match(const SignedSoftwareCertificate& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SignedSoftwareCertificate valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SignedSoftwareCertificate_template& list_item(unsigned int list_index) const;
ByteString_template& certificateData();
const ByteString_template& certificateData() const;
ByteString_template& Signature();
const ByteString_template& Signature() const;
int size_of() const;
void log() const;
void log_match(const SignedSoftwareCertificate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowseDescriptionArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BrowseDescription **value_elements;
} *val_ptr;

static const BrowseDescription UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const BrowseDescriptionArray& other_value);

public:
  typedef BrowseDescription of_type;
BrowseDescriptionArray();
BrowseDescriptionArray(null_type other_value);
BrowseDescriptionArray(const BrowseDescriptionArray& other_value);
~BrowseDescriptionArray();

void clean_up();
BrowseDescriptionArray& operator=(null_type other_value);
BrowseDescriptionArray& operator=(const BrowseDescriptionArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const BrowseDescriptionArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const BrowseDescriptionArray& other_value) const { return !(*this == other_value); }

BrowseDescription& operator[](int index_value);
BrowseDescription& operator[](const INTEGER& index_value);
const BrowseDescription& operator[](int index_value) const;
const BrowseDescription& operator[](const INTEGER& index_value) const;

BrowseDescriptionArray operator<<=(int rotate_count) const;
BrowseDescriptionArray operator<<=(const INTEGER& rotate_count) const;
BrowseDescriptionArray operator>>=(int rotate_count) const;
BrowseDescriptionArray operator>>=(const INTEGER& rotate_count) const;

BrowseDescriptionArray operator+(const BrowseDescriptionArray& other_value) const;

BrowseDescriptionArray substr(int index, int returncount) const;

BrowseDescriptionArray replace(int index, int len, const BrowseDescriptionArray& repl) const;

BrowseDescriptionArray replace(int index, int len, const BrowseDescriptionArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseDescriptionArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
BrowseDescription_template **value_elements;
} single_value;
struct {
unsigned int n_values;
BrowseDescriptionArray_template *list_value;
} value_list;
};
void copy_value(const BrowseDescriptionArray& other_value);
void copy_template(const BrowseDescriptionArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
BrowseDescriptionArray_template();
BrowseDescriptionArray_template(template_sel other_value);
BrowseDescriptionArray_template(null_type other_value);
BrowseDescriptionArray_template(const BrowseDescriptionArray& other_value);
BrowseDescriptionArray_template(const OPTIONAL<BrowseDescriptionArray>& other_value);
BrowseDescriptionArray_template(const BrowseDescriptionArray_template& other_value);
~BrowseDescriptionArray_template();

void clean_up();
BrowseDescriptionArray_template& operator=(template_sel other_value);
BrowseDescriptionArray_template& operator=(null_type other_value);
BrowseDescriptionArray_template& operator=(const BrowseDescriptionArray& other_value);
BrowseDescriptionArray_template& operator=(const OPTIONAL<BrowseDescriptionArray>& other_value);
BrowseDescriptionArray_template& operator=(const BrowseDescriptionArray_template& other_value);

BrowseDescription_template& operator[](int index_value);
BrowseDescription_template& operator[](const INTEGER& index_value);
const BrowseDescription_template& operator[](int index_value) const;
const BrowseDescription_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const BrowseDescriptionArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
BrowseDescriptionArray valueof() const;
BrowseDescriptionArray substr(int index, int returncount) const;

BrowseDescriptionArray replace(int index, int len, const BrowseDescriptionArray_template& repl) const;

BrowseDescriptionArray replace(int index, int len, const BrowseDescriptionArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
BrowseDescriptionArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const BrowseDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class BrowseDescription : public Base_Type {
  NodeId field_nodeId;
  BrowseDirection field_browseDirection;
  NodeId field_referenceTypeId;
  INTEGER field_includeSubtypes;
  INTEGER field_nodeClassMask;
  INTEGER field_resultMask;
public:
  BrowseDescription();
  BrowseDescription(const NodeId& par_nodeId,
    const BrowseDirection& par_browseDirection,
    const NodeId& par_referenceTypeId,
    const INTEGER& par_includeSubtypes,
    const INTEGER& par_nodeClassMask,
    const INTEGER& par_resultMask);
  BrowseDescription(const BrowseDescription& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowseDescription& operator=(const BrowseDescription& other_value);
  boolean operator==(const BrowseDescription& other_value) const;
  inline boolean operator!=(const BrowseDescription& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline BrowseDirection& browseDirection()
    {return field_browseDirection;}
  inline const BrowseDirection& browseDirection() const
    {return field_browseDirection;}
  inline NodeId& referenceTypeId()
    {return field_referenceTypeId;}
  inline const NodeId& referenceTypeId() const
    {return field_referenceTypeId;}
  inline INTEGER& includeSubtypes()
    {return field_includeSubtypes;}
  inline const INTEGER& includeSubtypes() const
    {return field_includeSubtypes;}
  inline INTEGER& nodeClassMask()
    {return field_nodeClassMask;}
  inline const INTEGER& nodeClassMask() const
    {return field_nodeClassMask;}
  inline INTEGER& resultMask()
    {return field_resultMask;}
  inline const INTEGER& resultMask() const
    {return field_resultMask;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseDescription_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowseDescription_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowseDescription& other_value);
void copy_template(const BrowseDescription_template& other_value);

public:
BrowseDescription_template();
BrowseDescription_template(template_sel other_value);
BrowseDescription_template(const BrowseDescription& other_value);
BrowseDescription_template(const OPTIONAL<BrowseDescription>& other_value);
BrowseDescription_template(const BrowseDescription_template& other_value);
~BrowseDescription_template();
BrowseDescription_template& operator=(template_sel other_value);
BrowseDescription_template& operator=(const BrowseDescription& other_value);
BrowseDescription_template& operator=(const OPTIONAL<BrowseDescription>& other_value);
BrowseDescription_template& operator=(const BrowseDescription_template& other_value);
boolean match(const BrowseDescription& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowseDescription valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowseDescription_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
BrowseDirection_template& browseDirection();
const BrowseDirection_template& browseDirection() const;
NodeId_template& referenceTypeId();
const NodeId_template& referenceTypeId() const;
INTEGER_template& includeSubtypes();
const INTEGER_template& includeSubtypes() const;
INTEGER_template& nodeClassMask();
const INTEGER_template& nodeClassMask() const;
INTEGER_template& resultMask();
const INTEGER_template& resultMask() const;
int size_of() const;
void log() const;
void log_match(const BrowseDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowsePathArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BrowsePath **value_elements;
} *val_ptr;

static const BrowsePath UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const BrowsePathArray& other_value);

public:
  typedef BrowsePath of_type;
BrowsePathArray();
BrowsePathArray(null_type other_value);
BrowsePathArray(const BrowsePathArray& other_value);
~BrowsePathArray();

void clean_up();
BrowsePathArray& operator=(null_type other_value);
BrowsePathArray& operator=(const BrowsePathArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const BrowsePathArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const BrowsePathArray& other_value) const { return !(*this == other_value); }

BrowsePath& operator[](int index_value);
BrowsePath& operator[](const INTEGER& index_value);
const BrowsePath& operator[](int index_value) const;
const BrowsePath& operator[](const INTEGER& index_value) const;

BrowsePathArray operator<<=(int rotate_count) const;
BrowsePathArray operator<<=(const INTEGER& rotate_count) const;
BrowsePathArray operator>>=(int rotate_count) const;
BrowsePathArray operator>>=(const INTEGER& rotate_count) const;

BrowsePathArray operator+(const BrowsePathArray& other_value) const;

BrowsePathArray substr(int index, int returncount) const;

BrowsePathArray replace(int index, int len, const BrowsePathArray& repl) const;

BrowsePathArray replace(int index, int len, const BrowsePathArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowsePathArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
BrowsePath_template **value_elements;
} single_value;
struct {
unsigned int n_values;
BrowsePathArray_template *list_value;
} value_list;
};
void copy_value(const BrowsePathArray& other_value);
void copy_template(const BrowsePathArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
BrowsePathArray_template();
BrowsePathArray_template(template_sel other_value);
BrowsePathArray_template(null_type other_value);
BrowsePathArray_template(const BrowsePathArray& other_value);
BrowsePathArray_template(const OPTIONAL<BrowsePathArray>& other_value);
BrowsePathArray_template(const BrowsePathArray_template& other_value);
~BrowsePathArray_template();

void clean_up();
BrowsePathArray_template& operator=(template_sel other_value);
BrowsePathArray_template& operator=(null_type other_value);
BrowsePathArray_template& operator=(const BrowsePathArray& other_value);
BrowsePathArray_template& operator=(const OPTIONAL<BrowsePathArray>& other_value);
BrowsePathArray_template& operator=(const BrowsePathArray_template& other_value);

BrowsePath_template& operator[](int index_value);
BrowsePath_template& operator[](const INTEGER& index_value);
const BrowsePath_template& operator[](int index_value) const;
const BrowsePath_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const BrowsePathArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
BrowsePathArray valueof() const;
BrowsePathArray substr(int index, int returncount) const;

BrowsePathArray replace(int index, int len, const BrowsePathArray_template& repl) const;

BrowsePathArray replace(int index, int len, const BrowsePathArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
BrowsePathArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const BrowsePathArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class BrowsePath : public Base_Type {
  NodeId field_startingNode;
  RelativePath field_relativePath;
public:
  BrowsePath();
  BrowsePath(const NodeId& par_startingNode,
    const RelativePath& par_relativePath);
  BrowsePath(const BrowsePath& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowsePath& operator=(const BrowsePath& other_value);
  boolean operator==(const BrowsePath& other_value) const;
  inline boolean operator!=(const BrowsePath& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& startingNode()
    {return field_startingNode;}
  inline const NodeId& startingNode() const
    {return field_startingNode;}
  inline RelativePath& relativePath()
    {return field_relativePath;}
  inline const RelativePath& relativePath() const
    {return field_relativePath;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowsePath_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowsePath_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowsePath& other_value);
void copy_template(const BrowsePath_template& other_value);

public:
BrowsePath_template();
BrowsePath_template(template_sel other_value);
BrowsePath_template(const BrowsePath& other_value);
BrowsePath_template(const OPTIONAL<BrowsePath>& other_value);
BrowsePath_template(const BrowsePath_template& other_value);
~BrowsePath_template();
BrowsePath_template& operator=(template_sel other_value);
BrowsePath_template& operator=(const BrowsePath& other_value);
BrowsePath_template& operator=(const OPTIONAL<BrowsePath>& other_value);
BrowsePath_template& operator=(const BrowsePath_template& other_value);
boolean match(const BrowsePath& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowsePath valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowsePath_template& list_item(unsigned int list_index) const;
NodeId_template& startingNode();
const NodeId_template& startingNode() const;
RelativePath_template& relativePath();
const RelativePath_template& relativePath() const;
int size_of() const;
void log() const;
void log_match(const BrowsePath& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowsePathResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BrowsePathResult **value_elements;
} *val_ptr;

static const BrowsePathResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const BrowsePathResultArray& other_value);

public:
  typedef BrowsePathResult of_type;
BrowsePathResultArray();
BrowsePathResultArray(null_type other_value);
BrowsePathResultArray(const BrowsePathResultArray& other_value);
~BrowsePathResultArray();

void clean_up();
BrowsePathResultArray& operator=(null_type other_value);
BrowsePathResultArray& operator=(const BrowsePathResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const BrowsePathResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const BrowsePathResultArray& other_value) const { return !(*this == other_value); }

BrowsePathResult& operator[](int index_value);
BrowsePathResult& operator[](const INTEGER& index_value);
const BrowsePathResult& operator[](int index_value) const;
const BrowsePathResult& operator[](const INTEGER& index_value) const;

BrowsePathResultArray operator<<=(int rotate_count) const;
BrowsePathResultArray operator<<=(const INTEGER& rotate_count) const;
BrowsePathResultArray operator>>=(int rotate_count) const;
BrowsePathResultArray operator>>=(const INTEGER& rotate_count) const;

BrowsePathResultArray operator+(const BrowsePathResultArray& other_value) const;

BrowsePathResultArray substr(int index, int returncount) const;

BrowsePathResultArray replace(int index, int len, const BrowsePathResultArray& repl) const;

BrowsePathResultArray replace(int index, int len, const BrowsePathResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowsePathResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
BrowsePathResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
BrowsePathResultArray_template *list_value;
} value_list;
};
void copy_value(const BrowsePathResultArray& other_value);
void copy_template(const BrowsePathResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
BrowsePathResultArray_template();
BrowsePathResultArray_template(template_sel other_value);
BrowsePathResultArray_template(null_type other_value);
BrowsePathResultArray_template(const BrowsePathResultArray& other_value);
BrowsePathResultArray_template(const OPTIONAL<BrowsePathResultArray>& other_value);
BrowsePathResultArray_template(const BrowsePathResultArray_template& other_value);
~BrowsePathResultArray_template();

void clean_up();
BrowsePathResultArray_template& operator=(template_sel other_value);
BrowsePathResultArray_template& operator=(null_type other_value);
BrowsePathResultArray_template& operator=(const BrowsePathResultArray& other_value);
BrowsePathResultArray_template& operator=(const OPTIONAL<BrowsePathResultArray>& other_value);
BrowsePathResultArray_template& operator=(const BrowsePathResultArray_template& other_value);

BrowsePathResult_template& operator[](int index_value);
BrowsePathResult_template& operator[](const INTEGER& index_value);
const BrowsePathResult_template& operator[](int index_value) const;
const BrowsePathResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const BrowsePathResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
BrowsePathResultArray valueof() const;
BrowsePathResultArray substr(int index, int returncount) const;

BrowsePathResultArray replace(int index, int len, const BrowsePathResultArray_template& repl) const;

BrowsePathResultArray replace(int index, int len, const BrowsePathResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
BrowsePathResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const BrowsePathResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfBrowsePathTarget : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfBrowsePathTargetArray *field_realArray;
};
void copy_value(const ListOfBrowsePathTarget& other_value);

public:
ListOfBrowsePathTarget();
ListOfBrowsePathTarget(const ListOfBrowsePathTarget& other_value);
~ListOfBrowsePathTarget();
ListOfBrowsePathTarget& operator=(const ListOfBrowsePathTarget& other_value);
boolean operator==(const ListOfBrowsePathTarget& other_value) const;
inline boolean operator!=(const ListOfBrowsePathTarget& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfBrowsePathTargetArray& realArray();
const ListOfBrowsePathTargetArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowsePathTarget_template : public Base_Template {
union {
struct {
ListOfBrowsePathTarget::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfBrowsePathTargetArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfBrowsePathTarget_template *list_value;
} value_list;
};
void copy_value(const ListOfBrowsePathTarget& other_value);

void copy_template(const ListOfBrowsePathTarget_template& other_value);

public:
ListOfBrowsePathTarget_template();
ListOfBrowsePathTarget_template(template_sel other_value);
ListOfBrowsePathTarget_template(const ListOfBrowsePathTarget& other_value);
ListOfBrowsePathTarget_template(const OPTIONAL<ListOfBrowsePathTarget>& other_value);
ListOfBrowsePathTarget_template(const ListOfBrowsePathTarget_template& other_value);
~ListOfBrowsePathTarget_template();
void clean_up();
ListOfBrowsePathTarget_template& operator=(template_sel other_value);
ListOfBrowsePathTarget_template& operator=(const ListOfBrowsePathTarget& other_value);
ListOfBrowsePathTarget_template& operator=(const OPTIONAL<ListOfBrowsePathTarget>& other_value);
ListOfBrowsePathTarget_template& operator=(const ListOfBrowsePathTarget_template& other_value);
boolean match(const ListOfBrowsePathTarget& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfBrowsePathTarget valueof() const;
ListOfBrowsePathTarget_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfBrowsePathTargetArray_template& realArray();
const ListOfBrowsePathTargetArray_template& realArray() const;
boolean ischosen(ListOfBrowsePathTarget::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfBrowsePathTarget& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class BrowsePathTargetArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
BrowsePathTarget **value_elements;
} *val_ptr;

static const BrowsePathTarget UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const BrowsePathTargetArray& other_value);

public:
  typedef BrowsePathTarget of_type;
BrowsePathTargetArray();
BrowsePathTargetArray(null_type other_value);
BrowsePathTargetArray(const BrowsePathTargetArray& other_value);
~BrowsePathTargetArray();

void clean_up();
BrowsePathTargetArray& operator=(null_type other_value);
BrowsePathTargetArray& operator=(const BrowsePathTargetArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const BrowsePathTargetArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const BrowsePathTargetArray& other_value) const { return !(*this == other_value); }

BrowsePathTarget& operator[](int index_value);
BrowsePathTarget& operator[](const INTEGER& index_value);
const BrowsePathTarget& operator[](int index_value) const;
const BrowsePathTarget& operator[](const INTEGER& index_value) const;

BrowsePathTargetArray operator<<=(int rotate_count) const;
BrowsePathTargetArray operator<<=(const INTEGER& rotate_count) const;
BrowsePathTargetArray operator>>=(int rotate_count) const;
BrowsePathTargetArray operator>>=(const INTEGER& rotate_count) const;

BrowsePathTargetArray operator+(const BrowsePathTargetArray& other_value) const;

BrowsePathTargetArray substr(int index, int returncount) const;

BrowsePathTargetArray replace(int index, int len, const BrowsePathTargetArray& repl) const;

BrowsePathTargetArray replace(int index, int len, const BrowsePathTargetArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowsePathTargetArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
BrowsePathTarget_template **value_elements;
} single_value;
struct {
unsigned int n_values;
BrowsePathTargetArray_template *list_value;
} value_list;
};
void copy_value(const BrowsePathTargetArray& other_value);
void copy_template(const BrowsePathTargetArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
BrowsePathTargetArray_template();
BrowsePathTargetArray_template(template_sel other_value);
BrowsePathTargetArray_template(null_type other_value);
BrowsePathTargetArray_template(const BrowsePathTargetArray& other_value);
BrowsePathTargetArray_template(const OPTIONAL<BrowsePathTargetArray>& other_value);
BrowsePathTargetArray_template(const BrowsePathTargetArray_template& other_value);
~BrowsePathTargetArray_template();

void clean_up();
BrowsePathTargetArray_template& operator=(template_sel other_value);
BrowsePathTargetArray_template& operator=(null_type other_value);
BrowsePathTargetArray_template& operator=(const BrowsePathTargetArray& other_value);
BrowsePathTargetArray_template& operator=(const OPTIONAL<BrowsePathTargetArray>& other_value);
BrowsePathTargetArray_template& operator=(const BrowsePathTargetArray_template& other_value);

BrowsePathTarget_template& operator[](int index_value);
BrowsePathTarget_template& operator[](const INTEGER& index_value);
const BrowsePathTarget_template& operator[](int index_value) const;
const BrowsePathTarget_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const BrowsePathTargetArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
BrowsePathTargetArray valueof() const;
BrowsePathTargetArray substr(int index, int returncount) const;

BrowsePathTargetArray replace(int index, int len, const BrowsePathTargetArray_template& repl) const;

BrowsePathTargetArray replace(int index, int len, const BrowsePathTargetArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
BrowsePathTargetArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const BrowsePathTargetArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class BrowsePathTarget : public Base_Type {
  ExpandedNodeId field_targetId;
  INTEGER field_remainingPathIndex;
public:
  BrowsePathTarget();
  BrowsePathTarget(const ExpandedNodeId& par_targetId,
    const INTEGER& par_remainingPathIndex);
  BrowsePathTarget(const BrowsePathTarget& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowsePathTarget& operator=(const BrowsePathTarget& other_value);
  boolean operator==(const BrowsePathTarget& other_value) const;
  inline boolean operator!=(const BrowsePathTarget& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ExpandedNodeId& targetId()
    {return field_targetId;}
  inline const ExpandedNodeId& targetId() const
    {return field_targetId;}
  inline INTEGER& remainingPathIndex()
    {return field_remainingPathIndex;}
  inline const INTEGER& remainingPathIndex() const
    {return field_remainingPathIndex;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowsePathTarget_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowsePathTarget_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowsePathTarget& other_value);
void copy_template(const BrowsePathTarget_template& other_value);

public:
BrowsePathTarget_template();
BrowsePathTarget_template(template_sel other_value);
BrowsePathTarget_template(const BrowsePathTarget& other_value);
BrowsePathTarget_template(const OPTIONAL<BrowsePathTarget>& other_value);
BrowsePathTarget_template(const BrowsePathTarget_template& other_value);
~BrowsePathTarget_template();
BrowsePathTarget_template& operator=(template_sel other_value);
BrowsePathTarget_template& operator=(const BrowsePathTarget& other_value);
BrowsePathTarget_template& operator=(const OPTIONAL<BrowsePathTarget>& other_value);
BrowsePathTarget_template& operator=(const BrowsePathTarget_template& other_value);
boolean match(const BrowsePathTarget& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowsePathTarget valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowsePathTarget_template& list_item(unsigned int list_index) const;
ExpandedNodeId_template& targetId();
const ExpandedNodeId_template& targetId() const;
INTEGER_template& remainingPathIndex();
const INTEGER_template& remainingPathIndex() const;
int size_of() const;
void log() const;
void log_match(const BrowsePathTarget& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfBrowsePathTargetArray : public Base_Type {
  INTEGER field_arrayLength;
  BrowsePathTargetArray field_arrayValues;
public:
  ListOfBrowsePathTargetArray();
  ListOfBrowsePathTargetArray(const INTEGER& par_arrayLength,
    const BrowsePathTargetArray& par_arrayValues);
  ListOfBrowsePathTargetArray(const ListOfBrowsePathTargetArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfBrowsePathTargetArray& operator=(const ListOfBrowsePathTargetArray& other_value);
  boolean operator==(const ListOfBrowsePathTargetArray& other_value) const;
  inline boolean operator!=(const ListOfBrowsePathTargetArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline BrowsePathTargetArray& arrayValues()
    {return field_arrayValues;}
  inline const BrowsePathTargetArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowsePathTargetArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfBrowsePathTargetArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfBrowsePathTargetArray& other_value);
void copy_template(const ListOfBrowsePathTargetArray_template& other_value);

public:
ListOfBrowsePathTargetArray_template();
ListOfBrowsePathTargetArray_template(template_sel other_value);
ListOfBrowsePathTargetArray_template(const ListOfBrowsePathTargetArray& other_value);
ListOfBrowsePathTargetArray_template(const OPTIONAL<ListOfBrowsePathTargetArray>& other_value);
ListOfBrowsePathTargetArray_template(const ListOfBrowsePathTargetArray_template& other_value);
~ListOfBrowsePathTargetArray_template();
ListOfBrowsePathTargetArray_template& operator=(template_sel other_value);
ListOfBrowsePathTargetArray_template& operator=(const ListOfBrowsePathTargetArray& other_value);
ListOfBrowsePathTargetArray_template& operator=(const OPTIONAL<ListOfBrowsePathTargetArray>& other_value);
ListOfBrowsePathTargetArray_template& operator=(const ListOfBrowsePathTargetArray_template& other_value);
boolean match(const ListOfBrowsePathTargetArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfBrowsePathTargetArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfBrowsePathTargetArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
BrowsePathTargetArray_template& arrayValues();
const BrowsePathTargetArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfBrowsePathTargetArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowsePathResult : public Base_Type {
  INTEGER field_statusCode;
  ListOfBrowsePathTarget field_targets;
public:
  BrowsePathResult();
  BrowsePathResult(const INTEGER& par_statusCode,
    const ListOfBrowsePathTarget& par_targets);
  BrowsePathResult(const BrowsePathResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowsePathResult& operator=(const BrowsePathResult& other_value);
  boolean operator==(const BrowsePathResult& other_value) const;
  inline boolean operator!=(const BrowsePathResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline ListOfBrowsePathTarget& targets()
    {return field_targets;}
  inline const ListOfBrowsePathTarget& targets() const
    {return field_targets;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowsePathResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowsePathResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowsePathResult& other_value);
void copy_template(const BrowsePathResult_template& other_value);

public:
BrowsePathResult_template();
BrowsePathResult_template(template_sel other_value);
BrowsePathResult_template(const BrowsePathResult& other_value);
BrowsePathResult_template(const OPTIONAL<BrowsePathResult>& other_value);
BrowsePathResult_template(const BrowsePathResult_template& other_value);
~BrowsePathResult_template();
BrowsePathResult_template& operator=(template_sel other_value);
BrowsePathResult_template& operator=(const BrowsePathResult& other_value);
BrowsePathResult_template& operator=(const OPTIONAL<BrowsePathResult>& other_value);
BrowsePathResult_template& operator=(const BrowsePathResult_template& other_value);
boolean match(const BrowsePathResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowsePathResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowsePathResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
ListOfBrowsePathTarget_template& targets();
const ListOfBrowsePathTarget_template& targets() const;
int size_of() const;
void log() const;
void log_match(const BrowsePathResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NodeTypeDescriptionArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
NodeTypeDescription **value_elements;
} *val_ptr;

static const NodeTypeDescription UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const NodeTypeDescriptionArray& other_value);

public:
  typedef NodeTypeDescription of_type;
NodeTypeDescriptionArray();
NodeTypeDescriptionArray(null_type other_value);
NodeTypeDescriptionArray(const NodeTypeDescriptionArray& other_value);
~NodeTypeDescriptionArray();

void clean_up();
NodeTypeDescriptionArray& operator=(null_type other_value);
NodeTypeDescriptionArray& operator=(const NodeTypeDescriptionArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const NodeTypeDescriptionArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const NodeTypeDescriptionArray& other_value) const { return !(*this == other_value); }

NodeTypeDescription& operator[](int index_value);
NodeTypeDescription& operator[](const INTEGER& index_value);
const NodeTypeDescription& operator[](int index_value) const;
const NodeTypeDescription& operator[](const INTEGER& index_value) const;

NodeTypeDescriptionArray operator<<=(int rotate_count) const;
NodeTypeDescriptionArray operator<<=(const INTEGER& rotate_count) const;
NodeTypeDescriptionArray operator>>=(int rotate_count) const;
NodeTypeDescriptionArray operator>>=(const INTEGER& rotate_count) const;

NodeTypeDescriptionArray operator+(const NodeTypeDescriptionArray& other_value) const;

NodeTypeDescriptionArray substr(int index, int returncount) const;

NodeTypeDescriptionArray replace(int index, int len, const NodeTypeDescriptionArray& repl) const;

NodeTypeDescriptionArray replace(int index, int len, const NodeTypeDescriptionArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NodeTypeDescriptionArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
NodeTypeDescription_template **value_elements;
} single_value;
struct {
unsigned int n_values;
NodeTypeDescriptionArray_template *list_value;
} value_list;
};
void copy_value(const NodeTypeDescriptionArray& other_value);
void copy_template(const NodeTypeDescriptionArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
NodeTypeDescriptionArray_template();
NodeTypeDescriptionArray_template(template_sel other_value);
NodeTypeDescriptionArray_template(null_type other_value);
NodeTypeDescriptionArray_template(const NodeTypeDescriptionArray& other_value);
NodeTypeDescriptionArray_template(const OPTIONAL<NodeTypeDescriptionArray>& other_value);
NodeTypeDescriptionArray_template(const NodeTypeDescriptionArray_template& other_value);
~NodeTypeDescriptionArray_template();

void clean_up();
NodeTypeDescriptionArray_template& operator=(template_sel other_value);
NodeTypeDescriptionArray_template& operator=(null_type other_value);
NodeTypeDescriptionArray_template& operator=(const NodeTypeDescriptionArray& other_value);
NodeTypeDescriptionArray_template& operator=(const OPTIONAL<NodeTypeDescriptionArray>& other_value);
NodeTypeDescriptionArray_template& operator=(const NodeTypeDescriptionArray_template& other_value);

NodeTypeDescription_template& operator[](int index_value);
NodeTypeDescription_template& operator[](const INTEGER& index_value);
const NodeTypeDescription_template& operator[](int index_value) const;
const NodeTypeDescription_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const NodeTypeDescriptionArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
NodeTypeDescriptionArray valueof() const;
NodeTypeDescriptionArray substr(int index, int returncount) const;

NodeTypeDescriptionArray replace(int index, int len, const NodeTypeDescriptionArray_template& repl) const;

NodeTypeDescriptionArray replace(int index, int len, const NodeTypeDescriptionArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
NodeTypeDescriptionArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const NodeTypeDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfQueryDataDescription : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfQueryDataDescriptionArray *field_realArray;
};
void copy_value(const ListOfQueryDataDescription& other_value);

public:
ListOfQueryDataDescription();
ListOfQueryDataDescription(const ListOfQueryDataDescription& other_value);
~ListOfQueryDataDescription();
ListOfQueryDataDescription& operator=(const ListOfQueryDataDescription& other_value);
boolean operator==(const ListOfQueryDataDescription& other_value) const;
inline boolean operator!=(const ListOfQueryDataDescription& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfQueryDataDescriptionArray& realArray();
const ListOfQueryDataDescriptionArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfQueryDataDescription_template : public Base_Template {
union {
struct {
ListOfQueryDataDescription::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfQueryDataDescriptionArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfQueryDataDescription_template *list_value;
} value_list;
};
void copy_value(const ListOfQueryDataDescription& other_value);

void copy_template(const ListOfQueryDataDescription_template& other_value);

public:
ListOfQueryDataDescription_template();
ListOfQueryDataDescription_template(template_sel other_value);
ListOfQueryDataDescription_template(const ListOfQueryDataDescription& other_value);
ListOfQueryDataDescription_template(const OPTIONAL<ListOfQueryDataDescription>& other_value);
ListOfQueryDataDescription_template(const ListOfQueryDataDescription_template& other_value);
~ListOfQueryDataDescription_template();
void clean_up();
ListOfQueryDataDescription_template& operator=(template_sel other_value);
ListOfQueryDataDescription_template& operator=(const ListOfQueryDataDescription& other_value);
ListOfQueryDataDescription_template& operator=(const OPTIONAL<ListOfQueryDataDescription>& other_value);
ListOfQueryDataDescription_template& operator=(const ListOfQueryDataDescription_template& other_value);
boolean match(const ListOfQueryDataDescription& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfQueryDataDescription valueof() const;
ListOfQueryDataDescription_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfQueryDataDescriptionArray_template& realArray();
const ListOfQueryDataDescriptionArray_template& realArray() const;
boolean ischosen(ListOfQueryDataDescription::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfQueryDataDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class QueryDataDescriptionArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
QueryDataDescription **value_elements;
} *val_ptr;

static const QueryDataDescription UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const QueryDataDescriptionArray& other_value);

public:
  typedef QueryDataDescription of_type;
QueryDataDescriptionArray();
QueryDataDescriptionArray(null_type other_value);
QueryDataDescriptionArray(const QueryDataDescriptionArray& other_value);
~QueryDataDescriptionArray();

void clean_up();
QueryDataDescriptionArray& operator=(null_type other_value);
QueryDataDescriptionArray& operator=(const QueryDataDescriptionArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const QueryDataDescriptionArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const QueryDataDescriptionArray& other_value) const { return !(*this == other_value); }

QueryDataDescription& operator[](int index_value);
QueryDataDescription& operator[](const INTEGER& index_value);
const QueryDataDescription& operator[](int index_value) const;
const QueryDataDescription& operator[](const INTEGER& index_value) const;

QueryDataDescriptionArray operator<<=(int rotate_count) const;
QueryDataDescriptionArray operator<<=(const INTEGER& rotate_count) const;
QueryDataDescriptionArray operator>>=(int rotate_count) const;
QueryDataDescriptionArray operator>>=(const INTEGER& rotate_count) const;

QueryDataDescriptionArray operator+(const QueryDataDescriptionArray& other_value) const;

QueryDataDescriptionArray substr(int index, int returncount) const;

QueryDataDescriptionArray replace(int index, int len, const QueryDataDescriptionArray& repl) const;

QueryDataDescriptionArray replace(int index, int len, const QueryDataDescriptionArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QueryDataDescriptionArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
QueryDataDescription_template **value_elements;
} single_value;
struct {
unsigned int n_values;
QueryDataDescriptionArray_template *list_value;
} value_list;
};
void copy_value(const QueryDataDescriptionArray& other_value);
void copy_template(const QueryDataDescriptionArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
QueryDataDescriptionArray_template();
QueryDataDescriptionArray_template(template_sel other_value);
QueryDataDescriptionArray_template(null_type other_value);
QueryDataDescriptionArray_template(const QueryDataDescriptionArray& other_value);
QueryDataDescriptionArray_template(const OPTIONAL<QueryDataDescriptionArray>& other_value);
QueryDataDescriptionArray_template(const QueryDataDescriptionArray_template& other_value);
~QueryDataDescriptionArray_template();

void clean_up();
QueryDataDescriptionArray_template& operator=(template_sel other_value);
QueryDataDescriptionArray_template& operator=(null_type other_value);
QueryDataDescriptionArray_template& operator=(const QueryDataDescriptionArray& other_value);
QueryDataDescriptionArray_template& operator=(const OPTIONAL<QueryDataDescriptionArray>& other_value);
QueryDataDescriptionArray_template& operator=(const QueryDataDescriptionArray_template& other_value);

QueryDataDescription_template& operator[](int index_value);
QueryDataDescription_template& operator[](const INTEGER& index_value);
const QueryDataDescription_template& operator[](int index_value) const;
const QueryDataDescription_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const QueryDataDescriptionArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
QueryDataDescriptionArray valueof() const;
QueryDataDescriptionArray substr(int index, int returncount) const;

QueryDataDescriptionArray replace(int index, int len, const QueryDataDescriptionArray_template& repl) const;

QueryDataDescriptionArray replace(int index, int len, const QueryDataDescriptionArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
QueryDataDescriptionArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const QueryDataDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class QueryDataDescription : public Base_Type {
  RelativePath field_relativePath;
  INTEGER field_attributeId;
  String field_indexRange;
public:
  QueryDataDescription();
  QueryDataDescription(const RelativePath& par_relativePath,
    const INTEGER& par_attributeId,
    const String& par_indexRange);
  QueryDataDescription(const QueryDataDescription& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QueryDataDescription& operator=(const QueryDataDescription& other_value);
  boolean operator==(const QueryDataDescription& other_value) const;
  inline boolean operator!=(const QueryDataDescription& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RelativePath& relativePath()
    {return field_relativePath;}
  inline const RelativePath& relativePath() const
    {return field_relativePath;}
  inline INTEGER& attributeId()
    {return field_attributeId;}
  inline const INTEGER& attributeId() const
    {return field_attributeId;}
  inline String& indexRange()
    {return field_indexRange;}
  inline const String& indexRange() const
    {return field_indexRange;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QueryDataDescription_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QueryDataDescription_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QueryDataDescription& other_value);
void copy_template(const QueryDataDescription_template& other_value);

public:
QueryDataDescription_template();
QueryDataDescription_template(template_sel other_value);
QueryDataDescription_template(const QueryDataDescription& other_value);
QueryDataDescription_template(const OPTIONAL<QueryDataDescription>& other_value);
QueryDataDescription_template(const QueryDataDescription_template& other_value);
~QueryDataDescription_template();
QueryDataDescription_template& operator=(template_sel other_value);
QueryDataDescription_template& operator=(const QueryDataDescription& other_value);
QueryDataDescription_template& operator=(const OPTIONAL<QueryDataDescription>& other_value);
QueryDataDescription_template& operator=(const QueryDataDescription_template& other_value);
boolean match(const QueryDataDescription& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QueryDataDescription valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QueryDataDescription_template& list_item(unsigned int list_index) const;
RelativePath_template& relativePath();
const RelativePath_template& relativePath() const;
INTEGER_template& attributeId();
const INTEGER_template& attributeId() const;
String_template& indexRange();
const String_template& indexRange() const;
int size_of() const;
void log() const;
void log_match(const QueryDataDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfQueryDataDescriptionArray : public Base_Type {
  INTEGER field_arrayLength;
  QueryDataDescriptionArray field_arrayValues;
public:
  ListOfQueryDataDescriptionArray();
  ListOfQueryDataDescriptionArray(const INTEGER& par_arrayLength,
    const QueryDataDescriptionArray& par_arrayValues);
  ListOfQueryDataDescriptionArray(const ListOfQueryDataDescriptionArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfQueryDataDescriptionArray& operator=(const ListOfQueryDataDescriptionArray& other_value);
  boolean operator==(const ListOfQueryDataDescriptionArray& other_value) const;
  inline boolean operator!=(const ListOfQueryDataDescriptionArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline QueryDataDescriptionArray& arrayValues()
    {return field_arrayValues;}
  inline const QueryDataDescriptionArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfQueryDataDescriptionArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfQueryDataDescriptionArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfQueryDataDescriptionArray& other_value);
void copy_template(const ListOfQueryDataDescriptionArray_template& other_value);

public:
ListOfQueryDataDescriptionArray_template();
ListOfQueryDataDescriptionArray_template(template_sel other_value);
ListOfQueryDataDescriptionArray_template(const ListOfQueryDataDescriptionArray& other_value);
ListOfQueryDataDescriptionArray_template(const OPTIONAL<ListOfQueryDataDescriptionArray>& other_value);
ListOfQueryDataDescriptionArray_template(const ListOfQueryDataDescriptionArray_template& other_value);
~ListOfQueryDataDescriptionArray_template();
ListOfQueryDataDescriptionArray_template& operator=(template_sel other_value);
ListOfQueryDataDescriptionArray_template& operator=(const ListOfQueryDataDescriptionArray& other_value);
ListOfQueryDataDescriptionArray_template& operator=(const OPTIONAL<ListOfQueryDataDescriptionArray>& other_value);
ListOfQueryDataDescriptionArray_template& operator=(const ListOfQueryDataDescriptionArray_template& other_value);
boolean match(const ListOfQueryDataDescriptionArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfQueryDataDescriptionArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfQueryDataDescriptionArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
QueryDataDescriptionArray_template& arrayValues();
const QueryDataDescriptionArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfQueryDataDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class NodeTypeDescription : public Base_Type {
  ExpandedNodeId field_typeDefinitionNode;
  INTEGER field_includeSubtypes;
  ListOfQueryDataDescription field_dataToReturn;
public:
  NodeTypeDescription();
  NodeTypeDescription(const ExpandedNodeId& par_typeDefinitionNode,
    const INTEGER& par_includeSubtypes,
    const ListOfQueryDataDescription& par_dataToReturn);
  NodeTypeDescription(const NodeTypeDescription& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  NodeTypeDescription& operator=(const NodeTypeDescription& other_value);
  boolean operator==(const NodeTypeDescription& other_value) const;
  inline boolean operator!=(const NodeTypeDescription& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ExpandedNodeId& typeDefinitionNode()
    {return field_typeDefinitionNode;}
  inline const ExpandedNodeId& typeDefinitionNode() const
    {return field_typeDefinitionNode;}
  inline INTEGER& includeSubtypes()
    {return field_includeSubtypes;}
  inline const INTEGER& includeSubtypes() const
    {return field_includeSubtypes;}
  inline ListOfQueryDataDescription& dataToReturn()
    {return field_dataToReturn;}
  inline const ListOfQueryDataDescription& dataToReturn() const
    {return field_dataToReturn;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NodeTypeDescription_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
NodeTypeDescription_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const NodeTypeDescription& other_value);
void copy_template(const NodeTypeDescription_template& other_value);

public:
NodeTypeDescription_template();
NodeTypeDescription_template(template_sel other_value);
NodeTypeDescription_template(const NodeTypeDescription& other_value);
NodeTypeDescription_template(const OPTIONAL<NodeTypeDescription>& other_value);
NodeTypeDescription_template(const NodeTypeDescription_template& other_value);
~NodeTypeDescription_template();
NodeTypeDescription_template& operator=(template_sel other_value);
NodeTypeDescription_template& operator=(const NodeTypeDescription& other_value);
NodeTypeDescription_template& operator=(const OPTIONAL<NodeTypeDescription>& other_value);
NodeTypeDescription_template& operator=(const NodeTypeDescription_template& other_value);
boolean match(const NodeTypeDescription& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
NodeTypeDescription valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NodeTypeDescription_template& list_item(unsigned int list_index) const;
ExpandedNodeId_template& typeDefinitionNode();
const ExpandedNodeId_template& typeDefinitionNode() const;
INTEGER_template& includeSubtypes();
const INTEGER_template& includeSubtypes() const;
ListOfQueryDataDescription_template& dataToReturn();
const ListOfQueryDataDescription_template& dataToReturn() const;
int size_of() const;
void log() const;
void log_match(const NodeTypeDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ParsingResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
ParsingResult **value_elements;
} *val_ptr;

static const ParsingResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const ParsingResultArray& other_value);

public:
  typedef ParsingResult of_type;
ParsingResultArray();
ParsingResultArray(null_type other_value);
ParsingResultArray(const ParsingResultArray& other_value);
~ParsingResultArray();

void clean_up();
ParsingResultArray& operator=(null_type other_value);
ParsingResultArray& operator=(const ParsingResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const ParsingResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const ParsingResultArray& other_value) const { return !(*this == other_value); }

ParsingResult& operator[](int index_value);
ParsingResult& operator[](const INTEGER& index_value);
const ParsingResult& operator[](int index_value) const;
const ParsingResult& operator[](const INTEGER& index_value) const;

ParsingResultArray operator<<=(int rotate_count) const;
ParsingResultArray operator<<=(const INTEGER& rotate_count) const;
ParsingResultArray operator>>=(int rotate_count) const;
ParsingResultArray operator>>=(const INTEGER& rotate_count) const;

ParsingResultArray operator+(const ParsingResultArray& other_value) const;

ParsingResultArray substr(int index, int returncount) const;

ParsingResultArray replace(int index, int len, const ParsingResultArray& repl) const;

ParsingResultArray replace(int index, int len, const ParsingResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ParsingResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
ParsingResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
ParsingResultArray_template *list_value;
} value_list;
};
void copy_value(const ParsingResultArray& other_value);
void copy_template(const ParsingResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
ParsingResultArray_template();
ParsingResultArray_template(template_sel other_value);
ParsingResultArray_template(null_type other_value);
ParsingResultArray_template(const ParsingResultArray& other_value);
ParsingResultArray_template(const OPTIONAL<ParsingResultArray>& other_value);
ParsingResultArray_template(const ParsingResultArray_template& other_value);
~ParsingResultArray_template();

void clean_up();
ParsingResultArray_template& operator=(template_sel other_value);
ParsingResultArray_template& operator=(null_type other_value);
ParsingResultArray_template& operator=(const ParsingResultArray& other_value);
ParsingResultArray_template& operator=(const OPTIONAL<ParsingResultArray>& other_value);
ParsingResultArray_template& operator=(const ParsingResultArray_template& other_value);

ParsingResult_template& operator[](int index_value);
ParsingResult_template& operator[](const INTEGER& index_value);
const ParsingResult_template& operator[](int index_value) const;
const ParsingResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const ParsingResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
ParsingResultArray valueof() const;
ParsingResultArray substr(int index, int returncount) const;

ParsingResultArray replace(int index, int len, const ParsingResultArray_template& repl) const;

ParsingResultArray replace(int index, int len, const ParsingResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
ParsingResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const ParsingResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ParsingResult : public Base_Type {
  INTEGER field_statusCode;
  ListOfStatusCode field_dataStatusCodes;
  ListOfDiagnosticInfo field_dataDiagnosticInfos;
public:
  ParsingResult();
  ParsingResult(const INTEGER& par_statusCode,
    const ListOfStatusCode& par_dataStatusCodes,
    const ListOfDiagnosticInfo& par_dataDiagnosticInfos);
  ParsingResult(const ParsingResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ParsingResult& operator=(const ParsingResult& other_value);
  boolean operator==(const ParsingResult& other_value) const;
  inline boolean operator!=(const ParsingResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline ListOfStatusCode& dataStatusCodes()
    {return field_dataStatusCodes;}
  inline const ListOfStatusCode& dataStatusCodes() const
    {return field_dataStatusCodes;}
  inline ListOfDiagnosticInfo& dataDiagnosticInfos()
    {return field_dataDiagnosticInfos;}
  inline const ListOfDiagnosticInfo& dataDiagnosticInfos() const
    {return field_dataDiagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ParsingResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ParsingResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ParsingResult& other_value);
void copy_template(const ParsingResult_template& other_value);

public:
ParsingResult_template();
ParsingResult_template(template_sel other_value);
ParsingResult_template(const ParsingResult& other_value);
ParsingResult_template(const OPTIONAL<ParsingResult>& other_value);
ParsingResult_template(const ParsingResult_template& other_value);
~ParsingResult_template();
ParsingResult_template& operator=(template_sel other_value);
ParsingResult_template& operator=(const ParsingResult& other_value);
ParsingResult_template& operator=(const OPTIONAL<ParsingResult>& other_value);
ParsingResult_template& operator=(const ParsingResult_template& other_value);
boolean match(const ParsingResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ParsingResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ParsingResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
ListOfStatusCode_template& dataStatusCodes();
const ListOfStatusCode_template& dataStatusCodes() const;
ListOfDiagnosticInfo_template& dataDiagnosticInfos();
const ListOfDiagnosticInfo_template& dataDiagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const ParsingResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HistoryReadValueIdArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
HistoryReadValueId **value_elements;
} *val_ptr;

static const HistoryReadValueId UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const HistoryReadValueIdArray& other_value);

public:
  typedef HistoryReadValueId of_type;
HistoryReadValueIdArray();
HistoryReadValueIdArray(null_type other_value);
HistoryReadValueIdArray(const HistoryReadValueIdArray& other_value);
~HistoryReadValueIdArray();

void clean_up();
HistoryReadValueIdArray& operator=(null_type other_value);
HistoryReadValueIdArray& operator=(const HistoryReadValueIdArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const HistoryReadValueIdArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HistoryReadValueIdArray& other_value) const { return !(*this == other_value); }

HistoryReadValueId& operator[](int index_value);
HistoryReadValueId& operator[](const INTEGER& index_value);
const HistoryReadValueId& operator[](int index_value) const;
const HistoryReadValueId& operator[](const INTEGER& index_value) const;

HistoryReadValueIdArray operator<<=(int rotate_count) const;
HistoryReadValueIdArray operator<<=(const INTEGER& rotate_count) const;
HistoryReadValueIdArray operator>>=(int rotate_count) const;
HistoryReadValueIdArray operator>>=(const INTEGER& rotate_count) const;

HistoryReadValueIdArray operator+(const HistoryReadValueIdArray& other_value) const;

HistoryReadValueIdArray substr(int index, int returncount) const;

HistoryReadValueIdArray replace(int index, int len, const HistoryReadValueIdArray& repl) const;

HistoryReadValueIdArray replace(int index, int len, const HistoryReadValueIdArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryReadValueIdArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
HistoryReadValueId_template **value_elements;
} single_value;
struct {
unsigned int n_values;
HistoryReadValueIdArray_template *list_value;
} value_list;
};
void copy_value(const HistoryReadValueIdArray& other_value);
void copy_template(const HistoryReadValueIdArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
HistoryReadValueIdArray_template();
HistoryReadValueIdArray_template(template_sel other_value);
HistoryReadValueIdArray_template(null_type other_value);
HistoryReadValueIdArray_template(const HistoryReadValueIdArray& other_value);
HistoryReadValueIdArray_template(const OPTIONAL<HistoryReadValueIdArray>& other_value);
HistoryReadValueIdArray_template(const HistoryReadValueIdArray_template& other_value);
~HistoryReadValueIdArray_template();

void clean_up();
HistoryReadValueIdArray_template& operator=(template_sel other_value);
HistoryReadValueIdArray_template& operator=(null_type other_value);
HistoryReadValueIdArray_template& operator=(const HistoryReadValueIdArray& other_value);
HistoryReadValueIdArray_template& operator=(const OPTIONAL<HistoryReadValueIdArray>& other_value);
HistoryReadValueIdArray_template& operator=(const HistoryReadValueIdArray_template& other_value);

HistoryReadValueId_template& operator[](int index_value);
HistoryReadValueId_template& operator[](const INTEGER& index_value);
const HistoryReadValueId_template& operator[](int index_value) const;
const HistoryReadValueId_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const HistoryReadValueIdArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
HistoryReadValueIdArray valueof() const;
HistoryReadValueIdArray substr(int index, int returncount) const;

HistoryReadValueIdArray replace(int index, int len, const HistoryReadValueIdArray_template& repl) const;

HistoryReadValueIdArray replace(int index, int len, const HistoryReadValueIdArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
HistoryReadValueIdArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HistoryReadValueIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class HistoryReadValueId : public Base_Type {
  NodeId field_nodeId;
  String field_indexRange;
  QualifiedName field_dataEncoding;
  ByteString field_continuationPoint;
public:
  HistoryReadValueId();
  HistoryReadValueId(const NodeId& par_nodeId,
    const String& par_indexRange,
    const QualifiedName& par_dataEncoding,
    const ByteString& par_continuationPoint);
  HistoryReadValueId(const HistoryReadValueId& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HistoryReadValueId& operator=(const HistoryReadValueId& other_value);
  boolean operator==(const HistoryReadValueId& other_value) const;
  inline boolean operator!=(const HistoryReadValueId& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline String& indexRange()
    {return field_indexRange;}
  inline const String& indexRange() const
    {return field_indexRange;}
  inline QualifiedName& dataEncoding()
    {return field_dataEncoding;}
  inline const QualifiedName& dataEncoding() const
    {return field_dataEncoding;}
  inline ByteString& continuationPoint()
    {return field_continuationPoint;}
  inline const ByteString& continuationPoint() const
    {return field_continuationPoint;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryReadValueId_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HistoryReadValueId_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HistoryReadValueId& other_value);
void copy_template(const HistoryReadValueId_template& other_value);

public:
HistoryReadValueId_template();
HistoryReadValueId_template(template_sel other_value);
HistoryReadValueId_template(const HistoryReadValueId& other_value);
HistoryReadValueId_template(const OPTIONAL<HistoryReadValueId>& other_value);
HistoryReadValueId_template(const HistoryReadValueId_template& other_value);
~HistoryReadValueId_template();
HistoryReadValueId_template& operator=(template_sel other_value);
HistoryReadValueId_template& operator=(const HistoryReadValueId& other_value);
HistoryReadValueId_template& operator=(const OPTIONAL<HistoryReadValueId>& other_value);
HistoryReadValueId_template& operator=(const HistoryReadValueId_template& other_value);
boolean match(const HistoryReadValueId& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HistoryReadValueId valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HistoryReadValueId_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
String_template& indexRange();
const String_template& indexRange() const;
QualifiedName_template& dataEncoding();
const QualifiedName_template& dataEncoding() const;
ByteString_template& continuationPoint();
const ByteString_template& continuationPoint() const;
int size_of() const;
void log() const;
void log_match(const HistoryReadValueId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HistoryReadResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
HistoryReadResult **value_elements;
} *val_ptr;

static const HistoryReadResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const HistoryReadResultArray& other_value);

public:
  typedef HistoryReadResult of_type;
HistoryReadResultArray();
HistoryReadResultArray(null_type other_value);
HistoryReadResultArray(const HistoryReadResultArray& other_value);
~HistoryReadResultArray();

void clean_up();
HistoryReadResultArray& operator=(null_type other_value);
HistoryReadResultArray& operator=(const HistoryReadResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const HistoryReadResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HistoryReadResultArray& other_value) const { return !(*this == other_value); }

HistoryReadResult& operator[](int index_value);
HistoryReadResult& operator[](const INTEGER& index_value);
const HistoryReadResult& operator[](int index_value) const;
const HistoryReadResult& operator[](const INTEGER& index_value) const;

HistoryReadResultArray operator<<=(int rotate_count) const;
HistoryReadResultArray operator<<=(const INTEGER& rotate_count) const;
HistoryReadResultArray operator>>=(int rotate_count) const;
HistoryReadResultArray operator>>=(const INTEGER& rotate_count) const;

HistoryReadResultArray operator+(const HistoryReadResultArray& other_value) const;

HistoryReadResultArray substr(int index, int returncount) const;

HistoryReadResultArray replace(int index, int len, const HistoryReadResultArray& repl) const;

HistoryReadResultArray replace(int index, int len, const HistoryReadResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryReadResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
HistoryReadResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
HistoryReadResultArray_template *list_value;
} value_list;
};
void copy_value(const HistoryReadResultArray& other_value);
void copy_template(const HistoryReadResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
HistoryReadResultArray_template();
HistoryReadResultArray_template(template_sel other_value);
HistoryReadResultArray_template(null_type other_value);
HistoryReadResultArray_template(const HistoryReadResultArray& other_value);
HistoryReadResultArray_template(const OPTIONAL<HistoryReadResultArray>& other_value);
HistoryReadResultArray_template(const HistoryReadResultArray_template& other_value);
~HistoryReadResultArray_template();

void clean_up();
HistoryReadResultArray_template& operator=(template_sel other_value);
HistoryReadResultArray_template& operator=(null_type other_value);
HistoryReadResultArray_template& operator=(const HistoryReadResultArray& other_value);
HistoryReadResultArray_template& operator=(const OPTIONAL<HistoryReadResultArray>& other_value);
HistoryReadResultArray_template& operator=(const HistoryReadResultArray_template& other_value);

HistoryReadResult_template& operator[](int index_value);
HistoryReadResult_template& operator[](const INTEGER& index_value);
const HistoryReadResult_template& operator[](int index_value) const;
const HistoryReadResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const HistoryReadResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
HistoryReadResultArray valueof() const;
HistoryReadResultArray substr(int index, int returncount) const;

HistoryReadResultArray replace(int index, int len, const HistoryReadResultArray_template& repl) const;

HistoryReadResultArray replace(int index, int len, const HistoryReadResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
HistoryReadResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HistoryReadResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class HistoryReadResult : public Base_Type {
  INTEGER field_statusCode;
  ByteString field_continuationPoint;
  ExtensibleParameter field_historyData;
public:
  HistoryReadResult();
  HistoryReadResult(const INTEGER& par_statusCode,
    const ByteString& par_continuationPoint,
    const ExtensibleParameter& par_historyData);
  HistoryReadResult(const HistoryReadResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HistoryReadResult& operator=(const HistoryReadResult& other_value);
  boolean operator==(const HistoryReadResult& other_value) const;
  inline boolean operator!=(const HistoryReadResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline ByteString& continuationPoint()
    {return field_continuationPoint;}
  inline const ByteString& continuationPoint() const
    {return field_continuationPoint;}
  inline ExtensibleParameter& historyData()
    {return field_historyData;}
  inline const ExtensibleParameter& historyData() const
    {return field_historyData;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryReadResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HistoryReadResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HistoryReadResult& other_value);
void copy_template(const HistoryReadResult_template& other_value);

public:
HistoryReadResult_template();
HistoryReadResult_template(template_sel other_value);
HistoryReadResult_template(const HistoryReadResult& other_value);
HistoryReadResult_template(const OPTIONAL<HistoryReadResult>& other_value);
HistoryReadResult_template(const HistoryReadResult_template& other_value);
~HistoryReadResult_template();
HistoryReadResult_template& operator=(template_sel other_value);
HistoryReadResult_template& operator=(const HistoryReadResult& other_value);
HistoryReadResult_template& operator=(const OPTIONAL<HistoryReadResult>& other_value);
HistoryReadResult_template& operator=(const HistoryReadResult_template& other_value);
boolean match(const HistoryReadResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HistoryReadResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HistoryReadResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
ByteString_template& continuationPoint();
const ByteString_template& continuationPoint() const;
ExtensibleParameter_template& historyData();
const ExtensibleParameter_template& historyData() const;
int size_of() const;
void log() const;
void log_match(const HistoryReadResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class WriteValueArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
WriteValue **value_elements;
} *val_ptr;

static const WriteValue UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const WriteValueArray& other_value);

public:
  typedef WriteValue of_type;
WriteValueArray();
WriteValueArray(null_type other_value);
WriteValueArray(const WriteValueArray& other_value);
~WriteValueArray();

void clean_up();
WriteValueArray& operator=(null_type other_value);
WriteValueArray& operator=(const WriteValueArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const WriteValueArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const WriteValueArray& other_value) const { return !(*this == other_value); }

WriteValue& operator[](int index_value);
WriteValue& operator[](const INTEGER& index_value);
const WriteValue& operator[](int index_value) const;
const WriteValue& operator[](const INTEGER& index_value) const;

WriteValueArray operator<<=(int rotate_count) const;
WriteValueArray operator<<=(const INTEGER& rotate_count) const;
WriteValueArray operator>>=(int rotate_count) const;
WriteValueArray operator>>=(const INTEGER& rotate_count) const;

WriteValueArray operator+(const WriteValueArray& other_value) const;

WriteValueArray substr(int index, int returncount) const;

WriteValueArray replace(int index, int len, const WriteValueArray& repl) const;

WriteValueArray replace(int index, int len, const WriteValueArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class WriteValueArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
WriteValue_template **value_elements;
} single_value;
struct {
unsigned int n_values;
WriteValueArray_template *list_value;
} value_list;
};
void copy_value(const WriteValueArray& other_value);
void copy_template(const WriteValueArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
WriteValueArray_template();
WriteValueArray_template(template_sel other_value);
WriteValueArray_template(null_type other_value);
WriteValueArray_template(const WriteValueArray& other_value);
WriteValueArray_template(const OPTIONAL<WriteValueArray>& other_value);
WriteValueArray_template(const WriteValueArray_template& other_value);
~WriteValueArray_template();

void clean_up();
WriteValueArray_template& operator=(template_sel other_value);
WriteValueArray_template& operator=(null_type other_value);
WriteValueArray_template& operator=(const WriteValueArray& other_value);
WriteValueArray_template& operator=(const OPTIONAL<WriteValueArray>& other_value);
WriteValueArray_template& operator=(const WriteValueArray_template& other_value);

WriteValue_template& operator[](int index_value);
WriteValue_template& operator[](const INTEGER& index_value);
const WriteValue_template& operator[](int index_value) const;
const WriteValue_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const WriteValueArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
WriteValueArray valueof() const;
WriteValueArray substr(int index, int returncount) const;

WriteValueArray replace(int index, int len, const WriteValueArray_template& repl) const;

WriteValueArray replace(int index, int len, const WriteValueArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
WriteValueArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const WriteValueArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class WriteValue : public Base_Type {
  NodeId field_nodeId;
  INTEGER field_attributeId;
  String field_indexRange;
  DataValue field_datavalue;
public:
  WriteValue();
  WriteValue(const NodeId& par_nodeId,
    const INTEGER& par_attributeId,
    const String& par_indexRange,
    const DataValue& par_datavalue);
  WriteValue(const WriteValue& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  WriteValue& operator=(const WriteValue& other_value);
  boolean operator==(const WriteValue& other_value) const;
  inline boolean operator!=(const WriteValue& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& nodeId()
    {return field_nodeId;}
  inline const NodeId& nodeId() const
    {return field_nodeId;}
  inline INTEGER& attributeId()
    {return field_attributeId;}
  inline const INTEGER& attributeId() const
    {return field_attributeId;}
  inline String& indexRange()
    {return field_indexRange;}
  inline const String& indexRange() const
    {return field_indexRange;}
  inline DataValue& datavalue()
    {return field_datavalue;}
  inline const DataValue& datavalue() const
    {return field_datavalue;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class WriteValue_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
WriteValue_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const WriteValue& other_value);
void copy_template(const WriteValue_template& other_value);

public:
WriteValue_template();
WriteValue_template(template_sel other_value);
WriteValue_template(const WriteValue& other_value);
WriteValue_template(const OPTIONAL<WriteValue>& other_value);
WriteValue_template(const WriteValue_template& other_value);
~WriteValue_template();
WriteValue_template& operator=(template_sel other_value);
WriteValue_template& operator=(const WriteValue& other_value);
WriteValue_template& operator=(const OPTIONAL<WriteValue>& other_value);
WriteValue_template& operator=(const WriteValue_template& other_value);
boolean match(const WriteValue& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
WriteValue valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
WriteValue_template& list_item(unsigned int list_index) const;
NodeId_template& nodeId();
const NodeId_template& nodeId() const;
INTEGER_template& attributeId();
const INTEGER_template& attributeId() const;
String_template& indexRange();
const String_template& indexRange() const;
DataValue_template& datavalue();
const DataValue_template& datavalue() const;
int size_of() const;
void log() const;
void log_match(const WriteValue& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HistoryUpdateResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
HistoryUpdateResult **value_elements;
} *val_ptr;

static const HistoryUpdateResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const HistoryUpdateResultArray& other_value);

public:
  typedef HistoryUpdateResult of_type;
HistoryUpdateResultArray();
HistoryUpdateResultArray(null_type other_value);
HistoryUpdateResultArray(const HistoryUpdateResultArray& other_value);
~HistoryUpdateResultArray();

void clean_up();
HistoryUpdateResultArray& operator=(null_type other_value);
HistoryUpdateResultArray& operator=(const HistoryUpdateResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const HistoryUpdateResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const HistoryUpdateResultArray& other_value) const { return !(*this == other_value); }

HistoryUpdateResult& operator[](int index_value);
HistoryUpdateResult& operator[](const INTEGER& index_value);
const HistoryUpdateResult& operator[](int index_value) const;
const HistoryUpdateResult& operator[](const INTEGER& index_value) const;

HistoryUpdateResultArray operator<<=(int rotate_count) const;
HistoryUpdateResultArray operator<<=(const INTEGER& rotate_count) const;
HistoryUpdateResultArray operator>>=(int rotate_count) const;
HistoryUpdateResultArray operator>>=(const INTEGER& rotate_count) const;

HistoryUpdateResultArray operator+(const HistoryUpdateResultArray& other_value) const;

HistoryUpdateResultArray substr(int index, int returncount) const;

HistoryUpdateResultArray replace(int index, int len, const HistoryUpdateResultArray& repl) const;

HistoryUpdateResultArray replace(int index, int len, const HistoryUpdateResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryUpdateResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
HistoryUpdateResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
HistoryUpdateResultArray_template *list_value;
} value_list;
};
void copy_value(const HistoryUpdateResultArray& other_value);
void copy_template(const HistoryUpdateResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
HistoryUpdateResultArray_template();
HistoryUpdateResultArray_template(template_sel other_value);
HistoryUpdateResultArray_template(null_type other_value);
HistoryUpdateResultArray_template(const HistoryUpdateResultArray& other_value);
HistoryUpdateResultArray_template(const OPTIONAL<HistoryUpdateResultArray>& other_value);
HistoryUpdateResultArray_template(const HistoryUpdateResultArray_template& other_value);
~HistoryUpdateResultArray_template();

void clean_up();
HistoryUpdateResultArray_template& operator=(template_sel other_value);
HistoryUpdateResultArray_template& operator=(null_type other_value);
HistoryUpdateResultArray_template& operator=(const HistoryUpdateResultArray& other_value);
HistoryUpdateResultArray_template& operator=(const OPTIONAL<HistoryUpdateResultArray>& other_value);
HistoryUpdateResultArray_template& operator=(const HistoryUpdateResultArray_template& other_value);

HistoryUpdateResult_template& operator[](int index_value);
HistoryUpdateResult_template& operator[](const INTEGER& index_value);
const HistoryUpdateResult_template& operator[](int index_value) const;
const HistoryUpdateResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const HistoryUpdateResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
HistoryUpdateResultArray valueof() const;
HistoryUpdateResultArray substr(int index, int returncount) const;

HistoryUpdateResultArray replace(int index, int len, const HistoryUpdateResultArray_template& repl) const;

HistoryUpdateResultArray replace(int index, int len, const HistoryUpdateResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
HistoryUpdateResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const HistoryUpdateResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class HistoryUpdateResult : public Base_Type {
  INTEGER field_statusCode;
  ListOfStatusCode field_operationResults;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  HistoryUpdateResult();
  HistoryUpdateResult(const INTEGER& par_statusCode,
    const ListOfStatusCode& par_operationResults,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  HistoryUpdateResult(const HistoryUpdateResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HistoryUpdateResult& operator=(const HistoryUpdateResult& other_value);
  boolean operator==(const HistoryUpdateResult& other_value) const;
  inline boolean operator!=(const HistoryUpdateResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline ListOfStatusCode& operationResults()
    {return field_operationResults;}
  inline const ListOfStatusCode& operationResults() const
    {return field_operationResults;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryUpdateResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HistoryUpdateResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HistoryUpdateResult& other_value);
void copy_template(const HistoryUpdateResult_template& other_value);

public:
HistoryUpdateResult_template();
HistoryUpdateResult_template(template_sel other_value);
HistoryUpdateResult_template(const HistoryUpdateResult& other_value);
HistoryUpdateResult_template(const OPTIONAL<HistoryUpdateResult>& other_value);
HistoryUpdateResult_template(const HistoryUpdateResult_template& other_value);
~HistoryUpdateResult_template();
HistoryUpdateResult_template& operator=(template_sel other_value);
HistoryUpdateResult_template& operator=(const HistoryUpdateResult& other_value);
HistoryUpdateResult_template& operator=(const OPTIONAL<HistoryUpdateResult>& other_value);
HistoryUpdateResult_template& operator=(const HistoryUpdateResult_template& other_value);
boolean match(const HistoryUpdateResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HistoryUpdateResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HistoryUpdateResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
ListOfStatusCode_template& operationResults();
const ListOfStatusCode_template& operationResults() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const HistoryUpdateResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CallMethodRequestArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
CallMethodRequest **value_elements;
} *val_ptr;

static const CallMethodRequest UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const CallMethodRequestArray& other_value);

public:
  typedef CallMethodRequest of_type;
CallMethodRequestArray();
CallMethodRequestArray(null_type other_value);
CallMethodRequestArray(const CallMethodRequestArray& other_value);
~CallMethodRequestArray();

void clean_up();
CallMethodRequestArray& operator=(null_type other_value);
CallMethodRequestArray& operator=(const CallMethodRequestArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const CallMethodRequestArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const CallMethodRequestArray& other_value) const { return !(*this == other_value); }

CallMethodRequest& operator[](int index_value);
CallMethodRequest& operator[](const INTEGER& index_value);
const CallMethodRequest& operator[](int index_value) const;
const CallMethodRequest& operator[](const INTEGER& index_value) const;

CallMethodRequestArray operator<<=(int rotate_count) const;
CallMethodRequestArray operator<<=(const INTEGER& rotate_count) const;
CallMethodRequestArray operator>>=(int rotate_count) const;
CallMethodRequestArray operator>>=(const INTEGER& rotate_count) const;

CallMethodRequestArray operator+(const CallMethodRequestArray& other_value) const;

CallMethodRequestArray substr(int index, int returncount) const;

CallMethodRequestArray replace(int index, int len, const CallMethodRequestArray& repl) const;

CallMethodRequestArray replace(int index, int len, const CallMethodRequestArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CallMethodRequestArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
CallMethodRequest_template **value_elements;
} single_value;
struct {
unsigned int n_values;
CallMethodRequestArray_template *list_value;
} value_list;
};
void copy_value(const CallMethodRequestArray& other_value);
void copy_template(const CallMethodRequestArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
CallMethodRequestArray_template();
CallMethodRequestArray_template(template_sel other_value);
CallMethodRequestArray_template(null_type other_value);
CallMethodRequestArray_template(const CallMethodRequestArray& other_value);
CallMethodRequestArray_template(const OPTIONAL<CallMethodRequestArray>& other_value);
CallMethodRequestArray_template(const CallMethodRequestArray_template& other_value);
~CallMethodRequestArray_template();

void clean_up();
CallMethodRequestArray_template& operator=(template_sel other_value);
CallMethodRequestArray_template& operator=(null_type other_value);
CallMethodRequestArray_template& operator=(const CallMethodRequestArray& other_value);
CallMethodRequestArray_template& operator=(const OPTIONAL<CallMethodRequestArray>& other_value);
CallMethodRequestArray_template& operator=(const CallMethodRequestArray_template& other_value);

CallMethodRequest_template& operator[](int index_value);
CallMethodRequest_template& operator[](const INTEGER& index_value);
const CallMethodRequest_template& operator[](int index_value) const;
const CallMethodRequest_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const CallMethodRequestArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
CallMethodRequestArray valueof() const;
CallMethodRequestArray substr(int index, int returncount) const;

CallMethodRequestArray replace(int index, int len, const CallMethodRequestArray_template& repl) const;

CallMethodRequestArray replace(int index, int len, const CallMethodRequestArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
CallMethodRequestArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const CallMethodRequestArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class CallMethodRequest : public Base_Type {
  NodeId field_objectId;
  NodeId field_methodId;
  ListOfVariant field_inputArguments;
public:
  CallMethodRequest();
  CallMethodRequest(const NodeId& par_objectId,
    const NodeId& par_methodId,
    const ListOfVariant& par_inputArguments);
  CallMethodRequest(const CallMethodRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CallMethodRequest& operator=(const CallMethodRequest& other_value);
  boolean operator==(const CallMethodRequest& other_value) const;
  inline boolean operator!=(const CallMethodRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& objectId()
    {return field_objectId;}
  inline const NodeId& objectId() const
    {return field_objectId;}
  inline NodeId& methodId()
    {return field_methodId;}
  inline const NodeId& methodId() const
    {return field_methodId;}
  inline ListOfVariant& inputArguments()
    {return field_inputArguments;}
  inline const ListOfVariant& inputArguments() const
    {return field_inputArguments;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CallMethodRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CallMethodRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CallMethodRequest& other_value);
void copy_template(const CallMethodRequest_template& other_value);

public:
CallMethodRequest_template();
CallMethodRequest_template(template_sel other_value);
CallMethodRequest_template(const CallMethodRequest& other_value);
CallMethodRequest_template(const OPTIONAL<CallMethodRequest>& other_value);
CallMethodRequest_template(const CallMethodRequest_template& other_value);
~CallMethodRequest_template();
CallMethodRequest_template& operator=(template_sel other_value);
CallMethodRequest_template& operator=(const CallMethodRequest& other_value);
CallMethodRequest_template& operator=(const OPTIONAL<CallMethodRequest>& other_value);
CallMethodRequest_template& operator=(const CallMethodRequest_template& other_value);
boolean match(const CallMethodRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CallMethodRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CallMethodRequest_template& list_item(unsigned int list_index) const;
NodeId_template& objectId();
const NodeId_template& objectId() const;
NodeId_template& methodId();
const NodeId_template& methodId() const;
ListOfVariant_template& inputArguments();
const ListOfVariant_template& inputArguments() const;
int size_of() const;
void log() const;
void log_match(const CallMethodRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CallMethodResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
CallMethodResult **value_elements;
} *val_ptr;

static const CallMethodResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const CallMethodResultArray& other_value);

public:
  typedef CallMethodResult of_type;
CallMethodResultArray();
CallMethodResultArray(null_type other_value);
CallMethodResultArray(const CallMethodResultArray& other_value);
~CallMethodResultArray();

void clean_up();
CallMethodResultArray& operator=(null_type other_value);
CallMethodResultArray& operator=(const CallMethodResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const CallMethodResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const CallMethodResultArray& other_value) const { return !(*this == other_value); }

CallMethodResult& operator[](int index_value);
CallMethodResult& operator[](const INTEGER& index_value);
const CallMethodResult& operator[](int index_value) const;
const CallMethodResult& operator[](const INTEGER& index_value) const;

CallMethodResultArray operator<<=(int rotate_count) const;
CallMethodResultArray operator<<=(const INTEGER& rotate_count) const;
CallMethodResultArray operator>>=(int rotate_count) const;
CallMethodResultArray operator>>=(const INTEGER& rotate_count) const;

CallMethodResultArray operator+(const CallMethodResultArray& other_value) const;

CallMethodResultArray substr(int index, int returncount) const;

CallMethodResultArray replace(int index, int len, const CallMethodResultArray& repl) const;

CallMethodResultArray replace(int index, int len, const CallMethodResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CallMethodResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
CallMethodResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
CallMethodResultArray_template *list_value;
} value_list;
};
void copy_value(const CallMethodResultArray& other_value);
void copy_template(const CallMethodResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
CallMethodResultArray_template();
CallMethodResultArray_template(template_sel other_value);
CallMethodResultArray_template(null_type other_value);
CallMethodResultArray_template(const CallMethodResultArray& other_value);
CallMethodResultArray_template(const OPTIONAL<CallMethodResultArray>& other_value);
CallMethodResultArray_template(const CallMethodResultArray_template& other_value);
~CallMethodResultArray_template();

void clean_up();
CallMethodResultArray_template& operator=(template_sel other_value);
CallMethodResultArray_template& operator=(null_type other_value);
CallMethodResultArray_template& operator=(const CallMethodResultArray& other_value);
CallMethodResultArray_template& operator=(const OPTIONAL<CallMethodResultArray>& other_value);
CallMethodResultArray_template& operator=(const CallMethodResultArray_template& other_value);

CallMethodResult_template& operator[](int index_value);
CallMethodResult_template& operator[](const INTEGER& index_value);
const CallMethodResult_template& operator[](int index_value) const;
const CallMethodResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const CallMethodResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
CallMethodResultArray valueof() const;
CallMethodResultArray substr(int index, int returncount) const;

CallMethodResultArray replace(int index, int len, const CallMethodResultArray_template& repl) const;

CallMethodResultArray replace(int index, int len, const CallMethodResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
CallMethodResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const CallMethodResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class CallMethodResult : public Base_Type {
  INTEGER field_statusCode;
  ListOfStatusCode field_inputArgumentResults;
  ListOfDiagnosticInfo field_inputArgumentDiagnosticInfos;
  ListOfVariant field_outputArguments;
public:
  CallMethodResult();
  CallMethodResult(const INTEGER& par_statusCode,
    const ListOfStatusCode& par_inputArgumentResults,
    const ListOfDiagnosticInfo& par_inputArgumentDiagnosticInfos,
    const ListOfVariant& par_outputArguments);
  CallMethodResult(const CallMethodResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CallMethodResult& operator=(const CallMethodResult& other_value);
  boolean operator==(const CallMethodResult& other_value) const;
  inline boolean operator!=(const CallMethodResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline ListOfStatusCode& inputArgumentResults()
    {return field_inputArgumentResults;}
  inline const ListOfStatusCode& inputArgumentResults() const
    {return field_inputArgumentResults;}
  inline ListOfDiagnosticInfo& inputArgumentDiagnosticInfos()
    {return field_inputArgumentDiagnosticInfos;}
  inline const ListOfDiagnosticInfo& inputArgumentDiagnosticInfos() const
    {return field_inputArgumentDiagnosticInfos;}
  inline ListOfVariant& outputArguments()
    {return field_outputArguments;}
  inline const ListOfVariant& outputArguments() const
    {return field_outputArguments;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CallMethodResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CallMethodResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CallMethodResult& other_value);
void copy_template(const CallMethodResult_template& other_value);

public:
CallMethodResult_template();
CallMethodResult_template(template_sel other_value);
CallMethodResult_template(const CallMethodResult& other_value);
CallMethodResult_template(const OPTIONAL<CallMethodResult>& other_value);
CallMethodResult_template(const CallMethodResult_template& other_value);
~CallMethodResult_template();
CallMethodResult_template& operator=(template_sel other_value);
CallMethodResult_template& operator=(const CallMethodResult& other_value);
CallMethodResult_template& operator=(const OPTIONAL<CallMethodResult>& other_value);
CallMethodResult_template& operator=(const CallMethodResult_template& other_value);
boolean match(const CallMethodResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CallMethodResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CallMethodResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
ListOfStatusCode_template& inputArgumentResults();
const ListOfStatusCode_template& inputArgumentResults() const;
ListOfDiagnosticInfo_template& inputArgumentDiagnosticInfos();
const ListOfDiagnosticInfo_template& inputArgumentDiagnosticInfos() const;
ListOfVariant_template& outputArguments();
const ListOfVariant_template& outputArguments() const;
int size_of() const;
void log() const;
void log_match(const CallMethodResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MonitoredItemCreateRequestArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MonitoredItemCreateRequest **value_elements;
} *val_ptr;

static const MonitoredItemCreateRequest UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MonitoredItemCreateRequestArray& other_value);

public:
  typedef MonitoredItemCreateRequest of_type;
MonitoredItemCreateRequestArray();
MonitoredItemCreateRequestArray(null_type other_value);
MonitoredItemCreateRequestArray(const MonitoredItemCreateRequestArray& other_value);
~MonitoredItemCreateRequestArray();

void clean_up();
MonitoredItemCreateRequestArray& operator=(null_type other_value);
MonitoredItemCreateRequestArray& operator=(const MonitoredItemCreateRequestArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MonitoredItemCreateRequestArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MonitoredItemCreateRequestArray& other_value) const { return !(*this == other_value); }

MonitoredItemCreateRequest& operator[](int index_value);
MonitoredItemCreateRequest& operator[](const INTEGER& index_value);
const MonitoredItemCreateRequest& operator[](int index_value) const;
const MonitoredItemCreateRequest& operator[](const INTEGER& index_value) const;

MonitoredItemCreateRequestArray operator<<=(int rotate_count) const;
MonitoredItemCreateRequestArray operator<<=(const INTEGER& rotate_count) const;
MonitoredItemCreateRequestArray operator>>=(int rotate_count) const;
MonitoredItemCreateRequestArray operator>>=(const INTEGER& rotate_count) const;

MonitoredItemCreateRequestArray operator+(const MonitoredItemCreateRequestArray& other_value) const;

MonitoredItemCreateRequestArray substr(int index, int returncount) const;

MonitoredItemCreateRequestArray replace(int index, int len, const MonitoredItemCreateRequestArray& repl) const;

MonitoredItemCreateRequestArray replace(int index, int len, const MonitoredItemCreateRequestArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemCreateRequestArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
MonitoredItemCreateRequest_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MonitoredItemCreateRequestArray_template *list_value;
} value_list;
};
void copy_value(const MonitoredItemCreateRequestArray& other_value);
void copy_template(const MonitoredItemCreateRequestArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MonitoredItemCreateRequestArray_template();
MonitoredItemCreateRequestArray_template(template_sel other_value);
MonitoredItemCreateRequestArray_template(null_type other_value);
MonitoredItemCreateRequestArray_template(const MonitoredItemCreateRequestArray& other_value);
MonitoredItemCreateRequestArray_template(const OPTIONAL<MonitoredItemCreateRequestArray>& other_value);
MonitoredItemCreateRequestArray_template(const MonitoredItemCreateRequestArray_template& other_value);
~MonitoredItemCreateRequestArray_template();

void clean_up();
MonitoredItemCreateRequestArray_template& operator=(template_sel other_value);
MonitoredItemCreateRequestArray_template& operator=(null_type other_value);
MonitoredItemCreateRequestArray_template& operator=(const MonitoredItemCreateRequestArray& other_value);
MonitoredItemCreateRequestArray_template& operator=(const OPTIONAL<MonitoredItemCreateRequestArray>& other_value);
MonitoredItemCreateRequestArray_template& operator=(const MonitoredItemCreateRequestArray_template& other_value);

MonitoredItemCreateRequest_template& operator[](int index_value);
MonitoredItemCreateRequest_template& operator[](const INTEGER& index_value);
const MonitoredItemCreateRequest_template& operator[](int index_value) const;
const MonitoredItemCreateRequest_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MonitoredItemCreateRequestArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MonitoredItemCreateRequestArray valueof() const;
MonitoredItemCreateRequestArray substr(int index, int returncount) const;

MonitoredItemCreateRequestArray replace(int index, int len, const MonitoredItemCreateRequestArray_template& repl) const;

MonitoredItemCreateRequestArray replace(int index, int len, const MonitoredItemCreateRequestArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemCreateRequestArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MonitoredItemCreateRequestArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class MonitoredItemCreateRequest : public Base_Type {
  ReadValueId field_itemToMonitor;
  MonitoringMode field_monitoringMode;
  MonitoringParameters field_requestedParameters;
public:
  MonitoredItemCreateRequest();
  MonitoredItemCreateRequest(const ReadValueId& par_itemToMonitor,
    const MonitoringMode& par_monitoringMode,
    const MonitoringParameters& par_requestedParameters);
  MonitoredItemCreateRequest(const MonitoredItemCreateRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MonitoredItemCreateRequest& operator=(const MonitoredItemCreateRequest& other_value);
  boolean operator==(const MonitoredItemCreateRequest& other_value) const;
  inline boolean operator!=(const MonitoredItemCreateRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ReadValueId& itemToMonitor()
    {return field_itemToMonitor;}
  inline const ReadValueId& itemToMonitor() const
    {return field_itemToMonitor;}
  inline MonitoringMode& monitoringMode()
    {return field_monitoringMode;}
  inline const MonitoringMode& monitoringMode() const
    {return field_monitoringMode;}
  inline MonitoringParameters& requestedParameters()
    {return field_requestedParameters;}
  inline const MonitoringParameters& requestedParameters() const
    {return field_requestedParameters;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemCreateRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MonitoredItemCreateRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MonitoredItemCreateRequest& other_value);
void copy_template(const MonitoredItemCreateRequest_template& other_value);

public:
MonitoredItemCreateRequest_template();
MonitoredItemCreateRequest_template(template_sel other_value);
MonitoredItemCreateRequest_template(const MonitoredItemCreateRequest& other_value);
MonitoredItemCreateRequest_template(const OPTIONAL<MonitoredItemCreateRequest>& other_value);
MonitoredItemCreateRequest_template(const MonitoredItemCreateRequest_template& other_value);
~MonitoredItemCreateRequest_template();
MonitoredItemCreateRequest_template& operator=(template_sel other_value);
MonitoredItemCreateRequest_template& operator=(const MonitoredItemCreateRequest& other_value);
MonitoredItemCreateRequest_template& operator=(const OPTIONAL<MonitoredItemCreateRequest>& other_value);
MonitoredItemCreateRequest_template& operator=(const MonitoredItemCreateRequest_template& other_value);
boolean match(const MonitoredItemCreateRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MonitoredItemCreateRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemCreateRequest_template& list_item(unsigned int list_index) const;
ReadValueId_template& itemToMonitor();
const ReadValueId_template& itemToMonitor() const;
MonitoringMode_template& monitoringMode();
const MonitoringMode_template& monitoringMode() const;
MonitoringParameters_template& requestedParameters();
const MonitoringParameters_template& requestedParameters() const;
int size_of() const;
void log() const;
void log_match(const MonitoredItemCreateRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MonitoredItemCreateResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MonitoredItemCreateResult **value_elements;
} *val_ptr;

static const MonitoredItemCreateResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MonitoredItemCreateResultArray& other_value);

public:
  typedef MonitoredItemCreateResult of_type;
MonitoredItemCreateResultArray();
MonitoredItemCreateResultArray(null_type other_value);
MonitoredItemCreateResultArray(const MonitoredItemCreateResultArray& other_value);
~MonitoredItemCreateResultArray();

void clean_up();
MonitoredItemCreateResultArray& operator=(null_type other_value);
MonitoredItemCreateResultArray& operator=(const MonitoredItemCreateResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MonitoredItemCreateResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MonitoredItemCreateResultArray& other_value) const { return !(*this == other_value); }

MonitoredItemCreateResult& operator[](int index_value);
MonitoredItemCreateResult& operator[](const INTEGER& index_value);
const MonitoredItemCreateResult& operator[](int index_value) const;
const MonitoredItemCreateResult& operator[](const INTEGER& index_value) const;

MonitoredItemCreateResultArray operator<<=(int rotate_count) const;
MonitoredItemCreateResultArray operator<<=(const INTEGER& rotate_count) const;
MonitoredItemCreateResultArray operator>>=(int rotate_count) const;
MonitoredItemCreateResultArray operator>>=(const INTEGER& rotate_count) const;

MonitoredItemCreateResultArray operator+(const MonitoredItemCreateResultArray& other_value) const;

MonitoredItemCreateResultArray substr(int index, int returncount) const;

MonitoredItemCreateResultArray replace(int index, int len, const MonitoredItemCreateResultArray& repl) const;

MonitoredItemCreateResultArray replace(int index, int len, const MonitoredItemCreateResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemCreateResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
MonitoredItemCreateResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MonitoredItemCreateResultArray_template *list_value;
} value_list;
};
void copy_value(const MonitoredItemCreateResultArray& other_value);
void copy_template(const MonitoredItemCreateResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MonitoredItemCreateResultArray_template();
MonitoredItemCreateResultArray_template(template_sel other_value);
MonitoredItemCreateResultArray_template(null_type other_value);
MonitoredItemCreateResultArray_template(const MonitoredItemCreateResultArray& other_value);
MonitoredItemCreateResultArray_template(const OPTIONAL<MonitoredItemCreateResultArray>& other_value);
MonitoredItemCreateResultArray_template(const MonitoredItemCreateResultArray_template& other_value);
~MonitoredItemCreateResultArray_template();

void clean_up();
MonitoredItemCreateResultArray_template& operator=(template_sel other_value);
MonitoredItemCreateResultArray_template& operator=(null_type other_value);
MonitoredItemCreateResultArray_template& operator=(const MonitoredItemCreateResultArray& other_value);
MonitoredItemCreateResultArray_template& operator=(const OPTIONAL<MonitoredItemCreateResultArray>& other_value);
MonitoredItemCreateResultArray_template& operator=(const MonitoredItemCreateResultArray_template& other_value);

MonitoredItemCreateResult_template& operator[](int index_value);
MonitoredItemCreateResult_template& operator[](const INTEGER& index_value);
const MonitoredItemCreateResult_template& operator[](int index_value) const;
const MonitoredItemCreateResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MonitoredItemCreateResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MonitoredItemCreateResultArray valueof() const;
MonitoredItemCreateResultArray substr(int index, int returncount) const;

MonitoredItemCreateResultArray replace(int index, int len, const MonitoredItemCreateResultArray_template& repl) const;

MonitoredItemCreateResultArray replace(int index, int len, const MonitoredItemCreateResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemCreateResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MonitoredItemCreateResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class MonitoredItemCreateResult : public Base_Type {
  INTEGER field_statusCode;
  INTEGER field_monitoredItemId;
  FLOAT field_revisedSamplingInterval;
  INTEGER field_revisedQueueSize;
  ExtensibleParameter field_filterResult;
public:
  MonitoredItemCreateResult();
  MonitoredItemCreateResult(const INTEGER& par_statusCode,
    const INTEGER& par_monitoredItemId,
    const FLOAT& par_revisedSamplingInterval,
    const INTEGER& par_revisedQueueSize,
    const ExtensibleParameter& par_filterResult);
  MonitoredItemCreateResult(const MonitoredItemCreateResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MonitoredItemCreateResult& operator=(const MonitoredItemCreateResult& other_value);
  boolean operator==(const MonitoredItemCreateResult& other_value) const;
  inline boolean operator!=(const MonitoredItemCreateResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline INTEGER& monitoredItemId()
    {return field_monitoredItemId;}
  inline const INTEGER& monitoredItemId() const
    {return field_monitoredItemId;}
  inline FLOAT& revisedSamplingInterval()
    {return field_revisedSamplingInterval;}
  inline const FLOAT& revisedSamplingInterval() const
    {return field_revisedSamplingInterval;}
  inline INTEGER& revisedQueueSize()
    {return field_revisedQueueSize;}
  inline const INTEGER& revisedQueueSize() const
    {return field_revisedQueueSize;}
  inline ExtensibleParameter& filterResult()
    {return field_filterResult;}
  inline const ExtensibleParameter& filterResult() const
    {return field_filterResult;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemCreateResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MonitoredItemCreateResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MonitoredItemCreateResult& other_value);
void copy_template(const MonitoredItemCreateResult_template& other_value);

public:
MonitoredItemCreateResult_template();
MonitoredItemCreateResult_template(template_sel other_value);
MonitoredItemCreateResult_template(const MonitoredItemCreateResult& other_value);
MonitoredItemCreateResult_template(const OPTIONAL<MonitoredItemCreateResult>& other_value);
MonitoredItemCreateResult_template(const MonitoredItemCreateResult_template& other_value);
~MonitoredItemCreateResult_template();
MonitoredItemCreateResult_template& operator=(template_sel other_value);
MonitoredItemCreateResult_template& operator=(const MonitoredItemCreateResult& other_value);
MonitoredItemCreateResult_template& operator=(const OPTIONAL<MonitoredItemCreateResult>& other_value);
MonitoredItemCreateResult_template& operator=(const MonitoredItemCreateResult_template& other_value);
boolean match(const MonitoredItemCreateResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MonitoredItemCreateResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemCreateResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
INTEGER_template& monitoredItemId();
const INTEGER_template& monitoredItemId() const;
FLOAT_template& revisedSamplingInterval();
const FLOAT_template& revisedSamplingInterval() const;
INTEGER_template& revisedQueueSize();
const INTEGER_template& revisedQueueSize() const;
ExtensibleParameter_template& filterResult();
const ExtensibleParameter_template& filterResult() const;
int size_of() const;
void log() const;
void log_match(const MonitoredItemCreateResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MonitoredItemModifyRequestArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MonitoredItemModifyRequest **value_elements;
} *val_ptr;

static const MonitoredItemModifyRequest UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MonitoredItemModifyRequestArray& other_value);

public:
  typedef MonitoredItemModifyRequest of_type;
MonitoredItemModifyRequestArray();
MonitoredItemModifyRequestArray(null_type other_value);
MonitoredItemModifyRequestArray(const MonitoredItemModifyRequestArray& other_value);
~MonitoredItemModifyRequestArray();

void clean_up();
MonitoredItemModifyRequestArray& operator=(null_type other_value);
MonitoredItemModifyRequestArray& operator=(const MonitoredItemModifyRequestArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MonitoredItemModifyRequestArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MonitoredItemModifyRequestArray& other_value) const { return !(*this == other_value); }

MonitoredItemModifyRequest& operator[](int index_value);
MonitoredItemModifyRequest& operator[](const INTEGER& index_value);
const MonitoredItemModifyRequest& operator[](int index_value) const;
const MonitoredItemModifyRequest& operator[](const INTEGER& index_value) const;

MonitoredItemModifyRequestArray operator<<=(int rotate_count) const;
MonitoredItemModifyRequestArray operator<<=(const INTEGER& rotate_count) const;
MonitoredItemModifyRequestArray operator>>=(int rotate_count) const;
MonitoredItemModifyRequestArray operator>>=(const INTEGER& rotate_count) const;

MonitoredItemModifyRequestArray operator+(const MonitoredItemModifyRequestArray& other_value) const;

MonitoredItemModifyRequestArray substr(int index, int returncount) const;

MonitoredItemModifyRequestArray replace(int index, int len, const MonitoredItemModifyRequestArray& repl) const;

MonitoredItemModifyRequestArray replace(int index, int len, const MonitoredItemModifyRequestArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemModifyRequestArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
MonitoredItemModifyRequest_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MonitoredItemModifyRequestArray_template *list_value;
} value_list;
};
void copy_value(const MonitoredItemModifyRequestArray& other_value);
void copy_template(const MonitoredItemModifyRequestArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MonitoredItemModifyRequestArray_template();
MonitoredItemModifyRequestArray_template(template_sel other_value);
MonitoredItemModifyRequestArray_template(null_type other_value);
MonitoredItemModifyRequestArray_template(const MonitoredItemModifyRequestArray& other_value);
MonitoredItemModifyRequestArray_template(const OPTIONAL<MonitoredItemModifyRequestArray>& other_value);
MonitoredItemModifyRequestArray_template(const MonitoredItemModifyRequestArray_template& other_value);
~MonitoredItemModifyRequestArray_template();

void clean_up();
MonitoredItemModifyRequestArray_template& operator=(template_sel other_value);
MonitoredItemModifyRequestArray_template& operator=(null_type other_value);
MonitoredItemModifyRequestArray_template& operator=(const MonitoredItemModifyRequestArray& other_value);
MonitoredItemModifyRequestArray_template& operator=(const OPTIONAL<MonitoredItemModifyRequestArray>& other_value);
MonitoredItemModifyRequestArray_template& operator=(const MonitoredItemModifyRequestArray_template& other_value);

MonitoredItemModifyRequest_template& operator[](int index_value);
MonitoredItemModifyRequest_template& operator[](const INTEGER& index_value);
const MonitoredItemModifyRequest_template& operator[](int index_value) const;
const MonitoredItemModifyRequest_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MonitoredItemModifyRequestArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MonitoredItemModifyRequestArray valueof() const;
MonitoredItemModifyRequestArray substr(int index, int returncount) const;

MonitoredItemModifyRequestArray replace(int index, int len, const MonitoredItemModifyRequestArray_template& repl) const;

MonitoredItemModifyRequestArray replace(int index, int len, const MonitoredItemModifyRequestArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemModifyRequestArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MonitoredItemModifyRequestArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class MonitoredItemModifyRequest : public Base_Type {
  INTEGER field_monitoredItemId;
  MonitoringParameters field_requestedParameters;
public:
  MonitoredItemModifyRequest();
  MonitoredItemModifyRequest(const INTEGER& par_monitoredItemId,
    const MonitoringParameters& par_requestedParameters);
  MonitoredItemModifyRequest(const MonitoredItemModifyRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MonitoredItemModifyRequest& operator=(const MonitoredItemModifyRequest& other_value);
  boolean operator==(const MonitoredItemModifyRequest& other_value) const;
  inline boolean operator!=(const MonitoredItemModifyRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& monitoredItemId()
    {return field_monitoredItemId;}
  inline const INTEGER& monitoredItemId() const
    {return field_monitoredItemId;}
  inline MonitoringParameters& requestedParameters()
    {return field_requestedParameters;}
  inline const MonitoringParameters& requestedParameters() const
    {return field_requestedParameters;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemModifyRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MonitoredItemModifyRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MonitoredItemModifyRequest& other_value);
void copy_template(const MonitoredItemModifyRequest_template& other_value);

public:
MonitoredItemModifyRequest_template();
MonitoredItemModifyRequest_template(template_sel other_value);
MonitoredItemModifyRequest_template(const MonitoredItemModifyRequest& other_value);
MonitoredItemModifyRequest_template(const OPTIONAL<MonitoredItemModifyRequest>& other_value);
MonitoredItemModifyRequest_template(const MonitoredItemModifyRequest_template& other_value);
~MonitoredItemModifyRequest_template();
MonitoredItemModifyRequest_template& operator=(template_sel other_value);
MonitoredItemModifyRequest_template& operator=(const MonitoredItemModifyRequest& other_value);
MonitoredItemModifyRequest_template& operator=(const OPTIONAL<MonitoredItemModifyRequest>& other_value);
MonitoredItemModifyRequest_template& operator=(const MonitoredItemModifyRequest_template& other_value);
boolean match(const MonitoredItemModifyRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MonitoredItemModifyRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemModifyRequest_template& list_item(unsigned int list_index) const;
INTEGER_template& monitoredItemId();
const INTEGER_template& monitoredItemId() const;
MonitoringParameters_template& requestedParameters();
const MonitoringParameters_template& requestedParameters() const;
int size_of() const;
void log() const;
void log_match(const MonitoredItemModifyRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MonitoredItemModifyResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
MonitoredItemModifyResult **value_elements;
} *val_ptr;

static const MonitoredItemModifyResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const MonitoredItemModifyResultArray& other_value);

public:
  typedef MonitoredItemModifyResult of_type;
MonitoredItemModifyResultArray();
MonitoredItemModifyResultArray(null_type other_value);
MonitoredItemModifyResultArray(const MonitoredItemModifyResultArray& other_value);
~MonitoredItemModifyResultArray();

void clean_up();
MonitoredItemModifyResultArray& operator=(null_type other_value);
MonitoredItemModifyResultArray& operator=(const MonitoredItemModifyResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const MonitoredItemModifyResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const MonitoredItemModifyResultArray& other_value) const { return !(*this == other_value); }

MonitoredItemModifyResult& operator[](int index_value);
MonitoredItemModifyResult& operator[](const INTEGER& index_value);
const MonitoredItemModifyResult& operator[](int index_value) const;
const MonitoredItemModifyResult& operator[](const INTEGER& index_value) const;

MonitoredItemModifyResultArray operator<<=(int rotate_count) const;
MonitoredItemModifyResultArray operator<<=(const INTEGER& rotate_count) const;
MonitoredItemModifyResultArray operator>>=(int rotate_count) const;
MonitoredItemModifyResultArray operator>>=(const INTEGER& rotate_count) const;

MonitoredItemModifyResultArray operator+(const MonitoredItemModifyResultArray& other_value) const;

MonitoredItemModifyResultArray substr(int index, int returncount) const;

MonitoredItemModifyResultArray replace(int index, int len, const MonitoredItemModifyResultArray& repl) const;

MonitoredItemModifyResultArray replace(int index, int len, const MonitoredItemModifyResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemModifyResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
MonitoredItemModifyResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
MonitoredItemModifyResultArray_template *list_value;
} value_list;
};
void copy_value(const MonitoredItemModifyResultArray& other_value);
void copy_template(const MonitoredItemModifyResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
MonitoredItemModifyResultArray_template();
MonitoredItemModifyResultArray_template(template_sel other_value);
MonitoredItemModifyResultArray_template(null_type other_value);
MonitoredItemModifyResultArray_template(const MonitoredItemModifyResultArray& other_value);
MonitoredItemModifyResultArray_template(const OPTIONAL<MonitoredItemModifyResultArray>& other_value);
MonitoredItemModifyResultArray_template(const MonitoredItemModifyResultArray_template& other_value);
~MonitoredItemModifyResultArray_template();

void clean_up();
MonitoredItemModifyResultArray_template& operator=(template_sel other_value);
MonitoredItemModifyResultArray_template& operator=(null_type other_value);
MonitoredItemModifyResultArray_template& operator=(const MonitoredItemModifyResultArray& other_value);
MonitoredItemModifyResultArray_template& operator=(const OPTIONAL<MonitoredItemModifyResultArray>& other_value);
MonitoredItemModifyResultArray_template& operator=(const MonitoredItemModifyResultArray_template& other_value);

MonitoredItemModifyResult_template& operator[](int index_value);
MonitoredItemModifyResult_template& operator[](const INTEGER& index_value);
const MonitoredItemModifyResult_template& operator[](int index_value) const;
const MonitoredItemModifyResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const MonitoredItemModifyResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
MonitoredItemModifyResultArray valueof() const;
MonitoredItemModifyResultArray substr(int index, int returncount) const;

MonitoredItemModifyResultArray replace(int index, int len, const MonitoredItemModifyResultArray_template& repl) const;

MonitoredItemModifyResultArray replace(int index, int len, const MonitoredItemModifyResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemModifyResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const MonitoredItemModifyResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class MonitoredItemModifyResult : public Base_Type {
  INTEGER field_statusCode;
  FLOAT field_revisedSamplingInterval;
  INTEGER field_revisedQueueSize;
  ExtensibleParameter field_filterResult;
public:
  MonitoredItemModifyResult();
  MonitoredItemModifyResult(const INTEGER& par_statusCode,
    const FLOAT& par_revisedSamplingInterval,
    const INTEGER& par_revisedQueueSize,
    const ExtensibleParameter& par_filterResult);
  MonitoredItemModifyResult(const MonitoredItemModifyResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MonitoredItemModifyResult& operator=(const MonitoredItemModifyResult& other_value);
  boolean operator==(const MonitoredItemModifyResult& other_value) const;
  inline boolean operator!=(const MonitoredItemModifyResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline FLOAT& revisedSamplingInterval()
    {return field_revisedSamplingInterval;}
  inline const FLOAT& revisedSamplingInterval() const
    {return field_revisedSamplingInterval;}
  inline INTEGER& revisedQueueSize()
    {return field_revisedQueueSize;}
  inline const INTEGER& revisedQueueSize() const
    {return field_revisedQueueSize;}
  inline ExtensibleParameter& filterResult()
    {return field_filterResult;}
  inline const ExtensibleParameter& filterResult() const
    {return field_filterResult;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MonitoredItemModifyResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MonitoredItemModifyResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MonitoredItemModifyResult& other_value);
void copy_template(const MonitoredItemModifyResult_template& other_value);

public:
MonitoredItemModifyResult_template();
MonitoredItemModifyResult_template(template_sel other_value);
MonitoredItemModifyResult_template(const MonitoredItemModifyResult& other_value);
MonitoredItemModifyResult_template(const OPTIONAL<MonitoredItemModifyResult>& other_value);
MonitoredItemModifyResult_template(const MonitoredItemModifyResult_template& other_value);
~MonitoredItemModifyResult_template();
MonitoredItemModifyResult_template& operator=(template_sel other_value);
MonitoredItemModifyResult_template& operator=(const MonitoredItemModifyResult& other_value);
MonitoredItemModifyResult_template& operator=(const OPTIONAL<MonitoredItemModifyResult>& other_value);
MonitoredItemModifyResult_template& operator=(const MonitoredItemModifyResult_template& other_value);
boolean match(const MonitoredItemModifyResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MonitoredItemModifyResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MonitoredItemModifyResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
FLOAT_template& revisedSamplingInterval();
const FLOAT_template& revisedSamplingInterval() const;
INTEGER_template& revisedQueueSize();
const INTEGER_template& revisedQueueSize() const;
ExtensibleParameter_template& filterResult();
const ExtensibleParameter_template& filterResult() const;
int size_of() const;
void log() const;
void log_match(const MonitoredItemModifyResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SubscriptionAcknowledgementArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
SubscriptionAcknowledgement **value_elements;
} *val_ptr;

static const SubscriptionAcknowledgement UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const SubscriptionAcknowledgementArray& other_value);

public:
  typedef SubscriptionAcknowledgement of_type;
SubscriptionAcknowledgementArray();
SubscriptionAcknowledgementArray(null_type other_value);
SubscriptionAcknowledgementArray(const SubscriptionAcknowledgementArray& other_value);
~SubscriptionAcknowledgementArray();

void clean_up();
SubscriptionAcknowledgementArray& operator=(null_type other_value);
SubscriptionAcknowledgementArray& operator=(const SubscriptionAcknowledgementArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const SubscriptionAcknowledgementArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const SubscriptionAcknowledgementArray& other_value) const { return !(*this == other_value); }

SubscriptionAcknowledgement& operator[](int index_value);
SubscriptionAcknowledgement& operator[](const INTEGER& index_value);
const SubscriptionAcknowledgement& operator[](int index_value) const;
const SubscriptionAcknowledgement& operator[](const INTEGER& index_value) const;

SubscriptionAcknowledgementArray operator<<=(int rotate_count) const;
SubscriptionAcknowledgementArray operator<<=(const INTEGER& rotate_count) const;
SubscriptionAcknowledgementArray operator>>=(int rotate_count) const;
SubscriptionAcknowledgementArray operator>>=(const INTEGER& rotate_count) const;

SubscriptionAcknowledgementArray operator+(const SubscriptionAcknowledgementArray& other_value) const;

SubscriptionAcknowledgementArray substr(int index, int returncount) const;

SubscriptionAcknowledgementArray replace(int index, int len, const SubscriptionAcknowledgementArray& repl) const;

SubscriptionAcknowledgementArray replace(int index, int len, const SubscriptionAcknowledgementArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SubscriptionAcknowledgementArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
SubscriptionAcknowledgement_template **value_elements;
} single_value;
struct {
unsigned int n_values;
SubscriptionAcknowledgementArray_template *list_value;
} value_list;
};
void copy_value(const SubscriptionAcknowledgementArray& other_value);
void copy_template(const SubscriptionAcknowledgementArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
SubscriptionAcknowledgementArray_template();
SubscriptionAcknowledgementArray_template(template_sel other_value);
SubscriptionAcknowledgementArray_template(null_type other_value);
SubscriptionAcknowledgementArray_template(const SubscriptionAcknowledgementArray& other_value);
SubscriptionAcknowledgementArray_template(const OPTIONAL<SubscriptionAcknowledgementArray>& other_value);
SubscriptionAcknowledgementArray_template(const SubscriptionAcknowledgementArray_template& other_value);
~SubscriptionAcknowledgementArray_template();

void clean_up();
SubscriptionAcknowledgementArray_template& operator=(template_sel other_value);
SubscriptionAcknowledgementArray_template& operator=(null_type other_value);
SubscriptionAcknowledgementArray_template& operator=(const SubscriptionAcknowledgementArray& other_value);
SubscriptionAcknowledgementArray_template& operator=(const OPTIONAL<SubscriptionAcknowledgementArray>& other_value);
SubscriptionAcknowledgementArray_template& operator=(const SubscriptionAcknowledgementArray_template& other_value);

SubscriptionAcknowledgement_template& operator[](int index_value);
SubscriptionAcknowledgement_template& operator[](const INTEGER& index_value);
const SubscriptionAcknowledgement_template& operator[](int index_value) const;
const SubscriptionAcknowledgement_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const SubscriptionAcknowledgementArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
SubscriptionAcknowledgementArray valueof() const;
SubscriptionAcknowledgementArray substr(int index, int returncount) const;

SubscriptionAcknowledgementArray replace(int index, int len, const SubscriptionAcknowledgementArray_template& repl) const;

SubscriptionAcknowledgementArray replace(int index, int len, const SubscriptionAcknowledgementArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
SubscriptionAcknowledgementArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const SubscriptionAcknowledgementArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class SubscriptionAcknowledgement : public Base_Type {
  INTEGER field_subscriptionId;
  INTEGER field_sequenceNumber;
public:
  SubscriptionAcknowledgement();
  SubscriptionAcknowledgement(const INTEGER& par_subscriptionId,
    const INTEGER& par_sequenceNumber);
  SubscriptionAcknowledgement(const SubscriptionAcknowledgement& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SubscriptionAcknowledgement& operator=(const SubscriptionAcknowledgement& other_value);
  boolean operator==(const SubscriptionAcknowledgement& other_value) const;
  inline boolean operator!=(const SubscriptionAcknowledgement& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline INTEGER& sequenceNumber()
    {return field_sequenceNumber;}
  inline const INTEGER& sequenceNumber() const
    {return field_sequenceNumber;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SubscriptionAcknowledgement_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SubscriptionAcknowledgement_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SubscriptionAcknowledgement& other_value);
void copy_template(const SubscriptionAcknowledgement_template& other_value);

public:
SubscriptionAcknowledgement_template();
SubscriptionAcknowledgement_template(template_sel other_value);
SubscriptionAcknowledgement_template(const SubscriptionAcknowledgement& other_value);
SubscriptionAcknowledgement_template(const OPTIONAL<SubscriptionAcknowledgement>& other_value);
SubscriptionAcknowledgement_template(const SubscriptionAcknowledgement_template& other_value);
~SubscriptionAcknowledgement_template();
SubscriptionAcknowledgement_template& operator=(template_sel other_value);
SubscriptionAcknowledgement_template& operator=(const SubscriptionAcknowledgement& other_value);
SubscriptionAcknowledgement_template& operator=(const OPTIONAL<SubscriptionAcknowledgement>& other_value);
SubscriptionAcknowledgement_template& operator=(const SubscriptionAcknowledgement_template& other_value);
boolean match(const SubscriptionAcknowledgement& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SubscriptionAcknowledgement valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SubscriptionAcknowledgement_template& list_item(unsigned int list_index) const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
INTEGER_template& sequenceNumber();
const INTEGER_template& sequenceNumber() const;
int size_of() const;
void log() const;
void log_match(const SubscriptionAcknowledgement& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TransferResultArray : public Base_Type {
struct recordof_setof_struct {
int ref_count;
int n_elements;
TransferResult **value_elements;
} *val_ptr;

static const TransferResult UNBOUND_ELEM;
private:
friend boolean operator==(null_type null_value, const TransferResultArray& other_value);

public:
  typedef TransferResult of_type;
TransferResultArray();
TransferResultArray(null_type other_value);
TransferResultArray(const TransferResultArray& other_value);
~TransferResultArray();

void clean_up();
TransferResultArray& operator=(null_type other_value);
TransferResultArray& operator=(const TransferResultArray& other_value);

boolean operator==(null_type other_value) const;
boolean operator==(const TransferResultArray& other_value) const;
inline boolean operator!=(null_type other_value) const { return !(*this == other_value); }
inline boolean operator!=(const TransferResultArray& other_value) const { return !(*this == other_value); }

TransferResult& operator[](int index_value);
TransferResult& operator[](const INTEGER& index_value);
const TransferResult& operator[](int index_value) const;
const TransferResult& operator[](const INTEGER& index_value) const;

TransferResultArray operator<<=(int rotate_count) const;
TransferResultArray operator<<=(const INTEGER& rotate_count) const;
TransferResultArray operator>>=(int rotate_count) const;
TransferResultArray operator>>=(const INTEGER& rotate_count) const;

TransferResultArray operator+(const TransferResultArray& other_value) const;

TransferResultArray substr(int index, int returncount) const;

TransferResultArray replace(int index, int len, const TransferResultArray& repl) const;

TransferResultArray replace(int index, int len, const TransferResultArray_template& repl) const;

void set_size(int new_size);
inline boolean is_bound() const {return val_ptr != NULL; }
inline boolean is_present() const { return is_bound(); }
boolean is_value() const;
int size_of() const;
int n_elem() const { return size_of(); }
int lengthof() const;
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TransferResultArray_template : public Record_Of_Template {
union {
struct {
int n_elements;
TransferResult_template **value_elements;
} single_value;
struct {
unsigned int n_values;
TransferResultArray_template *list_value;
} value_list;
};
void copy_value(const TransferResultArray& other_value);
void copy_template(const TransferResultArray_template& other_value);
static boolean match_function_specific(const Base_Type *value_ptr, int value_index, const Restricted_Length_Template *template_ptr, int template_index, boolean legacy);

public:
TransferResultArray_template();
TransferResultArray_template(template_sel other_value);
TransferResultArray_template(null_type other_value);
TransferResultArray_template(const TransferResultArray& other_value);
TransferResultArray_template(const OPTIONAL<TransferResultArray>& other_value);
TransferResultArray_template(const TransferResultArray_template& other_value);
~TransferResultArray_template();

void clean_up();
TransferResultArray_template& operator=(template_sel other_value);
TransferResultArray_template& operator=(null_type other_value);
TransferResultArray_template& operator=(const TransferResultArray& other_value);
TransferResultArray_template& operator=(const OPTIONAL<TransferResultArray>& other_value);
TransferResultArray_template& operator=(const TransferResultArray_template& other_value);

TransferResult_template& operator[](int index_value);
TransferResult_template& operator[](const INTEGER& index_value);
const TransferResult_template& operator[](int index_value) const;
const TransferResult_template& operator[](const INTEGER& index_value) const;

void set_size(int new_size);
int n_elem() const;
int size_of(boolean is_size) const;
inline int size_of() const { return size_of(TRUE); }
inline int lengthof() const { return size_of(FALSE); }
boolean match(const TransferResultArray& other_value, boolean legacy = FALSE) const;
inline boolean is_bound() const 
  {return template_selection != UNINITIALIZED_TEMPLATE; }
boolean is_value() const;
TransferResultArray valueof() const;
TransferResultArray substr(int index, int returncount) const;

TransferResultArray replace(int index, int len, const TransferResultArray_template& repl) const;

TransferResultArray replace(int index, int len, const TransferResultArray& repl) const;

void set_type(template_sel template_type, unsigned int list_length);
TransferResultArray_template& list_item(unsigned int list_index);
void log() const;
void log_match(const TransferResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean get_istemplate_kind(const char* type) const;
};

class ListOfCounter : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfCounterArray *field_realArray;
};
void copy_value(const ListOfCounter& other_value);

public:
ListOfCounter();
ListOfCounter(const ListOfCounter& other_value);
~ListOfCounter();
ListOfCounter& operator=(const ListOfCounter& other_value);
boolean operator==(const ListOfCounter& other_value) const;
inline boolean operator!=(const ListOfCounter& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfCounterArray& realArray();
const ListOfCounterArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfCounter_template : public Base_Template {
union {
struct {
ListOfCounter::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfCounterArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfCounter_template *list_value;
} value_list;
};
void copy_value(const ListOfCounter& other_value);

void copy_template(const ListOfCounter_template& other_value);

public:
ListOfCounter_template();
ListOfCounter_template(template_sel other_value);
ListOfCounter_template(const ListOfCounter& other_value);
ListOfCounter_template(const OPTIONAL<ListOfCounter>& other_value);
ListOfCounter_template(const ListOfCounter_template& other_value);
~ListOfCounter_template();
void clean_up();
ListOfCounter_template& operator=(template_sel other_value);
ListOfCounter_template& operator=(const ListOfCounter& other_value);
ListOfCounter_template& operator=(const OPTIONAL<ListOfCounter>& other_value);
ListOfCounter_template& operator=(const ListOfCounter_template& other_value);
boolean match(const ListOfCounter& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfCounter valueof() const;
ListOfCounter_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfCounterArray_template& realArray();
const ListOfCounterArray_template& realArray() const;
boolean ischosen(ListOfCounter::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfCounter& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfCounterArray : public Base_Type {
  INTEGER field_arrayLength;
  CounterArray field_arrayValues;
public:
  ListOfCounterArray();
  ListOfCounterArray(const INTEGER& par_arrayLength,
    const CounterArray& par_arrayValues);
  ListOfCounterArray(const ListOfCounterArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfCounterArray& operator=(const ListOfCounterArray& other_value);
  boolean operator==(const ListOfCounterArray& other_value) const;
  inline boolean operator!=(const ListOfCounterArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline CounterArray& arrayValues()
    {return field_arrayValues;}
  inline const CounterArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfCounterArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfCounterArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfCounterArray& other_value);
void copy_template(const ListOfCounterArray_template& other_value);

public:
ListOfCounterArray_template();
ListOfCounterArray_template(template_sel other_value);
ListOfCounterArray_template(const ListOfCounterArray& other_value);
ListOfCounterArray_template(const OPTIONAL<ListOfCounterArray>& other_value);
ListOfCounterArray_template(const ListOfCounterArray_template& other_value);
~ListOfCounterArray_template();
ListOfCounterArray_template& operator=(template_sel other_value);
ListOfCounterArray_template& operator=(const ListOfCounterArray& other_value);
ListOfCounterArray_template& operator=(const OPTIONAL<ListOfCounterArray>& other_value);
ListOfCounterArray_template& operator=(const ListOfCounterArray_template& other_value);
boolean match(const ListOfCounterArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfCounterArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfCounterArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
CounterArray_template& arrayValues();
const CounterArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfCounterArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TransferResult : public Base_Type {
  INTEGER field_statusCode;
  ListOfCounter field_availableSequenceNumbers;
public:
  TransferResult();
  TransferResult(const INTEGER& par_statusCode,
    const ListOfCounter& par_availableSequenceNumbers);
  TransferResult(const TransferResult& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TransferResult& operator=(const TransferResult& other_value);
  boolean operator==(const TransferResult& other_value) const;
  inline boolean operator!=(const TransferResult& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& statusCode()
    {return field_statusCode;}
  inline const INTEGER& statusCode() const
    {return field_statusCode;}
  inline ListOfCounter& availableSequenceNumbers()
    {return field_availableSequenceNumbers;}
  inline const ListOfCounter& availableSequenceNumbers() const
    {return field_availableSequenceNumbers;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TransferResult_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TransferResult_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TransferResult& other_value);
void copy_template(const TransferResult_template& other_value);

public:
TransferResult_template();
TransferResult_template(template_sel other_value);
TransferResult_template(const TransferResult& other_value);
TransferResult_template(const OPTIONAL<TransferResult>& other_value);
TransferResult_template(const TransferResult_template& other_value);
~TransferResult_template();
TransferResult_template& operator=(template_sel other_value);
TransferResult_template& operator=(const TransferResult& other_value);
TransferResult_template& operator=(const OPTIONAL<TransferResult>& other_value);
TransferResult_template& operator=(const TransferResult_template& other_value);
boolean match(const TransferResult& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TransferResult valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TransferResult_template& list_item(unsigned int list_index) const;
INTEGER_template& statusCode();
const INTEGER_template& statusCode() const;
ListOfCounter_template& availableSequenceNumbers();
const ListOfCounter_template& availableSequenceNumbers() const;
int size_of() const;
void log() const;
void log_match(const TransferResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfIntegerIdArray : public Base_Type {
  INTEGER field_arrayLength;
  IntegerIdArray field_arrayValues;
public:
  ListOfIntegerIdArray();
  ListOfIntegerIdArray(const INTEGER& par_arrayLength,
    const IntegerIdArray& par_arrayValues);
  ListOfIntegerIdArray(const ListOfIntegerIdArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfIntegerIdArray& operator=(const ListOfIntegerIdArray& other_value);
  boolean operator==(const ListOfIntegerIdArray& other_value) const;
  inline boolean operator!=(const ListOfIntegerIdArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline IntegerIdArray& arrayValues()
    {return field_arrayValues;}
  inline const IntegerIdArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfIntegerIdArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfIntegerIdArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfIntegerIdArray& other_value);
void copy_template(const ListOfIntegerIdArray_template& other_value);

public:
ListOfIntegerIdArray_template();
ListOfIntegerIdArray_template(template_sel other_value);
ListOfIntegerIdArray_template(const ListOfIntegerIdArray& other_value);
ListOfIntegerIdArray_template(const OPTIONAL<ListOfIntegerIdArray>& other_value);
ListOfIntegerIdArray_template(const ListOfIntegerIdArray_template& other_value);
~ListOfIntegerIdArray_template();
ListOfIntegerIdArray_template& operator=(template_sel other_value);
ListOfIntegerIdArray_template& operator=(const ListOfIntegerIdArray& other_value);
ListOfIntegerIdArray_template& operator=(const OPTIONAL<ListOfIntegerIdArray>& other_value);
ListOfIntegerIdArray_template& operator=(const ListOfIntegerIdArray_template& other_value);
boolean match(const ListOfIntegerIdArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfIntegerIdArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfIntegerIdArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
IntegerIdArray_template& arrayValues();
const IntegerIdArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfIntegerIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfLocaleIdArray : public Base_Type {
  INTEGER field_arrayLength;
  LocaleIdArray field_arrayValues;
public:
  ListOfLocaleIdArray();
  ListOfLocaleIdArray(const INTEGER& par_arrayLength,
    const LocaleIdArray& par_arrayValues);
  ListOfLocaleIdArray(const ListOfLocaleIdArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfLocaleIdArray& operator=(const ListOfLocaleIdArray& other_value);
  boolean operator==(const ListOfLocaleIdArray& other_value) const;
  inline boolean operator!=(const ListOfLocaleIdArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline LocaleIdArray& arrayValues()
    {return field_arrayValues;}
  inline const LocaleIdArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfLocaleIdArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfLocaleIdArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfLocaleIdArray& other_value);
void copy_template(const ListOfLocaleIdArray_template& other_value);

public:
ListOfLocaleIdArray_template();
ListOfLocaleIdArray_template(template_sel other_value);
ListOfLocaleIdArray_template(const ListOfLocaleIdArray& other_value);
ListOfLocaleIdArray_template(const OPTIONAL<ListOfLocaleIdArray>& other_value);
ListOfLocaleIdArray_template(const ListOfLocaleIdArray_template& other_value);
~ListOfLocaleIdArray_template();
ListOfLocaleIdArray_template& operator=(template_sel other_value);
ListOfLocaleIdArray_template& operator=(const ListOfLocaleIdArray& other_value);
ListOfLocaleIdArray_template& operator=(const OPTIONAL<ListOfLocaleIdArray>& other_value);
ListOfLocaleIdArray_template& operator=(const ListOfLocaleIdArray_template& other_value);
boolean match(const ListOfLocaleIdArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfLocaleIdArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfLocaleIdArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
LocaleIdArray_template& arrayValues();
const LocaleIdArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfLocaleIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfContinuationPointArray : public Base_Type {
  INTEGER field_arrayLength;
  ContinuationPointArray field_arrayValues;
public:
  ListOfContinuationPointArray();
  ListOfContinuationPointArray(const INTEGER& par_arrayLength,
    const ContinuationPointArray& par_arrayValues);
  ListOfContinuationPointArray(const ListOfContinuationPointArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfContinuationPointArray& operator=(const ListOfContinuationPointArray& other_value);
  boolean operator==(const ListOfContinuationPointArray& other_value) const;
  inline boolean operator!=(const ListOfContinuationPointArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ContinuationPointArray& arrayValues()
    {return field_arrayValues;}
  inline const ContinuationPointArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfContinuationPointArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfContinuationPointArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfContinuationPointArray& other_value);
void copy_template(const ListOfContinuationPointArray_template& other_value);

public:
ListOfContinuationPointArray_template();
ListOfContinuationPointArray_template(template_sel other_value);
ListOfContinuationPointArray_template(const ListOfContinuationPointArray& other_value);
ListOfContinuationPointArray_template(const OPTIONAL<ListOfContinuationPointArray>& other_value);
ListOfContinuationPointArray_template(const ListOfContinuationPointArray_template& other_value);
~ListOfContinuationPointArray_template();
ListOfContinuationPointArray_template& operator=(template_sel other_value);
ListOfContinuationPointArray_template& operator=(const ListOfContinuationPointArray& other_value);
ListOfContinuationPointArray_template& operator=(const OPTIONAL<ListOfContinuationPointArray>& other_value);
ListOfContinuationPointArray_template& operator=(const ListOfContinuationPointArray_template& other_value);
boolean match(const ListOfContinuationPointArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfContinuationPointArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfContinuationPointArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ContinuationPointArray_template& arrayValues();
const ContinuationPointArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfContinuationPointArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfDecimalArray : public Base_Type {
  INTEGER field_arrayLength;
  DecimalArray field_arrayValues;
public:
  ListOfDecimalArray();
  ListOfDecimalArray(const INTEGER& par_arrayLength,
    const DecimalArray& par_arrayValues);
  ListOfDecimalArray(const ListOfDecimalArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfDecimalArray& operator=(const ListOfDecimalArray& other_value);
  boolean operator==(const ListOfDecimalArray& other_value) const;
  inline boolean operator!=(const ListOfDecimalArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline DecimalArray& arrayValues()
    {return field_arrayValues;}
  inline const DecimalArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDecimalArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfDecimalArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfDecimalArray& other_value);
void copy_template(const ListOfDecimalArray_template& other_value);

public:
ListOfDecimalArray_template();
ListOfDecimalArray_template(template_sel other_value);
ListOfDecimalArray_template(const ListOfDecimalArray& other_value);
ListOfDecimalArray_template(const OPTIONAL<ListOfDecimalArray>& other_value);
ListOfDecimalArray_template(const ListOfDecimalArray_template& other_value);
~ListOfDecimalArray_template();
ListOfDecimalArray_template& operator=(template_sel other_value);
ListOfDecimalArray_template& operator=(const ListOfDecimalArray& other_value);
ListOfDecimalArray_template& operator=(const OPTIONAL<ListOfDecimalArray>& other_value);
ListOfDecimalArray_template& operator=(const ListOfDecimalArray_template& other_value);
boolean match(const ListOfDecimalArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfDecimalArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfDecimalArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
DecimalArray_template& arrayValues();
const DecimalArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfDecimalArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfEnumValueTypeArray : public Base_Type {
  INTEGER field_arrayLength;
  EnumValueTypeArray field_arrayValues;
public:
  ListOfEnumValueTypeArray();
  ListOfEnumValueTypeArray(const INTEGER& par_arrayLength,
    const EnumValueTypeArray& par_arrayValues);
  ListOfEnumValueTypeArray(const ListOfEnumValueTypeArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfEnumValueTypeArray& operator=(const ListOfEnumValueTypeArray& other_value);
  boolean operator==(const ListOfEnumValueTypeArray& other_value) const;
  inline boolean operator!=(const ListOfEnumValueTypeArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline EnumValueTypeArray& arrayValues()
    {return field_arrayValues;}
  inline const EnumValueTypeArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfEnumValueTypeArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfEnumValueTypeArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfEnumValueTypeArray& other_value);
void copy_template(const ListOfEnumValueTypeArray_template& other_value);

public:
ListOfEnumValueTypeArray_template();
ListOfEnumValueTypeArray_template(template_sel other_value);
ListOfEnumValueTypeArray_template(const ListOfEnumValueTypeArray& other_value);
ListOfEnumValueTypeArray_template(const OPTIONAL<ListOfEnumValueTypeArray>& other_value);
ListOfEnumValueTypeArray_template(const ListOfEnumValueTypeArray_template& other_value);
~ListOfEnumValueTypeArray_template();
ListOfEnumValueTypeArray_template& operator=(template_sel other_value);
ListOfEnumValueTypeArray_template& operator=(const ListOfEnumValueTypeArray& other_value);
ListOfEnumValueTypeArray_template& operator=(const OPTIONAL<ListOfEnumValueTypeArray>& other_value);
ListOfEnumValueTypeArray_template& operator=(const ListOfEnumValueTypeArray_template& other_value);
boolean match(const ListOfEnumValueTypeArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfEnumValueTypeArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfEnumValueTypeArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
EnumValueTypeArray_template& arrayValues();
const EnumValueTypeArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfEnumValueTypeArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfApplicationDescriptionArray : public Base_Type {
  INTEGER field_arrayLength;
  ApplicationDescriptionArray field_arrayValues;
public:
  ListOfApplicationDescriptionArray();
  ListOfApplicationDescriptionArray(const INTEGER& par_arrayLength,
    const ApplicationDescriptionArray& par_arrayValues);
  ListOfApplicationDescriptionArray(const ListOfApplicationDescriptionArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfApplicationDescriptionArray& operator=(const ListOfApplicationDescriptionArray& other_value);
  boolean operator==(const ListOfApplicationDescriptionArray& other_value) const;
  inline boolean operator!=(const ListOfApplicationDescriptionArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ApplicationDescriptionArray& arrayValues()
    {return field_arrayValues;}
  inline const ApplicationDescriptionArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfApplicationDescriptionArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfApplicationDescriptionArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfApplicationDescriptionArray& other_value);
void copy_template(const ListOfApplicationDescriptionArray_template& other_value);

public:
ListOfApplicationDescriptionArray_template();
ListOfApplicationDescriptionArray_template(template_sel other_value);
ListOfApplicationDescriptionArray_template(const ListOfApplicationDescriptionArray& other_value);
ListOfApplicationDescriptionArray_template(const OPTIONAL<ListOfApplicationDescriptionArray>& other_value);
ListOfApplicationDescriptionArray_template(const ListOfApplicationDescriptionArray_template& other_value);
~ListOfApplicationDescriptionArray_template();
ListOfApplicationDescriptionArray_template& operator=(template_sel other_value);
ListOfApplicationDescriptionArray_template& operator=(const ListOfApplicationDescriptionArray& other_value);
ListOfApplicationDescriptionArray_template& operator=(const OPTIONAL<ListOfApplicationDescriptionArray>& other_value);
ListOfApplicationDescriptionArray_template& operator=(const ListOfApplicationDescriptionArray_template& other_value);
boolean match(const ListOfApplicationDescriptionArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfApplicationDescriptionArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfApplicationDescriptionArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ApplicationDescriptionArray_template& arrayValues();
const ApplicationDescriptionArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfApplicationDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfBrowseResultArray : public Base_Type {
  INTEGER field_arrayLength;
  BrowseResultArray field_arrayValues;
public:
  ListOfBrowseResultArray();
  ListOfBrowseResultArray(const INTEGER& par_arrayLength,
    const BrowseResultArray& par_arrayValues);
  ListOfBrowseResultArray(const ListOfBrowseResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfBrowseResultArray& operator=(const ListOfBrowseResultArray& other_value);
  boolean operator==(const ListOfBrowseResultArray& other_value) const;
  inline boolean operator!=(const ListOfBrowseResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline BrowseResultArray& arrayValues()
    {return field_arrayValues;}
  inline const BrowseResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowseResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfBrowseResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfBrowseResultArray& other_value);
void copy_template(const ListOfBrowseResultArray_template& other_value);

public:
ListOfBrowseResultArray_template();
ListOfBrowseResultArray_template(template_sel other_value);
ListOfBrowseResultArray_template(const ListOfBrowseResultArray& other_value);
ListOfBrowseResultArray_template(const OPTIONAL<ListOfBrowseResultArray>& other_value);
ListOfBrowseResultArray_template(const ListOfBrowseResultArray_template& other_value);
~ListOfBrowseResultArray_template();
ListOfBrowseResultArray_template& operator=(template_sel other_value);
ListOfBrowseResultArray_template& operator=(const ListOfBrowseResultArray& other_value);
ListOfBrowseResultArray_template& operator=(const OPTIONAL<ListOfBrowseResultArray>& other_value);
ListOfBrowseResultArray_template& operator=(const ListOfBrowseResultArray_template& other_value);
boolean match(const ListOfBrowseResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfBrowseResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfBrowseResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
BrowseResultArray_template& arrayValues();
const BrowseResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfBrowseResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfEndpointDescriptionArray : public Base_Type {
  INTEGER field_arrayLength;
  EndpointDescriptionArray field_arrayValues;
public:
  ListOfEndpointDescriptionArray();
  ListOfEndpointDescriptionArray(const INTEGER& par_arrayLength,
    const EndpointDescriptionArray& par_arrayValues);
  ListOfEndpointDescriptionArray(const ListOfEndpointDescriptionArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfEndpointDescriptionArray& operator=(const ListOfEndpointDescriptionArray& other_value);
  boolean operator==(const ListOfEndpointDescriptionArray& other_value) const;
  inline boolean operator!=(const ListOfEndpointDescriptionArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline EndpointDescriptionArray& arrayValues()
    {return field_arrayValues;}
  inline const EndpointDescriptionArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfEndpointDescriptionArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfEndpointDescriptionArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfEndpointDescriptionArray& other_value);
void copy_template(const ListOfEndpointDescriptionArray_template& other_value);

public:
ListOfEndpointDescriptionArray_template();
ListOfEndpointDescriptionArray_template(template_sel other_value);
ListOfEndpointDescriptionArray_template(const ListOfEndpointDescriptionArray& other_value);
ListOfEndpointDescriptionArray_template(const OPTIONAL<ListOfEndpointDescriptionArray>& other_value);
ListOfEndpointDescriptionArray_template(const ListOfEndpointDescriptionArray_template& other_value);
~ListOfEndpointDescriptionArray_template();
ListOfEndpointDescriptionArray_template& operator=(template_sel other_value);
ListOfEndpointDescriptionArray_template& operator=(const ListOfEndpointDescriptionArray& other_value);
ListOfEndpointDescriptionArray_template& operator=(const OPTIONAL<ListOfEndpointDescriptionArray>& other_value);
ListOfEndpointDescriptionArray_template& operator=(const ListOfEndpointDescriptionArray_template& other_value);
boolean match(const ListOfEndpointDescriptionArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfEndpointDescriptionArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfEndpointDescriptionArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
EndpointDescriptionArray_template& arrayValues();
const EndpointDescriptionArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfEndpointDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfMonitoringParametersArray : public Base_Type {
  INTEGER field_arrayLength;
  MonitoringParametersArray field_arrayValues;
public:
  ListOfMonitoringParametersArray();
  ListOfMonitoringParametersArray(const INTEGER& par_arrayLength,
    const MonitoringParametersArray& par_arrayValues);
  ListOfMonitoringParametersArray(const ListOfMonitoringParametersArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfMonitoringParametersArray& operator=(const ListOfMonitoringParametersArray& other_value);
  boolean operator==(const ListOfMonitoringParametersArray& other_value) const;
  inline boolean operator!=(const ListOfMonitoringParametersArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline MonitoringParametersArray& arrayValues()
    {return field_arrayValues;}
  inline const MonitoringParametersArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoringParametersArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfMonitoringParametersArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfMonitoringParametersArray& other_value);
void copy_template(const ListOfMonitoringParametersArray_template& other_value);

public:
ListOfMonitoringParametersArray_template();
ListOfMonitoringParametersArray_template(template_sel other_value);
ListOfMonitoringParametersArray_template(const ListOfMonitoringParametersArray& other_value);
ListOfMonitoringParametersArray_template(const OPTIONAL<ListOfMonitoringParametersArray>& other_value);
ListOfMonitoringParametersArray_template(const ListOfMonitoringParametersArray_template& other_value);
~ListOfMonitoringParametersArray_template();
ListOfMonitoringParametersArray_template& operator=(template_sel other_value);
ListOfMonitoringParametersArray_template& operator=(const ListOfMonitoringParametersArray& other_value);
ListOfMonitoringParametersArray_template& operator=(const OPTIONAL<ListOfMonitoringParametersArray>& other_value);
ListOfMonitoringParametersArray_template& operator=(const ListOfMonitoringParametersArray_template& other_value);
boolean match(const ListOfMonitoringParametersArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfMonitoringParametersArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfMonitoringParametersArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
MonitoringParametersArray_template& arrayValues();
const MonitoringParametersArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfMonitoringParametersArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfQueryDataSetArray : public Base_Type {
  INTEGER field_arrayLength;
  QueryDataSetArray field_arrayValues;
public:
  ListOfQueryDataSetArray();
  ListOfQueryDataSetArray(const INTEGER& par_arrayLength,
    const QueryDataSetArray& par_arrayValues);
  ListOfQueryDataSetArray(const ListOfQueryDataSetArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfQueryDataSetArray& operator=(const ListOfQueryDataSetArray& other_value);
  boolean operator==(const ListOfQueryDataSetArray& other_value) const;
  inline boolean operator!=(const ListOfQueryDataSetArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline QueryDataSetArray& arrayValues()
    {return field_arrayValues;}
  inline const QueryDataSetArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfQueryDataSetArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfQueryDataSetArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfQueryDataSetArray& other_value);
void copy_template(const ListOfQueryDataSetArray_template& other_value);

public:
ListOfQueryDataSetArray_template();
ListOfQueryDataSetArray_template(template_sel other_value);
ListOfQueryDataSetArray_template(const ListOfQueryDataSetArray& other_value);
ListOfQueryDataSetArray_template(const OPTIONAL<ListOfQueryDataSetArray>& other_value);
ListOfQueryDataSetArray_template(const ListOfQueryDataSetArray_template& other_value);
~ListOfQueryDataSetArray_template();
ListOfQueryDataSetArray_template& operator=(template_sel other_value);
ListOfQueryDataSetArray_template& operator=(const ListOfQueryDataSetArray& other_value);
ListOfQueryDataSetArray_template& operator=(const OPTIONAL<ListOfQueryDataSetArray>& other_value);
ListOfQueryDataSetArray_template& operator=(const ListOfQueryDataSetArray_template& other_value);
boolean match(const ListOfQueryDataSetArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfQueryDataSetArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfQueryDataSetArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
QueryDataSetArray_template& arrayValues();
const QueryDataSetArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfQueryDataSetArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfReadValueIdArray : public Base_Type {
  INTEGER field_arrayLength;
  ReadValueIdArray field_arrayValues;
public:
  ListOfReadValueIdArray();
  ListOfReadValueIdArray(const INTEGER& par_arrayLength,
    const ReadValueIdArray& par_arrayValues);
  ListOfReadValueIdArray(const ListOfReadValueIdArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfReadValueIdArray& operator=(const ListOfReadValueIdArray& other_value);
  boolean operator==(const ListOfReadValueIdArray& other_value) const;
  inline boolean operator!=(const ListOfReadValueIdArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ReadValueIdArray& arrayValues()
    {return field_arrayValues;}
  inline const ReadValueIdArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfReadValueIdArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfReadValueIdArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfReadValueIdArray& other_value);
void copy_template(const ListOfReadValueIdArray_template& other_value);

public:
ListOfReadValueIdArray_template();
ListOfReadValueIdArray_template(template_sel other_value);
ListOfReadValueIdArray_template(const ListOfReadValueIdArray& other_value);
ListOfReadValueIdArray_template(const OPTIONAL<ListOfReadValueIdArray>& other_value);
ListOfReadValueIdArray_template(const ListOfReadValueIdArray_template& other_value);
~ListOfReadValueIdArray_template();
ListOfReadValueIdArray_template& operator=(template_sel other_value);
ListOfReadValueIdArray_template& operator=(const ListOfReadValueIdArray& other_value);
ListOfReadValueIdArray_template& operator=(const OPTIONAL<ListOfReadValueIdArray>& other_value);
ListOfReadValueIdArray_template& operator=(const ListOfReadValueIdArray_template& other_value);
boolean match(const ListOfReadValueIdArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfReadValueIdArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfReadValueIdArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ReadValueIdArray_template& arrayValues();
const ReadValueIdArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfReadValueIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfApplicationInstanceCertificateArray : public Base_Type {
  INTEGER field_arrayLength;
  ApplicationInstanceCertificateArray field_arrayValues;
public:
  ListOfApplicationInstanceCertificateArray();
  ListOfApplicationInstanceCertificateArray(const INTEGER& par_arrayLength,
    const ApplicationInstanceCertificateArray& par_arrayValues);
  ListOfApplicationInstanceCertificateArray(const ListOfApplicationInstanceCertificateArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfApplicationInstanceCertificateArray& operator=(const ListOfApplicationInstanceCertificateArray& other_value);
  boolean operator==(const ListOfApplicationInstanceCertificateArray& other_value) const;
  inline boolean operator!=(const ListOfApplicationInstanceCertificateArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ApplicationInstanceCertificateArray& arrayValues()
    {return field_arrayValues;}
  inline const ApplicationInstanceCertificateArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfApplicationInstanceCertificateArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfApplicationInstanceCertificateArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfApplicationInstanceCertificateArray& other_value);
void copy_template(const ListOfApplicationInstanceCertificateArray_template& other_value);

public:
ListOfApplicationInstanceCertificateArray_template();
ListOfApplicationInstanceCertificateArray_template(template_sel other_value);
ListOfApplicationInstanceCertificateArray_template(const ListOfApplicationInstanceCertificateArray& other_value);
ListOfApplicationInstanceCertificateArray_template(const OPTIONAL<ListOfApplicationInstanceCertificateArray>& other_value);
ListOfApplicationInstanceCertificateArray_template(const ListOfApplicationInstanceCertificateArray_template& other_value);
~ListOfApplicationInstanceCertificateArray_template();
ListOfApplicationInstanceCertificateArray_template& operator=(template_sel other_value);
ListOfApplicationInstanceCertificateArray_template& operator=(const ListOfApplicationInstanceCertificateArray& other_value);
ListOfApplicationInstanceCertificateArray_template& operator=(const OPTIONAL<ListOfApplicationInstanceCertificateArray>& other_value);
ListOfApplicationInstanceCertificateArray_template& operator=(const ListOfApplicationInstanceCertificateArray_template& other_value);
boolean match(const ListOfApplicationInstanceCertificateArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfApplicationInstanceCertificateArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfApplicationInstanceCertificateArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ApplicationInstanceCertificateArray_template& arrayValues();
const ApplicationInstanceCertificateArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfApplicationInstanceCertificateArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfChannelSecurityTokenArray : public Base_Type {
  INTEGER field_arrayLength;
  ChannelSecurityTokenArray field_arrayValues;
public:
  ListOfChannelSecurityTokenArray();
  ListOfChannelSecurityTokenArray(const INTEGER& par_arrayLength,
    const ChannelSecurityTokenArray& par_arrayValues);
  ListOfChannelSecurityTokenArray(const ListOfChannelSecurityTokenArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfChannelSecurityTokenArray& operator=(const ListOfChannelSecurityTokenArray& other_value);
  boolean operator==(const ListOfChannelSecurityTokenArray& other_value) const;
  inline boolean operator!=(const ListOfChannelSecurityTokenArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ChannelSecurityTokenArray& arrayValues()
    {return field_arrayValues;}
  inline const ChannelSecurityTokenArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfChannelSecurityTokenArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfChannelSecurityTokenArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfChannelSecurityTokenArray& other_value);
void copy_template(const ListOfChannelSecurityTokenArray_template& other_value);

public:
ListOfChannelSecurityTokenArray_template();
ListOfChannelSecurityTokenArray_template(template_sel other_value);
ListOfChannelSecurityTokenArray_template(const ListOfChannelSecurityTokenArray& other_value);
ListOfChannelSecurityTokenArray_template(const OPTIONAL<ListOfChannelSecurityTokenArray>& other_value);
ListOfChannelSecurityTokenArray_template(const ListOfChannelSecurityTokenArray_template& other_value);
~ListOfChannelSecurityTokenArray_template();
ListOfChannelSecurityTokenArray_template& operator=(template_sel other_value);
ListOfChannelSecurityTokenArray_template& operator=(const ListOfChannelSecurityTokenArray& other_value);
ListOfChannelSecurityTokenArray_template& operator=(const OPTIONAL<ListOfChannelSecurityTokenArray>& other_value);
ListOfChannelSecurityTokenArray_template& operator=(const ListOfChannelSecurityTokenArray_template& other_value);
boolean match(const ListOfChannelSecurityTokenArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfChannelSecurityTokenArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfChannelSecurityTokenArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ChannelSecurityTokenArray_template& arrayValues();
const ChannelSecurityTokenArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfChannelSecurityTokenArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfServerOnNetworkArray : public Base_Type {
  INTEGER field_arrayLength;
  ServerOnNetworkArray field_arrayValues;
public:
  ListOfServerOnNetworkArray();
  ListOfServerOnNetworkArray(const INTEGER& par_arrayLength,
    const ServerOnNetworkArray& par_arrayValues);
  ListOfServerOnNetworkArray(const ListOfServerOnNetworkArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfServerOnNetworkArray& operator=(const ListOfServerOnNetworkArray& other_value);
  boolean operator==(const ListOfServerOnNetworkArray& other_value) const;
  inline boolean operator!=(const ListOfServerOnNetworkArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ServerOnNetworkArray& arrayValues()
    {return field_arrayValues;}
  inline const ServerOnNetworkArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfServerOnNetworkArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfServerOnNetworkArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfServerOnNetworkArray& other_value);
void copy_template(const ListOfServerOnNetworkArray_template& other_value);

public:
ListOfServerOnNetworkArray_template();
ListOfServerOnNetworkArray_template(template_sel other_value);
ListOfServerOnNetworkArray_template(const ListOfServerOnNetworkArray& other_value);
ListOfServerOnNetworkArray_template(const OPTIONAL<ListOfServerOnNetworkArray>& other_value);
ListOfServerOnNetworkArray_template(const ListOfServerOnNetworkArray_template& other_value);
~ListOfServerOnNetworkArray_template();
ListOfServerOnNetworkArray_template& operator=(template_sel other_value);
ListOfServerOnNetworkArray_template& operator=(const ListOfServerOnNetworkArray& other_value);
ListOfServerOnNetworkArray_template& operator=(const OPTIONAL<ListOfServerOnNetworkArray>& other_value);
ListOfServerOnNetworkArray_template& operator=(const ListOfServerOnNetworkArray_template& other_value);
boolean match(const ListOfServerOnNetworkArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfServerOnNetworkArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfServerOnNetworkArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ServerOnNetworkArray_template& arrayValues();
const ServerOnNetworkArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfServerOnNetworkArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfAddNodesItemArray : public Base_Type {
  INTEGER field_arrayLength;
  AddNodesItemArray field_arrayValues;
public:
  ListOfAddNodesItemArray();
  ListOfAddNodesItemArray(const INTEGER& par_arrayLength,
    const AddNodesItemArray& par_arrayValues);
  ListOfAddNodesItemArray(const ListOfAddNodesItemArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfAddNodesItemArray& operator=(const ListOfAddNodesItemArray& other_value);
  boolean operator==(const ListOfAddNodesItemArray& other_value) const;
  inline boolean operator!=(const ListOfAddNodesItemArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline AddNodesItemArray& arrayValues()
    {return field_arrayValues;}
  inline const AddNodesItemArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfAddNodesItemArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfAddNodesItemArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfAddNodesItemArray& other_value);
void copy_template(const ListOfAddNodesItemArray_template& other_value);

public:
ListOfAddNodesItemArray_template();
ListOfAddNodesItemArray_template(template_sel other_value);
ListOfAddNodesItemArray_template(const ListOfAddNodesItemArray& other_value);
ListOfAddNodesItemArray_template(const OPTIONAL<ListOfAddNodesItemArray>& other_value);
ListOfAddNodesItemArray_template(const ListOfAddNodesItemArray_template& other_value);
~ListOfAddNodesItemArray_template();
ListOfAddNodesItemArray_template& operator=(template_sel other_value);
ListOfAddNodesItemArray_template& operator=(const ListOfAddNodesItemArray& other_value);
ListOfAddNodesItemArray_template& operator=(const OPTIONAL<ListOfAddNodesItemArray>& other_value);
ListOfAddNodesItemArray_template& operator=(const ListOfAddNodesItemArray_template& other_value);
boolean match(const ListOfAddNodesItemArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfAddNodesItemArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfAddNodesItemArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
AddNodesItemArray_template& arrayValues();
const AddNodesItemArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfAddNodesItemArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfAddNodesResultArray : public Base_Type {
  INTEGER field_arrayLength;
  AddNodesResultArray field_arrayValues;
public:
  ListOfAddNodesResultArray();
  ListOfAddNodesResultArray(const INTEGER& par_arrayLength,
    const AddNodesResultArray& par_arrayValues);
  ListOfAddNodesResultArray(const ListOfAddNodesResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfAddNodesResultArray& operator=(const ListOfAddNodesResultArray& other_value);
  boolean operator==(const ListOfAddNodesResultArray& other_value) const;
  inline boolean operator!=(const ListOfAddNodesResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline AddNodesResultArray& arrayValues()
    {return field_arrayValues;}
  inline const AddNodesResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfAddNodesResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfAddNodesResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfAddNodesResultArray& other_value);
void copy_template(const ListOfAddNodesResultArray_template& other_value);

public:
ListOfAddNodesResultArray_template();
ListOfAddNodesResultArray_template(template_sel other_value);
ListOfAddNodesResultArray_template(const ListOfAddNodesResultArray& other_value);
ListOfAddNodesResultArray_template(const OPTIONAL<ListOfAddNodesResultArray>& other_value);
ListOfAddNodesResultArray_template(const ListOfAddNodesResultArray_template& other_value);
~ListOfAddNodesResultArray_template();
ListOfAddNodesResultArray_template& operator=(template_sel other_value);
ListOfAddNodesResultArray_template& operator=(const ListOfAddNodesResultArray& other_value);
ListOfAddNodesResultArray_template& operator=(const OPTIONAL<ListOfAddNodesResultArray>& other_value);
ListOfAddNodesResultArray_template& operator=(const ListOfAddNodesResultArray_template& other_value);
boolean match(const ListOfAddNodesResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfAddNodesResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfAddNodesResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
AddNodesResultArray_template& arrayValues();
const AddNodesResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfAddNodesResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfAddReferencesItemArray : public Base_Type {
  INTEGER field_arrayLength;
  AddReferencesItemArray field_arrayValues;
public:
  ListOfAddReferencesItemArray();
  ListOfAddReferencesItemArray(const INTEGER& par_arrayLength,
    const AddReferencesItemArray& par_arrayValues);
  ListOfAddReferencesItemArray(const ListOfAddReferencesItemArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfAddReferencesItemArray& operator=(const ListOfAddReferencesItemArray& other_value);
  boolean operator==(const ListOfAddReferencesItemArray& other_value) const;
  inline boolean operator!=(const ListOfAddReferencesItemArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline AddReferencesItemArray& arrayValues()
    {return field_arrayValues;}
  inline const AddReferencesItemArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfAddReferencesItemArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfAddReferencesItemArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfAddReferencesItemArray& other_value);
void copy_template(const ListOfAddReferencesItemArray_template& other_value);

public:
ListOfAddReferencesItemArray_template();
ListOfAddReferencesItemArray_template(template_sel other_value);
ListOfAddReferencesItemArray_template(const ListOfAddReferencesItemArray& other_value);
ListOfAddReferencesItemArray_template(const OPTIONAL<ListOfAddReferencesItemArray>& other_value);
ListOfAddReferencesItemArray_template(const ListOfAddReferencesItemArray_template& other_value);
~ListOfAddReferencesItemArray_template();
ListOfAddReferencesItemArray_template& operator=(template_sel other_value);
ListOfAddReferencesItemArray_template& operator=(const ListOfAddReferencesItemArray& other_value);
ListOfAddReferencesItemArray_template& operator=(const OPTIONAL<ListOfAddReferencesItemArray>& other_value);
ListOfAddReferencesItemArray_template& operator=(const ListOfAddReferencesItemArray_template& other_value);
boolean match(const ListOfAddReferencesItemArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfAddReferencesItemArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfAddReferencesItemArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
AddReferencesItemArray_template& arrayValues();
const AddReferencesItemArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfAddReferencesItemArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfDeleteNodesItemArray : public Base_Type {
  INTEGER field_arrayLength;
  DeleteNodesItemArray field_arrayValues;
public:
  ListOfDeleteNodesItemArray();
  ListOfDeleteNodesItemArray(const INTEGER& par_arrayLength,
    const DeleteNodesItemArray& par_arrayValues);
  ListOfDeleteNodesItemArray(const ListOfDeleteNodesItemArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfDeleteNodesItemArray& operator=(const ListOfDeleteNodesItemArray& other_value);
  boolean operator==(const ListOfDeleteNodesItemArray& other_value) const;
  inline boolean operator!=(const ListOfDeleteNodesItemArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline DeleteNodesItemArray& arrayValues()
    {return field_arrayValues;}
  inline const DeleteNodesItemArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDeleteNodesItemArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfDeleteNodesItemArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfDeleteNodesItemArray& other_value);
void copy_template(const ListOfDeleteNodesItemArray_template& other_value);

public:
ListOfDeleteNodesItemArray_template();
ListOfDeleteNodesItemArray_template(template_sel other_value);
ListOfDeleteNodesItemArray_template(const ListOfDeleteNodesItemArray& other_value);
ListOfDeleteNodesItemArray_template(const OPTIONAL<ListOfDeleteNodesItemArray>& other_value);
ListOfDeleteNodesItemArray_template(const ListOfDeleteNodesItemArray_template& other_value);
~ListOfDeleteNodesItemArray_template();
ListOfDeleteNodesItemArray_template& operator=(template_sel other_value);
ListOfDeleteNodesItemArray_template& operator=(const ListOfDeleteNodesItemArray& other_value);
ListOfDeleteNodesItemArray_template& operator=(const OPTIONAL<ListOfDeleteNodesItemArray>& other_value);
ListOfDeleteNodesItemArray_template& operator=(const ListOfDeleteNodesItemArray_template& other_value);
boolean match(const ListOfDeleteNodesItemArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfDeleteNodesItemArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfDeleteNodesItemArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
DeleteNodesItemArray_template& arrayValues();
const DeleteNodesItemArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfDeleteNodesItemArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfDeleteReferencesItemArray : public Base_Type {
  INTEGER field_arrayLength;
  DeleteReferencesItemArray field_arrayValues;
public:
  ListOfDeleteReferencesItemArray();
  ListOfDeleteReferencesItemArray(const INTEGER& par_arrayLength,
    const DeleteReferencesItemArray& par_arrayValues);
  ListOfDeleteReferencesItemArray(const ListOfDeleteReferencesItemArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfDeleteReferencesItemArray& operator=(const ListOfDeleteReferencesItemArray& other_value);
  boolean operator==(const ListOfDeleteReferencesItemArray& other_value) const;
  inline boolean operator!=(const ListOfDeleteReferencesItemArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline DeleteReferencesItemArray& arrayValues()
    {return field_arrayValues;}
  inline const DeleteReferencesItemArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDeleteReferencesItemArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfDeleteReferencesItemArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfDeleteReferencesItemArray& other_value);
void copy_template(const ListOfDeleteReferencesItemArray_template& other_value);

public:
ListOfDeleteReferencesItemArray_template();
ListOfDeleteReferencesItemArray_template(template_sel other_value);
ListOfDeleteReferencesItemArray_template(const ListOfDeleteReferencesItemArray& other_value);
ListOfDeleteReferencesItemArray_template(const OPTIONAL<ListOfDeleteReferencesItemArray>& other_value);
ListOfDeleteReferencesItemArray_template(const ListOfDeleteReferencesItemArray_template& other_value);
~ListOfDeleteReferencesItemArray_template();
ListOfDeleteReferencesItemArray_template& operator=(template_sel other_value);
ListOfDeleteReferencesItemArray_template& operator=(const ListOfDeleteReferencesItemArray& other_value);
ListOfDeleteReferencesItemArray_template& operator=(const OPTIONAL<ListOfDeleteReferencesItemArray>& other_value);
ListOfDeleteReferencesItemArray_template& operator=(const ListOfDeleteReferencesItemArray_template& other_value);
boolean match(const ListOfDeleteReferencesItemArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfDeleteReferencesItemArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfDeleteReferencesItemArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
DeleteReferencesItemArray_template& arrayValues();
const DeleteReferencesItemArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfDeleteReferencesItemArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfSignedSoftwareCertificateArray : public Base_Type {
  INTEGER field_arrayLength;
  SignedSoftwareCertificateArray field_arrayValues;
public:
  ListOfSignedSoftwareCertificateArray();
  ListOfSignedSoftwareCertificateArray(const INTEGER& par_arrayLength,
    const SignedSoftwareCertificateArray& par_arrayValues);
  ListOfSignedSoftwareCertificateArray(const ListOfSignedSoftwareCertificateArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfSignedSoftwareCertificateArray& operator=(const ListOfSignedSoftwareCertificateArray& other_value);
  boolean operator==(const ListOfSignedSoftwareCertificateArray& other_value) const;
  inline boolean operator!=(const ListOfSignedSoftwareCertificateArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline SignedSoftwareCertificateArray& arrayValues()
    {return field_arrayValues;}
  inline const SignedSoftwareCertificateArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfSignedSoftwareCertificateArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfSignedSoftwareCertificateArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfSignedSoftwareCertificateArray& other_value);
void copy_template(const ListOfSignedSoftwareCertificateArray_template& other_value);

public:
ListOfSignedSoftwareCertificateArray_template();
ListOfSignedSoftwareCertificateArray_template(template_sel other_value);
ListOfSignedSoftwareCertificateArray_template(const ListOfSignedSoftwareCertificateArray& other_value);
ListOfSignedSoftwareCertificateArray_template(const OPTIONAL<ListOfSignedSoftwareCertificateArray>& other_value);
ListOfSignedSoftwareCertificateArray_template(const ListOfSignedSoftwareCertificateArray_template& other_value);
~ListOfSignedSoftwareCertificateArray_template();
ListOfSignedSoftwareCertificateArray_template& operator=(template_sel other_value);
ListOfSignedSoftwareCertificateArray_template& operator=(const ListOfSignedSoftwareCertificateArray& other_value);
ListOfSignedSoftwareCertificateArray_template& operator=(const OPTIONAL<ListOfSignedSoftwareCertificateArray>& other_value);
ListOfSignedSoftwareCertificateArray_template& operator=(const ListOfSignedSoftwareCertificateArray_template& other_value);
boolean match(const ListOfSignedSoftwareCertificateArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfSignedSoftwareCertificateArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfSignedSoftwareCertificateArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
SignedSoftwareCertificateArray_template& arrayValues();
const SignedSoftwareCertificateArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfSignedSoftwareCertificateArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfBrowseDescriptionArray : public Base_Type {
  INTEGER field_arrayLength;
  BrowseDescriptionArray field_arrayValues;
public:
  ListOfBrowseDescriptionArray();
  ListOfBrowseDescriptionArray(const INTEGER& par_arrayLength,
    const BrowseDescriptionArray& par_arrayValues);
  ListOfBrowseDescriptionArray(const ListOfBrowseDescriptionArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfBrowseDescriptionArray& operator=(const ListOfBrowseDescriptionArray& other_value);
  boolean operator==(const ListOfBrowseDescriptionArray& other_value) const;
  inline boolean operator!=(const ListOfBrowseDescriptionArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline BrowseDescriptionArray& arrayValues()
    {return field_arrayValues;}
  inline const BrowseDescriptionArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowseDescriptionArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfBrowseDescriptionArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfBrowseDescriptionArray& other_value);
void copy_template(const ListOfBrowseDescriptionArray_template& other_value);

public:
ListOfBrowseDescriptionArray_template();
ListOfBrowseDescriptionArray_template(template_sel other_value);
ListOfBrowseDescriptionArray_template(const ListOfBrowseDescriptionArray& other_value);
ListOfBrowseDescriptionArray_template(const OPTIONAL<ListOfBrowseDescriptionArray>& other_value);
ListOfBrowseDescriptionArray_template(const ListOfBrowseDescriptionArray_template& other_value);
~ListOfBrowseDescriptionArray_template();
ListOfBrowseDescriptionArray_template& operator=(template_sel other_value);
ListOfBrowseDescriptionArray_template& operator=(const ListOfBrowseDescriptionArray& other_value);
ListOfBrowseDescriptionArray_template& operator=(const OPTIONAL<ListOfBrowseDescriptionArray>& other_value);
ListOfBrowseDescriptionArray_template& operator=(const ListOfBrowseDescriptionArray_template& other_value);
boolean match(const ListOfBrowseDescriptionArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfBrowseDescriptionArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfBrowseDescriptionArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
BrowseDescriptionArray_template& arrayValues();
const BrowseDescriptionArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfBrowseDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfBrowsePathArray : public Base_Type {
  INTEGER field_arrayLength;
  BrowsePathArray field_arrayValues;
public:
  ListOfBrowsePathArray();
  ListOfBrowsePathArray(const INTEGER& par_arrayLength,
    const BrowsePathArray& par_arrayValues);
  ListOfBrowsePathArray(const ListOfBrowsePathArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfBrowsePathArray& operator=(const ListOfBrowsePathArray& other_value);
  boolean operator==(const ListOfBrowsePathArray& other_value) const;
  inline boolean operator!=(const ListOfBrowsePathArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline BrowsePathArray& arrayValues()
    {return field_arrayValues;}
  inline const BrowsePathArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowsePathArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfBrowsePathArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfBrowsePathArray& other_value);
void copy_template(const ListOfBrowsePathArray_template& other_value);

public:
ListOfBrowsePathArray_template();
ListOfBrowsePathArray_template(template_sel other_value);
ListOfBrowsePathArray_template(const ListOfBrowsePathArray& other_value);
ListOfBrowsePathArray_template(const OPTIONAL<ListOfBrowsePathArray>& other_value);
ListOfBrowsePathArray_template(const ListOfBrowsePathArray_template& other_value);
~ListOfBrowsePathArray_template();
ListOfBrowsePathArray_template& operator=(template_sel other_value);
ListOfBrowsePathArray_template& operator=(const ListOfBrowsePathArray& other_value);
ListOfBrowsePathArray_template& operator=(const OPTIONAL<ListOfBrowsePathArray>& other_value);
ListOfBrowsePathArray_template& operator=(const ListOfBrowsePathArray_template& other_value);
boolean match(const ListOfBrowsePathArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfBrowsePathArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfBrowsePathArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
BrowsePathArray_template& arrayValues();
const BrowsePathArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfBrowsePathArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfBrowsePathResultArray : public Base_Type {
  INTEGER field_arrayLength;
  BrowsePathResultArray field_arrayValues;
public:
  ListOfBrowsePathResultArray();
  ListOfBrowsePathResultArray(const INTEGER& par_arrayLength,
    const BrowsePathResultArray& par_arrayValues);
  ListOfBrowsePathResultArray(const ListOfBrowsePathResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfBrowsePathResultArray& operator=(const ListOfBrowsePathResultArray& other_value);
  boolean operator==(const ListOfBrowsePathResultArray& other_value) const;
  inline boolean operator!=(const ListOfBrowsePathResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline BrowsePathResultArray& arrayValues()
    {return field_arrayValues;}
  inline const BrowsePathResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowsePathResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfBrowsePathResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfBrowsePathResultArray& other_value);
void copy_template(const ListOfBrowsePathResultArray_template& other_value);

public:
ListOfBrowsePathResultArray_template();
ListOfBrowsePathResultArray_template(template_sel other_value);
ListOfBrowsePathResultArray_template(const ListOfBrowsePathResultArray& other_value);
ListOfBrowsePathResultArray_template(const OPTIONAL<ListOfBrowsePathResultArray>& other_value);
ListOfBrowsePathResultArray_template(const ListOfBrowsePathResultArray_template& other_value);
~ListOfBrowsePathResultArray_template();
ListOfBrowsePathResultArray_template& operator=(template_sel other_value);
ListOfBrowsePathResultArray_template& operator=(const ListOfBrowsePathResultArray& other_value);
ListOfBrowsePathResultArray_template& operator=(const OPTIONAL<ListOfBrowsePathResultArray>& other_value);
ListOfBrowsePathResultArray_template& operator=(const ListOfBrowsePathResultArray_template& other_value);
boolean match(const ListOfBrowsePathResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfBrowsePathResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfBrowsePathResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
BrowsePathResultArray_template& arrayValues();
const BrowsePathResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfBrowsePathResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfNodeTypeDescriptionArray : public Base_Type {
  INTEGER field_arrayLength;
  NodeTypeDescriptionArray field_arrayValues;
public:
  ListOfNodeTypeDescriptionArray();
  ListOfNodeTypeDescriptionArray(const INTEGER& par_arrayLength,
    const NodeTypeDescriptionArray& par_arrayValues);
  ListOfNodeTypeDescriptionArray(const ListOfNodeTypeDescriptionArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfNodeTypeDescriptionArray& operator=(const ListOfNodeTypeDescriptionArray& other_value);
  boolean operator==(const ListOfNodeTypeDescriptionArray& other_value) const;
  inline boolean operator!=(const ListOfNodeTypeDescriptionArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline NodeTypeDescriptionArray& arrayValues()
    {return field_arrayValues;}
  inline const NodeTypeDescriptionArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfNodeTypeDescriptionArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfNodeTypeDescriptionArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfNodeTypeDescriptionArray& other_value);
void copy_template(const ListOfNodeTypeDescriptionArray_template& other_value);

public:
ListOfNodeTypeDescriptionArray_template();
ListOfNodeTypeDescriptionArray_template(template_sel other_value);
ListOfNodeTypeDescriptionArray_template(const ListOfNodeTypeDescriptionArray& other_value);
ListOfNodeTypeDescriptionArray_template(const OPTIONAL<ListOfNodeTypeDescriptionArray>& other_value);
ListOfNodeTypeDescriptionArray_template(const ListOfNodeTypeDescriptionArray_template& other_value);
~ListOfNodeTypeDescriptionArray_template();
ListOfNodeTypeDescriptionArray_template& operator=(template_sel other_value);
ListOfNodeTypeDescriptionArray_template& operator=(const ListOfNodeTypeDescriptionArray& other_value);
ListOfNodeTypeDescriptionArray_template& operator=(const OPTIONAL<ListOfNodeTypeDescriptionArray>& other_value);
ListOfNodeTypeDescriptionArray_template& operator=(const ListOfNodeTypeDescriptionArray_template& other_value);
boolean match(const ListOfNodeTypeDescriptionArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfNodeTypeDescriptionArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfNodeTypeDescriptionArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
NodeTypeDescriptionArray_template& arrayValues();
const NodeTypeDescriptionArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfNodeTypeDescriptionArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfParsingResultArray : public Base_Type {
  INTEGER field_arrayLength;
  ParsingResultArray field_arrayValues;
public:
  ListOfParsingResultArray();
  ListOfParsingResultArray(const INTEGER& par_arrayLength,
    const ParsingResultArray& par_arrayValues);
  ListOfParsingResultArray(const ListOfParsingResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfParsingResultArray& operator=(const ListOfParsingResultArray& other_value);
  boolean operator==(const ListOfParsingResultArray& other_value) const;
  inline boolean operator!=(const ListOfParsingResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline ParsingResultArray& arrayValues()
    {return field_arrayValues;}
  inline const ParsingResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfParsingResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfParsingResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfParsingResultArray& other_value);
void copy_template(const ListOfParsingResultArray_template& other_value);

public:
ListOfParsingResultArray_template();
ListOfParsingResultArray_template(template_sel other_value);
ListOfParsingResultArray_template(const ListOfParsingResultArray& other_value);
ListOfParsingResultArray_template(const OPTIONAL<ListOfParsingResultArray>& other_value);
ListOfParsingResultArray_template(const ListOfParsingResultArray_template& other_value);
~ListOfParsingResultArray_template();
ListOfParsingResultArray_template& operator=(template_sel other_value);
ListOfParsingResultArray_template& operator=(const ListOfParsingResultArray& other_value);
ListOfParsingResultArray_template& operator=(const OPTIONAL<ListOfParsingResultArray>& other_value);
ListOfParsingResultArray_template& operator=(const ListOfParsingResultArray_template& other_value);
boolean match(const ListOfParsingResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfParsingResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfParsingResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
ParsingResultArray_template& arrayValues();
const ParsingResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfParsingResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfHistoryReadValueIdArray : public Base_Type {
  INTEGER field_arrayLength;
  HistoryReadValueIdArray field_arrayValues;
public:
  ListOfHistoryReadValueIdArray();
  ListOfHistoryReadValueIdArray(const INTEGER& par_arrayLength,
    const HistoryReadValueIdArray& par_arrayValues);
  ListOfHistoryReadValueIdArray(const ListOfHistoryReadValueIdArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfHistoryReadValueIdArray& operator=(const ListOfHistoryReadValueIdArray& other_value);
  boolean operator==(const ListOfHistoryReadValueIdArray& other_value) const;
  inline boolean operator!=(const ListOfHistoryReadValueIdArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline HistoryReadValueIdArray& arrayValues()
    {return field_arrayValues;}
  inline const HistoryReadValueIdArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfHistoryReadValueIdArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfHistoryReadValueIdArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfHistoryReadValueIdArray& other_value);
void copy_template(const ListOfHistoryReadValueIdArray_template& other_value);

public:
ListOfHistoryReadValueIdArray_template();
ListOfHistoryReadValueIdArray_template(template_sel other_value);
ListOfHistoryReadValueIdArray_template(const ListOfHistoryReadValueIdArray& other_value);
ListOfHistoryReadValueIdArray_template(const OPTIONAL<ListOfHistoryReadValueIdArray>& other_value);
ListOfHistoryReadValueIdArray_template(const ListOfHistoryReadValueIdArray_template& other_value);
~ListOfHistoryReadValueIdArray_template();
ListOfHistoryReadValueIdArray_template& operator=(template_sel other_value);
ListOfHistoryReadValueIdArray_template& operator=(const ListOfHistoryReadValueIdArray& other_value);
ListOfHistoryReadValueIdArray_template& operator=(const OPTIONAL<ListOfHistoryReadValueIdArray>& other_value);
ListOfHistoryReadValueIdArray_template& operator=(const ListOfHistoryReadValueIdArray_template& other_value);
boolean match(const ListOfHistoryReadValueIdArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfHistoryReadValueIdArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfHistoryReadValueIdArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
HistoryReadValueIdArray_template& arrayValues();
const HistoryReadValueIdArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfHistoryReadValueIdArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfHistoryReadResultArray : public Base_Type {
  INTEGER field_arrayLength;
  HistoryReadResultArray field_arrayValues;
public:
  ListOfHistoryReadResultArray();
  ListOfHistoryReadResultArray(const INTEGER& par_arrayLength,
    const HistoryReadResultArray& par_arrayValues);
  ListOfHistoryReadResultArray(const ListOfHistoryReadResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfHistoryReadResultArray& operator=(const ListOfHistoryReadResultArray& other_value);
  boolean operator==(const ListOfHistoryReadResultArray& other_value) const;
  inline boolean operator!=(const ListOfHistoryReadResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline HistoryReadResultArray& arrayValues()
    {return field_arrayValues;}
  inline const HistoryReadResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfHistoryReadResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfHistoryReadResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfHistoryReadResultArray& other_value);
void copy_template(const ListOfHistoryReadResultArray_template& other_value);

public:
ListOfHistoryReadResultArray_template();
ListOfHistoryReadResultArray_template(template_sel other_value);
ListOfHistoryReadResultArray_template(const ListOfHistoryReadResultArray& other_value);
ListOfHistoryReadResultArray_template(const OPTIONAL<ListOfHistoryReadResultArray>& other_value);
ListOfHistoryReadResultArray_template(const ListOfHistoryReadResultArray_template& other_value);
~ListOfHistoryReadResultArray_template();
ListOfHistoryReadResultArray_template& operator=(template_sel other_value);
ListOfHistoryReadResultArray_template& operator=(const ListOfHistoryReadResultArray& other_value);
ListOfHistoryReadResultArray_template& operator=(const OPTIONAL<ListOfHistoryReadResultArray>& other_value);
ListOfHistoryReadResultArray_template& operator=(const ListOfHistoryReadResultArray_template& other_value);
boolean match(const ListOfHistoryReadResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfHistoryReadResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfHistoryReadResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
HistoryReadResultArray_template& arrayValues();
const HistoryReadResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfHistoryReadResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfWriteValueArray : public Base_Type {
  INTEGER field_arrayLength;
  WriteValueArray field_arrayValues;
public:
  ListOfWriteValueArray();
  ListOfWriteValueArray(const INTEGER& par_arrayLength,
    const WriteValueArray& par_arrayValues);
  ListOfWriteValueArray(const ListOfWriteValueArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfWriteValueArray& operator=(const ListOfWriteValueArray& other_value);
  boolean operator==(const ListOfWriteValueArray& other_value) const;
  inline boolean operator!=(const ListOfWriteValueArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline WriteValueArray& arrayValues()
    {return field_arrayValues;}
  inline const WriteValueArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfWriteValueArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfWriteValueArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfWriteValueArray& other_value);
void copy_template(const ListOfWriteValueArray_template& other_value);

public:
ListOfWriteValueArray_template();
ListOfWriteValueArray_template(template_sel other_value);
ListOfWriteValueArray_template(const ListOfWriteValueArray& other_value);
ListOfWriteValueArray_template(const OPTIONAL<ListOfWriteValueArray>& other_value);
ListOfWriteValueArray_template(const ListOfWriteValueArray_template& other_value);
~ListOfWriteValueArray_template();
ListOfWriteValueArray_template& operator=(template_sel other_value);
ListOfWriteValueArray_template& operator=(const ListOfWriteValueArray& other_value);
ListOfWriteValueArray_template& operator=(const OPTIONAL<ListOfWriteValueArray>& other_value);
ListOfWriteValueArray_template& operator=(const ListOfWriteValueArray_template& other_value);
boolean match(const ListOfWriteValueArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfWriteValueArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfWriteValueArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
WriteValueArray_template& arrayValues();
const WriteValueArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfWriteValueArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfHistoryUpdateResultArray : public Base_Type {
  INTEGER field_arrayLength;
  HistoryUpdateResultArray field_arrayValues;
public:
  ListOfHistoryUpdateResultArray();
  ListOfHistoryUpdateResultArray(const INTEGER& par_arrayLength,
    const HistoryUpdateResultArray& par_arrayValues);
  ListOfHistoryUpdateResultArray(const ListOfHistoryUpdateResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfHistoryUpdateResultArray& operator=(const ListOfHistoryUpdateResultArray& other_value);
  boolean operator==(const ListOfHistoryUpdateResultArray& other_value) const;
  inline boolean operator!=(const ListOfHistoryUpdateResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline HistoryUpdateResultArray& arrayValues()
    {return field_arrayValues;}
  inline const HistoryUpdateResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfHistoryUpdateResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfHistoryUpdateResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfHistoryUpdateResultArray& other_value);
void copy_template(const ListOfHistoryUpdateResultArray_template& other_value);

public:
ListOfHistoryUpdateResultArray_template();
ListOfHistoryUpdateResultArray_template(template_sel other_value);
ListOfHistoryUpdateResultArray_template(const ListOfHistoryUpdateResultArray& other_value);
ListOfHistoryUpdateResultArray_template(const OPTIONAL<ListOfHistoryUpdateResultArray>& other_value);
ListOfHistoryUpdateResultArray_template(const ListOfHistoryUpdateResultArray_template& other_value);
~ListOfHistoryUpdateResultArray_template();
ListOfHistoryUpdateResultArray_template& operator=(template_sel other_value);
ListOfHistoryUpdateResultArray_template& operator=(const ListOfHistoryUpdateResultArray& other_value);
ListOfHistoryUpdateResultArray_template& operator=(const OPTIONAL<ListOfHistoryUpdateResultArray>& other_value);
ListOfHistoryUpdateResultArray_template& operator=(const ListOfHistoryUpdateResultArray_template& other_value);
boolean match(const ListOfHistoryUpdateResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfHistoryUpdateResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfHistoryUpdateResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
HistoryUpdateResultArray_template& arrayValues();
const HistoryUpdateResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfHistoryUpdateResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfCallMethodRequestArray : public Base_Type {
  INTEGER field_arrayLength;
  CallMethodRequestArray field_arrayValues;
public:
  ListOfCallMethodRequestArray();
  ListOfCallMethodRequestArray(const INTEGER& par_arrayLength,
    const CallMethodRequestArray& par_arrayValues);
  ListOfCallMethodRequestArray(const ListOfCallMethodRequestArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfCallMethodRequestArray& operator=(const ListOfCallMethodRequestArray& other_value);
  boolean operator==(const ListOfCallMethodRequestArray& other_value) const;
  inline boolean operator!=(const ListOfCallMethodRequestArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline CallMethodRequestArray& arrayValues()
    {return field_arrayValues;}
  inline const CallMethodRequestArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfCallMethodRequestArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfCallMethodRequestArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfCallMethodRequestArray& other_value);
void copy_template(const ListOfCallMethodRequestArray_template& other_value);

public:
ListOfCallMethodRequestArray_template();
ListOfCallMethodRequestArray_template(template_sel other_value);
ListOfCallMethodRequestArray_template(const ListOfCallMethodRequestArray& other_value);
ListOfCallMethodRequestArray_template(const OPTIONAL<ListOfCallMethodRequestArray>& other_value);
ListOfCallMethodRequestArray_template(const ListOfCallMethodRequestArray_template& other_value);
~ListOfCallMethodRequestArray_template();
ListOfCallMethodRequestArray_template& operator=(template_sel other_value);
ListOfCallMethodRequestArray_template& operator=(const ListOfCallMethodRequestArray& other_value);
ListOfCallMethodRequestArray_template& operator=(const OPTIONAL<ListOfCallMethodRequestArray>& other_value);
ListOfCallMethodRequestArray_template& operator=(const ListOfCallMethodRequestArray_template& other_value);
boolean match(const ListOfCallMethodRequestArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfCallMethodRequestArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfCallMethodRequestArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
CallMethodRequestArray_template& arrayValues();
const CallMethodRequestArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfCallMethodRequestArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfCallMethodResultArray : public Base_Type {
  INTEGER field_arrayLength;
  CallMethodResultArray field_arrayValues;
public:
  ListOfCallMethodResultArray();
  ListOfCallMethodResultArray(const INTEGER& par_arrayLength,
    const CallMethodResultArray& par_arrayValues);
  ListOfCallMethodResultArray(const ListOfCallMethodResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfCallMethodResultArray& operator=(const ListOfCallMethodResultArray& other_value);
  boolean operator==(const ListOfCallMethodResultArray& other_value) const;
  inline boolean operator!=(const ListOfCallMethodResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline CallMethodResultArray& arrayValues()
    {return field_arrayValues;}
  inline const CallMethodResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfCallMethodResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfCallMethodResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfCallMethodResultArray& other_value);
void copy_template(const ListOfCallMethodResultArray_template& other_value);

public:
ListOfCallMethodResultArray_template();
ListOfCallMethodResultArray_template(template_sel other_value);
ListOfCallMethodResultArray_template(const ListOfCallMethodResultArray& other_value);
ListOfCallMethodResultArray_template(const OPTIONAL<ListOfCallMethodResultArray>& other_value);
ListOfCallMethodResultArray_template(const ListOfCallMethodResultArray_template& other_value);
~ListOfCallMethodResultArray_template();
ListOfCallMethodResultArray_template& operator=(template_sel other_value);
ListOfCallMethodResultArray_template& operator=(const ListOfCallMethodResultArray& other_value);
ListOfCallMethodResultArray_template& operator=(const OPTIONAL<ListOfCallMethodResultArray>& other_value);
ListOfCallMethodResultArray_template& operator=(const ListOfCallMethodResultArray_template& other_value);
boolean match(const ListOfCallMethodResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfCallMethodResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfCallMethodResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
CallMethodResultArray_template& arrayValues();
const CallMethodResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfCallMethodResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfMonitoredItemCreateRequestArray : public Base_Type {
  INTEGER field_arrayLength;
  MonitoredItemCreateRequestArray field_arrayValues;
public:
  ListOfMonitoredItemCreateRequestArray();
  ListOfMonitoredItemCreateRequestArray(const INTEGER& par_arrayLength,
    const MonitoredItemCreateRequestArray& par_arrayValues);
  ListOfMonitoredItemCreateRequestArray(const ListOfMonitoredItemCreateRequestArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfMonitoredItemCreateRequestArray& operator=(const ListOfMonitoredItemCreateRequestArray& other_value);
  boolean operator==(const ListOfMonitoredItemCreateRequestArray& other_value) const;
  inline boolean operator!=(const ListOfMonitoredItemCreateRequestArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline MonitoredItemCreateRequestArray& arrayValues()
    {return field_arrayValues;}
  inline const MonitoredItemCreateRequestArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemCreateRequestArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemCreateRequestArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfMonitoredItemCreateRequestArray& other_value);
void copy_template(const ListOfMonitoredItemCreateRequestArray_template& other_value);

public:
ListOfMonitoredItemCreateRequestArray_template();
ListOfMonitoredItemCreateRequestArray_template(template_sel other_value);
ListOfMonitoredItemCreateRequestArray_template(const ListOfMonitoredItemCreateRequestArray& other_value);
ListOfMonitoredItemCreateRequestArray_template(const OPTIONAL<ListOfMonitoredItemCreateRequestArray>& other_value);
ListOfMonitoredItemCreateRequestArray_template(const ListOfMonitoredItemCreateRequestArray_template& other_value);
~ListOfMonitoredItemCreateRequestArray_template();
ListOfMonitoredItemCreateRequestArray_template& operator=(template_sel other_value);
ListOfMonitoredItemCreateRequestArray_template& operator=(const ListOfMonitoredItemCreateRequestArray& other_value);
ListOfMonitoredItemCreateRequestArray_template& operator=(const OPTIONAL<ListOfMonitoredItemCreateRequestArray>& other_value);
ListOfMonitoredItemCreateRequestArray_template& operator=(const ListOfMonitoredItemCreateRequestArray_template& other_value);
boolean match(const ListOfMonitoredItemCreateRequestArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfMonitoredItemCreateRequestArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfMonitoredItemCreateRequestArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
MonitoredItemCreateRequestArray_template& arrayValues();
const MonitoredItemCreateRequestArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfMonitoredItemCreateRequestArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfMonitoredItemCreateResultArray : public Base_Type {
  INTEGER field_arrayLength;
  MonitoredItemCreateResultArray field_arrayValues;
public:
  ListOfMonitoredItemCreateResultArray();
  ListOfMonitoredItemCreateResultArray(const INTEGER& par_arrayLength,
    const MonitoredItemCreateResultArray& par_arrayValues);
  ListOfMonitoredItemCreateResultArray(const ListOfMonitoredItemCreateResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfMonitoredItemCreateResultArray& operator=(const ListOfMonitoredItemCreateResultArray& other_value);
  boolean operator==(const ListOfMonitoredItemCreateResultArray& other_value) const;
  inline boolean operator!=(const ListOfMonitoredItemCreateResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline MonitoredItemCreateResultArray& arrayValues()
    {return field_arrayValues;}
  inline const MonitoredItemCreateResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemCreateResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemCreateResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfMonitoredItemCreateResultArray& other_value);
void copy_template(const ListOfMonitoredItemCreateResultArray_template& other_value);

public:
ListOfMonitoredItemCreateResultArray_template();
ListOfMonitoredItemCreateResultArray_template(template_sel other_value);
ListOfMonitoredItemCreateResultArray_template(const ListOfMonitoredItemCreateResultArray& other_value);
ListOfMonitoredItemCreateResultArray_template(const OPTIONAL<ListOfMonitoredItemCreateResultArray>& other_value);
ListOfMonitoredItemCreateResultArray_template(const ListOfMonitoredItemCreateResultArray_template& other_value);
~ListOfMonitoredItemCreateResultArray_template();
ListOfMonitoredItemCreateResultArray_template& operator=(template_sel other_value);
ListOfMonitoredItemCreateResultArray_template& operator=(const ListOfMonitoredItemCreateResultArray& other_value);
ListOfMonitoredItemCreateResultArray_template& operator=(const OPTIONAL<ListOfMonitoredItemCreateResultArray>& other_value);
ListOfMonitoredItemCreateResultArray_template& operator=(const ListOfMonitoredItemCreateResultArray_template& other_value);
boolean match(const ListOfMonitoredItemCreateResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfMonitoredItemCreateResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfMonitoredItemCreateResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
MonitoredItemCreateResultArray_template& arrayValues();
const MonitoredItemCreateResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfMonitoredItemCreateResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfMonitoredItemModifyRequestArray : public Base_Type {
  INTEGER field_arrayLength;
  MonitoredItemModifyRequestArray field_arrayValues;
public:
  ListOfMonitoredItemModifyRequestArray();
  ListOfMonitoredItemModifyRequestArray(const INTEGER& par_arrayLength,
    const MonitoredItemModifyRequestArray& par_arrayValues);
  ListOfMonitoredItemModifyRequestArray(const ListOfMonitoredItemModifyRequestArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfMonitoredItemModifyRequestArray& operator=(const ListOfMonitoredItemModifyRequestArray& other_value);
  boolean operator==(const ListOfMonitoredItemModifyRequestArray& other_value) const;
  inline boolean operator!=(const ListOfMonitoredItemModifyRequestArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline MonitoredItemModifyRequestArray& arrayValues()
    {return field_arrayValues;}
  inline const MonitoredItemModifyRequestArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemModifyRequestArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemModifyRequestArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfMonitoredItemModifyRequestArray& other_value);
void copy_template(const ListOfMonitoredItemModifyRequestArray_template& other_value);

public:
ListOfMonitoredItemModifyRequestArray_template();
ListOfMonitoredItemModifyRequestArray_template(template_sel other_value);
ListOfMonitoredItemModifyRequestArray_template(const ListOfMonitoredItemModifyRequestArray& other_value);
ListOfMonitoredItemModifyRequestArray_template(const OPTIONAL<ListOfMonitoredItemModifyRequestArray>& other_value);
ListOfMonitoredItemModifyRequestArray_template(const ListOfMonitoredItemModifyRequestArray_template& other_value);
~ListOfMonitoredItemModifyRequestArray_template();
ListOfMonitoredItemModifyRequestArray_template& operator=(template_sel other_value);
ListOfMonitoredItemModifyRequestArray_template& operator=(const ListOfMonitoredItemModifyRequestArray& other_value);
ListOfMonitoredItemModifyRequestArray_template& operator=(const OPTIONAL<ListOfMonitoredItemModifyRequestArray>& other_value);
ListOfMonitoredItemModifyRequestArray_template& operator=(const ListOfMonitoredItemModifyRequestArray_template& other_value);
boolean match(const ListOfMonitoredItemModifyRequestArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfMonitoredItemModifyRequestArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfMonitoredItemModifyRequestArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
MonitoredItemModifyRequestArray_template& arrayValues();
const MonitoredItemModifyRequestArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfMonitoredItemModifyRequestArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfMonitoredItemModifyResultArray : public Base_Type {
  INTEGER field_arrayLength;
  MonitoredItemModifyResultArray field_arrayValues;
public:
  ListOfMonitoredItemModifyResultArray();
  ListOfMonitoredItemModifyResultArray(const INTEGER& par_arrayLength,
    const MonitoredItemModifyResultArray& par_arrayValues);
  ListOfMonitoredItemModifyResultArray(const ListOfMonitoredItemModifyResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfMonitoredItemModifyResultArray& operator=(const ListOfMonitoredItemModifyResultArray& other_value);
  boolean operator==(const ListOfMonitoredItemModifyResultArray& other_value) const;
  inline boolean operator!=(const ListOfMonitoredItemModifyResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline MonitoredItemModifyResultArray& arrayValues()
    {return field_arrayValues;}
  inline const MonitoredItemModifyResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemModifyResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemModifyResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfMonitoredItemModifyResultArray& other_value);
void copy_template(const ListOfMonitoredItemModifyResultArray_template& other_value);

public:
ListOfMonitoredItemModifyResultArray_template();
ListOfMonitoredItemModifyResultArray_template(template_sel other_value);
ListOfMonitoredItemModifyResultArray_template(const ListOfMonitoredItemModifyResultArray& other_value);
ListOfMonitoredItemModifyResultArray_template(const OPTIONAL<ListOfMonitoredItemModifyResultArray>& other_value);
ListOfMonitoredItemModifyResultArray_template(const ListOfMonitoredItemModifyResultArray_template& other_value);
~ListOfMonitoredItemModifyResultArray_template();
ListOfMonitoredItemModifyResultArray_template& operator=(template_sel other_value);
ListOfMonitoredItemModifyResultArray_template& operator=(const ListOfMonitoredItemModifyResultArray& other_value);
ListOfMonitoredItemModifyResultArray_template& operator=(const OPTIONAL<ListOfMonitoredItemModifyResultArray>& other_value);
ListOfMonitoredItemModifyResultArray_template& operator=(const ListOfMonitoredItemModifyResultArray_template& other_value);
boolean match(const ListOfMonitoredItemModifyResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfMonitoredItemModifyResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfMonitoredItemModifyResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
MonitoredItemModifyResultArray_template& arrayValues();
const MonitoredItemModifyResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfMonitoredItemModifyResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfSubscriptionAcknowledgementArray : public Base_Type {
  INTEGER field_arrayLength;
  SubscriptionAcknowledgementArray field_arrayValues;
public:
  ListOfSubscriptionAcknowledgementArray();
  ListOfSubscriptionAcknowledgementArray(const INTEGER& par_arrayLength,
    const SubscriptionAcknowledgementArray& par_arrayValues);
  ListOfSubscriptionAcknowledgementArray(const ListOfSubscriptionAcknowledgementArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfSubscriptionAcknowledgementArray& operator=(const ListOfSubscriptionAcknowledgementArray& other_value);
  boolean operator==(const ListOfSubscriptionAcknowledgementArray& other_value) const;
  inline boolean operator!=(const ListOfSubscriptionAcknowledgementArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline SubscriptionAcknowledgementArray& arrayValues()
    {return field_arrayValues;}
  inline const SubscriptionAcknowledgementArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfSubscriptionAcknowledgementArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfSubscriptionAcknowledgementArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfSubscriptionAcknowledgementArray& other_value);
void copy_template(const ListOfSubscriptionAcknowledgementArray_template& other_value);

public:
ListOfSubscriptionAcknowledgementArray_template();
ListOfSubscriptionAcknowledgementArray_template(template_sel other_value);
ListOfSubscriptionAcknowledgementArray_template(const ListOfSubscriptionAcknowledgementArray& other_value);
ListOfSubscriptionAcknowledgementArray_template(const OPTIONAL<ListOfSubscriptionAcknowledgementArray>& other_value);
ListOfSubscriptionAcknowledgementArray_template(const ListOfSubscriptionAcknowledgementArray_template& other_value);
~ListOfSubscriptionAcknowledgementArray_template();
ListOfSubscriptionAcknowledgementArray_template& operator=(template_sel other_value);
ListOfSubscriptionAcknowledgementArray_template& operator=(const ListOfSubscriptionAcknowledgementArray& other_value);
ListOfSubscriptionAcknowledgementArray_template& operator=(const OPTIONAL<ListOfSubscriptionAcknowledgementArray>& other_value);
ListOfSubscriptionAcknowledgementArray_template& operator=(const ListOfSubscriptionAcknowledgementArray_template& other_value);
boolean match(const ListOfSubscriptionAcknowledgementArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfSubscriptionAcknowledgementArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfSubscriptionAcknowledgementArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
SubscriptionAcknowledgementArray_template& arrayValues();
const SubscriptionAcknowledgementArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfSubscriptionAcknowledgementArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfTransferResultArray : public Base_Type {
  INTEGER field_arrayLength;
  TransferResultArray field_arrayValues;
public:
  ListOfTransferResultArray();
  ListOfTransferResultArray(const INTEGER& par_arrayLength,
    const TransferResultArray& par_arrayValues);
  ListOfTransferResultArray(const ListOfTransferResultArray& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ListOfTransferResultArray& operator=(const ListOfTransferResultArray& other_value);
  boolean operator==(const ListOfTransferResultArray& other_value) const;
  inline boolean operator!=(const ListOfTransferResultArray& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& arrayLength()
    {return field_arrayLength;}
  inline const INTEGER& arrayLength() const
    {return field_arrayLength;}
  inline TransferResultArray& arrayValues()
    {return field_arrayValues;}
  inline const TransferResultArray& arrayValues() const
    {return field_arrayValues;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfTransferResultArray_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ListOfTransferResultArray_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ListOfTransferResultArray& other_value);
void copy_template(const ListOfTransferResultArray_template& other_value);

public:
ListOfTransferResultArray_template();
ListOfTransferResultArray_template(template_sel other_value);
ListOfTransferResultArray_template(const ListOfTransferResultArray& other_value);
ListOfTransferResultArray_template(const OPTIONAL<ListOfTransferResultArray>& other_value);
ListOfTransferResultArray_template(const ListOfTransferResultArray_template& other_value);
~ListOfTransferResultArray_template();
ListOfTransferResultArray_template& operator=(template_sel other_value);
ListOfTransferResultArray_template& operator=(const ListOfTransferResultArray& other_value);
ListOfTransferResultArray_template& operator=(const OPTIONAL<ListOfTransferResultArray>& other_value);
ListOfTransferResultArray_template& operator=(const ListOfTransferResultArray_template& other_value);
boolean match(const ListOfTransferResultArray& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ListOfTransferResultArray valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ListOfTransferResultArray_template& list_item(unsigned int list_index) const;
INTEGER_template& arrayLength();
const INTEGER_template& arrayLength() const;
TransferResultArray_template& arrayValues();
const TransferResultArray_template& arrayValues() const;
int size_of() const;
void log() const;
void log_match(const ListOfTransferResultArray& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ListOfIntegerId : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfIntegerIdArray *field_realArray;
};
void copy_value(const ListOfIntegerId& other_value);

public:
ListOfIntegerId();
ListOfIntegerId(const ListOfIntegerId& other_value);
~ListOfIntegerId();
ListOfIntegerId& operator=(const ListOfIntegerId& other_value);
boolean operator==(const ListOfIntegerId& other_value) const;
inline boolean operator!=(const ListOfIntegerId& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfIntegerIdArray& realArray();
const ListOfIntegerIdArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfIntegerId_template : public Base_Template {
union {
struct {
ListOfIntegerId::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfIntegerIdArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfIntegerId_template *list_value;
} value_list;
};
void copy_value(const ListOfIntegerId& other_value);

void copy_template(const ListOfIntegerId_template& other_value);

public:
ListOfIntegerId_template();
ListOfIntegerId_template(template_sel other_value);
ListOfIntegerId_template(const ListOfIntegerId& other_value);
ListOfIntegerId_template(const OPTIONAL<ListOfIntegerId>& other_value);
ListOfIntegerId_template(const ListOfIntegerId_template& other_value);
~ListOfIntegerId_template();
void clean_up();
ListOfIntegerId_template& operator=(template_sel other_value);
ListOfIntegerId_template& operator=(const ListOfIntegerId& other_value);
ListOfIntegerId_template& operator=(const OPTIONAL<ListOfIntegerId>& other_value);
ListOfIntegerId_template& operator=(const ListOfIntegerId_template& other_value);
boolean match(const ListOfIntegerId& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfIntegerId valueof() const;
ListOfIntegerId_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfIntegerIdArray_template& realArray();
const ListOfIntegerIdArray_template& realArray() const;
boolean ischosen(ListOfIntegerId::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfIntegerId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfLocaleId : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfLocaleIdArray *field_realArray;
};
void copy_value(const ListOfLocaleId& other_value);

public:
ListOfLocaleId();
ListOfLocaleId(const ListOfLocaleId& other_value);
~ListOfLocaleId();
ListOfLocaleId& operator=(const ListOfLocaleId& other_value);
boolean operator==(const ListOfLocaleId& other_value) const;
inline boolean operator!=(const ListOfLocaleId& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfLocaleIdArray& realArray();
const ListOfLocaleIdArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfLocaleId_template : public Base_Template {
union {
struct {
ListOfLocaleId::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfLocaleIdArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfLocaleId_template *list_value;
} value_list;
};
void copy_value(const ListOfLocaleId& other_value);

void copy_template(const ListOfLocaleId_template& other_value);

public:
ListOfLocaleId_template();
ListOfLocaleId_template(template_sel other_value);
ListOfLocaleId_template(const ListOfLocaleId& other_value);
ListOfLocaleId_template(const OPTIONAL<ListOfLocaleId>& other_value);
ListOfLocaleId_template(const ListOfLocaleId_template& other_value);
~ListOfLocaleId_template();
void clean_up();
ListOfLocaleId_template& operator=(template_sel other_value);
ListOfLocaleId_template& operator=(const ListOfLocaleId& other_value);
ListOfLocaleId_template& operator=(const OPTIONAL<ListOfLocaleId>& other_value);
ListOfLocaleId_template& operator=(const ListOfLocaleId_template& other_value);
boolean match(const ListOfLocaleId& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfLocaleId valueof() const;
ListOfLocaleId_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfLocaleIdArray_template& realArray();
const ListOfLocaleIdArray_template& realArray() const;
boolean ischosen(ListOfLocaleId::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfLocaleId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfContinuationPoint : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfContinuationPointArray *field_realArray;
};
void copy_value(const ListOfContinuationPoint& other_value);

public:
ListOfContinuationPoint();
ListOfContinuationPoint(const ListOfContinuationPoint& other_value);
~ListOfContinuationPoint();
ListOfContinuationPoint& operator=(const ListOfContinuationPoint& other_value);
boolean operator==(const ListOfContinuationPoint& other_value) const;
inline boolean operator!=(const ListOfContinuationPoint& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfContinuationPointArray& realArray();
const ListOfContinuationPointArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfContinuationPoint_template : public Base_Template {
union {
struct {
ListOfContinuationPoint::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfContinuationPointArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfContinuationPoint_template *list_value;
} value_list;
};
void copy_value(const ListOfContinuationPoint& other_value);

void copy_template(const ListOfContinuationPoint_template& other_value);

public:
ListOfContinuationPoint_template();
ListOfContinuationPoint_template(template_sel other_value);
ListOfContinuationPoint_template(const ListOfContinuationPoint& other_value);
ListOfContinuationPoint_template(const OPTIONAL<ListOfContinuationPoint>& other_value);
ListOfContinuationPoint_template(const ListOfContinuationPoint_template& other_value);
~ListOfContinuationPoint_template();
void clean_up();
ListOfContinuationPoint_template& operator=(template_sel other_value);
ListOfContinuationPoint_template& operator=(const ListOfContinuationPoint& other_value);
ListOfContinuationPoint_template& operator=(const OPTIONAL<ListOfContinuationPoint>& other_value);
ListOfContinuationPoint_template& operator=(const ListOfContinuationPoint_template& other_value);
boolean match(const ListOfContinuationPoint& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfContinuationPoint valueof() const;
ListOfContinuationPoint_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfContinuationPointArray_template& realArray();
const ListOfContinuationPointArray_template& realArray() const;
boolean ischosen(ListOfContinuationPoint::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfContinuationPoint& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfDecimal : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfDecimalArray *field_realArray;
};
void copy_value(const ListOfDecimal& other_value);

public:
ListOfDecimal();
ListOfDecimal(const ListOfDecimal& other_value);
~ListOfDecimal();
ListOfDecimal& operator=(const ListOfDecimal& other_value);
boolean operator==(const ListOfDecimal& other_value) const;
inline boolean operator!=(const ListOfDecimal& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfDecimalArray& realArray();
const ListOfDecimalArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ListOfDecimal_template : public Base_Template {
union {
struct {
ListOfDecimal::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfDecimalArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfDecimal_template *list_value;
} value_list;
};
void copy_value(const ListOfDecimal& other_value);

void copy_template(const ListOfDecimal_template& other_value);

public:
ListOfDecimal_template();
ListOfDecimal_template(template_sel other_value);
ListOfDecimal_template(const ListOfDecimal& other_value);
ListOfDecimal_template(const OPTIONAL<ListOfDecimal>& other_value);
ListOfDecimal_template(const ListOfDecimal_template& other_value);
~ListOfDecimal_template();
void clean_up();
ListOfDecimal_template& operator=(template_sel other_value);
ListOfDecimal_template& operator=(const ListOfDecimal& other_value);
ListOfDecimal_template& operator=(const OPTIONAL<ListOfDecimal>& other_value);
ListOfDecimal_template& operator=(const ListOfDecimal_template& other_value);
boolean match(const ListOfDecimal& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfDecimal valueof() const;
ListOfDecimal_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfDecimalArray_template& realArray();
const ListOfDecimalArray_template& realArray() const;
boolean ischosen(ListOfDecimal::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfDecimal& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfEnumValueType : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfEnumValueTypeArray *field_realArray;
};
void copy_value(const ListOfEnumValueType& other_value);

public:
ListOfEnumValueType();
ListOfEnumValueType(const ListOfEnumValueType& other_value);
~ListOfEnumValueType();
ListOfEnumValueType& operator=(const ListOfEnumValueType& other_value);
boolean operator==(const ListOfEnumValueType& other_value) const;
inline boolean operator!=(const ListOfEnumValueType& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfEnumValueTypeArray& realArray();
const ListOfEnumValueTypeArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ListOfEnumValueType_template : public Base_Template {
union {
struct {
ListOfEnumValueType::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfEnumValueTypeArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfEnumValueType_template *list_value;
} value_list;
};
void copy_value(const ListOfEnumValueType& other_value);

void copy_template(const ListOfEnumValueType_template& other_value);

public:
ListOfEnumValueType_template();
ListOfEnumValueType_template(template_sel other_value);
ListOfEnumValueType_template(const ListOfEnumValueType& other_value);
ListOfEnumValueType_template(const OPTIONAL<ListOfEnumValueType>& other_value);
ListOfEnumValueType_template(const ListOfEnumValueType_template& other_value);
~ListOfEnumValueType_template();
void clean_up();
ListOfEnumValueType_template& operator=(template_sel other_value);
ListOfEnumValueType_template& operator=(const ListOfEnumValueType& other_value);
ListOfEnumValueType_template& operator=(const OPTIONAL<ListOfEnumValueType>& other_value);
ListOfEnumValueType_template& operator=(const ListOfEnumValueType_template& other_value);
boolean match(const ListOfEnumValueType& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfEnumValueType valueof() const;
ListOfEnumValueType_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfEnumValueTypeArray_template& realArray();
const ListOfEnumValueTypeArray_template& realArray() const;
boolean ischosen(ListOfEnumValueType::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfEnumValueType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfApplicationDescription : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfApplicationDescriptionArray *field_realArray;
};
void copy_value(const ListOfApplicationDescription& other_value);

public:
ListOfApplicationDescription();
ListOfApplicationDescription(const ListOfApplicationDescription& other_value);
~ListOfApplicationDescription();
ListOfApplicationDescription& operator=(const ListOfApplicationDescription& other_value);
boolean operator==(const ListOfApplicationDescription& other_value) const;
inline boolean operator!=(const ListOfApplicationDescription& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfApplicationDescriptionArray& realArray();
const ListOfApplicationDescriptionArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfApplicationDescription_template : public Base_Template {
union {
struct {
ListOfApplicationDescription::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfApplicationDescriptionArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfApplicationDescription_template *list_value;
} value_list;
};
void copy_value(const ListOfApplicationDescription& other_value);

void copy_template(const ListOfApplicationDescription_template& other_value);

public:
ListOfApplicationDescription_template();
ListOfApplicationDescription_template(template_sel other_value);
ListOfApplicationDescription_template(const ListOfApplicationDescription& other_value);
ListOfApplicationDescription_template(const OPTIONAL<ListOfApplicationDescription>& other_value);
ListOfApplicationDescription_template(const ListOfApplicationDescription_template& other_value);
~ListOfApplicationDescription_template();
void clean_up();
ListOfApplicationDescription_template& operator=(template_sel other_value);
ListOfApplicationDescription_template& operator=(const ListOfApplicationDescription& other_value);
ListOfApplicationDescription_template& operator=(const OPTIONAL<ListOfApplicationDescription>& other_value);
ListOfApplicationDescription_template& operator=(const ListOfApplicationDescription_template& other_value);
boolean match(const ListOfApplicationDescription& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfApplicationDescription valueof() const;
ListOfApplicationDescription_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfApplicationDescriptionArray_template& realArray();
const ListOfApplicationDescriptionArray_template& realArray() const;
boolean ischosen(ListOfApplicationDescription::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfApplicationDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfBrowseResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfBrowseResultArray *field_realArray;
};
void copy_value(const ListOfBrowseResult& other_value);

public:
ListOfBrowseResult();
ListOfBrowseResult(const ListOfBrowseResult& other_value);
~ListOfBrowseResult();
ListOfBrowseResult& operator=(const ListOfBrowseResult& other_value);
boolean operator==(const ListOfBrowseResult& other_value) const;
inline boolean operator!=(const ListOfBrowseResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfBrowseResultArray& realArray();
const ListOfBrowseResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowseResult_template : public Base_Template {
union {
struct {
ListOfBrowseResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfBrowseResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfBrowseResult_template *list_value;
} value_list;
};
void copy_value(const ListOfBrowseResult& other_value);

void copy_template(const ListOfBrowseResult_template& other_value);

public:
ListOfBrowseResult_template();
ListOfBrowseResult_template(template_sel other_value);
ListOfBrowseResult_template(const ListOfBrowseResult& other_value);
ListOfBrowseResult_template(const OPTIONAL<ListOfBrowseResult>& other_value);
ListOfBrowseResult_template(const ListOfBrowseResult_template& other_value);
~ListOfBrowseResult_template();
void clean_up();
ListOfBrowseResult_template& operator=(template_sel other_value);
ListOfBrowseResult_template& operator=(const ListOfBrowseResult& other_value);
ListOfBrowseResult_template& operator=(const OPTIONAL<ListOfBrowseResult>& other_value);
ListOfBrowseResult_template& operator=(const ListOfBrowseResult_template& other_value);
boolean match(const ListOfBrowseResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfBrowseResult valueof() const;
ListOfBrowseResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfBrowseResultArray_template& realArray();
const ListOfBrowseResultArray_template& realArray() const;
boolean ischosen(ListOfBrowseResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfBrowseResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfEndpointDescription : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfEndpointDescriptionArray *field_realArray;
};
void copy_value(const ListOfEndpointDescription& other_value);

public:
ListOfEndpointDescription();
ListOfEndpointDescription(const ListOfEndpointDescription& other_value);
~ListOfEndpointDescription();
ListOfEndpointDescription& operator=(const ListOfEndpointDescription& other_value);
boolean operator==(const ListOfEndpointDescription& other_value) const;
inline boolean operator!=(const ListOfEndpointDescription& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfEndpointDescriptionArray& realArray();
const ListOfEndpointDescriptionArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfEndpointDescription_template : public Base_Template {
union {
struct {
ListOfEndpointDescription::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfEndpointDescriptionArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfEndpointDescription_template *list_value;
} value_list;
};
void copy_value(const ListOfEndpointDescription& other_value);

void copy_template(const ListOfEndpointDescription_template& other_value);

public:
ListOfEndpointDescription_template();
ListOfEndpointDescription_template(template_sel other_value);
ListOfEndpointDescription_template(const ListOfEndpointDescription& other_value);
ListOfEndpointDescription_template(const OPTIONAL<ListOfEndpointDescription>& other_value);
ListOfEndpointDescription_template(const ListOfEndpointDescription_template& other_value);
~ListOfEndpointDescription_template();
void clean_up();
ListOfEndpointDescription_template& operator=(template_sel other_value);
ListOfEndpointDescription_template& operator=(const ListOfEndpointDescription& other_value);
ListOfEndpointDescription_template& operator=(const OPTIONAL<ListOfEndpointDescription>& other_value);
ListOfEndpointDescription_template& operator=(const ListOfEndpointDescription_template& other_value);
boolean match(const ListOfEndpointDescription& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfEndpointDescription valueof() const;
ListOfEndpointDescription_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfEndpointDescriptionArray_template& realArray();
const ListOfEndpointDescriptionArray_template& realArray() const;
boolean ischosen(ListOfEndpointDescription::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfEndpointDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfMonitoringParameters : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfMonitoringParametersArray *field_realArray;
};
void copy_value(const ListOfMonitoringParameters& other_value);

public:
ListOfMonitoringParameters();
ListOfMonitoringParameters(const ListOfMonitoringParameters& other_value);
~ListOfMonitoringParameters();
ListOfMonitoringParameters& operator=(const ListOfMonitoringParameters& other_value);
boolean operator==(const ListOfMonitoringParameters& other_value) const;
inline boolean operator!=(const ListOfMonitoringParameters& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfMonitoringParametersArray& realArray();
const ListOfMonitoringParametersArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ListOfMonitoringParameters_template : public Base_Template {
union {
struct {
ListOfMonitoringParameters::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfMonitoringParametersArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfMonitoringParameters_template *list_value;
} value_list;
};
void copy_value(const ListOfMonitoringParameters& other_value);

void copy_template(const ListOfMonitoringParameters_template& other_value);

public:
ListOfMonitoringParameters_template();
ListOfMonitoringParameters_template(template_sel other_value);
ListOfMonitoringParameters_template(const ListOfMonitoringParameters& other_value);
ListOfMonitoringParameters_template(const OPTIONAL<ListOfMonitoringParameters>& other_value);
ListOfMonitoringParameters_template(const ListOfMonitoringParameters_template& other_value);
~ListOfMonitoringParameters_template();
void clean_up();
ListOfMonitoringParameters_template& operator=(template_sel other_value);
ListOfMonitoringParameters_template& operator=(const ListOfMonitoringParameters& other_value);
ListOfMonitoringParameters_template& operator=(const OPTIONAL<ListOfMonitoringParameters>& other_value);
ListOfMonitoringParameters_template& operator=(const ListOfMonitoringParameters_template& other_value);
boolean match(const ListOfMonitoringParameters& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfMonitoringParameters valueof() const;
ListOfMonitoringParameters_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfMonitoringParametersArray_template& realArray();
const ListOfMonitoringParametersArray_template& realArray() const;
boolean ischosen(ListOfMonitoringParameters::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfMonitoringParameters& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfQueryDataSet : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfQueryDataSetArray *field_realArray;
};
void copy_value(const ListOfQueryDataSet& other_value);

public:
ListOfQueryDataSet();
ListOfQueryDataSet(const ListOfQueryDataSet& other_value);
~ListOfQueryDataSet();
ListOfQueryDataSet& operator=(const ListOfQueryDataSet& other_value);
boolean operator==(const ListOfQueryDataSet& other_value) const;
inline boolean operator!=(const ListOfQueryDataSet& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfQueryDataSetArray& realArray();
const ListOfQueryDataSetArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfQueryDataSet_template : public Base_Template {
union {
struct {
ListOfQueryDataSet::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfQueryDataSetArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfQueryDataSet_template *list_value;
} value_list;
};
void copy_value(const ListOfQueryDataSet& other_value);

void copy_template(const ListOfQueryDataSet_template& other_value);

public:
ListOfQueryDataSet_template();
ListOfQueryDataSet_template(template_sel other_value);
ListOfQueryDataSet_template(const ListOfQueryDataSet& other_value);
ListOfQueryDataSet_template(const OPTIONAL<ListOfQueryDataSet>& other_value);
ListOfQueryDataSet_template(const ListOfQueryDataSet_template& other_value);
~ListOfQueryDataSet_template();
void clean_up();
ListOfQueryDataSet_template& operator=(template_sel other_value);
ListOfQueryDataSet_template& operator=(const ListOfQueryDataSet& other_value);
ListOfQueryDataSet_template& operator=(const OPTIONAL<ListOfQueryDataSet>& other_value);
ListOfQueryDataSet_template& operator=(const ListOfQueryDataSet_template& other_value);
boolean match(const ListOfQueryDataSet& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfQueryDataSet valueof() const;
ListOfQueryDataSet_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfQueryDataSetArray_template& realArray();
const ListOfQueryDataSetArray_template& realArray() const;
boolean ischosen(ListOfQueryDataSet::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfQueryDataSet& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfReadValueId : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfReadValueIdArray *field_realArray;
};
void copy_value(const ListOfReadValueId& other_value);

public:
ListOfReadValueId();
ListOfReadValueId(const ListOfReadValueId& other_value);
~ListOfReadValueId();
ListOfReadValueId& operator=(const ListOfReadValueId& other_value);
boolean operator==(const ListOfReadValueId& other_value) const;
inline boolean operator!=(const ListOfReadValueId& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfReadValueIdArray& realArray();
const ListOfReadValueIdArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfReadValueId_template : public Base_Template {
union {
struct {
ListOfReadValueId::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfReadValueIdArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfReadValueId_template *list_value;
} value_list;
};
void copy_value(const ListOfReadValueId& other_value);

void copy_template(const ListOfReadValueId_template& other_value);

public:
ListOfReadValueId_template();
ListOfReadValueId_template(template_sel other_value);
ListOfReadValueId_template(const ListOfReadValueId& other_value);
ListOfReadValueId_template(const OPTIONAL<ListOfReadValueId>& other_value);
ListOfReadValueId_template(const ListOfReadValueId_template& other_value);
~ListOfReadValueId_template();
void clean_up();
ListOfReadValueId_template& operator=(template_sel other_value);
ListOfReadValueId_template& operator=(const ListOfReadValueId& other_value);
ListOfReadValueId_template& operator=(const OPTIONAL<ListOfReadValueId>& other_value);
ListOfReadValueId_template& operator=(const ListOfReadValueId_template& other_value);
boolean match(const ListOfReadValueId& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfReadValueId valueof() const;
ListOfReadValueId_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfReadValueIdArray_template& realArray();
const ListOfReadValueIdArray_template& realArray() const;
boolean ischosen(ListOfReadValueId::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfReadValueId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfApplicationInstanceCertificate : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfApplicationInstanceCertificateArray *field_realArray;
};
void copy_value(const ListOfApplicationInstanceCertificate& other_value);

public:
ListOfApplicationInstanceCertificate();
ListOfApplicationInstanceCertificate(const ListOfApplicationInstanceCertificate& other_value);
~ListOfApplicationInstanceCertificate();
ListOfApplicationInstanceCertificate& operator=(const ListOfApplicationInstanceCertificate& other_value);
boolean operator==(const ListOfApplicationInstanceCertificate& other_value) const;
inline boolean operator!=(const ListOfApplicationInstanceCertificate& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfApplicationInstanceCertificateArray& realArray();
const ListOfApplicationInstanceCertificateArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ListOfApplicationInstanceCertificate_template : public Base_Template {
union {
struct {
ListOfApplicationInstanceCertificate::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfApplicationInstanceCertificateArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfApplicationInstanceCertificate_template *list_value;
} value_list;
};
void copy_value(const ListOfApplicationInstanceCertificate& other_value);

void copy_template(const ListOfApplicationInstanceCertificate_template& other_value);

public:
ListOfApplicationInstanceCertificate_template();
ListOfApplicationInstanceCertificate_template(template_sel other_value);
ListOfApplicationInstanceCertificate_template(const ListOfApplicationInstanceCertificate& other_value);
ListOfApplicationInstanceCertificate_template(const OPTIONAL<ListOfApplicationInstanceCertificate>& other_value);
ListOfApplicationInstanceCertificate_template(const ListOfApplicationInstanceCertificate_template& other_value);
~ListOfApplicationInstanceCertificate_template();
void clean_up();
ListOfApplicationInstanceCertificate_template& operator=(template_sel other_value);
ListOfApplicationInstanceCertificate_template& operator=(const ListOfApplicationInstanceCertificate& other_value);
ListOfApplicationInstanceCertificate_template& operator=(const OPTIONAL<ListOfApplicationInstanceCertificate>& other_value);
ListOfApplicationInstanceCertificate_template& operator=(const ListOfApplicationInstanceCertificate_template& other_value);
boolean match(const ListOfApplicationInstanceCertificate& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfApplicationInstanceCertificate valueof() const;
ListOfApplicationInstanceCertificate_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfApplicationInstanceCertificateArray_template& realArray();
const ListOfApplicationInstanceCertificateArray_template& realArray() const;
boolean ischosen(ListOfApplicationInstanceCertificate::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfApplicationInstanceCertificate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfChannelSecurityToken : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfChannelSecurityTokenArray *field_realArray;
};
void copy_value(const ListOfChannelSecurityToken& other_value);

public:
ListOfChannelSecurityToken();
ListOfChannelSecurityToken(const ListOfChannelSecurityToken& other_value);
~ListOfChannelSecurityToken();
ListOfChannelSecurityToken& operator=(const ListOfChannelSecurityToken& other_value);
boolean operator==(const ListOfChannelSecurityToken& other_value) const;
inline boolean operator!=(const ListOfChannelSecurityToken& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfChannelSecurityTokenArray& realArray();
const ListOfChannelSecurityTokenArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class ListOfChannelSecurityToken_template : public Base_Template {
union {
struct {
ListOfChannelSecurityToken::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfChannelSecurityTokenArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfChannelSecurityToken_template *list_value;
} value_list;
};
void copy_value(const ListOfChannelSecurityToken& other_value);

void copy_template(const ListOfChannelSecurityToken_template& other_value);

public:
ListOfChannelSecurityToken_template();
ListOfChannelSecurityToken_template(template_sel other_value);
ListOfChannelSecurityToken_template(const ListOfChannelSecurityToken& other_value);
ListOfChannelSecurityToken_template(const OPTIONAL<ListOfChannelSecurityToken>& other_value);
ListOfChannelSecurityToken_template(const ListOfChannelSecurityToken_template& other_value);
~ListOfChannelSecurityToken_template();
void clean_up();
ListOfChannelSecurityToken_template& operator=(template_sel other_value);
ListOfChannelSecurityToken_template& operator=(const ListOfChannelSecurityToken& other_value);
ListOfChannelSecurityToken_template& operator=(const OPTIONAL<ListOfChannelSecurityToken>& other_value);
ListOfChannelSecurityToken_template& operator=(const ListOfChannelSecurityToken_template& other_value);
boolean match(const ListOfChannelSecurityToken& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfChannelSecurityToken valueof() const;
ListOfChannelSecurityToken_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfChannelSecurityTokenArray_template& realArray();
const ListOfChannelSecurityTokenArray_template& realArray() const;
boolean ischosen(ListOfChannelSecurityToken::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfChannelSecurityToken& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfServerOnNetwork : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfServerOnNetworkArray *field_realArray;
};
void copy_value(const ListOfServerOnNetwork& other_value);

public:
ListOfServerOnNetwork();
ListOfServerOnNetwork(const ListOfServerOnNetwork& other_value);
~ListOfServerOnNetwork();
ListOfServerOnNetwork& operator=(const ListOfServerOnNetwork& other_value);
boolean operator==(const ListOfServerOnNetwork& other_value) const;
inline boolean operator!=(const ListOfServerOnNetwork& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfServerOnNetworkArray& realArray();
const ListOfServerOnNetworkArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfServerOnNetwork_template : public Base_Template {
union {
struct {
ListOfServerOnNetwork::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfServerOnNetworkArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfServerOnNetwork_template *list_value;
} value_list;
};
void copy_value(const ListOfServerOnNetwork& other_value);

void copy_template(const ListOfServerOnNetwork_template& other_value);

public:
ListOfServerOnNetwork_template();
ListOfServerOnNetwork_template(template_sel other_value);
ListOfServerOnNetwork_template(const ListOfServerOnNetwork& other_value);
ListOfServerOnNetwork_template(const OPTIONAL<ListOfServerOnNetwork>& other_value);
ListOfServerOnNetwork_template(const ListOfServerOnNetwork_template& other_value);
~ListOfServerOnNetwork_template();
void clean_up();
ListOfServerOnNetwork_template& operator=(template_sel other_value);
ListOfServerOnNetwork_template& operator=(const ListOfServerOnNetwork& other_value);
ListOfServerOnNetwork_template& operator=(const OPTIONAL<ListOfServerOnNetwork>& other_value);
ListOfServerOnNetwork_template& operator=(const ListOfServerOnNetwork_template& other_value);
boolean match(const ListOfServerOnNetwork& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfServerOnNetwork valueof() const;
ListOfServerOnNetwork_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfServerOnNetworkArray_template& realArray();
const ListOfServerOnNetworkArray_template& realArray() const;
boolean ischosen(ListOfServerOnNetwork::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfServerOnNetwork& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfAddNodesItem : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfAddNodesItemArray *field_realArray;
};
void copy_value(const ListOfAddNodesItem& other_value);

public:
ListOfAddNodesItem();
ListOfAddNodesItem(const ListOfAddNodesItem& other_value);
~ListOfAddNodesItem();
ListOfAddNodesItem& operator=(const ListOfAddNodesItem& other_value);
boolean operator==(const ListOfAddNodesItem& other_value) const;
inline boolean operator!=(const ListOfAddNodesItem& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfAddNodesItemArray& realArray();
const ListOfAddNodesItemArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfAddNodesItem_template : public Base_Template {
union {
struct {
ListOfAddNodesItem::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfAddNodesItemArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfAddNodesItem_template *list_value;
} value_list;
};
void copy_value(const ListOfAddNodesItem& other_value);

void copy_template(const ListOfAddNodesItem_template& other_value);

public:
ListOfAddNodesItem_template();
ListOfAddNodesItem_template(template_sel other_value);
ListOfAddNodesItem_template(const ListOfAddNodesItem& other_value);
ListOfAddNodesItem_template(const OPTIONAL<ListOfAddNodesItem>& other_value);
ListOfAddNodesItem_template(const ListOfAddNodesItem_template& other_value);
~ListOfAddNodesItem_template();
void clean_up();
ListOfAddNodesItem_template& operator=(template_sel other_value);
ListOfAddNodesItem_template& operator=(const ListOfAddNodesItem& other_value);
ListOfAddNodesItem_template& operator=(const OPTIONAL<ListOfAddNodesItem>& other_value);
ListOfAddNodesItem_template& operator=(const ListOfAddNodesItem_template& other_value);
boolean match(const ListOfAddNodesItem& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfAddNodesItem valueof() const;
ListOfAddNodesItem_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfAddNodesItemArray_template& realArray();
const ListOfAddNodesItemArray_template& realArray() const;
boolean ischosen(ListOfAddNodesItem::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfAddNodesItem& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfAddNodesResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfAddNodesResultArray *field_realArray;
};
void copy_value(const ListOfAddNodesResult& other_value);

public:
ListOfAddNodesResult();
ListOfAddNodesResult(const ListOfAddNodesResult& other_value);
~ListOfAddNodesResult();
ListOfAddNodesResult& operator=(const ListOfAddNodesResult& other_value);
boolean operator==(const ListOfAddNodesResult& other_value) const;
inline boolean operator!=(const ListOfAddNodesResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfAddNodesResultArray& realArray();
const ListOfAddNodesResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfAddNodesResult_template : public Base_Template {
union {
struct {
ListOfAddNodesResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfAddNodesResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfAddNodesResult_template *list_value;
} value_list;
};
void copy_value(const ListOfAddNodesResult& other_value);

void copy_template(const ListOfAddNodesResult_template& other_value);

public:
ListOfAddNodesResult_template();
ListOfAddNodesResult_template(template_sel other_value);
ListOfAddNodesResult_template(const ListOfAddNodesResult& other_value);
ListOfAddNodesResult_template(const OPTIONAL<ListOfAddNodesResult>& other_value);
ListOfAddNodesResult_template(const ListOfAddNodesResult_template& other_value);
~ListOfAddNodesResult_template();
void clean_up();
ListOfAddNodesResult_template& operator=(template_sel other_value);
ListOfAddNodesResult_template& operator=(const ListOfAddNodesResult& other_value);
ListOfAddNodesResult_template& operator=(const OPTIONAL<ListOfAddNodesResult>& other_value);
ListOfAddNodesResult_template& operator=(const ListOfAddNodesResult_template& other_value);
boolean match(const ListOfAddNodesResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfAddNodesResult valueof() const;
ListOfAddNodesResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfAddNodesResultArray_template& realArray();
const ListOfAddNodesResultArray_template& realArray() const;
boolean ischosen(ListOfAddNodesResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfAddNodesResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfAddReferencesItem : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfAddReferencesItemArray *field_realArray;
};
void copy_value(const ListOfAddReferencesItem& other_value);

public:
ListOfAddReferencesItem();
ListOfAddReferencesItem(const ListOfAddReferencesItem& other_value);
~ListOfAddReferencesItem();
ListOfAddReferencesItem& operator=(const ListOfAddReferencesItem& other_value);
boolean operator==(const ListOfAddReferencesItem& other_value) const;
inline boolean operator!=(const ListOfAddReferencesItem& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfAddReferencesItemArray& realArray();
const ListOfAddReferencesItemArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfAddReferencesItem_template : public Base_Template {
union {
struct {
ListOfAddReferencesItem::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfAddReferencesItemArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfAddReferencesItem_template *list_value;
} value_list;
};
void copy_value(const ListOfAddReferencesItem& other_value);

void copy_template(const ListOfAddReferencesItem_template& other_value);

public:
ListOfAddReferencesItem_template();
ListOfAddReferencesItem_template(template_sel other_value);
ListOfAddReferencesItem_template(const ListOfAddReferencesItem& other_value);
ListOfAddReferencesItem_template(const OPTIONAL<ListOfAddReferencesItem>& other_value);
ListOfAddReferencesItem_template(const ListOfAddReferencesItem_template& other_value);
~ListOfAddReferencesItem_template();
void clean_up();
ListOfAddReferencesItem_template& operator=(template_sel other_value);
ListOfAddReferencesItem_template& operator=(const ListOfAddReferencesItem& other_value);
ListOfAddReferencesItem_template& operator=(const OPTIONAL<ListOfAddReferencesItem>& other_value);
ListOfAddReferencesItem_template& operator=(const ListOfAddReferencesItem_template& other_value);
boolean match(const ListOfAddReferencesItem& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfAddReferencesItem valueof() const;
ListOfAddReferencesItem_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfAddReferencesItemArray_template& realArray();
const ListOfAddReferencesItemArray_template& realArray() const;
boolean ischosen(ListOfAddReferencesItem::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfAddReferencesItem& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfDeleteNodesItem : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfDeleteNodesItemArray *field_realArray;
};
void copy_value(const ListOfDeleteNodesItem& other_value);

public:
ListOfDeleteNodesItem();
ListOfDeleteNodesItem(const ListOfDeleteNodesItem& other_value);
~ListOfDeleteNodesItem();
ListOfDeleteNodesItem& operator=(const ListOfDeleteNodesItem& other_value);
boolean operator==(const ListOfDeleteNodesItem& other_value) const;
inline boolean operator!=(const ListOfDeleteNodesItem& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfDeleteNodesItemArray& realArray();
const ListOfDeleteNodesItemArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDeleteNodesItem_template : public Base_Template {
union {
struct {
ListOfDeleteNodesItem::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfDeleteNodesItemArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfDeleteNodesItem_template *list_value;
} value_list;
};
void copy_value(const ListOfDeleteNodesItem& other_value);

void copy_template(const ListOfDeleteNodesItem_template& other_value);

public:
ListOfDeleteNodesItem_template();
ListOfDeleteNodesItem_template(template_sel other_value);
ListOfDeleteNodesItem_template(const ListOfDeleteNodesItem& other_value);
ListOfDeleteNodesItem_template(const OPTIONAL<ListOfDeleteNodesItem>& other_value);
ListOfDeleteNodesItem_template(const ListOfDeleteNodesItem_template& other_value);
~ListOfDeleteNodesItem_template();
void clean_up();
ListOfDeleteNodesItem_template& operator=(template_sel other_value);
ListOfDeleteNodesItem_template& operator=(const ListOfDeleteNodesItem& other_value);
ListOfDeleteNodesItem_template& operator=(const OPTIONAL<ListOfDeleteNodesItem>& other_value);
ListOfDeleteNodesItem_template& operator=(const ListOfDeleteNodesItem_template& other_value);
boolean match(const ListOfDeleteNodesItem& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfDeleteNodesItem valueof() const;
ListOfDeleteNodesItem_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfDeleteNodesItemArray_template& realArray();
const ListOfDeleteNodesItemArray_template& realArray() const;
boolean ischosen(ListOfDeleteNodesItem::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfDeleteNodesItem& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfDeleteReferencesItem : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfDeleteReferencesItemArray *field_realArray;
};
void copy_value(const ListOfDeleteReferencesItem& other_value);

public:
ListOfDeleteReferencesItem();
ListOfDeleteReferencesItem(const ListOfDeleteReferencesItem& other_value);
~ListOfDeleteReferencesItem();
ListOfDeleteReferencesItem& operator=(const ListOfDeleteReferencesItem& other_value);
boolean operator==(const ListOfDeleteReferencesItem& other_value) const;
inline boolean operator!=(const ListOfDeleteReferencesItem& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfDeleteReferencesItemArray& realArray();
const ListOfDeleteReferencesItemArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfDeleteReferencesItem_template : public Base_Template {
union {
struct {
ListOfDeleteReferencesItem::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfDeleteReferencesItemArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfDeleteReferencesItem_template *list_value;
} value_list;
};
void copy_value(const ListOfDeleteReferencesItem& other_value);

void copy_template(const ListOfDeleteReferencesItem_template& other_value);

public:
ListOfDeleteReferencesItem_template();
ListOfDeleteReferencesItem_template(template_sel other_value);
ListOfDeleteReferencesItem_template(const ListOfDeleteReferencesItem& other_value);
ListOfDeleteReferencesItem_template(const OPTIONAL<ListOfDeleteReferencesItem>& other_value);
ListOfDeleteReferencesItem_template(const ListOfDeleteReferencesItem_template& other_value);
~ListOfDeleteReferencesItem_template();
void clean_up();
ListOfDeleteReferencesItem_template& operator=(template_sel other_value);
ListOfDeleteReferencesItem_template& operator=(const ListOfDeleteReferencesItem& other_value);
ListOfDeleteReferencesItem_template& operator=(const OPTIONAL<ListOfDeleteReferencesItem>& other_value);
ListOfDeleteReferencesItem_template& operator=(const ListOfDeleteReferencesItem_template& other_value);
boolean match(const ListOfDeleteReferencesItem& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfDeleteReferencesItem valueof() const;
ListOfDeleteReferencesItem_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfDeleteReferencesItemArray_template& realArray();
const ListOfDeleteReferencesItemArray_template& realArray() const;
boolean ischosen(ListOfDeleteReferencesItem::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfDeleteReferencesItem& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfSignedSoftwareCertificate : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfSignedSoftwareCertificateArray *field_realArray;
};
void copy_value(const ListOfSignedSoftwareCertificate& other_value);

public:
ListOfSignedSoftwareCertificate();
ListOfSignedSoftwareCertificate(const ListOfSignedSoftwareCertificate& other_value);
~ListOfSignedSoftwareCertificate();
ListOfSignedSoftwareCertificate& operator=(const ListOfSignedSoftwareCertificate& other_value);
boolean operator==(const ListOfSignedSoftwareCertificate& other_value) const;
inline boolean operator!=(const ListOfSignedSoftwareCertificate& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfSignedSoftwareCertificateArray& realArray();
const ListOfSignedSoftwareCertificateArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfSignedSoftwareCertificate_template : public Base_Template {
union {
struct {
ListOfSignedSoftwareCertificate::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfSignedSoftwareCertificateArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfSignedSoftwareCertificate_template *list_value;
} value_list;
};
void copy_value(const ListOfSignedSoftwareCertificate& other_value);

void copy_template(const ListOfSignedSoftwareCertificate_template& other_value);

public:
ListOfSignedSoftwareCertificate_template();
ListOfSignedSoftwareCertificate_template(template_sel other_value);
ListOfSignedSoftwareCertificate_template(const ListOfSignedSoftwareCertificate& other_value);
ListOfSignedSoftwareCertificate_template(const OPTIONAL<ListOfSignedSoftwareCertificate>& other_value);
ListOfSignedSoftwareCertificate_template(const ListOfSignedSoftwareCertificate_template& other_value);
~ListOfSignedSoftwareCertificate_template();
void clean_up();
ListOfSignedSoftwareCertificate_template& operator=(template_sel other_value);
ListOfSignedSoftwareCertificate_template& operator=(const ListOfSignedSoftwareCertificate& other_value);
ListOfSignedSoftwareCertificate_template& operator=(const OPTIONAL<ListOfSignedSoftwareCertificate>& other_value);
ListOfSignedSoftwareCertificate_template& operator=(const ListOfSignedSoftwareCertificate_template& other_value);
boolean match(const ListOfSignedSoftwareCertificate& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfSignedSoftwareCertificate valueof() const;
ListOfSignedSoftwareCertificate_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfSignedSoftwareCertificateArray_template& realArray();
const ListOfSignedSoftwareCertificateArray_template& realArray() const;
boolean ischosen(ListOfSignedSoftwareCertificate::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfSignedSoftwareCertificate& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfBrowseDescription : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfBrowseDescriptionArray *field_realArray;
};
void copy_value(const ListOfBrowseDescription& other_value);

public:
ListOfBrowseDescription();
ListOfBrowseDescription(const ListOfBrowseDescription& other_value);
~ListOfBrowseDescription();
ListOfBrowseDescription& operator=(const ListOfBrowseDescription& other_value);
boolean operator==(const ListOfBrowseDescription& other_value) const;
inline boolean operator!=(const ListOfBrowseDescription& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfBrowseDescriptionArray& realArray();
const ListOfBrowseDescriptionArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowseDescription_template : public Base_Template {
union {
struct {
ListOfBrowseDescription::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfBrowseDescriptionArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfBrowseDescription_template *list_value;
} value_list;
};
void copy_value(const ListOfBrowseDescription& other_value);

void copy_template(const ListOfBrowseDescription_template& other_value);

public:
ListOfBrowseDescription_template();
ListOfBrowseDescription_template(template_sel other_value);
ListOfBrowseDescription_template(const ListOfBrowseDescription& other_value);
ListOfBrowseDescription_template(const OPTIONAL<ListOfBrowseDescription>& other_value);
ListOfBrowseDescription_template(const ListOfBrowseDescription_template& other_value);
~ListOfBrowseDescription_template();
void clean_up();
ListOfBrowseDescription_template& operator=(template_sel other_value);
ListOfBrowseDescription_template& operator=(const ListOfBrowseDescription& other_value);
ListOfBrowseDescription_template& operator=(const OPTIONAL<ListOfBrowseDescription>& other_value);
ListOfBrowseDescription_template& operator=(const ListOfBrowseDescription_template& other_value);
boolean match(const ListOfBrowseDescription& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfBrowseDescription valueof() const;
ListOfBrowseDescription_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfBrowseDescriptionArray_template& realArray();
const ListOfBrowseDescriptionArray_template& realArray() const;
boolean ischosen(ListOfBrowseDescription::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfBrowseDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfBrowsePath : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfBrowsePathArray *field_realArray;
};
void copy_value(const ListOfBrowsePath& other_value);

public:
ListOfBrowsePath();
ListOfBrowsePath(const ListOfBrowsePath& other_value);
~ListOfBrowsePath();
ListOfBrowsePath& operator=(const ListOfBrowsePath& other_value);
boolean operator==(const ListOfBrowsePath& other_value) const;
inline boolean operator!=(const ListOfBrowsePath& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfBrowsePathArray& realArray();
const ListOfBrowsePathArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowsePath_template : public Base_Template {
union {
struct {
ListOfBrowsePath::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfBrowsePathArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfBrowsePath_template *list_value;
} value_list;
};
void copy_value(const ListOfBrowsePath& other_value);

void copy_template(const ListOfBrowsePath_template& other_value);

public:
ListOfBrowsePath_template();
ListOfBrowsePath_template(template_sel other_value);
ListOfBrowsePath_template(const ListOfBrowsePath& other_value);
ListOfBrowsePath_template(const OPTIONAL<ListOfBrowsePath>& other_value);
ListOfBrowsePath_template(const ListOfBrowsePath_template& other_value);
~ListOfBrowsePath_template();
void clean_up();
ListOfBrowsePath_template& operator=(template_sel other_value);
ListOfBrowsePath_template& operator=(const ListOfBrowsePath& other_value);
ListOfBrowsePath_template& operator=(const OPTIONAL<ListOfBrowsePath>& other_value);
ListOfBrowsePath_template& operator=(const ListOfBrowsePath_template& other_value);
boolean match(const ListOfBrowsePath& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfBrowsePath valueof() const;
ListOfBrowsePath_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfBrowsePathArray_template& realArray();
const ListOfBrowsePathArray_template& realArray() const;
boolean ischosen(ListOfBrowsePath::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfBrowsePath& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfBrowsePathResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfBrowsePathResultArray *field_realArray;
};
void copy_value(const ListOfBrowsePathResult& other_value);

public:
ListOfBrowsePathResult();
ListOfBrowsePathResult(const ListOfBrowsePathResult& other_value);
~ListOfBrowsePathResult();
ListOfBrowsePathResult& operator=(const ListOfBrowsePathResult& other_value);
boolean operator==(const ListOfBrowsePathResult& other_value) const;
inline boolean operator!=(const ListOfBrowsePathResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfBrowsePathResultArray& realArray();
const ListOfBrowsePathResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfBrowsePathResult_template : public Base_Template {
union {
struct {
ListOfBrowsePathResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfBrowsePathResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfBrowsePathResult_template *list_value;
} value_list;
};
void copy_value(const ListOfBrowsePathResult& other_value);

void copy_template(const ListOfBrowsePathResult_template& other_value);

public:
ListOfBrowsePathResult_template();
ListOfBrowsePathResult_template(template_sel other_value);
ListOfBrowsePathResult_template(const ListOfBrowsePathResult& other_value);
ListOfBrowsePathResult_template(const OPTIONAL<ListOfBrowsePathResult>& other_value);
ListOfBrowsePathResult_template(const ListOfBrowsePathResult_template& other_value);
~ListOfBrowsePathResult_template();
void clean_up();
ListOfBrowsePathResult_template& operator=(template_sel other_value);
ListOfBrowsePathResult_template& operator=(const ListOfBrowsePathResult& other_value);
ListOfBrowsePathResult_template& operator=(const OPTIONAL<ListOfBrowsePathResult>& other_value);
ListOfBrowsePathResult_template& operator=(const ListOfBrowsePathResult_template& other_value);
boolean match(const ListOfBrowsePathResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfBrowsePathResult valueof() const;
ListOfBrowsePathResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfBrowsePathResultArray_template& realArray();
const ListOfBrowsePathResultArray_template& realArray() const;
boolean ischosen(ListOfBrowsePathResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfBrowsePathResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfNodeTypeDescription : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfNodeTypeDescriptionArray *field_realArray;
};
void copy_value(const ListOfNodeTypeDescription& other_value);

public:
ListOfNodeTypeDescription();
ListOfNodeTypeDescription(const ListOfNodeTypeDescription& other_value);
~ListOfNodeTypeDescription();
ListOfNodeTypeDescription& operator=(const ListOfNodeTypeDescription& other_value);
boolean operator==(const ListOfNodeTypeDescription& other_value) const;
inline boolean operator!=(const ListOfNodeTypeDescription& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfNodeTypeDescriptionArray& realArray();
const ListOfNodeTypeDescriptionArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfNodeTypeDescription_template : public Base_Template {
union {
struct {
ListOfNodeTypeDescription::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfNodeTypeDescriptionArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfNodeTypeDescription_template *list_value;
} value_list;
};
void copy_value(const ListOfNodeTypeDescription& other_value);

void copy_template(const ListOfNodeTypeDescription_template& other_value);

public:
ListOfNodeTypeDescription_template();
ListOfNodeTypeDescription_template(template_sel other_value);
ListOfNodeTypeDescription_template(const ListOfNodeTypeDescription& other_value);
ListOfNodeTypeDescription_template(const OPTIONAL<ListOfNodeTypeDescription>& other_value);
ListOfNodeTypeDescription_template(const ListOfNodeTypeDescription_template& other_value);
~ListOfNodeTypeDescription_template();
void clean_up();
ListOfNodeTypeDescription_template& operator=(template_sel other_value);
ListOfNodeTypeDescription_template& operator=(const ListOfNodeTypeDescription& other_value);
ListOfNodeTypeDescription_template& operator=(const OPTIONAL<ListOfNodeTypeDescription>& other_value);
ListOfNodeTypeDescription_template& operator=(const ListOfNodeTypeDescription_template& other_value);
boolean match(const ListOfNodeTypeDescription& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfNodeTypeDescription valueof() const;
ListOfNodeTypeDescription_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfNodeTypeDescriptionArray_template& realArray();
const ListOfNodeTypeDescriptionArray_template& realArray() const;
boolean ischosen(ListOfNodeTypeDescription::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfNodeTypeDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfParsingResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfParsingResultArray *field_realArray;
};
void copy_value(const ListOfParsingResult& other_value);

public:
ListOfParsingResult();
ListOfParsingResult(const ListOfParsingResult& other_value);
~ListOfParsingResult();
ListOfParsingResult& operator=(const ListOfParsingResult& other_value);
boolean operator==(const ListOfParsingResult& other_value) const;
inline boolean operator!=(const ListOfParsingResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfParsingResultArray& realArray();
const ListOfParsingResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfParsingResult_template : public Base_Template {
union {
struct {
ListOfParsingResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfParsingResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfParsingResult_template *list_value;
} value_list;
};
void copy_value(const ListOfParsingResult& other_value);

void copy_template(const ListOfParsingResult_template& other_value);

public:
ListOfParsingResult_template();
ListOfParsingResult_template(template_sel other_value);
ListOfParsingResult_template(const ListOfParsingResult& other_value);
ListOfParsingResult_template(const OPTIONAL<ListOfParsingResult>& other_value);
ListOfParsingResult_template(const ListOfParsingResult_template& other_value);
~ListOfParsingResult_template();
void clean_up();
ListOfParsingResult_template& operator=(template_sel other_value);
ListOfParsingResult_template& operator=(const ListOfParsingResult& other_value);
ListOfParsingResult_template& operator=(const OPTIONAL<ListOfParsingResult>& other_value);
ListOfParsingResult_template& operator=(const ListOfParsingResult_template& other_value);
boolean match(const ListOfParsingResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfParsingResult valueof() const;
ListOfParsingResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfParsingResultArray_template& realArray();
const ListOfParsingResultArray_template& realArray() const;
boolean ischosen(ListOfParsingResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfParsingResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfHistoryReadValueId : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfHistoryReadValueIdArray *field_realArray;
};
void copy_value(const ListOfHistoryReadValueId& other_value);

public:
ListOfHistoryReadValueId();
ListOfHistoryReadValueId(const ListOfHistoryReadValueId& other_value);
~ListOfHistoryReadValueId();
ListOfHistoryReadValueId& operator=(const ListOfHistoryReadValueId& other_value);
boolean operator==(const ListOfHistoryReadValueId& other_value) const;
inline boolean operator!=(const ListOfHistoryReadValueId& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfHistoryReadValueIdArray& realArray();
const ListOfHistoryReadValueIdArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfHistoryReadValueId_template : public Base_Template {
union {
struct {
ListOfHistoryReadValueId::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfHistoryReadValueIdArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfHistoryReadValueId_template *list_value;
} value_list;
};
void copy_value(const ListOfHistoryReadValueId& other_value);

void copy_template(const ListOfHistoryReadValueId_template& other_value);

public:
ListOfHistoryReadValueId_template();
ListOfHistoryReadValueId_template(template_sel other_value);
ListOfHistoryReadValueId_template(const ListOfHistoryReadValueId& other_value);
ListOfHistoryReadValueId_template(const OPTIONAL<ListOfHistoryReadValueId>& other_value);
ListOfHistoryReadValueId_template(const ListOfHistoryReadValueId_template& other_value);
~ListOfHistoryReadValueId_template();
void clean_up();
ListOfHistoryReadValueId_template& operator=(template_sel other_value);
ListOfHistoryReadValueId_template& operator=(const ListOfHistoryReadValueId& other_value);
ListOfHistoryReadValueId_template& operator=(const OPTIONAL<ListOfHistoryReadValueId>& other_value);
ListOfHistoryReadValueId_template& operator=(const ListOfHistoryReadValueId_template& other_value);
boolean match(const ListOfHistoryReadValueId& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfHistoryReadValueId valueof() const;
ListOfHistoryReadValueId_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfHistoryReadValueIdArray_template& realArray();
const ListOfHistoryReadValueIdArray_template& realArray() const;
boolean ischosen(ListOfHistoryReadValueId::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfHistoryReadValueId& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfHistoryReadResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfHistoryReadResultArray *field_realArray;
};
void copy_value(const ListOfHistoryReadResult& other_value);

public:
ListOfHistoryReadResult();
ListOfHistoryReadResult(const ListOfHistoryReadResult& other_value);
~ListOfHistoryReadResult();
ListOfHistoryReadResult& operator=(const ListOfHistoryReadResult& other_value);
boolean operator==(const ListOfHistoryReadResult& other_value) const;
inline boolean operator!=(const ListOfHistoryReadResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfHistoryReadResultArray& realArray();
const ListOfHistoryReadResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfHistoryReadResult_template : public Base_Template {
union {
struct {
ListOfHistoryReadResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfHistoryReadResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfHistoryReadResult_template *list_value;
} value_list;
};
void copy_value(const ListOfHistoryReadResult& other_value);

void copy_template(const ListOfHistoryReadResult_template& other_value);

public:
ListOfHistoryReadResult_template();
ListOfHistoryReadResult_template(template_sel other_value);
ListOfHistoryReadResult_template(const ListOfHistoryReadResult& other_value);
ListOfHistoryReadResult_template(const OPTIONAL<ListOfHistoryReadResult>& other_value);
ListOfHistoryReadResult_template(const ListOfHistoryReadResult_template& other_value);
~ListOfHistoryReadResult_template();
void clean_up();
ListOfHistoryReadResult_template& operator=(template_sel other_value);
ListOfHistoryReadResult_template& operator=(const ListOfHistoryReadResult& other_value);
ListOfHistoryReadResult_template& operator=(const OPTIONAL<ListOfHistoryReadResult>& other_value);
ListOfHistoryReadResult_template& operator=(const ListOfHistoryReadResult_template& other_value);
boolean match(const ListOfHistoryReadResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfHistoryReadResult valueof() const;
ListOfHistoryReadResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfHistoryReadResultArray_template& realArray();
const ListOfHistoryReadResultArray_template& realArray() const;
boolean ischosen(ListOfHistoryReadResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfHistoryReadResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfWriteValue : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfWriteValueArray *field_realArray;
};
void copy_value(const ListOfWriteValue& other_value);

public:
ListOfWriteValue();
ListOfWriteValue(const ListOfWriteValue& other_value);
~ListOfWriteValue();
ListOfWriteValue& operator=(const ListOfWriteValue& other_value);
boolean operator==(const ListOfWriteValue& other_value) const;
inline boolean operator!=(const ListOfWriteValue& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfWriteValueArray& realArray();
const ListOfWriteValueArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfWriteValue_template : public Base_Template {
union {
struct {
ListOfWriteValue::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfWriteValueArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfWriteValue_template *list_value;
} value_list;
};
void copy_value(const ListOfWriteValue& other_value);

void copy_template(const ListOfWriteValue_template& other_value);

public:
ListOfWriteValue_template();
ListOfWriteValue_template(template_sel other_value);
ListOfWriteValue_template(const ListOfWriteValue& other_value);
ListOfWriteValue_template(const OPTIONAL<ListOfWriteValue>& other_value);
ListOfWriteValue_template(const ListOfWriteValue_template& other_value);
~ListOfWriteValue_template();
void clean_up();
ListOfWriteValue_template& operator=(template_sel other_value);
ListOfWriteValue_template& operator=(const ListOfWriteValue& other_value);
ListOfWriteValue_template& operator=(const OPTIONAL<ListOfWriteValue>& other_value);
ListOfWriteValue_template& operator=(const ListOfWriteValue_template& other_value);
boolean match(const ListOfWriteValue& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfWriteValue valueof() const;
ListOfWriteValue_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfWriteValueArray_template& realArray();
const ListOfWriteValueArray_template& realArray() const;
boolean ischosen(ListOfWriteValue::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfWriteValue& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfHistoryUpdateResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfHistoryUpdateResultArray *field_realArray;
};
void copy_value(const ListOfHistoryUpdateResult& other_value);

public:
ListOfHistoryUpdateResult();
ListOfHistoryUpdateResult(const ListOfHistoryUpdateResult& other_value);
~ListOfHistoryUpdateResult();
ListOfHistoryUpdateResult& operator=(const ListOfHistoryUpdateResult& other_value);
boolean operator==(const ListOfHistoryUpdateResult& other_value) const;
inline boolean operator!=(const ListOfHistoryUpdateResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfHistoryUpdateResultArray& realArray();
const ListOfHistoryUpdateResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfHistoryUpdateResult_template : public Base_Template {
union {
struct {
ListOfHistoryUpdateResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfHistoryUpdateResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfHistoryUpdateResult_template *list_value;
} value_list;
};
void copy_value(const ListOfHistoryUpdateResult& other_value);

void copy_template(const ListOfHistoryUpdateResult_template& other_value);

public:
ListOfHistoryUpdateResult_template();
ListOfHistoryUpdateResult_template(template_sel other_value);
ListOfHistoryUpdateResult_template(const ListOfHistoryUpdateResult& other_value);
ListOfHistoryUpdateResult_template(const OPTIONAL<ListOfHistoryUpdateResult>& other_value);
ListOfHistoryUpdateResult_template(const ListOfHistoryUpdateResult_template& other_value);
~ListOfHistoryUpdateResult_template();
void clean_up();
ListOfHistoryUpdateResult_template& operator=(template_sel other_value);
ListOfHistoryUpdateResult_template& operator=(const ListOfHistoryUpdateResult& other_value);
ListOfHistoryUpdateResult_template& operator=(const OPTIONAL<ListOfHistoryUpdateResult>& other_value);
ListOfHistoryUpdateResult_template& operator=(const ListOfHistoryUpdateResult_template& other_value);
boolean match(const ListOfHistoryUpdateResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfHistoryUpdateResult valueof() const;
ListOfHistoryUpdateResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfHistoryUpdateResultArray_template& realArray();
const ListOfHistoryUpdateResultArray_template& realArray() const;
boolean ischosen(ListOfHistoryUpdateResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfHistoryUpdateResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfCallMethodRequest : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfCallMethodRequestArray *field_realArray;
};
void copy_value(const ListOfCallMethodRequest& other_value);

public:
ListOfCallMethodRequest();
ListOfCallMethodRequest(const ListOfCallMethodRequest& other_value);
~ListOfCallMethodRequest();
ListOfCallMethodRequest& operator=(const ListOfCallMethodRequest& other_value);
boolean operator==(const ListOfCallMethodRequest& other_value) const;
inline boolean operator!=(const ListOfCallMethodRequest& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfCallMethodRequestArray& realArray();
const ListOfCallMethodRequestArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfCallMethodRequest_template : public Base_Template {
union {
struct {
ListOfCallMethodRequest::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfCallMethodRequestArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfCallMethodRequest_template *list_value;
} value_list;
};
void copy_value(const ListOfCallMethodRequest& other_value);

void copy_template(const ListOfCallMethodRequest_template& other_value);

public:
ListOfCallMethodRequest_template();
ListOfCallMethodRequest_template(template_sel other_value);
ListOfCallMethodRequest_template(const ListOfCallMethodRequest& other_value);
ListOfCallMethodRequest_template(const OPTIONAL<ListOfCallMethodRequest>& other_value);
ListOfCallMethodRequest_template(const ListOfCallMethodRequest_template& other_value);
~ListOfCallMethodRequest_template();
void clean_up();
ListOfCallMethodRequest_template& operator=(template_sel other_value);
ListOfCallMethodRequest_template& operator=(const ListOfCallMethodRequest& other_value);
ListOfCallMethodRequest_template& operator=(const OPTIONAL<ListOfCallMethodRequest>& other_value);
ListOfCallMethodRequest_template& operator=(const ListOfCallMethodRequest_template& other_value);
boolean match(const ListOfCallMethodRequest& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfCallMethodRequest valueof() const;
ListOfCallMethodRequest_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfCallMethodRequestArray_template& realArray();
const ListOfCallMethodRequestArray_template& realArray() const;
boolean ischosen(ListOfCallMethodRequest::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfCallMethodRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfCallMethodResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfCallMethodResultArray *field_realArray;
};
void copy_value(const ListOfCallMethodResult& other_value);

public:
ListOfCallMethodResult();
ListOfCallMethodResult(const ListOfCallMethodResult& other_value);
~ListOfCallMethodResult();
ListOfCallMethodResult& operator=(const ListOfCallMethodResult& other_value);
boolean operator==(const ListOfCallMethodResult& other_value) const;
inline boolean operator!=(const ListOfCallMethodResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfCallMethodResultArray& realArray();
const ListOfCallMethodResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfCallMethodResult_template : public Base_Template {
union {
struct {
ListOfCallMethodResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfCallMethodResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfCallMethodResult_template *list_value;
} value_list;
};
void copy_value(const ListOfCallMethodResult& other_value);

void copy_template(const ListOfCallMethodResult_template& other_value);

public:
ListOfCallMethodResult_template();
ListOfCallMethodResult_template(template_sel other_value);
ListOfCallMethodResult_template(const ListOfCallMethodResult& other_value);
ListOfCallMethodResult_template(const OPTIONAL<ListOfCallMethodResult>& other_value);
ListOfCallMethodResult_template(const ListOfCallMethodResult_template& other_value);
~ListOfCallMethodResult_template();
void clean_up();
ListOfCallMethodResult_template& operator=(template_sel other_value);
ListOfCallMethodResult_template& operator=(const ListOfCallMethodResult& other_value);
ListOfCallMethodResult_template& operator=(const OPTIONAL<ListOfCallMethodResult>& other_value);
ListOfCallMethodResult_template& operator=(const ListOfCallMethodResult_template& other_value);
boolean match(const ListOfCallMethodResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfCallMethodResult valueof() const;
ListOfCallMethodResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfCallMethodResultArray_template& realArray();
const ListOfCallMethodResultArray_template& realArray() const;
boolean ischosen(ListOfCallMethodResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfCallMethodResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfMonitoredItemCreateRequest : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfMonitoredItemCreateRequestArray *field_realArray;
};
void copy_value(const ListOfMonitoredItemCreateRequest& other_value);

public:
ListOfMonitoredItemCreateRequest();
ListOfMonitoredItemCreateRequest(const ListOfMonitoredItemCreateRequest& other_value);
~ListOfMonitoredItemCreateRequest();
ListOfMonitoredItemCreateRequest& operator=(const ListOfMonitoredItemCreateRequest& other_value);
boolean operator==(const ListOfMonitoredItemCreateRequest& other_value) const;
inline boolean operator!=(const ListOfMonitoredItemCreateRequest& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfMonitoredItemCreateRequestArray& realArray();
const ListOfMonitoredItemCreateRequestArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemCreateRequest_template : public Base_Template {
union {
struct {
ListOfMonitoredItemCreateRequest::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfMonitoredItemCreateRequestArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemCreateRequest_template *list_value;
} value_list;
};
void copy_value(const ListOfMonitoredItemCreateRequest& other_value);

void copy_template(const ListOfMonitoredItemCreateRequest_template& other_value);

public:
ListOfMonitoredItemCreateRequest_template();
ListOfMonitoredItemCreateRequest_template(template_sel other_value);
ListOfMonitoredItemCreateRequest_template(const ListOfMonitoredItemCreateRequest& other_value);
ListOfMonitoredItemCreateRequest_template(const OPTIONAL<ListOfMonitoredItemCreateRequest>& other_value);
ListOfMonitoredItemCreateRequest_template(const ListOfMonitoredItemCreateRequest_template& other_value);
~ListOfMonitoredItemCreateRequest_template();
void clean_up();
ListOfMonitoredItemCreateRequest_template& operator=(template_sel other_value);
ListOfMonitoredItemCreateRequest_template& operator=(const ListOfMonitoredItemCreateRequest& other_value);
ListOfMonitoredItemCreateRequest_template& operator=(const OPTIONAL<ListOfMonitoredItemCreateRequest>& other_value);
ListOfMonitoredItemCreateRequest_template& operator=(const ListOfMonitoredItemCreateRequest_template& other_value);
boolean match(const ListOfMonitoredItemCreateRequest& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfMonitoredItemCreateRequest valueof() const;
ListOfMonitoredItemCreateRequest_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfMonitoredItemCreateRequestArray_template& realArray();
const ListOfMonitoredItemCreateRequestArray_template& realArray() const;
boolean ischosen(ListOfMonitoredItemCreateRequest::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfMonitoredItemCreateRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfMonitoredItemCreateResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfMonitoredItemCreateResultArray *field_realArray;
};
void copy_value(const ListOfMonitoredItemCreateResult& other_value);

public:
ListOfMonitoredItemCreateResult();
ListOfMonitoredItemCreateResult(const ListOfMonitoredItemCreateResult& other_value);
~ListOfMonitoredItemCreateResult();
ListOfMonitoredItemCreateResult& operator=(const ListOfMonitoredItemCreateResult& other_value);
boolean operator==(const ListOfMonitoredItemCreateResult& other_value) const;
inline boolean operator!=(const ListOfMonitoredItemCreateResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfMonitoredItemCreateResultArray& realArray();
const ListOfMonitoredItemCreateResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemCreateResult_template : public Base_Template {
union {
struct {
ListOfMonitoredItemCreateResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfMonitoredItemCreateResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemCreateResult_template *list_value;
} value_list;
};
void copy_value(const ListOfMonitoredItemCreateResult& other_value);

void copy_template(const ListOfMonitoredItemCreateResult_template& other_value);

public:
ListOfMonitoredItemCreateResult_template();
ListOfMonitoredItemCreateResult_template(template_sel other_value);
ListOfMonitoredItemCreateResult_template(const ListOfMonitoredItemCreateResult& other_value);
ListOfMonitoredItemCreateResult_template(const OPTIONAL<ListOfMonitoredItemCreateResult>& other_value);
ListOfMonitoredItemCreateResult_template(const ListOfMonitoredItemCreateResult_template& other_value);
~ListOfMonitoredItemCreateResult_template();
void clean_up();
ListOfMonitoredItemCreateResult_template& operator=(template_sel other_value);
ListOfMonitoredItemCreateResult_template& operator=(const ListOfMonitoredItemCreateResult& other_value);
ListOfMonitoredItemCreateResult_template& operator=(const OPTIONAL<ListOfMonitoredItemCreateResult>& other_value);
ListOfMonitoredItemCreateResult_template& operator=(const ListOfMonitoredItemCreateResult_template& other_value);
boolean match(const ListOfMonitoredItemCreateResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfMonitoredItemCreateResult valueof() const;
ListOfMonitoredItemCreateResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfMonitoredItemCreateResultArray_template& realArray();
const ListOfMonitoredItemCreateResultArray_template& realArray() const;
boolean ischosen(ListOfMonitoredItemCreateResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfMonitoredItemCreateResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfMonitoredItemModifyRequest : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfMonitoredItemModifyRequestArray *field_realArray;
};
void copy_value(const ListOfMonitoredItemModifyRequest& other_value);

public:
ListOfMonitoredItemModifyRequest();
ListOfMonitoredItemModifyRequest(const ListOfMonitoredItemModifyRequest& other_value);
~ListOfMonitoredItemModifyRequest();
ListOfMonitoredItemModifyRequest& operator=(const ListOfMonitoredItemModifyRequest& other_value);
boolean operator==(const ListOfMonitoredItemModifyRequest& other_value) const;
inline boolean operator!=(const ListOfMonitoredItemModifyRequest& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfMonitoredItemModifyRequestArray& realArray();
const ListOfMonitoredItemModifyRequestArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemModifyRequest_template : public Base_Template {
union {
struct {
ListOfMonitoredItemModifyRequest::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfMonitoredItemModifyRequestArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemModifyRequest_template *list_value;
} value_list;
};
void copy_value(const ListOfMonitoredItemModifyRequest& other_value);

void copy_template(const ListOfMonitoredItemModifyRequest_template& other_value);

public:
ListOfMonitoredItemModifyRequest_template();
ListOfMonitoredItemModifyRequest_template(template_sel other_value);
ListOfMonitoredItemModifyRequest_template(const ListOfMonitoredItemModifyRequest& other_value);
ListOfMonitoredItemModifyRequest_template(const OPTIONAL<ListOfMonitoredItemModifyRequest>& other_value);
ListOfMonitoredItemModifyRequest_template(const ListOfMonitoredItemModifyRequest_template& other_value);
~ListOfMonitoredItemModifyRequest_template();
void clean_up();
ListOfMonitoredItemModifyRequest_template& operator=(template_sel other_value);
ListOfMonitoredItemModifyRequest_template& operator=(const ListOfMonitoredItemModifyRequest& other_value);
ListOfMonitoredItemModifyRequest_template& operator=(const OPTIONAL<ListOfMonitoredItemModifyRequest>& other_value);
ListOfMonitoredItemModifyRequest_template& operator=(const ListOfMonitoredItemModifyRequest_template& other_value);
boolean match(const ListOfMonitoredItemModifyRequest& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfMonitoredItemModifyRequest valueof() const;
ListOfMonitoredItemModifyRequest_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfMonitoredItemModifyRequestArray_template& realArray();
const ListOfMonitoredItemModifyRequestArray_template& realArray() const;
boolean ischosen(ListOfMonitoredItemModifyRequest::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfMonitoredItemModifyRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfMonitoredItemModifyResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfMonitoredItemModifyResultArray *field_realArray;
};
void copy_value(const ListOfMonitoredItemModifyResult& other_value);

public:
ListOfMonitoredItemModifyResult();
ListOfMonitoredItemModifyResult(const ListOfMonitoredItemModifyResult& other_value);
~ListOfMonitoredItemModifyResult();
ListOfMonitoredItemModifyResult& operator=(const ListOfMonitoredItemModifyResult& other_value);
boolean operator==(const ListOfMonitoredItemModifyResult& other_value) const;
inline boolean operator!=(const ListOfMonitoredItemModifyResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfMonitoredItemModifyResultArray& realArray();
const ListOfMonitoredItemModifyResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfMonitoredItemModifyResult_template : public Base_Template {
union {
struct {
ListOfMonitoredItemModifyResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfMonitoredItemModifyResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfMonitoredItemModifyResult_template *list_value;
} value_list;
};
void copy_value(const ListOfMonitoredItemModifyResult& other_value);

void copy_template(const ListOfMonitoredItemModifyResult_template& other_value);

public:
ListOfMonitoredItemModifyResult_template();
ListOfMonitoredItemModifyResult_template(template_sel other_value);
ListOfMonitoredItemModifyResult_template(const ListOfMonitoredItemModifyResult& other_value);
ListOfMonitoredItemModifyResult_template(const OPTIONAL<ListOfMonitoredItemModifyResult>& other_value);
ListOfMonitoredItemModifyResult_template(const ListOfMonitoredItemModifyResult_template& other_value);
~ListOfMonitoredItemModifyResult_template();
void clean_up();
ListOfMonitoredItemModifyResult_template& operator=(template_sel other_value);
ListOfMonitoredItemModifyResult_template& operator=(const ListOfMonitoredItemModifyResult& other_value);
ListOfMonitoredItemModifyResult_template& operator=(const OPTIONAL<ListOfMonitoredItemModifyResult>& other_value);
ListOfMonitoredItemModifyResult_template& operator=(const ListOfMonitoredItemModifyResult_template& other_value);
boolean match(const ListOfMonitoredItemModifyResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfMonitoredItemModifyResult valueof() const;
ListOfMonitoredItemModifyResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfMonitoredItemModifyResultArray_template& realArray();
const ListOfMonitoredItemModifyResultArray_template& realArray() const;
boolean ischosen(ListOfMonitoredItemModifyResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfMonitoredItemModifyResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfSubscriptionAcknowledgement : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfSubscriptionAcknowledgementArray *field_realArray;
};
void copy_value(const ListOfSubscriptionAcknowledgement& other_value);

public:
ListOfSubscriptionAcknowledgement();
ListOfSubscriptionAcknowledgement(const ListOfSubscriptionAcknowledgement& other_value);
~ListOfSubscriptionAcknowledgement();
ListOfSubscriptionAcknowledgement& operator=(const ListOfSubscriptionAcknowledgement& other_value);
boolean operator==(const ListOfSubscriptionAcknowledgement& other_value) const;
inline boolean operator!=(const ListOfSubscriptionAcknowledgement& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfSubscriptionAcknowledgementArray& realArray();
const ListOfSubscriptionAcknowledgementArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfSubscriptionAcknowledgement_template : public Base_Template {
union {
struct {
ListOfSubscriptionAcknowledgement::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfSubscriptionAcknowledgementArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfSubscriptionAcknowledgement_template *list_value;
} value_list;
};
void copy_value(const ListOfSubscriptionAcknowledgement& other_value);

void copy_template(const ListOfSubscriptionAcknowledgement_template& other_value);

public:
ListOfSubscriptionAcknowledgement_template();
ListOfSubscriptionAcknowledgement_template(template_sel other_value);
ListOfSubscriptionAcknowledgement_template(const ListOfSubscriptionAcknowledgement& other_value);
ListOfSubscriptionAcknowledgement_template(const OPTIONAL<ListOfSubscriptionAcknowledgement>& other_value);
ListOfSubscriptionAcknowledgement_template(const ListOfSubscriptionAcknowledgement_template& other_value);
~ListOfSubscriptionAcknowledgement_template();
void clean_up();
ListOfSubscriptionAcknowledgement_template& operator=(template_sel other_value);
ListOfSubscriptionAcknowledgement_template& operator=(const ListOfSubscriptionAcknowledgement& other_value);
ListOfSubscriptionAcknowledgement_template& operator=(const OPTIONAL<ListOfSubscriptionAcknowledgement>& other_value);
ListOfSubscriptionAcknowledgement_template& operator=(const ListOfSubscriptionAcknowledgement_template& other_value);
boolean match(const ListOfSubscriptionAcknowledgement& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfSubscriptionAcknowledgement valueof() const;
ListOfSubscriptionAcknowledgement_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfSubscriptionAcknowledgementArray_template& realArray();
const ListOfSubscriptionAcknowledgementArray_template& realArray() const;
boolean ischosen(ListOfSubscriptionAcknowledgement::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfSubscriptionAcknowledgement& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class ListOfTransferResult : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_nullArray = 1, ALT_realArray = 2 };
private:
union_selection_type union_selection;
union {
NullArray *field_nullArray;
ListOfTransferResultArray *field_realArray;
};
void copy_value(const ListOfTransferResult& other_value);

public:
ListOfTransferResult();
ListOfTransferResult(const ListOfTransferResult& other_value);
~ListOfTransferResult();
ListOfTransferResult& operator=(const ListOfTransferResult& other_value);
boolean operator==(const ListOfTransferResult& other_value) const;
inline boolean operator!=(const ListOfTransferResult& other_value) const { return !(*this == other_value); }
NullArray& nullArray();
const NullArray& nullArray() const;
ListOfTransferResultArray& realArray();
const ListOfTransferResultArray& realArray() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ListOfTransferResult_template : public Base_Template {
union {
struct {
ListOfTransferResult::union_selection_type union_selection;
union {
NullArray_template *field_nullArray;
ListOfTransferResultArray_template *field_realArray;
};
} single_value;
struct {
unsigned int n_values;
ListOfTransferResult_template *list_value;
} value_list;
};
void copy_value(const ListOfTransferResult& other_value);

void copy_template(const ListOfTransferResult_template& other_value);

public:
ListOfTransferResult_template();
ListOfTransferResult_template(template_sel other_value);
ListOfTransferResult_template(const ListOfTransferResult& other_value);
ListOfTransferResult_template(const OPTIONAL<ListOfTransferResult>& other_value);
ListOfTransferResult_template(const ListOfTransferResult_template& other_value);
~ListOfTransferResult_template();
void clean_up();
ListOfTransferResult_template& operator=(template_sel other_value);
ListOfTransferResult_template& operator=(const ListOfTransferResult& other_value);
ListOfTransferResult_template& operator=(const OPTIONAL<ListOfTransferResult>& other_value);
ListOfTransferResult_template& operator=(const ListOfTransferResult_template& other_value);
boolean match(const ListOfTransferResult& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ListOfTransferResult valueof() const;
ListOfTransferResult_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
NullArray_template& nullArray();
const NullArray_template& nullArray() const;
ListOfTransferResultArray_template& realArray();
const ListOfTransferResultArray_template& realArray() const;
boolean ischosen(ListOfTransferResult::union_selection_type checked_selection) const;
void log() const;
void log_match(const ListOfTransferResult& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class NotificationMessage : public Base_Type {
  INTEGER field_sequenceNumber;
  INTEGER field_publishTime;
  ListOfExtensibleParameter field_notificationData;
public:
  NotificationMessage();
  NotificationMessage(const INTEGER& par_sequenceNumber,
    const INTEGER& par_publishTime,
    const ListOfExtensibleParameter& par_notificationData);
  NotificationMessage(const NotificationMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  NotificationMessage& operator=(const NotificationMessage& other_value);
  boolean operator==(const NotificationMessage& other_value) const;
  inline boolean operator!=(const NotificationMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& sequenceNumber()
    {return field_sequenceNumber;}
  inline const INTEGER& sequenceNumber() const
    {return field_sequenceNumber;}
  inline INTEGER& publishTime()
    {return field_publishTime;}
  inline const INTEGER& publishTime() const
    {return field_publishTime;}
  inline ListOfExtensibleParameter& notificationData()
    {return field_notificationData;}
  inline const ListOfExtensibleParameter& notificationData() const
    {return field_notificationData;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class NotificationMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
NotificationMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const NotificationMessage& other_value);
void copy_template(const NotificationMessage_template& other_value);

public:
NotificationMessage_template();
NotificationMessage_template(template_sel other_value);
NotificationMessage_template(const NotificationMessage& other_value);
NotificationMessage_template(const OPTIONAL<NotificationMessage>& other_value);
NotificationMessage_template(const NotificationMessage_template& other_value);
~NotificationMessage_template();
NotificationMessage_template& operator=(template_sel other_value);
NotificationMessage_template& operator=(const NotificationMessage& other_value);
NotificationMessage_template& operator=(const OPTIONAL<NotificationMessage>& other_value);
NotificationMessage_template& operator=(const NotificationMessage_template& other_value);
boolean match(const NotificationMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
NotificationMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
NotificationMessage_template& list_item(unsigned int list_index) const;
INTEGER_template& sequenceNumber();
const INTEGER_template& sequenceNumber() const;
INTEGER_template& publishTime();
const INTEGER_template& publishTime() const;
ListOfExtensibleParameter_template& notificationData();
const ListOfExtensibleParameter_template& notificationData() const;
int size_of() const;
void log() const;
void log_match(const NotificationMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegisteredServer : public Base_Type {
  String field_serverUri;
  String field_productUri;
  ListOfLocalizedText field_serverNames;
  ApplicationType field_serverType;
  String field_gatewayServerUri;
  ListOfString field_discoveryUrls;
  String field_semaphoreFilePath;
  INTEGER field_isOnline;
public:
  RegisteredServer();
  RegisteredServer(const String& par_serverUri,
    const String& par_productUri,
    const ListOfLocalizedText& par_serverNames,
    const ApplicationType& par_serverType,
    const String& par_gatewayServerUri,
    const ListOfString& par_discoveryUrls,
    const String& par_semaphoreFilePath,
    const INTEGER& par_isOnline);
  RegisteredServer(const RegisteredServer& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RegisteredServer& operator=(const RegisteredServer& other_value);
  boolean operator==(const RegisteredServer& other_value) const;
  inline boolean operator!=(const RegisteredServer& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& serverUri()
    {return field_serverUri;}
  inline const String& serverUri() const
    {return field_serverUri;}
  inline String& productUri()
    {return field_productUri;}
  inline const String& productUri() const
    {return field_productUri;}
  inline ListOfLocalizedText& serverNames()
    {return field_serverNames;}
  inline const ListOfLocalizedText& serverNames() const
    {return field_serverNames;}
  inline ApplicationType& serverType()
    {return field_serverType;}
  inline const ApplicationType& serverType() const
    {return field_serverType;}
  inline String& gatewayServerUri()
    {return field_gatewayServerUri;}
  inline const String& gatewayServerUri() const
    {return field_gatewayServerUri;}
  inline ListOfString& discoveryUrls()
    {return field_discoveryUrls;}
  inline const ListOfString& discoveryUrls() const
    {return field_discoveryUrls;}
  inline String& semaphoreFilePath()
    {return field_semaphoreFilePath;}
  inline const String& semaphoreFilePath() const
    {return field_semaphoreFilePath;}
  inline INTEGER& isOnline()
    {return field_isOnline;}
  inline const INTEGER& isOnline() const
    {return field_isOnline;}
  inline int size_of() const
    {return 8;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RegisteredServer_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RegisteredServer_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RegisteredServer& other_value);
void copy_template(const RegisteredServer_template& other_value);

public:
RegisteredServer_template();
RegisteredServer_template(template_sel other_value);
RegisteredServer_template(const RegisteredServer& other_value);
RegisteredServer_template(const OPTIONAL<RegisteredServer>& other_value);
RegisteredServer_template(const RegisteredServer_template& other_value);
~RegisteredServer_template();
RegisteredServer_template& operator=(template_sel other_value);
RegisteredServer_template& operator=(const RegisteredServer& other_value);
RegisteredServer_template& operator=(const OPTIONAL<RegisteredServer>& other_value);
RegisteredServer_template& operator=(const RegisteredServer_template& other_value);
boolean match(const RegisteredServer& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegisteredServer valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegisteredServer_template& list_item(unsigned int list_index) const;
String_template& serverUri();
const String_template& serverUri() const;
String_template& productUri();
const String_template& productUri() const;
ListOfLocalizedText_template& serverNames();
const ListOfLocalizedText_template& serverNames() const;
ApplicationType_template& serverType();
const ApplicationType_template& serverType() const;
String_template& gatewayServerUri();
const String_template& gatewayServerUri() const;
ListOfString_template& discoveryUrls();
const ListOfString_template& discoveryUrls() const;
String_template& semaphoreFilePath();
const String_template& semaphoreFilePath() const;
INTEGER_template& isOnline();
const INTEGER_template& isOnline() const;
int size_of() const;
void log() const;
void log_match(const RegisteredServer& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class EncryptedSecret {
  NodeId field_TypeId;
  INTEGER field_EncodingMask;
  INTEGER field_Length;
  String field_SecurityPolicyUri;
  ByteString field_EncryptingCertificate;
  INTEGER field_SigningTime;
  INTEGER field_PolicyHeaderLength;
  ByteString field_SigningKey;
  ByteString field_EncryptingKey;
  ByteString field_InitializationVector;
  ByteString field_Nonce;
  OPTIONAL<INTEGER> field_PolicyHeaderPadding;
  INTEGER field_PolicyHeaderPaddingSize;
  ByteString field_Secret;
  OPTIONAL<INTEGER> field_PayloadPadding;
  INTEGER field_PayloadPaddingSize;
  OPTIONAL<INTEGER> field_Signature;
public:
  EncryptedSecret();
  EncryptedSecret(const NodeId& par_TypeId,
    const INTEGER& par_EncodingMask,
    const INTEGER& par_Length,
    const String& par_SecurityPolicyUri,
    const ByteString& par_EncryptingCertificate,
    const INTEGER& par_SigningTime,
    const INTEGER& par_PolicyHeaderLength,
    const ByteString& par_SigningKey,
    const ByteString& par_EncryptingKey,
    const ByteString& par_InitializationVector,
    const ByteString& par_Nonce,
    const OPTIONAL<INTEGER>& par_PolicyHeaderPadding,
    const INTEGER& par_PolicyHeaderPaddingSize,
    const ByteString& par_Secret,
    const OPTIONAL<INTEGER>& par_PayloadPadding,
    const INTEGER& par_PayloadPaddingSize,
    const OPTIONAL<INTEGER>& par_Signature);
  EncryptedSecret(const EncryptedSecret& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  EncryptedSecret& operator=(const EncryptedSecret& other_value);
  boolean operator==(const EncryptedSecret& other_value) const;
  inline boolean operator!=(const EncryptedSecret& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& TypeId()
    {return field_TypeId;}
  inline const NodeId& TypeId() const
    {return field_TypeId;}
  inline INTEGER& EncodingMask()
    {return field_EncodingMask;}
  inline const INTEGER& EncodingMask() const
    {return field_EncodingMask;}
  inline INTEGER& Length()
    {return field_Length;}
  inline const INTEGER& Length() const
    {return field_Length;}
  inline String& SecurityPolicyUri()
    {return field_SecurityPolicyUri;}
  inline const String& SecurityPolicyUri() const
    {return field_SecurityPolicyUri;}
  inline ByteString& EncryptingCertificate()
    {return field_EncryptingCertificate;}
  inline const ByteString& EncryptingCertificate() const
    {return field_EncryptingCertificate;}
  inline INTEGER& SigningTime()
    {return field_SigningTime;}
  inline const INTEGER& SigningTime() const
    {return field_SigningTime;}
  inline INTEGER& PolicyHeaderLength()
    {return field_PolicyHeaderLength;}
  inline const INTEGER& PolicyHeaderLength() const
    {return field_PolicyHeaderLength;}
  inline ByteString& SigningKey()
    {return field_SigningKey;}
  inline const ByteString& SigningKey() const
    {return field_SigningKey;}
  inline ByteString& EncryptingKey()
    {return field_EncryptingKey;}
  inline const ByteString& EncryptingKey() const
    {return field_EncryptingKey;}
  inline ByteString& InitializationVector()
    {return field_InitializationVector;}
  inline const ByteString& InitializationVector() const
    {return field_InitializationVector;}
  inline ByteString& Nonce()
    {return field_Nonce;}
  inline const ByteString& Nonce() const
    {return field_Nonce;}
  inline OPTIONAL<INTEGER>& PolicyHeaderPadding()
    {return field_PolicyHeaderPadding;}
  inline const OPTIONAL<INTEGER>& PolicyHeaderPadding() const
    {return field_PolicyHeaderPadding;}
  inline INTEGER& PolicyHeaderPaddingSize()
    {return field_PolicyHeaderPaddingSize;}
  inline const INTEGER& PolicyHeaderPaddingSize() const
    {return field_PolicyHeaderPaddingSize;}
  inline ByteString& Secret()
    {return field_Secret;}
  inline const ByteString& Secret() const
    {return field_Secret;}
  inline OPTIONAL<INTEGER>& PayloadPadding()
    {return field_PayloadPadding;}
  inline const OPTIONAL<INTEGER>& PayloadPadding() const
    {return field_PayloadPadding;}
  inline INTEGER& PayloadPaddingSize()
    {return field_PayloadPaddingSize;}
  inline const INTEGER& PayloadPaddingSize() const
    {return field_PayloadPaddingSize;}
  inline OPTIONAL<INTEGER>& Signature()
    {return field_Signature;}
  inline const OPTIONAL<INTEGER>& Signature() const
    {return field_Signature;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class EncryptedSecret_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
EncryptedSecret_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const EncryptedSecret& other_value);
void copy_template(const EncryptedSecret_template& other_value);

public:
EncryptedSecret_template();
EncryptedSecret_template(template_sel other_value);
EncryptedSecret_template(const EncryptedSecret& other_value);
EncryptedSecret_template(const OPTIONAL<EncryptedSecret>& other_value);
EncryptedSecret_template(const EncryptedSecret_template& other_value);
~EncryptedSecret_template();
EncryptedSecret_template& operator=(template_sel other_value);
EncryptedSecret_template& operator=(const EncryptedSecret& other_value);
EncryptedSecret_template& operator=(const OPTIONAL<EncryptedSecret>& other_value);
EncryptedSecret_template& operator=(const EncryptedSecret_template& other_value);
boolean match(const EncryptedSecret& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
EncryptedSecret valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
EncryptedSecret_template& list_item(unsigned int list_index) const;
NodeId_template& TypeId();
const NodeId_template& TypeId() const;
INTEGER_template& EncodingMask();
const INTEGER_template& EncodingMask() const;
INTEGER_template& Length();
const INTEGER_template& Length() const;
String_template& SecurityPolicyUri();
const String_template& SecurityPolicyUri() const;
ByteString_template& EncryptingCertificate();
const ByteString_template& EncryptingCertificate() const;
INTEGER_template& SigningTime();
const INTEGER_template& SigningTime() const;
INTEGER_template& PolicyHeaderLength();
const INTEGER_template& PolicyHeaderLength() const;
ByteString_template& SigningKey();
const ByteString_template& SigningKey() const;
ByteString_template& EncryptingKey();
const ByteString_template& EncryptingKey() const;
ByteString_template& InitializationVector();
const ByteString_template& InitializationVector() const;
ByteString_template& Nonce();
const ByteString_template& Nonce() const;
INTEGER_template& PolicyHeaderPadding();
const INTEGER_template& PolicyHeaderPadding() const;
INTEGER_template& PolicyHeaderPaddingSize();
const INTEGER_template& PolicyHeaderPaddingSize() const;
ByteString_template& Secret();
const ByteString_template& Secret() const;
INTEGER_template& PayloadPadding();
const INTEGER_template& PayloadPadding() const;
INTEGER_template& PayloadPaddingSize();
const INTEGER_template& PayloadPaddingSize() const;
INTEGER_template& Signature();
const INTEGER_template& Signature() const;
int size_of() const;
void log() const;
void log_match(const EncryptedSecret& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RsaEncryptedSecret {
  NodeId field_TypeId;
  INTEGER field_EncodingMask;
  INTEGER field_Length;
  String field_SecurityPolicyUri;
  ByteString field_EncryptingCertificate;
  INTEGER field_SigningTime;
  INTEGER field_PolicyHeaderLength;
  ByteString field_SigningKey;
  ByteString field_EncryptingKey;
  ByteString field_InitializationVector;
  ByteString field_Nonce;
  OPTIONAL<INTEGER> field_PolicyHeaderPadding;
  INTEGER field_PolicyHeaderPaddingSize;
  ByteString field_Secret;
  OPTIONAL<INTEGER> field_PayloadPadding;
  INTEGER field_PayloadPaddingSize;
  OPTIONAL<INTEGER> field_Signature;
public:
  RsaEncryptedSecret();
  RsaEncryptedSecret(const NodeId& par_TypeId,
    const INTEGER& par_EncodingMask,
    const INTEGER& par_Length,
    const String& par_SecurityPolicyUri,
    const ByteString& par_EncryptingCertificate,
    const INTEGER& par_SigningTime,
    const INTEGER& par_PolicyHeaderLength,
    const ByteString& par_SigningKey,
    const ByteString& par_EncryptingKey,
    const ByteString& par_InitializationVector,
    const ByteString& par_Nonce,
    const OPTIONAL<INTEGER>& par_PolicyHeaderPadding,
    const INTEGER& par_PolicyHeaderPaddingSize,
    const ByteString& par_Secret,
    const OPTIONAL<INTEGER>& par_PayloadPadding,
    const INTEGER& par_PayloadPaddingSize,
    const OPTIONAL<INTEGER>& par_Signature);
  RsaEncryptedSecret(const RsaEncryptedSecret& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RsaEncryptedSecret& operator=(const RsaEncryptedSecret& other_value);
  boolean operator==(const RsaEncryptedSecret& other_value) const;
  inline boolean operator!=(const RsaEncryptedSecret& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& TypeId()
    {return field_TypeId;}
  inline const NodeId& TypeId() const
    {return field_TypeId;}
  inline INTEGER& EncodingMask()
    {return field_EncodingMask;}
  inline const INTEGER& EncodingMask() const
    {return field_EncodingMask;}
  inline INTEGER& Length()
    {return field_Length;}
  inline const INTEGER& Length() const
    {return field_Length;}
  inline String& SecurityPolicyUri()
    {return field_SecurityPolicyUri;}
  inline const String& SecurityPolicyUri() const
    {return field_SecurityPolicyUri;}
  inline ByteString& EncryptingCertificate()
    {return field_EncryptingCertificate;}
  inline const ByteString& EncryptingCertificate() const
    {return field_EncryptingCertificate;}
  inline INTEGER& SigningTime()
    {return field_SigningTime;}
  inline const INTEGER& SigningTime() const
    {return field_SigningTime;}
  inline INTEGER& PolicyHeaderLength()
    {return field_PolicyHeaderLength;}
  inline const INTEGER& PolicyHeaderLength() const
    {return field_PolicyHeaderLength;}
  inline ByteString& SigningKey()
    {return field_SigningKey;}
  inline const ByteString& SigningKey() const
    {return field_SigningKey;}
  inline ByteString& EncryptingKey()
    {return field_EncryptingKey;}
  inline const ByteString& EncryptingKey() const
    {return field_EncryptingKey;}
  inline ByteString& InitializationVector()
    {return field_InitializationVector;}
  inline const ByteString& InitializationVector() const
    {return field_InitializationVector;}
  inline ByteString& Nonce()
    {return field_Nonce;}
  inline const ByteString& Nonce() const
    {return field_Nonce;}
  inline OPTIONAL<INTEGER>& PolicyHeaderPadding()
    {return field_PolicyHeaderPadding;}
  inline const OPTIONAL<INTEGER>& PolicyHeaderPadding() const
    {return field_PolicyHeaderPadding;}
  inline INTEGER& PolicyHeaderPaddingSize()
    {return field_PolicyHeaderPaddingSize;}
  inline const INTEGER& PolicyHeaderPaddingSize() const
    {return field_PolicyHeaderPaddingSize;}
  inline ByteString& Secret()
    {return field_Secret;}
  inline const ByteString& Secret() const
    {return field_Secret;}
  inline OPTIONAL<INTEGER>& PayloadPadding()
    {return field_PayloadPadding;}
  inline const OPTIONAL<INTEGER>& PayloadPadding() const
    {return field_PayloadPadding;}
  inline INTEGER& PayloadPaddingSize()
    {return field_PayloadPaddingSize;}
  inline const INTEGER& PayloadPaddingSize() const
    {return field_PayloadPaddingSize;}
  inline OPTIONAL<INTEGER>& Signature()
    {return field_Signature;}
  inline const OPTIONAL<INTEGER>& Signature() const
    {return field_Signature;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class RsaEncryptedSecret_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RsaEncryptedSecret_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RsaEncryptedSecret& other_value);
void copy_template(const RsaEncryptedSecret_template& other_value);

public:
RsaEncryptedSecret_template();
RsaEncryptedSecret_template(template_sel other_value);
RsaEncryptedSecret_template(const RsaEncryptedSecret& other_value);
RsaEncryptedSecret_template(const OPTIONAL<RsaEncryptedSecret>& other_value);
RsaEncryptedSecret_template(const RsaEncryptedSecret_template& other_value);
~RsaEncryptedSecret_template();
RsaEncryptedSecret_template& operator=(template_sel other_value);
RsaEncryptedSecret_template& operator=(const RsaEncryptedSecret& other_value);
RsaEncryptedSecret_template& operator=(const OPTIONAL<RsaEncryptedSecret>& other_value);
RsaEncryptedSecret_template& operator=(const RsaEncryptedSecret_template& other_value);
boolean match(const RsaEncryptedSecret& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RsaEncryptedSecret valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RsaEncryptedSecret_template& list_item(unsigned int list_index) const;
NodeId_template& TypeId();
const NodeId_template& TypeId() const;
INTEGER_template& EncodingMask();
const INTEGER_template& EncodingMask() const;
INTEGER_template& Length();
const INTEGER_template& Length() const;
String_template& SecurityPolicyUri();
const String_template& SecurityPolicyUri() const;
ByteString_template& EncryptingCertificate();
const ByteString_template& EncryptingCertificate() const;
INTEGER_template& SigningTime();
const INTEGER_template& SigningTime() const;
INTEGER_template& PolicyHeaderLength();
const INTEGER_template& PolicyHeaderLength() const;
ByteString_template& SigningKey();
const ByteString_template& SigningKey() const;
ByteString_template& EncryptingKey();
const ByteString_template& EncryptingKey() const;
ByteString_template& InitializationVector();
const ByteString_template& InitializationVector() const;
ByteString_template& Nonce();
const ByteString_template& Nonce() const;
INTEGER_template& PolicyHeaderPadding();
const INTEGER_template& PolicyHeaderPadding() const;
INTEGER_template& PolicyHeaderPaddingSize();
const INTEGER_template& PolicyHeaderPaddingSize() const;
ByteString_template& Secret();
const ByteString_template& Secret() const;
INTEGER_template& PayloadPadding();
const INTEGER_template& PayloadPadding() const;
INTEGER_template& PayloadPaddingSize();
const INTEGER_template& PayloadPaddingSize() const;
INTEGER_template& Signature();
const INTEGER_template& Signature() const;
int size_of() const;
void log() const;
void log_match(const RsaEncryptedSecret& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ViewDescription : public Base_Type {
  NodeId field_viewId;
  INTEGER field_timestamp;
  INTEGER field_viewVersion;
public:
  ViewDescription();
  ViewDescription(const NodeId& par_viewId,
    const INTEGER& par_timestamp,
    const INTEGER& par_viewVersion);
  ViewDescription(const ViewDescription& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ViewDescription& operator=(const ViewDescription& other_value);
  boolean operator==(const ViewDescription& other_value) const;
  inline boolean operator!=(const ViewDescription& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& viewId()
    {return field_viewId;}
  inline const NodeId& viewId() const
    {return field_viewId;}
  inline INTEGER& timestamp()
    {return field_timestamp;}
  inline const INTEGER& timestamp() const
    {return field_timestamp;}
  inline INTEGER& viewVersion()
    {return field_viewVersion;}
  inline const INTEGER& viewVersion() const
    {return field_viewVersion;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ViewDescription_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ViewDescription_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ViewDescription& other_value);
void copy_template(const ViewDescription_template& other_value);

public:
ViewDescription_template();
ViewDescription_template(template_sel other_value);
ViewDescription_template(const ViewDescription& other_value);
ViewDescription_template(const OPTIONAL<ViewDescription>& other_value);
ViewDescription_template(const ViewDescription_template& other_value);
~ViewDescription_template();
ViewDescription_template& operator=(template_sel other_value);
ViewDescription_template& operator=(const ViewDescription& other_value);
ViewDescription_template& operator=(const OPTIONAL<ViewDescription>& other_value);
ViewDescription_template& operator=(const ViewDescription_template& other_value);
boolean match(const ViewDescription& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ViewDescription valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ViewDescription_template& list_item(unsigned int list_index) const;
NodeId_template& viewId();
const NodeId_template& viewId() const;
INTEGER_template& timestamp();
const INTEGER_template& timestamp() const;
INTEGER_template& viewVersion();
const INTEGER_template& viewVersion() const;
int size_of() const;
void log() const;
void log_match(const ViewDescription& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TrustListDataType {
  TrustListMasks field_specifiedLists;
  ListOfByteString field_trustedCertificates;
  ListOfByteString field_trustedCrls;
  ListOfByteString field_issuerCertificates;
  ListOfByteString field_issuerCrls;
public:
  TrustListDataType();
  TrustListDataType(const TrustListMasks& par_specifiedLists,
    const ListOfByteString& par_trustedCertificates,
    const ListOfByteString& par_trustedCrls,
    const ListOfByteString& par_issuerCertificates,
    const ListOfByteString& par_issuerCrls);
  TrustListDataType(const TrustListDataType& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TrustListDataType& operator=(const TrustListDataType& other_value);
  boolean operator==(const TrustListDataType& other_value) const;
  inline boolean operator!=(const TrustListDataType& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline TrustListMasks& specifiedLists()
    {return field_specifiedLists;}
  inline const TrustListMasks& specifiedLists() const
    {return field_specifiedLists;}
  inline ListOfByteString& trustedCertificates()
    {return field_trustedCertificates;}
  inline const ListOfByteString& trustedCertificates() const
    {return field_trustedCertificates;}
  inline ListOfByteString& trustedCrls()
    {return field_trustedCrls;}
  inline const ListOfByteString& trustedCrls() const
    {return field_trustedCrls;}
  inline ListOfByteString& issuerCertificates()
    {return field_issuerCertificates;}
  inline const ListOfByteString& issuerCertificates() const
    {return field_issuerCertificates;}
  inline ListOfByteString& issuerCrls()
    {return field_issuerCrls;}
  inline const ListOfByteString& issuerCrls() const
    {return field_issuerCrls;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class TrustListDataType_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TrustListDataType_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TrustListDataType& other_value);
void copy_template(const TrustListDataType_template& other_value);

public:
TrustListDataType_template();
TrustListDataType_template(template_sel other_value);
TrustListDataType_template(const TrustListDataType& other_value);
TrustListDataType_template(const OPTIONAL<TrustListDataType>& other_value);
TrustListDataType_template(const TrustListDataType_template& other_value);
~TrustListDataType_template();
TrustListDataType_template& operator=(template_sel other_value);
TrustListDataType_template& operator=(const TrustListDataType& other_value);
TrustListDataType_template& operator=(const OPTIONAL<TrustListDataType>& other_value);
TrustListDataType_template& operator=(const TrustListDataType_template& other_value);
boolean match(const TrustListDataType& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TrustListDataType valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TrustListDataType_template& list_item(unsigned int list_index) const;
TrustListMasks_template& specifiedLists();
const TrustListMasks_template& specifiedLists() const;
ListOfByteString_template& trustedCertificates();
const ListOfByteString_template& trustedCertificates() const;
ListOfByteString_template& trustedCrls();
const ListOfByteString_template& trustedCrls() const;
ListOfByteString_template& issuerCertificates();
const ListOfByteString_template& issuerCertificates() const;
ListOfByteString_template& issuerCrls();
const ListOfByteString_template& issuerCrls() const;
int size_of() const;
void log() const;
void log_match(const TrustListDataType& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SignatureData : public Base_Type {
  String field_algorithm;
  ByteString field_Signature;
public:
  SignatureData();
  SignatureData(const String& par_algorithm,
    const ByteString& par_Signature);
  SignatureData(const SignatureData& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SignatureData& operator=(const SignatureData& other_value);
  boolean operator==(const SignatureData& other_value) const;
  inline boolean operator!=(const SignatureData& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& algorithm()
    {return field_algorithm;}
  inline const String& algorithm() const
    {return field_algorithm;}
  inline ByteString& Signature()
    {return field_Signature;}
  inline const ByteString& Signature() const
    {return field_Signature;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SignatureData_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SignatureData_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SignatureData& other_value);
void copy_template(const SignatureData_template& other_value);

public:
SignatureData_template();
SignatureData_template(template_sel other_value);
SignatureData_template(const SignatureData& other_value);
SignatureData_template(const OPTIONAL<SignatureData>& other_value);
SignatureData_template(const SignatureData_template& other_value);
~SignatureData_template();
SignatureData_template& operator=(template_sel other_value);
SignatureData_template& operator=(const SignatureData& other_value);
SignatureData_template& operator=(const OPTIONAL<SignatureData>& other_value);
SignatureData_template& operator=(const SignatureData_template& other_value);
boolean match(const SignatureData& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SignatureData valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SignatureData_template& list_item(unsigned int list_index) const;
String_template& algorithm();
const String_template& algorithm() const;
ByteString_template& Signature();
const ByteString_template& Signature() const;
int size_of() const;
void log() const;
void log_match(const SignatureData& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MessageHeader : public Base_Type {
  INTEGER field_messageType;
  INTEGER field_chunkType;
  INTEGER field_messageSize;
public:
  MessageHeader();
  MessageHeader(const INTEGER& par_messageType,
    const INTEGER& par_chunkType,
    const INTEGER& par_messageSize);
  MessageHeader(const MessageHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MessageHeader& operator=(const MessageHeader& other_value);
  boolean operator==(const MessageHeader& other_value) const;
  inline boolean operator!=(const MessageHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& messageType()
    {return field_messageType;}
  inline const INTEGER& messageType() const
    {return field_messageType;}
  inline INTEGER& chunkType()
    {return field_chunkType;}
  inline const INTEGER& chunkType() const
    {return field_chunkType;}
  inline INTEGER& messageSize()
    {return field_messageSize;}
  inline const INTEGER& messageSize() const
    {return field_messageSize;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MessageHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MessageHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MessageHeader& other_value);
void copy_template(const MessageHeader_template& other_value);

public:
MessageHeader_template();
MessageHeader_template(template_sel other_value);
MessageHeader_template(const MessageHeader& other_value);
MessageHeader_template(const OPTIONAL<MessageHeader>& other_value);
MessageHeader_template(const MessageHeader_template& other_value);
~MessageHeader_template();
MessageHeader_template& operator=(template_sel other_value);
MessageHeader_template& operator=(const MessageHeader& other_value);
MessageHeader_template& operator=(const OPTIONAL<MessageHeader>& other_value);
MessageHeader_template& operator=(const MessageHeader_template& other_value);
boolean match(const MessageHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MessageHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MessageHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& messageType();
const INTEGER_template& messageType() const;
INTEGER_template& chunkType();
const INTEGER_template& chunkType() const;
INTEGER_template& messageSize();
const INTEGER_template& messageSize() const;
int size_of() const;
void log() const;
void log_match(const MessageHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SecurityHeader : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_asymmetricSecurityHeader = 1, ALT_symmetricSecurityHeader = 2 };
private:
union_selection_type union_selection;
union {
AsymmetricSecurityHeader *field_asymmetricSecurityHeader;
SymmetricSecurityHeader *field_symmetricSecurityHeader;
};
void copy_value(const SecurityHeader& other_value);

public:
SecurityHeader();
SecurityHeader(const SecurityHeader& other_value);
~SecurityHeader();
SecurityHeader& operator=(const SecurityHeader& other_value);
boolean operator==(const SecurityHeader& other_value) const;
inline boolean operator!=(const SecurityHeader& other_value) const { return !(*this == other_value); }
AsymmetricSecurityHeader& asymmetricSecurityHeader();
const AsymmetricSecurityHeader& asymmetricSecurityHeader() const;
SymmetricSecurityHeader& symmetricSecurityHeader();
const SymmetricSecurityHeader& symmetricSecurityHeader() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
};

class SecurityHeader_template : public Base_Template {
union {
struct {
SecurityHeader::union_selection_type union_selection;
union {
AsymmetricSecurityHeader_template *field_asymmetricSecurityHeader;
SymmetricSecurityHeader_template *field_symmetricSecurityHeader;
};
} single_value;
struct {
unsigned int n_values;
SecurityHeader_template *list_value;
} value_list;
};
void copy_value(const SecurityHeader& other_value);

void copy_template(const SecurityHeader_template& other_value);

public:
SecurityHeader_template();
SecurityHeader_template(template_sel other_value);
SecurityHeader_template(const SecurityHeader& other_value);
SecurityHeader_template(const OPTIONAL<SecurityHeader>& other_value);
SecurityHeader_template(const SecurityHeader_template& other_value);
~SecurityHeader_template();
void clean_up();
SecurityHeader_template& operator=(template_sel other_value);
SecurityHeader_template& operator=(const SecurityHeader& other_value);
SecurityHeader_template& operator=(const OPTIONAL<SecurityHeader>& other_value);
SecurityHeader_template& operator=(const SecurityHeader_template& other_value);
boolean match(const SecurityHeader& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SecurityHeader valueof() const;
SecurityHeader_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
AsymmetricSecurityHeader_template& asymmetricSecurityHeader();
const AsymmetricSecurityHeader_template& asymmetricSecurityHeader() const;
SymmetricSecurityHeader_template& symmetricSecurityHeader();
const SymmetricSecurityHeader_template& symmetricSecurityHeader() const;
boolean ischosen(SecurityHeader::union_selection_type checked_selection) const;
void log() const;
void log_match(const SecurityHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class AsymmetricSecurityHeader {
  INTEGER field_SecurityPolicyUriLength;
  ListOfByte field_SecurityPolicyUri;
  INTEGER field_SenderCertificateLength;
  ListOfByte field_SenderCertificate;
  INTEGER field_ReceiverCertificateThumbprintLength;
  ListOfByte field_ReceiverCertificateThumbprint;
public:
  AsymmetricSecurityHeader();
  AsymmetricSecurityHeader(const INTEGER& par_SecurityPolicyUriLength,
    const ListOfByte& par_SecurityPolicyUri,
    const INTEGER& par_SenderCertificateLength,
    const ListOfByte& par_SenderCertificate,
    const INTEGER& par_ReceiverCertificateThumbprintLength,
    const ListOfByte& par_ReceiverCertificateThumbprint);
  AsymmetricSecurityHeader(const AsymmetricSecurityHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AsymmetricSecurityHeader& operator=(const AsymmetricSecurityHeader& other_value);
  boolean operator==(const AsymmetricSecurityHeader& other_value) const;
  inline boolean operator!=(const AsymmetricSecurityHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& SecurityPolicyUriLength()
    {return field_SecurityPolicyUriLength;}
  inline const INTEGER& SecurityPolicyUriLength() const
    {return field_SecurityPolicyUriLength;}
  inline ListOfByte& SecurityPolicyUri()
    {return field_SecurityPolicyUri;}
  inline const ListOfByte& SecurityPolicyUri() const
    {return field_SecurityPolicyUri;}
  inline INTEGER& SenderCertificateLength()
    {return field_SenderCertificateLength;}
  inline const INTEGER& SenderCertificateLength() const
    {return field_SenderCertificateLength;}
  inline ListOfByte& SenderCertificate()
    {return field_SenderCertificate;}
  inline const ListOfByte& SenderCertificate() const
    {return field_SenderCertificate;}
  inline INTEGER& ReceiverCertificateThumbprintLength()
    {return field_ReceiverCertificateThumbprintLength;}
  inline const INTEGER& ReceiverCertificateThumbprintLength() const
    {return field_ReceiverCertificateThumbprintLength;}
  inline ListOfByte& ReceiverCertificateThumbprint()
    {return field_ReceiverCertificateThumbprint;}
  inline const ListOfByte& ReceiverCertificateThumbprint() const
    {return field_ReceiverCertificateThumbprint;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class AsymmetricSecurityHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AsymmetricSecurityHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AsymmetricSecurityHeader& other_value);
void copy_template(const AsymmetricSecurityHeader_template& other_value);

public:
AsymmetricSecurityHeader_template();
AsymmetricSecurityHeader_template(template_sel other_value);
AsymmetricSecurityHeader_template(const AsymmetricSecurityHeader& other_value);
AsymmetricSecurityHeader_template(const OPTIONAL<AsymmetricSecurityHeader>& other_value);
AsymmetricSecurityHeader_template(const AsymmetricSecurityHeader_template& other_value);
~AsymmetricSecurityHeader_template();
AsymmetricSecurityHeader_template& operator=(template_sel other_value);
AsymmetricSecurityHeader_template& operator=(const AsymmetricSecurityHeader& other_value);
AsymmetricSecurityHeader_template& operator=(const OPTIONAL<AsymmetricSecurityHeader>& other_value);
AsymmetricSecurityHeader_template& operator=(const AsymmetricSecurityHeader_template& other_value);
boolean match(const AsymmetricSecurityHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AsymmetricSecurityHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AsymmetricSecurityHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& SecurityPolicyUriLength();
const INTEGER_template& SecurityPolicyUriLength() const;
ListOfByte_template& SecurityPolicyUri();
const ListOfByte_template& SecurityPolicyUri() const;
INTEGER_template& SenderCertificateLength();
const INTEGER_template& SenderCertificateLength() const;
ListOfByte_template& SenderCertificate();
const ListOfByte_template& SenderCertificate() const;
INTEGER_template& ReceiverCertificateThumbprintLength();
const INTEGER_template& ReceiverCertificateThumbprintLength() const;
ListOfByte_template& ReceiverCertificateThumbprint();
const ListOfByte_template& ReceiverCertificateThumbprint() const;
int size_of() const;
void log() const;
void log_match(const AsymmetricSecurityHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SymmetricSecurityHeader {
  INTEGER field_TokenId;
public:
  SymmetricSecurityHeader();
  SymmetricSecurityHeader(const INTEGER& par_TokenId);
  SymmetricSecurityHeader(const SymmetricSecurityHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SymmetricSecurityHeader& operator=(const SymmetricSecurityHeader& other_value);
  boolean operator==(const SymmetricSecurityHeader& other_value) const;
  inline boolean operator!=(const SymmetricSecurityHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& TokenId()
    {return field_TokenId;}
  inline const INTEGER& TokenId() const
    {return field_TokenId;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SymmetricSecurityHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SymmetricSecurityHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SymmetricSecurityHeader& other_value);
void copy_template(const SymmetricSecurityHeader_template& other_value);

public:
SymmetricSecurityHeader_template();
SymmetricSecurityHeader_template(template_sel other_value);
SymmetricSecurityHeader_template(const SymmetricSecurityHeader& other_value);
SymmetricSecurityHeader_template(const OPTIONAL<SymmetricSecurityHeader>& other_value);
SymmetricSecurityHeader_template(const SymmetricSecurityHeader_template& other_value);
~SymmetricSecurityHeader_template();
SymmetricSecurityHeader_template& operator=(template_sel other_value);
SymmetricSecurityHeader_template& operator=(const SymmetricSecurityHeader& other_value);
SymmetricSecurityHeader_template& operator=(const OPTIONAL<SymmetricSecurityHeader>& other_value);
SymmetricSecurityHeader_template& operator=(const SymmetricSecurityHeader_template& other_value);
boolean match(const SymmetricSecurityHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SymmetricSecurityHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SymmetricSecurityHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& TokenId();
const INTEGER_template& TokenId() const;
int size_of() const;
void log() const;
void log_match(const SymmetricSecurityHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SequenceHeader : public Base_Type {
  INTEGER field_SequenceNumber;
  INTEGER field_RequestId;
public:
  SequenceHeader();
  SequenceHeader(const INTEGER& par_SequenceNumber,
    const INTEGER& par_RequestId);
  SequenceHeader(const SequenceHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SequenceHeader& operator=(const SequenceHeader& other_value);
  boolean operator==(const SequenceHeader& other_value) const;
  inline boolean operator!=(const SequenceHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& SequenceNumber()
    {return field_SequenceNumber;}
  inline const INTEGER& SequenceNumber() const
    {return field_SequenceNumber;}
  inline INTEGER& RequestId()
    {return field_RequestId;}
  inline const INTEGER& RequestId() const
    {return field_RequestId;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SequenceHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SequenceHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SequenceHeader& other_value);
void copy_template(const SequenceHeader_template& other_value);

public:
SequenceHeader_template();
SequenceHeader_template(template_sel other_value);
SequenceHeader_template(const SequenceHeader& other_value);
SequenceHeader_template(const OPTIONAL<SequenceHeader>& other_value);
SequenceHeader_template(const SequenceHeader_template& other_value);
~SequenceHeader_template();
SequenceHeader_template& operator=(template_sel other_value);
SequenceHeader_template& operator=(const SequenceHeader& other_value);
SequenceHeader_template& operator=(const OPTIONAL<SequenceHeader>& other_value);
SequenceHeader_template& operator=(const SequenceHeader_template& other_value);
boolean match(const SequenceHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SequenceHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SequenceHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& SequenceNumber();
const INTEGER_template& SequenceNumber() const;
INTEGER_template& RequestId();
const INTEGER_template& RequestId() const;
int size_of() const;
void log() const;
void log_match(const SequenceHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class MessageFooter : public Base_Type {
  OPTIONAL<INTEGER> field_PaddingSize;
  OPTIONAL<ListOfByte> field_Padding;
  OPTIONAL<INTEGER> field_ExtraPaddingSize;
  OPTIONAL<ListOfByte> field_Signature;
public:
  MessageFooter();
  MessageFooter(const OPTIONAL<INTEGER>& par_PaddingSize,
    const OPTIONAL<ListOfByte>& par_Padding,
    const OPTIONAL<INTEGER>& par_ExtraPaddingSize,
    const OPTIONAL<ListOfByte>& par_Signature);
  MessageFooter(const MessageFooter& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MessageFooter& operator=(const MessageFooter& other_value);
  boolean operator==(const MessageFooter& other_value) const;
  inline boolean operator!=(const MessageFooter& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline OPTIONAL<INTEGER>& PaddingSize()
    {return field_PaddingSize;}
  inline const OPTIONAL<INTEGER>& PaddingSize() const
    {return field_PaddingSize;}
  inline OPTIONAL<ListOfByte>& Padding()
    {return field_Padding;}
  inline const OPTIONAL<ListOfByte>& Padding() const
    {return field_Padding;}
  inline OPTIONAL<INTEGER>& ExtraPaddingSize()
    {return field_ExtraPaddingSize;}
  inline const OPTIONAL<INTEGER>& ExtraPaddingSize() const
    {return field_ExtraPaddingSize;}
  inline OPTIONAL<ListOfByte>& Signature()
    {return field_Signature;}
  inline const OPTIONAL<ListOfByte>& Signature() const
    {return field_Signature;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MessageFooter_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MessageFooter_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MessageFooter& other_value);
void copy_template(const MessageFooter_template& other_value);

public:
MessageFooter_template();
MessageFooter_template(template_sel other_value);
MessageFooter_template(const MessageFooter& other_value);
MessageFooter_template(const OPTIONAL<MessageFooter>& other_value);
MessageFooter_template(const MessageFooter_template& other_value);
~MessageFooter_template();
MessageFooter_template& operator=(template_sel other_value);
MessageFooter_template& operator=(const MessageFooter& other_value);
MessageFooter_template& operator=(const OPTIONAL<MessageFooter>& other_value);
MessageFooter_template& operator=(const MessageFooter_template& other_value);
boolean match(const MessageFooter& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MessageFooter valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MessageFooter_template& list_item(unsigned int list_index) const;
INTEGER_template& PaddingSize();
const INTEGER_template& PaddingSize() const;
ListOfByte_template& Padding();
const ListOfByte_template& Padding() const;
INTEGER_template& ExtraPaddingSize();
const INTEGER_template& ExtraPaddingSize() const;
ListOfByte_template& Signature();
const ListOfByte_template& Signature() const;
int size_of() const;
void log() const;
void log_match(const MessageFooter& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AdditionalHeader : public Base_Type {
  ExpandedNodeId field_typeId;
  INTEGER field_Value;
public:
  AdditionalHeader();
  AdditionalHeader(const ExpandedNodeId& par_typeId,
    const INTEGER& par_Value);
  AdditionalHeader(const AdditionalHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AdditionalHeader& operator=(const AdditionalHeader& other_value);
  boolean operator==(const AdditionalHeader& other_value) const;
  inline boolean operator!=(const AdditionalHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ExpandedNodeId& typeId()
    {return field_typeId;}
  inline const ExpandedNodeId& typeId() const
    {return field_typeId;}
  inline INTEGER& Value()
    {return field_Value;}
  inline const INTEGER& Value() const
    {return field_Value;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AdditionalHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AdditionalHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AdditionalHeader& other_value);
void copy_template(const AdditionalHeader_template& other_value);

public:
AdditionalHeader_template();
AdditionalHeader_template(template_sel other_value);
AdditionalHeader_template(const AdditionalHeader& other_value);
AdditionalHeader_template(const OPTIONAL<AdditionalHeader>& other_value);
AdditionalHeader_template(const AdditionalHeader_template& other_value);
~AdditionalHeader_template();
AdditionalHeader_template& operator=(template_sel other_value);
AdditionalHeader_template& operator=(const AdditionalHeader& other_value);
AdditionalHeader_template& operator=(const OPTIONAL<AdditionalHeader>& other_value);
AdditionalHeader_template& operator=(const AdditionalHeader_template& other_value);
boolean match(const AdditionalHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AdditionalHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AdditionalHeader_template& list_item(unsigned int list_index) const;
ExpandedNodeId_template& typeId();
const ExpandedNodeId_template& typeId() const;
INTEGER_template& Value();
const INTEGER_template& Value() const;
int size_of() const;
void log() const;
void log_match(const AdditionalHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RequestHeader : public Base_Type {
  NodeId field_authenticationToken;
  INTEGER field_timestamp;
  INTEGER field_requestHandle;
  INTEGER field_returnDiagnostics;
  String field_auditEntryId;
  INTEGER field_timeoutHint;
  AdditionalHeader field_additionalHeader;
public:
  RequestHeader();
  RequestHeader(const NodeId& par_authenticationToken,
    const INTEGER& par_timestamp,
    const INTEGER& par_requestHandle,
    const INTEGER& par_returnDiagnostics,
    const String& par_auditEntryId,
    const INTEGER& par_timeoutHint,
    const AdditionalHeader& par_additionalHeader);
  RequestHeader(const RequestHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RequestHeader& operator=(const RequestHeader& other_value);
  boolean operator==(const RequestHeader& other_value) const;
  inline boolean operator!=(const RequestHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline NodeId& authenticationToken()
    {return field_authenticationToken;}
  inline const NodeId& authenticationToken() const
    {return field_authenticationToken;}
  inline INTEGER& timestamp()
    {return field_timestamp;}
  inline const INTEGER& timestamp() const
    {return field_timestamp;}
  inline INTEGER& requestHandle()
    {return field_requestHandle;}
  inline const INTEGER& requestHandle() const
    {return field_requestHandle;}
  inline INTEGER& returnDiagnostics()
    {return field_returnDiagnostics;}
  inline const INTEGER& returnDiagnostics() const
    {return field_returnDiagnostics;}
  inline String& auditEntryId()
    {return field_auditEntryId;}
  inline const String& auditEntryId() const
    {return field_auditEntryId;}
  inline INTEGER& timeoutHint()
    {return field_timeoutHint;}
  inline const INTEGER& timeoutHint() const
    {return field_timeoutHint;}
  inline AdditionalHeader& additionalHeader()
    {return field_additionalHeader;}
  inline const AdditionalHeader& additionalHeader() const
    {return field_additionalHeader;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RequestHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RequestHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RequestHeader& other_value);
void copy_template(const RequestHeader_template& other_value);

public:
RequestHeader_template();
RequestHeader_template(template_sel other_value);
RequestHeader_template(const RequestHeader& other_value);
RequestHeader_template(const OPTIONAL<RequestHeader>& other_value);
RequestHeader_template(const RequestHeader_template& other_value);
~RequestHeader_template();
RequestHeader_template& operator=(template_sel other_value);
RequestHeader_template& operator=(const RequestHeader& other_value);
RequestHeader_template& operator=(const OPTIONAL<RequestHeader>& other_value);
RequestHeader_template& operator=(const RequestHeader_template& other_value);
boolean match(const RequestHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RequestHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RequestHeader_template& list_item(unsigned int list_index) const;
NodeId_template& authenticationToken();
const NodeId_template& authenticationToken() const;
INTEGER_template& timestamp();
const INTEGER_template& timestamp() const;
INTEGER_template& requestHandle();
const INTEGER_template& requestHandle() const;
INTEGER_template& returnDiagnostics();
const INTEGER_template& returnDiagnostics() const;
String_template& auditEntryId();
const String_template& auditEntryId() const;
INTEGER_template& timeoutHint();
const INTEGER_template& timeoutHint() const;
AdditionalHeader_template& additionalHeader();
const AdditionalHeader_template& additionalHeader() const;
int size_of() const;
void log() const;
void log_match(const RequestHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ResponseHeader : public Base_Type {
  INTEGER field_timestamp;
  INTEGER field_requestHandle;
  INTEGER field_serviceResult;
  DiagnosticInfo field_serviceDiagnostics;
  ListOfString field_stringTable;
  AdditionalHeader field_additionalHeader;
public:
  ResponseHeader();
  ResponseHeader(const INTEGER& par_timestamp,
    const INTEGER& par_requestHandle,
    const INTEGER& par_serviceResult,
    const DiagnosticInfo& par_serviceDiagnostics,
    const ListOfString& par_stringTable,
    const AdditionalHeader& par_additionalHeader);
  ResponseHeader(const ResponseHeader& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ResponseHeader& operator=(const ResponseHeader& other_value);
  boolean operator==(const ResponseHeader& other_value) const;
  inline boolean operator!=(const ResponseHeader& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& timestamp()
    {return field_timestamp;}
  inline const INTEGER& timestamp() const
    {return field_timestamp;}
  inline INTEGER& requestHandle()
    {return field_requestHandle;}
  inline const INTEGER& requestHandle() const
    {return field_requestHandle;}
  inline INTEGER& serviceResult()
    {return field_serviceResult;}
  inline const INTEGER& serviceResult() const
    {return field_serviceResult;}
  inline DiagnosticInfo& serviceDiagnostics()
    {return field_serviceDiagnostics;}
  inline const DiagnosticInfo& serviceDiagnostics() const
    {return field_serviceDiagnostics;}
  inline ListOfString& stringTable()
    {return field_stringTable;}
  inline const ListOfString& stringTable() const
    {return field_stringTable;}
  inline AdditionalHeader& additionalHeader()
    {return field_additionalHeader;}
  inline const AdditionalHeader& additionalHeader() const
    {return field_additionalHeader;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ResponseHeader_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ResponseHeader_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ResponseHeader& other_value);
void copy_template(const ResponseHeader_template& other_value);

public:
ResponseHeader_template();
ResponseHeader_template(template_sel other_value);
ResponseHeader_template(const ResponseHeader& other_value);
ResponseHeader_template(const OPTIONAL<ResponseHeader>& other_value);
ResponseHeader_template(const ResponseHeader_template& other_value);
~ResponseHeader_template();
ResponseHeader_template& operator=(template_sel other_value);
ResponseHeader_template& operator=(const ResponseHeader& other_value);
ResponseHeader_template& operator=(const OPTIONAL<ResponseHeader>& other_value);
ResponseHeader_template& operator=(const ResponseHeader_template& other_value);
boolean match(const ResponseHeader& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ResponseHeader valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ResponseHeader_template& list_item(unsigned int list_index) const;
INTEGER_template& timestamp();
const INTEGER_template& timestamp() const;
INTEGER_template& requestHandle();
const INTEGER_template& requestHandle() const;
INTEGER_template& serviceResult();
const INTEGER_template& serviceResult() const;
DiagnosticInfo_template& serviceDiagnostics();
const DiagnosticInfo_template& serviceDiagnostics() const;
ListOfString_template& stringTable();
const ListOfString_template& stringTable() const;
AdditionalHeader_template& additionalHeader();
const AdditionalHeader_template& additionalHeader() const;
int size_of() const;
void log() const;
void log_match(const ResponseHeader& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ServiceFault {
  ResponseHeader field_responseHeader;
public:
  ServiceFault();
  ServiceFault(const ResponseHeader& par_responseHeader);
  ServiceFault(const ServiceFault& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ServiceFault& operator=(const ServiceFault& other_value);
  boolean operator==(const ServiceFault& other_value) const;
  inline boolean operator!=(const ServiceFault& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class ServiceFault_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ServiceFault_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ServiceFault& other_value);
void copy_template(const ServiceFault_template& other_value);

public:
ServiceFault_template();
ServiceFault_template(template_sel other_value);
ServiceFault_template(const ServiceFault& other_value);
ServiceFault_template(const OPTIONAL<ServiceFault>& other_value);
ServiceFault_template(const ServiceFault_template& other_value);
~ServiceFault_template();
ServiceFault_template& operator=(template_sel other_value);
ServiceFault_template& operator=(const ServiceFault& other_value);
ServiceFault_template& operator=(const OPTIONAL<ServiceFault>& other_value);
ServiceFault_template& operator=(const ServiceFault_template& other_value);
boolean match(const ServiceFault& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ServiceFault valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ServiceFault_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
int size_of() const;
void log() const;
void log_match(const ServiceFault& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HelloMessage : public Base_Type {
  INTEGER field_version;
  INTEGER field_receiveBufferSize;
  INTEGER field_sendBufferSize;
  INTEGER field_maxMessageSize;
  INTEGER field_maxChunkCount;
  String field_endPointUrl;
public:
  HelloMessage();
  HelloMessage(const INTEGER& par_version,
    const INTEGER& par_receiveBufferSize,
    const INTEGER& par_sendBufferSize,
    const INTEGER& par_maxMessageSize,
    const INTEGER& par_maxChunkCount,
    const String& par_endPointUrl);
  HelloMessage(const HelloMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HelloMessage& operator=(const HelloMessage& other_value);
  boolean operator==(const HelloMessage& other_value) const;
  inline boolean operator!=(const HelloMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline INTEGER& receiveBufferSize()
    {return field_receiveBufferSize;}
  inline const INTEGER& receiveBufferSize() const
    {return field_receiveBufferSize;}
  inline INTEGER& sendBufferSize()
    {return field_sendBufferSize;}
  inline const INTEGER& sendBufferSize() const
    {return field_sendBufferSize;}
  inline INTEGER& maxMessageSize()
    {return field_maxMessageSize;}
  inline const INTEGER& maxMessageSize() const
    {return field_maxMessageSize;}
  inline INTEGER& maxChunkCount()
    {return field_maxChunkCount;}
  inline const INTEGER& maxChunkCount() const
    {return field_maxChunkCount;}
  inline String& endPointUrl()
    {return field_endPointUrl;}
  inline const String& endPointUrl() const
    {return field_endPointUrl;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HelloMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HelloMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HelloMessage& other_value);
void copy_template(const HelloMessage_template& other_value);

public:
HelloMessage_template();
HelloMessage_template(template_sel other_value);
HelloMessage_template(const HelloMessage& other_value);
HelloMessage_template(const OPTIONAL<HelloMessage>& other_value);
HelloMessage_template(const HelloMessage_template& other_value);
~HelloMessage_template();
HelloMessage_template& operator=(template_sel other_value);
HelloMessage_template& operator=(const HelloMessage& other_value);
HelloMessage_template& operator=(const OPTIONAL<HelloMessage>& other_value);
HelloMessage_template& operator=(const HelloMessage_template& other_value);
boolean match(const HelloMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HelloMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HelloMessage_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
INTEGER_template& receiveBufferSize();
const INTEGER_template& receiveBufferSize() const;
INTEGER_template& sendBufferSize();
const INTEGER_template& sendBufferSize() const;
INTEGER_template& maxMessageSize();
const INTEGER_template& maxMessageSize() const;
INTEGER_template& maxChunkCount();
const INTEGER_template& maxChunkCount() const;
String_template& endPointUrl();
const String_template& endPointUrl() const;
int size_of() const;
void log() const;
void log_match(const HelloMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AckMessage : public Base_Type {
  INTEGER field_version;
  INTEGER field_receiveBufferSize;
  INTEGER field_sendBufferSize;
  INTEGER field_maxMessageSize;
  INTEGER field_maxChunkCount;
public:
  AckMessage();
  AckMessage(const INTEGER& par_version,
    const INTEGER& par_receiveBufferSize,
    const INTEGER& par_sendBufferSize,
    const INTEGER& par_maxMessageSize,
    const INTEGER& par_maxChunkCount);
  AckMessage(const AckMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AckMessage& operator=(const AckMessage& other_value);
  boolean operator==(const AckMessage& other_value) const;
  inline boolean operator!=(const AckMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& version()
    {return field_version;}
  inline const INTEGER& version() const
    {return field_version;}
  inline INTEGER& receiveBufferSize()
    {return field_receiveBufferSize;}
  inline const INTEGER& receiveBufferSize() const
    {return field_receiveBufferSize;}
  inline INTEGER& sendBufferSize()
    {return field_sendBufferSize;}
  inline const INTEGER& sendBufferSize() const
    {return field_sendBufferSize;}
  inline INTEGER& maxMessageSize()
    {return field_maxMessageSize;}
  inline const INTEGER& maxMessageSize() const
    {return field_maxMessageSize;}
  inline INTEGER& maxChunkCount()
    {return field_maxChunkCount;}
  inline const INTEGER& maxChunkCount() const
    {return field_maxChunkCount;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AckMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AckMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AckMessage& other_value);
void copy_template(const AckMessage_template& other_value);

public:
AckMessage_template();
AckMessage_template(template_sel other_value);
AckMessage_template(const AckMessage& other_value);
AckMessage_template(const OPTIONAL<AckMessage>& other_value);
AckMessage_template(const AckMessage_template& other_value);
~AckMessage_template();
AckMessage_template& operator=(template_sel other_value);
AckMessage_template& operator=(const AckMessage& other_value);
AckMessage_template& operator=(const OPTIONAL<AckMessage>& other_value);
AckMessage_template& operator=(const AckMessage_template& other_value);
boolean match(const AckMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AckMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AckMessage_template& list_item(unsigned int list_index) const;
INTEGER_template& version();
const INTEGER_template& version() const;
INTEGER_template& receiveBufferSize();
const INTEGER_template& receiveBufferSize() const;
INTEGER_template& sendBufferSize();
const INTEGER_template& sendBufferSize() const;
INTEGER_template& maxMessageSize();
const INTEGER_template& maxMessageSize() const;
INTEGER_template& maxChunkCount();
const INTEGER_template& maxChunkCount() const;
int size_of() const;
void log() const;
void log_match(const AckMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ErrorMessage : public Base_Type {
  INTEGER field_errorCode;
  String field_reason;
public:
  ErrorMessage();
  ErrorMessage(const INTEGER& par_errorCode,
    const String& par_reason);
  ErrorMessage(const ErrorMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ErrorMessage& operator=(const ErrorMessage& other_value);
  boolean operator==(const ErrorMessage& other_value) const;
  inline boolean operator!=(const ErrorMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& errorCode()
    {return field_errorCode;}
  inline const INTEGER& errorCode() const
    {return field_errorCode;}
  inline String& reason()
    {return field_reason;}
  inline const String& reason() const
    {return field_reason;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ErrorMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ErrorMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ErrorMessage& other_value);
void copy_template(const ErrorMessage_template& other_value);

public:
ErrorMessage_template();
ErrorMessage_template(template_sel other_value);
ErrorMessage_template(const ErrorMessage& other_value);
ErrorMessage_template(const OPTIONAL<ErrorMessage>& other_value);
ErrorMessage_template(const ErrorMessage_template& other_value);
~ErrorMessage_template();
ErrorMessage_template& operator=(template_sel other_value);
ErrorMessage_template& operator=(const ErrorMessage& other_value);
ErrorMessage_template& operator=(const OPTIONAL<ErrorMessage>& other_value);
ErrorMessage_template& operator=(const ErrorMessage_template& other_value);
boolean match(const ErrorMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ErrorMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ErrorMessage_template& list_item(unsigned int list_index) const;
INTEGER_template& errorCode();
const INTEGER_template& errorCode() const;
String_template& reason();
const String_template& reason() const;
int size_of() const;
void log() const;
void log_match(const ErrorMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReverseHelloMessage : public Base_Type {
  String field_serverUri;
  String field_endPointUrl;
public:
  ReverseHelloMessage();
  ReverseHelloMessage(const String& par_serverUri,
    const String& par_endPointUrl);
  ReverseHelloMessage(const ReverseHelloMessage& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReverseHelloMessage& operator=(const ReverseHelloMessage& other_value);
  boolean operator==(const ReverseHelloMessage& other_value) const;
  inline boolean operator!=(const ReverseHelloMessage& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline String& serverUri()
    {return field_serverUri;}
  inline const String& serverUri() const
    {return field_serverUri;}
  inline String& endPointUrl()
    {return field_endPointUrl;}
  inline const String& endPointUrl() const
    {return field_endPointUrl;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReverseHelloMessage_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReverseHelloMessage_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReverseHelloMessage& other_value);
void copy_template(const ReverseHelloMessage_template& other_value);

public:
ReverseHelloMessage_template();
ReverseHelloMessage_template(template_sel other_value);
ReverseHelloMessage_template(const ReverseHelloMessage& other_value);
ReverseHelloMessage_template(const OPTIONAL<ReverseHelloMessage>& other_value);
ReverseHelloMessage_template(const ReverseHelloMessage_template& other_value);
~ReverseHelloMessage_template();
ReverseHelloMessage_template& operator=(template_sel other_value);
ReverseHelloMessage_template& operator=(const ReverseHelloMessage& other_value);
ReverseHelloMessage_template& operator=(const OPTIONAL<ReverseHelloMessage>& other_value);
ReverseHelloMessage_template& operator=(const ReverseHelloMessage_template& other_value);
boolean match(const ReverseHelloMessage& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReverseHelloMessage valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReverseHelloMessage_template& list_item(unsigned int list_index) const;
String_template& serverUri();
const String_template& serverUri() const;
String_template& endPointUrl();
const String_template& endPointUrl() const;
int size_of() const;
void log() const;
void log_match(const ReverseHelloMessage& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class FindServiceRequest : public Base_Type {
  RequestHeader field_requestHeader;
  String field_endpointUrl;
  ListOfLocaleId field_localeIds;
  ListOfString field_serverUris;
public:
  FindServiceRequest();
  FindServiceRequest(const RequestHeader& par_requestHeader,
    const String& par_endpointUrl,
    const ListOfLocaleId& par_localeIds,
    const ListOfString& par_serverUris);
  FindServiceRequest(const FindServiceRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  FindServiceRequest& operator=(const FindServiceRequest& other_value);
  boolean operator==(const FindServiceRequest& other_value) const;
  inline boolean operator!=(const FindServiceRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline String& endpointUrl()
    {return field_endpointUrl;}
  inline const String& endpointUrl() const
    {return field_endpointUrl;}
  inline ListOfLocaleId& localeIds()
    {return field_localeIds;}
  inline const ListOfLocaleId& localeIds() const
    {return field_localeIds;}
  inline ListOfString& serverUris()
    {return field_serverUris;}
  inline const ListOfString& serverUris() const
    {return field_serverUris;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class FindServiceRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
FindServiceRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const FindServiceRequest& other_value);
void copy_template(const FindServiceRequest_template& other_value);

public:
FindServiceRequest_template();
FindServiceRequest_template(template_sel other_value);
FindServiceRequest_template(const FindServiceRequest& other_value);
FindServiceRequest_template(const OPTIONAL<FindServiceRequest>& other_value);
FindServiceRequest_template(const FindServiceRequest_template& other_value);
~FindServiceRequest_template();
FindServiceRequest_template& operator=(template_sel other_value);
FindServiceRequest_template& operator=(const FindServiceRequest& other_value);
FindServiceRequest_template& operator=(const OPTIONAL<FindServiceRequest>& other_value);
FindServiceRequest_template& operator=(const FindServiceRequest_template& other_value);
boolean match(const FindServiceRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
FindServiceRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
FindServiceRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
String_template& endpointUrl();
const String_template& endpointUrl() const;
ListOfLocaleId_template& localeIds();
const ListOfLocaleId_template& localeIds() const;
ListOfString_template& serverUris();
const ListOfString_template& serverUris() const;
int size_of() const;
void log() const;
void log_match(const FindServiceRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class FindServiceResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfApplicationDescription field_servers;
public:
  FindServiceResponse();
  FindServiceResponse(const ResponseHeader& par_responseHeader,
    const ListOfApplicationDescription& par_servers);
  FindServiceResponse(const FindServiceResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  FindServiceResponse& operator=(const FindServiceResponse& other_value);
  boolean operator==(const FindServiceResponse& other_value) const;
  inline boolean operator!=(const FindServiceResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfApplicationDescription& servers()
    {return field_servers;}
  inline const ListOfApplicationDescription& servers() const
    {return field_servers;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class FindServiceResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
FindServiceResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const FindServiceResponse& other_value);
void copy_template(const FindServiceResponse_template& other_value);

public:
FindServiceResponse_template();
FindServiceResponse_template(template_sel other_value);
FindServiceResponse_template(const FindServiceResponse& other_value);
FindServiceResponse_template(const OPTIONAL<FindServiceResponse>& other_value);
FindServiceResponse_template(const FindServiceResponse_template& other_value);
~FindServiceResponse_template();
FindServiceResponse_template& operator=(template_sel other_value);
FindServiceResponse_template& operator=(const FindServiceResponse& other_value);
FindServiceResponse_template& operator=(const OPTIONAL<FindServiceResponse>& other_value);
FindServiceResponse_template& operator=(const FindServiceResponse_template& other_value);
boolean match(const FindServiceResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
FindServiceResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
FindServiceResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfApplicationDescription_template& servers();
const ListOfApplicationDescription_template& servers() const;
int size_of() const;
void log() const;
void log_match(const FindServiceResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class FindServersOnNetworkRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_startingRecordId;
  INTEGER field_maxRecordsToReturn;
  ListOfString field_serverCapabilityFilter;
public:
  FindServersOnNetworkRequest();
  FindServersOnNetworkRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_startingRecordId,
    const INTEGER& par_maxRecordsToReturn,
    const ListOfString& par_serverCapabilityFilter);
  FindServersOnNetworkRequest(const FindServersOnNetworkRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  FindServersOnNetworkRequest& operator=(const FindServersOnNetworkRequest& other_value);
  boolean operator==(const FindServersOnNetworkRequest& other_value) const;
  inline boolean operator!=(const FindServersOnNetworkRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& startingRecordId()
    {return field_startingRecordId;}
  inline const INTEGER& startingRecordId() const
    {return field_startingRecordId;}
  inline INTEGER& maxRecordsToReturn()
    {return field_maxRecordsToReturn;}
  inline const INTEGER& maxRecordsToReturn() const
    {return field_maxRecordsToReturn;}
  inline ListOfString& serverCapabilityFilter()
    {return field_serverCapabilityFilter;}
  inline const ListOfString& serverCapabilityFilter() const
    {return field_serverCapabilityFilter;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class FindServersOnNetworkRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
FindServersOnNetworkRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const FindServersOnNetworkRequest& other_value);
void copy_template(const FindServersOnNetworkRequest_template& other_value);

public:
FindServersOnNetworkRequest_template();
FindServersOnNetworkRequest_template(template_sel other_value);
FindServersOnNetworkRequest_template(const FindServersOnNetworkRequest& other_value);
FindServersOnNetworkRequest_template(const OPTIONAL<FindServersOnNetworkRequest>& other_value);
FindServersOnNetworkRequest_template(const FindServersOnNetworkRequest_template& other_value);
~FindServersOnNetworkRequest_template();
FindServersOnNetworkRequest_template& operator=(template_sel other_value);
FindServersOnNetworkRequest_template& operator=(const FindServersOnNetworkRequest& other_value);
FindServersOnNetworkRequest_template& operator=(const OPTIONAL<FindServersOnNetworkRequest>& other_value);
FindServersOnNetworkRequest_template& operator=(const FindServersOnNetworkRequest_template& other_value);
boolean match(const FindServersOnNetworkRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
FindServersOnNetworkRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
FindServersOnNetworkRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& startingRecordId();
const INTEGER_template& startingRecordId() const;
INTEGER_template& maxRecordsToReturn();
const INTEGER_template& maxRecordsToReturn() const;
ListOfString_template& serverCapabilityFilter();
const ListOfString_template& serverCapabilityFilter() const;
int size_of() const;
void log() const;
void log_match(const FindServersOnNetworkRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class FindServersOnNetworkResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  INTEGER field_lastCounterResetTime;
  ListOfServerOnNetwork field_servers;
public:
  FindServersOnNetworkResponse();
  FindServersOnNetworkResponse(const ResponseHeader& par_responseHeader,
    const INTEGER& par_lastCounterResetTime,
    const ListOfServerOnNetwork& par_servers);
  FindServersOnNetworkResponse(const FindServersOnNetworkResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  FindServersOnNetworkResponse& operator=(const FindServersOnNetworkResponse& other_value);
  boolean operator==(const FindServersOnNetworkResponse& other_value) const;
  inline boolean operator!=(const FindServersOnNetworkResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline INTEGER& lastCounterResetTime()
    {return field_lastCounterResetTime;}
  inline const INTEGER& lastCounterResetTime() const
    {return field_lastCounterResetTime;}
  inline ListOfServerOnNetwork& servers()
    {return field_servers;}
  inline const ListOfServerOnNetwork& servers() const
    {return field_servers;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class FindServersOnNetworkResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
FindServersOnNetworkResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const FindServersOnNetworkResponse& other_value);
void copy_template(const FindServersOnNetworkResponse_template& other_value);

public:
FindServersOnNetworkResponse_template();
FindServersOnNetworkResponse_template(template_sel other_value);
FindServersOnNetworkResponse_template(const FindServersOnNetworkResponse& other_value);
FindServersOnNetworkResponse_template(const OPTIONAL<FindServersOnNetworkResponse>& other_value);
FindServersOnNetworkResponse_template(const FindServersOnNetworkResponse_template& other_value);
~FindServersOnNetworkResponse_template();
FindServersOnNetworkResponse_template& operator=(template_sel other_value);
FindServersOnNetworkResponse_template& operator=(const FindServersOnNetworkResponse& other_value);
FindServersOnNetworkResponse_template& operator=(const OPTIONAL<FindServersOnNetworkResponse>& other_value);
FindServersOnNetworkResponse_template& operator=(const FindServersOnNetworkResponse_template& other_value);
boolean match(const FindServersOnNetworkResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
FindServersOnNetworkResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
FindServersOnNetworkResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
INTEGER_template& lastCounterResetTime();
const INTEGER_template& lastCounterResetTime() const;
ListOfServerOnNetwork_template& servers();
const ListOfServerOnNetwork_template& servers() const;
int size_of() const;
void log() const;
void log_match(const FindServersOnNetworkResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GetEndpointsRequest : public Base_Type {
  RequestHeader field_requestHeader;
  String field_endpointUrl;
  ListOfLocaleId field_localeIds;
  ListOfString field_profileUris;
public:
  GetEndpointsRequest();
  GetEndpointsRequest(const RequestHeader& par_requestHeader,
    const String& par_endpointUrl,
    const ListOfLocaleId& par_localeIds,
    const ListOfString& par_profileUris);
  GetEndpointsRequest(const GetEndpointsRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GetEndpointsRequest& operator=(const GetEndpointsRequest& other_value);
  boolean operator==(const GetEndpointsRequest& other_value) const;
  inline boolean operator!=(const GetEndpointsRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline String& endpointUrl()
    {return field_endpointUrl;}
  inline const String& endpointUrl() const
    {return field_endpointUrl;}
  inline ListOfLocaleId& localeIds()
    {return field_localeIds;}
  inline const ListOfLocaleId& localeIds() const
    {return field_localeIds;}
  inline ListOfString& profileUris()
    {return field_profileUris;}
  inline const ListOfString& profileUris() const
    {return field_profileUris;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GetEndpointsRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GetEndpointsRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GetEndpointsRequest& other_value);
void copy_template(const GetEndpointsRequest_template& other_value);

public:
GetEndpointsRequest_template();
GetEndpointsRequest_template(template_sel other_value);
GetEndpointsRequest_template(const GetEndpointsRequest& other_value);
GetEndpointsRequest_template(const OPTIONAL<GetEndpointsRequest>& other_value);
GetEndpointsRequest_template(const GetEndpointsRequest_template& other_value);
~GetEndpointsRequest_template();
GetEndpointsRequest_template& operator=(template_sel other_value);
GetEndpointsRequest_template& operator=(const GetEndpointsRequest& other_value);
GetEndpointsRequest_template& operator=(const OPTIONAL<GetEndpointsRequest>& other_value);
GetEndpointsRequest_template& operator=(const GetEndpointsRequest_template& other_value);
boolean match(const GetEndpointsRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GetEndpointsRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GetEndpointsRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
String_template& endpointUrl();
const String_template& endpointUrl() const;
ListOfLocaleId_template& localeIds();
const ListOfLocaleId_template& localeIds() const;
ListOfString_template& profileUris();
const ListOfString_template& profileUris() const;
int size_of() const;
void log() const;
void log_match(const GetEndpointsRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class GetEndpointsResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfEndpointDescription field_Endpoints;
public:
  GetEndpointsResponse();
  GetEndpointsResponse(const ResponseHeader& par_responseHeader,
    const ListOfEndpointDescription& par_Endpoints);
  GetEndpointsResponse(const GetEndpointsResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  GetEndpointsResponse& operator=(const GetEndpointsResponse& other_value);
  boolean operator==(const GetEndpointsResponse& other_value) const;
  inline boolean operator!=(const GetEndpointsResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfEndpointDescription& Endpoints()
    {return field_Endpoints;}
  inline const ListOfEndpointDescription& Endpoints() const
    {return field_Endpoints;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class GetEndpointsResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
GetEndpointsResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const GetEndpointsResponse& other_value);
void copy_template(const GetEndpointsResponse_template& other_value);

public:
GetEndpointsResponse_template();
GetEndpointsResponse_template(template_sel other_value);
GetEndpointsResponse_template(const GetEndpointsResponse& other_value);
GetEndpointsResponse_template(const OPTIONAL<GetEndpointsResponse>& other_value);
GetEndpointsResponse_template(const GetEndpointsResponse_template& other_value);
~GetEndpointsResponse_template();
GetEndpointsResponse_template& operator=(template_sel other_value);
GetEndpointsResponse_template& operator=(const GetEndpointsResponse& other_value);
GetEndpointsResponse_template& operator=(const OPTIONAL<GetEndpointsResponse>& other_value);
GetEndpointsResponse_template& operator=(const GetEndpointsResponse_template& other_value);
boolean match(const GetEndpointsResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
GetEndpointsResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
GetEndpointsResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfEndpointDescription_template& Endpoints();
const ListOfEndpointDescription_template& Endpoints() const;
int size_of() const;
void log() const;
void log_match(const GetEndpointsResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegisterServerRequest : public Base_Type {
  RequestHeader field_requestHeader;
  RegisteredServer field_server;
public:
  RegisterServerRequest();
  RegisterServerRequest(const RequestHeader& par_requestHeader,
    const RegisteredServer& par_server);
  RegisterServerRequest(const RegisterServerRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RegisterServerRequest& operator=(const RegisterServerRequest& other_value);
  boolean operator==(const RegisterServerRequest& other_value) const;
  inline boolean operator!=(const RegisterServerRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline RegisteredServer& server()
    {return field_server;}
  inline const RegisteredServer& server() const
    {return field_server;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RegisterServerRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RegisterServerRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RegisterServerRequest& other_value);
void copy_template(const RegisterServerRequest_template& other_value);

public:
RegisterServerRequest_template();
RegisterServerRequest_template(template_sel other_value);
RegisterServerRequest_template(const RegisterServerRequest& other_value);
RegisterServerRequest_template(const OPTIONAL<RegisterServerRequest>& other_value);
RegisterServerRequest_template(const RegisterServerRequest_template& other_value);
~RegisterServerRequest_template();
RegisterServerRequest_template& operator=(template_sel other_value);
RegisterServerRequest_template& operator=(const RegisterServerRequest& other_value);
RegisterServerRequest_template& operator=(const OPTIONAL<RegisterServerRequest>& other_value);
RegisterServerRequest_template& operator=(const RegisterServerRequest_template& other_value);
boolean match(const RegisterServerRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegisterServerRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegisterServerRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
RegisteredServer_template& server();
const RegisteredServer_template& server() const;
int size_of() const;
void log() const;
void log_match(const RegisterServerRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegisterServerResponse : public Base_Type {
  ResponseHeader field_responseHeader;
public:
  RegisterServerResponse();
  RegisterServerResponse(const ResponseHeader& par_responseHeader);
  RegisterServerResponse(const RegisterServerResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RegisterServerResponse& operator=(const RegisterServerResponse& other_value);
  boolean operator==(const RegisterServerResponse& other_value) const;
  inline boolean operator!=(const RegisterServerResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RegisterServerResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RegisterServerResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RegisterServerResponse& other_value);
void copy_template(const RegisterServerResponse_template& other_value);

public:
RegisterServerResponse_template();
RegisterServerResponse_template(template_sel other_value);
RegisterServerResponse_template(const RegisterServerResponse& other_value);
RegisterServerResponse_template(const OPTIONAL<RegisterServerResponse>& other_value);
RegisterServerResponse_template(const RegisterServerResponse_template& other_value);
~RegisterServerResponse_template();
RegisterServerResponse_template& operator=(template_sel other_value);
RegisterServerResponse_template& operator=(const RegisterServerResponse& other_value);
RegisterServerResponse_template& operator=(const OPTIONAL<RegisterServerResponse>& other_value);
RegisterServerResponse_template& operator=(const RegisterServerResponse_template& other_value);
boolean match(const RegisterServerResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegisterServerResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegisterServerResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
int size_of() const;
void log() const;
void log_match(const RegisterServerResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegisterServer2Request : public Base_Type {
  RequestHeader field_requestHeader;
  RegisteredServer field_server;
  ListOfExtensibleParameter field_discoveryConfiguration;
public:
  RegisterServer2Request();
  RegisterServer2Request(const RequestHeader& par_requestHeader,
    const RegisteredServer& par_server,
    const ListOfExtensibleParameter& par_discoveryConfiguration);
  RegisterServer2Request(const RegisterServer2Request& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RegisterServer2Request& operator=(const RegisterServer2Request& other_value);
  boolean operator==(const RegisterServer2Request& other_value) const;
  inline boolean operator!=(const RegisterServer2Request& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline RegisteredServer& server()
    {return field_server;}
  inline const RegisteredServer& server() const
    {return field_server;}
  inline ListOfExtensibleParameter& discoveryConfiguration()
    {return field_discoveryConfiguration;}
  inline const ListOfExtensibleParameter& discoveryConfiguration() const
    {return field_discoveryConfiguration;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RegisterServer2Request_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RegisterServer2Request_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RegisterServer2Request& other_value);
void copy_template(const RegisterServer2Request_template& other_value);

public:
RegisterServer2Request_template();
RegisterServer2Request_template(template_sel other_value);
RegisterServer2Request_template(const RegisterServer2Request& other_value);
RegisterServer2Request_template(const OPTIONAL<RegisterServer2Request>& other_value);
RegisterServer2Request_template(const RegisterServer2Request_template& other_value);
~RegisterServer2Request_template();
RegisterServer2Request_template& operator=(template_sel other_value);
RegisterServer2Request_template& operator=(const RegisterServer2Request& other_value);
RegisterServer2Request_template& operator=(const OPTIONAL<RegisterServer2Request>& other_value);
RegisterServer2Request_template& operator=(const RegisterServer2Request_template& other_value);
boolean match(const RegisterServer2Request& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegisterServer2Request valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegisterServer2Request_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
RegisteredServer_template& server();
const RegisteredServer_template& server() const;
ListOfExtensibleParameter_template& discoveryConfiguration();
const ListOfExtensibleParameter_template& discoveryConfiguration() const;
int size_of() const;
void log() const;
void log_match(const RegisterServer2Request& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegisterServer2Response : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_configurationResults;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  RegisterServer2Response();
  RegisterServer2Response(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_configurationResults,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  RegisterServer2Response(const RegisterServer2Response& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RegisterServer2Response& operator=(const RegisterServer2Response& other_value);
  boolean operator==(const RegisterServer2Response& other_value) const;
  inline boolean operator!=(const RegisterServer2Response& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& configurationResults()
    {return field_configurationResults;}
  inline const ListOfStatusCode& configurationResults() const
    {return field_configurationResults;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RegisterServer2Response_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RegisterServer2Response_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RegisterServer2Response& other_value);
void copy_template(const RegisterServer2Response_template& other_value);

public:
RegisterServer2Response_template();
RegisterServer2Response_template(template_sel other_value);
RegisterServer2Response_template(const RegisterServer2Response& other_value);
RegisterServer2Response_template(const OPTIONAL<RegisterServer2Response>& other_value);
RegisterServer2Response_template(const RegisterServer2Response_template& other_value);
~RegisterServer2Response_template();
RegisterServer2Response_template& operator=(template_sel other_value);
RegisterServer2Response_template& operator=(const RegisterServer2Response& other_value);
RegisterServer2Response_template& operator=(const OPTIONAL<RegisterServer2Response>& other_value);
RegisterServer2Response_template& operator=(const RegisterServer2Response_template& other_value);
boolean match(const RegisterServer2Response& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegisterServer2Response valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegisterServer2Response_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& configurationResults();
const ListOfStatusCode_template& configurationResults() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const RegisterServer2Response& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class OpenSecureChannelRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_clientProtocolVersion;
  SecurityTokenRequestType field_requestType;
  MessageSecurityMode field_securityMode;
  ByteString field_clientNonce;
  INTEGER field_requestedLifetime;
public:
  OpenSecureChannelRequest();
  OpenSecureChannelRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_clientProtocolVersion,
    const SecurityTokenRequestType& par_requestType,
    const MessageSecurityMode& par_securityMode,
    const ByteString& par_clientNonce,
    const INTEGER& par_requestedLifetime);
  OpenSecureChannelRequest(const OpenSecureChannelRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  OpenSecureChannelRequest& operator=(const OpenSecureChannelRequest& other_value);
  boolean operator==(const OpenSecureChannelRequest& other_value) const;
  inline boolean operator!=(const OpenSecureChannelRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& clientProtocolVersion()
    {return field_clientProtocolVersion;}
  inline const INTEGER& clientProtocolVersion() const
    {return field_clientProtocolVersion;}
  inline SecurityTokenRequestType& requestType()
    {return field_requestType;}
  inline const SecurityTokenRequestType& requestType() const
    {return field_requestType;}
  inline MessageSecurityMode& securityMode()
    {return field_securityMode;}
  inline const MessageSecurityMode& securityMode() const
    {return field_securityMode;}
  inline ByteString& clientNonce()
    {return field_clientNonce;}
  inline const ByteString& clientNonce() const
    {return field_clientNonce;}
  inline INTEGER& requestedLifetime()
    {return field_requestedLifetime;}
  inline const INTEGER& requestedLifetime() const
    {return field_requestedLifetime;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class OpenSecureChannelRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
OpenSecureChannelRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const OpenSecureChannelRequest& other_value);
void copy_template(const OpenSecureChannelRequest_template& other_value);

public:
OpenSecureChannelRequest_template();
OpenSecureChannelRequest_template(template_sel other_value);
OpenSecureChannelRequest_template(const OpenSecureChannelRequest& other_value);
OpenSecureChannelRequest_template(const OPTIONAL<OpenSecureChannelRequest>& other_value);
OpenSecureChannelRequest_template(const OpenSecureChannelRequest_template& other_value);
~OpenSecureChannelRequest_template();
OpenSecureChannelRequest_template& operator=(template_sel other_value);
OpenSecureChannelRequest_template& operator=(const OpenSecureChannelRequest& other_value);
OpenSecureChannelRequest_template& operator=(const OPTIONAL<OpenSecureChannelRequest>& other_value);
OpenSecureChannelRequest_template& operator=(const OpenSecureChannelRequest_template& other_value);
boolean match(const OpenSecureChannelRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
OpenSecureChannelRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
OpenSecureChannelRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& clientProtocolVersion();
const INTEGER_template& clientProtocolVersion() const;
SecurityTokenRequestType_template& requestType();
const SecurityTokenRequestType_template& requestType() const;
MessageSecurityMode_template& securityMode();
const MessageSecurityMode_template& securityMode() const;
ByteString_template& clientNonce();
const ByteString_template& clientNonce() const;
INTEGER_template& requestedLifetime();
const INTEGER_template& requestedLifetime() const;
int size_of() const;
void log() const;
void log_match(const OpenSecureChannelRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class OpenSecureChannelResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  INTEGER field_serverProtocolVersion;
  ChannelSecurityToken field_securityToken;
  ByteString field_serverNonce;
public:
  OpenSecureChannelResponse();
  OpenSecureChannelResponse(const ResponseHeader& par_responseHeader,
    const INTEGER& par_serverProtocolVersion,
    const ChannelSecurityToken& par_securityToken,
    const ByteString& par_serverNonce);
  OpenSecureChannelResponse(const OpenSecureChannelResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  OpenSecureChannelResponse& operator=(const OpenSecureChannelResponse& other_value);
  boolean operator==(const OpenSecureChannelResponse& other_value) const;
  inline boolean operator!=(const OpenSecureChannelResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline INTEGER& serverProtocolVersion()
    {return field_serverProtocolVersion;}
  inline const INTEGER& serverProtocolVersion() const
    {return field_serverProtocolVersion;}
  inline ChannelSecurityToken& securityToken()
    {return field_securityToken;}
  inline const ChannelSecurityToken& securityToken() const
    {return field_securityToken;}
  inline ByteString& serverNonce()
    {return field_serverNonce;}
  inline const ByteString& serverNonce() const
    {return field_serverNonce;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class OpenSecureChannelResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
OpenSecureChannelResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const OpenSecureChannelResponse& other_value);
void copy_template(const OpenSecureChannelResponse_template& other_value);

public:
OpenSecureChannelResponse_template();
OpenSecureChannelResponse_template(template_sel other_value);
OpenSecureChannelResponse_template(const OpenSecureChannelResponse& other_value);
OpenSecureChannelResponse_template(const OPTIONAL<OpenSecureChannelResponse>& other_value);
OpenSecureChannelResponse_template(const OpenSecureChannelResponse_template& other_value);
~OpenSecureChannelResponse_template();
OpenSecureChannelResponse_template& operator=(template_sel other_value);
OpenSecureChannelResponse_template& operator=(const OpenSecureChannelResponse& other_value);
OpenSecureChannelResponse_template& operator=(const OPTIONAL<OpenSecureChannelResponse>& other_value);
OpenSecureChannelResponse_template& operator=(const OpenSecureChannelResponse_template& other_value);
boolean match(const OpenSecureChannelResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
OpenSecureChannelResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
OpenSecureChannelResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
INTEGER_template& serverProtocolVersion();
const INTEGER_template& serverProtocolVersion() const;
ChannelSecurityToken_template& securityToken();
const ChannelSecurityToken_template& securityToken() const;
ByteString_template& serverNonce();
const ByteString_template& serverNonce() const;
int size_of() const;
void log() const;
void log_match(const OpenSecureChannelResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CloseSecureChannelRequest : public Base_Type {
  RequestHeader field_requestHeader;
public:
  CloseSecureChannelRequest();
  CloseSecureChannelRequest(const RequestHeader& par_requestHeader);
  CloseSecureChannelRequest(const CloseSecureChannelRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CloseSecureChannelRequest& operator=(const CloseSecureChannelRequest& other_value);
  boolean operator==(const CloseSecureChannelRequest& other_value) const;
  inline boolean operator!=(const CloseSecureChannelRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CloseSecureChannelRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CloseSecureChannelRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CloseSecureChannelRequest& other_value);
void copy_template(const CloseSecureChannelRequest_template& other_value);

public:
CloseSecureChannelRequest_template();
CloseSecureChannelRequest_template(template_sel other_value);
CloseSecureChannelRequest_template(const CloseSecureChannelRequest& other_value);
CloseSecureChannelRequest_template(const OPTIONAL<CloseSecureChannelRequest>& other_value);
CloseSecureChannelRequest_template(const CloseSecureChannelRequest_template& other_value);
~CloseSecureChannelRequest_template();
CloseSecureChannelRequest_template& operator=(template_sel other_value);
CloseSecureChannelRequest_template& operator=(const CloseSecureChannelRequest& other_value);
CloseSecureChannelRequest_template& operator=(const OPTIONAL<CloseSecureChannelRequest>& other_value);
CloseSecureChannelRequest_template& operator=(const CloseSecureChannelRequest_template& other_value);
boolean match(const CloseSecureChannelRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CloseSecureChannelRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CloseSecureChannelRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
int size_of() const;
void log() const;
void log_match(const CloseSecureChannelRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CloseSecureChannelResponse : public Base_Type {
  ResponseHeader field_responseHeader;
public:
  CloseSecureChannelResponse();
  CloseSecureChannelResponse(const ResponseHeader& par_responseHeader);
  CloseSecureChannelResponse(const CloseSecureChannelResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CloseSecureChannelResponse& operator=(const CloseSecureChannelResponse& other_value);
  boolean operator==(const CloseSecureChannelResponse& other_value) const;
  inline boolean operator!=(const CloseSecureChannelResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CloseSecureChannelResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CloseSecureChannelResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CloseSecureChannelResponse& other_value);
void copy_template(const CloseSecureChannelResponse_template& other_value);

public:
CloseSecureChannelResponse_template();
CloseSecureChannelResponse_template(template_sel other_value);
CloseSecureChannelResponse_template(const CloseSecureChannelResponse& other_value);
CloseSecureChannelResponse_template(const OPTIONAL<CloseSecureChannelResponse>& other_value);
CloseSecureChannelResponse_template(const CloseSecureChannelResponse_template& other_value);
~CloseSecureChannelResponse_template();
CloseSecureChannelResponse_template& operator=(template_sel other_value);
CloseSecureChannelResponse_template& operator=(const CloseSecureChannelResponse& other_value);
CloseSecureChannelResponse_template& operator=(const OPTIONAL<CloseSecureChannelResponse>& other_value);
CloseSecureChannelResponse_template& operator=(const CloseSecureChannelResponse_template& other_value);
boolean match(const CloseSecureChannelResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CloseSecureChannelResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CloseSecureChannelResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
int size_of() const;
void log() const;
void log_match(const CloseSecureChannelResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CreateSessionRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ApplicationDescription field_clientDescription;
  String field_serverUri;
  String field_endpointUrl;
  String field_sessionName;
  ByteString field_clientNonce;
  ByteString field_clientCertificate;
  FLOAT field_requestedSessionTimeout;
  INTEGER field_maxResponseMessageSize;
public:
  CreateSessionRequest();
  CreateSessionRequest(const RequestHeader& par_requestHeader,
    const ApplicationDescription& par_clientDescription,
    const String& par_serverUri,
    const String& par_endpointUrl,
    const String& par_sessionName,
    const ByteString& par_clientNonce,
    const ByteString& par_clientCertificate,
    const FLOAT& par_requestedSessionTimeout,
    const INTEGER& par_maxResponseMessageSize);
  CreateSessionRequest(const CreateSessionRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CreateSessionRequest& operator=(const CreateSessionRequest& other_value);
  boolean operator==(const CreateSessionRequest& other_value) const;
  inline boolean operator!=(const CreateSessionRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ApplicationDescription& clientDescription()
    {return field_clientDescription;}
  inline const ApplicationDescription& clientDescription() const
    {return field_clientDescription;}
  inline String& serverUri()
    {return field_serverUri;}
  inline const String& serverUri() const
    {return field_serverUri;}
  inline String& endpointUrl()
    {return field_endpointUrl;}
  inline const String& endpointUrl() const
    {return field_endpointUrl;}
  inline String& sessionName()
    {return field_sessionName;}
  inline const String& sessionName() const
    {return field_sessionName;}
  inline ByteString& clientNonce()
    {return field_clientNonce;}
  inline const ByteString& clientNonce() const
    {return field_clientNonce;}
  inline ByteString& clientCertificate()
    {return field_clientCertificate;}
  inline const ByteString& clientCertificate() const
    {return field_clientCertificate;}
  inline FLOAT& requestedSessionTimeout()
    {return field_requestedSessionTimeout;}
  inline const FLOAT& requestedSessionTimeout() const
    {return field_requestedSessionTimeout;}
  inline INTEGER& maxResponseMessageSize()
    {return field_maxResponseMessageSize;}
  inline const INTEGER& maxResponseMessageSize() const
    {return field_maxResponseMessageSize;}
  inline int size_of() const
    {return 9;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CreateSessionRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CreateSessionRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CreateSessionRequest& other_value);
void copy_template(const CreateSessionRequest_template& other_value);

public:
CreateSessionRequest_template();
CreateSessionRequest_template(template_sel other_value);
CreateSessionRequest_template(const CreateSessionRequest& other_value);
CreateSessionRequest_template(const OPTIONAL<CreateSessionRequest>& other_value);
CreateSessionRequest_template(const CreateSessionRequest_template& other_value);
~CreateSessionRequest_template();
CreateSessionRequest_template& operator=(template_sel other_value);
CreateSessionRequest_template& operator=(const CreateSessionRequest& other_value);
CreateSessionRequest_template& operator=(const OPTIONAL<CreateSessionRequest>& other_value);
CreateSessionRequest_template& operator=(const CreateSessionRequest_template& other_value);
boolean match(const CreateSessionRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CreateSessionRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CreateSessionRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ApplicationDescription_template& clientDescription();
const ApplicationDescription_template& clientDescription() const;
String_template& serverUri();
const String_template& serverUri() const;
String_template& endpointUrl();
const String_template& endpointUrl() const;
String_template& sessionName();
const String_template& sessionName() const;
ByteString_template& clientNonce();
const ByteString_template& clientNonce() const;
ByteString_template& clientCertificate();
const ByteString_template& clientCertificate() const;
FLOAT_template& requestedSessionTimeout();
const FLOAT_template& requestedSessionTimeout() const;
INTEGER_template& maxResponseMessageSize();
const INTEGER_template& maxResponseMessageSize() const;
int size_of() const;
void log() const;
void log_match(const CreateSessionRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CreateSessionResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  NodeId field_sessionId;
  NodeId field_authenticationToken;
  FLOAT field_revisedSessionTimeout;
  ByteString field_serverNonce;
  ByteString field_serverCertificate;
  ListOfEndpointDescription field_serverEndpoints;
  ListOfSignedSoftwareCertificate field_serverSoftwareCertificates;
  SignatureData field_serverSignature;
  INTEGER field_maxRequestMessageSize;
public:
  CreateSessionResponse();
  CreateSessionResponse(const ResponseHeader& par_responseHeader,
    const NodeId& par_sessionId,
    const NodeId& par_authenticationToken,
    const FLOAT& par_revisedSessionTimeout,
    const ByteString& par_serverNonce,
    const ByteString& par_serverCertificate,
    const ListOfEndpointDescription& par_serverEndpoints,
    const ListOfSignedSoftwareCertificate& par_serverSoftwareCertificates,
    const SignatureData& par_serverSignature,
    const INTEGER& par_maxRequestMessageSize);
  CreateSessionResponse(const CreateSessionResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CreateSessionResponse& operator=(const CreateSessionResponse& other_value);
  boolean operator==(const CreateSessionResponse& other_value) const;
  inline boolean operator!=(const CreateSessionResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline NodeId& sessionId()
    {return field_sessionId;}
  inline const NodeId& sessionId() const
    {return field_sessionId;}
  inline NodeId& authenticationToken()
    {return field_authenticationToken;}
  inline const NodeId& authenticationToken() const
    {return field_authenticationToken;}
  inline FLOAT& revisedSessionTimeout()
    {return field_revisedSessionTimeout;}
  inline const FLOAT& revisedSessionTimeout() const
    {return field_revisedSessionTimeout;}
  inline ByteString& serverNonce()
    {return field_serverNonce;}
  inline const ByteString& serverNonce() const
    {return field_serverNonce;}
  inline ByteString& serverCertificate()
    {return field_serverCertificate;}
  inline const ByteString& serverCertificate() const
    {return field_serverCertificate;}
  inline ListOfEndpointDescription& serverEndpoints()
    {return field_serverEndpoints;}
  inline const ListOfEndpointDescription& serverEndpoints() const
    {return field_serverEndpoints;}
  inline ListOfSignedSoftwareCertificate& serverSoftwareCertificates()
    {return field_serverSoftwareCertificates;}
  inline const ListOfSignedSoftwareCertificate& serverSoftwareCertificates() const
    {return field_serverSoftwareCertificates;}
  inline SignatureData& serverSignature()
    {return field_serverSignature;}
  inline const SignatureData& serverSignature() const
    {return field_serverSignature;}
  inline INTEGER& maxRequestMessageSize()
    {return field_maxRequestMessageSize;}
  inline const INTEGER& maxRequestMessageSize() const
    {return field_maxRequestMessageSize;}
  inline int size_of() const
    {return 10;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CreateSessionResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CreateSessionResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CreateSessionResponse& other_value);
void copy_template(const CreateSessionResponse_template& other_value);

public:
CreateSessionResponse_template();
CreateSessionResponse_template(template_sel other_value);
CreateSessionResponse_template(const CreateSessionResponse& other_value);
CreateSessionResponse_template(const OPTIONAL<CreateSessionResponse>& other_value);
CreateSessionResponse_template(const CreateSessionResponse_template& other_value);
~CreateSessionResponse_template();
CreateSessionResponse_template& operator=(template_sel other_value);
CreateSessionResponse_template& operator=(const CreateSessionResponse& other_value);
CreateSessionResponse_template& operator=(const OPTIONAL<CreateSessionResponse>& other_value);
CreateSessionResponse_template& operator=(const CreateSessionResponse_template& other_value);
boolean match(const CreateSessionResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CreateSessionResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CreateSessionResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
NodeId_template& sessionId();
const NodeId_template& sessionId() const;
NodeId_template& authenticationToken();
const NodeId_template& authenticationToken() const;
FLOAT_template& revisedSessionTimeout();
const FLOAT_template& revisedSessionTimeout() const;
ByteString_template& serverNonce();
const ByteString_template& serverNonce() const;
ByteString_template& serverCertificate();
const ByteString_template& serverCertificate() const;
ListOfEndpointDescription_template& serverEndpoints();
const ListOfEndpointDescription_template& serverEndpoints() const;
ListOfSignedSoftwareCertificate_template& serverSoftwareCertificates();
const ListOfSignedSoftwareCertificate_template& serverSoftwareCertificates() const;
SignatureData_template& serverSignature();
const SignatureData_template& serverSignature() const;
INTEGER_template& maxRequestMessageSize();
const INTEGER_template& maxRequestMessageSize() const;
int size_of() const;
void log() const;
void log_match(const CreateSessionResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ActivateSessionRequest : public Base_Type {
  RequestHeader field_requestHeader;
  SignatureData field_clientSignature;
  ListOfSignedSoftwareCertificate field_clientSoftwareCertificates;
  ListOfLocaleId field_localeIds;
  ExtensibleParameter field_userIdentityToken;
  SignatureData field_userTokenSignature;
public:
  ActivateSessionRequest();
  ActivateSessionRequest(const RequestHeader& par_requestHeader,
    const SignatureData& par_clientSignature,
    const ListOfSignedSoftwareCertificate& par_clientSoftwareCertificates,
    const ListOfLocaleId& par_localeIds,
    const ExtensibleParameter& par_userIdentityToken,
    const SignatureData& par_userTokenSignature);
  ActivateSessionRequest(const ActivateSessionRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ActivateSessionRequest& operator=(const ActivateSessionRequest& other_value);
  boolean operator==(const ActivateSessionRequest& other_value) const;
  inline boolean operator!=(const ActivateSessionRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline SignatureData& clientSignature()
    {return field_clientSignature;}
  inline const SignatureData& clientSignature() const
    {return field_clientSignature;}
  inline ListOfSignedSoftwareCertificate& clientSoftwareCertificates()
    {return field_clientSoftwareCertificates;}
  inline const ListOfSignedSoftwareCertificate& clientSoftwareCertificates() const
    {return field_clientSoftwareCertificates;}
  inline ListOfLocaleId& localeIds()
    {return field_localeIds;}
  inline const ListOfLocaleId& localeIds() const
    {return field_localeIds;}
  inline ExtensibleParameter& userIdentityToken()
    {return field_userIdentityToken;}
  inline const ExtensibleParameter& userIdentityToken() const
    {return field_userIdentityToken;}
  inline SignatureData& userTokenSignature()
    {return field_userTokenSignature;}
  inline const SignatureData& userTokenSignature() const
    {return field_userTokenSignature;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ActivateSessionRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ActivateSessionRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ActivateSessionRequest& other_value);
void copy_template(const ActivateSessionRequest_template& other_value);

public:
ActivateSessionRequest_template();
ActivateSessionRequest_template(template_sel other_value);
ActivateSessionRequest_template(const ActivateSessionRequest& other_value);
ActivateSessionRequest_template(const OPTIONAL<ActivateSessionRequest>& other_value);
ActivateSessionRequest_template(const ActivateSessionRequest_template& other_value);
~ActivateSessionRequest_template();
ActivateSessionRequest_template& operator=(template_sel other_value);
ActivateSessionRequest_template& operator=(const ActivateSessionRequest& other_value);
ActivateSessionRequest_template& operator=(const OPTIONAL<ActivateSessionRequest>& other_value);
ActivateSessionRequest_template& operator=(const ActivateSessionRequest_template& other_value);
boolean match(const ActivateSessionRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ActivateSessionRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ActivateSessionRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
SignatureData_template& clientSignature();
const SignatureData_template& clientSignature() const;
ListOfSignedSoftwareCertificate_template& clientSoftwareCertificates();
const ListOfSignedSoftwareCertificate_template& clientSoftwareCertificates() const;
ListOfLocaleId_template& localeIds();
const ListOfLocaleId_template& localeIds() const;
ExtensibleParameter_template& userIdentityToken();
const ExtensibleParameter_template& userIdentityToken() const;
SignatureData_template& userTokenSignature();
const SignatureData_template& userTokenSignature() const;
int size_of() const;
void log() const;
void log_match(const ActivateSessionRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ActivateSessionResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ByteString field_serverNonce;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  ActivateSessionResponse();
  ActivateSessionResponse(const ResponseHeader& par_responseHeader,
    const ByteString& par_serverNonce,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  ActivateSessionResponse(const ActivateSessionResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ActivateSessionResponse& operator=(const ActivateSessionResponse& other_value);
  boolean operator==(const ActivateSessionResponse& other_value) const;
  inline boolean operator!=(const ActivateSessionResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ByteString& serverNonce()
    {return field_serverNonce;}
  inline const ByteString& serverNonce() const
    {return field_serverNonce;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ActivateSessionResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ActivateSessionResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ActivateSessionResponse& other_value);
void copy_template(const ActivateSessionResponse_template& other_value);

public:
ActivateSessionResponse_template();
ActivateSessionResponse_template(template_sel other_value);
ActivateSessionResponse_template(const ActivateSessionResponse& other_value);
ActivateSessionResponse_template(const OPTIONAL<ActivateSessionResponse>& other_value);
ActivateSessionResponse_template(const ActivateSessionResponse_template& other_value);
~ActivateSessionResponse_template();
ActivateSessionResponse_template& operator=(template_sel other_value);
ActivateSessionResponse_template& operator=(const ActivateSessionResponse& other_value);
ActivateSessionResponse_template& operator=(const OPTIONAL<ActivateSessionResponse>& other_value);
ActivateSessionResponse_template& operator=(const ActivateSessionResponse_template& other_value);
boolean match(const ActivateSessionResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ActivateSessionResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ActivateSessionResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ByteString_template& serverNonce();
const ByteString_template& serverNonce() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const ActivateSessionResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CloseSessionRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_deleteSubscriptions;
public:
  CloseSessionRequest();
  CloseSessionRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_deleteSubscriptions);
  CloseSessionRequest(const CloseSessionRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CloseSessionRequest& operator=(const CloseSessionRequest& other_value);
  boolean operator==(const CloseSessionRequest& other_value) const;
  inline boolean operator!=(const CloseSessionRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& deleteSubscriptions()
    {return field_deleteSubscriptions;}
  inline const INTEGER& deleteSubscriptions() const
    {return field_deleteSubscriptions;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CloseSessionRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CloseSessionRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CloseSessionRequest& other_value);
void copy_template(const CloseSessionRequest_template& other_value);

public:
CloseSessionRequest_template();
CloseSessionRequest_template(template_sel other_value);
CloseSessionRequest_template(const CloseSessionRequest& other_value);
CloseSessionRequest_template(const OPTIONAL<CloseSessionRequest>& other_value);
CloseSessionRequest_template(const CloseSessionRequest_template& other_value);
~CloseSessionRequest_template();
CloseSessionRequest_template& operator=(template_sel other_value);
CloseSessionRequest_template& operator=(const CloseSessionRequest& other_value);
CloseSessionRequest_template& operator=(const OPTIONAL<CloseSessionRequest>& other_value);
CloseSessionRequest_template& operator=(const CloseSessionRequest_template& other_value);
boolean match(const CloseSessionRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CloseSessionRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CloseSessionRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& deleteSubscriptions();
const INTEGER_template& deleteSubscriptions() const;
int size_of() const;
void log() const;
void log_match(const CloseSessionRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CloseSessionResponse : public Base_Type {
  ResponseHeader field_responseHeader;
public:
  CloseSessionResponse();
  CloseSessionResponse(const ResponseHeader& par_responseHeader);
  CloseSessionResponse(const CloseSessionResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CloseSessionResponse& operator=(const CloseSessionResponse& other_value);
  boolean operator==(const CloseSessionResponse& other_value) const;
  inline boolean operator!=(const CloseSessionResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CloseSessionResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CloseSessionResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CloseSessionResponse& other_value);
void copy_template(const CloseSessionResponse_template& other_value);

public:
CloseSessionResponse_template();
CloseSessionResponse_template(template_sel other_value);
CloseSessionResponse_template(const CloseSessionResponse& other_value);
CloseSessionResponse_template(const OPTIONAL<CloseSessionResponse>& other_value);
CloseSessionResponse_template(const CloseSessionResponse_template& other_value);
~CloseSessionResponse_template();
CloseSessionResponse_template& operator=(template_sel other_value);
CloseSessionResponse_template& operator=(const CloseSessionResponse& other_value);
CloseSessionResponse_template& operator=(const OPTIONAL<CloseSessionResponse>& other_value);
CloseSessionResponse_template& operator=(const CloseSessionResponse_template& other_value);
boolean match(const CloseSessionResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CloseSessionResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CloseSessionResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
int size_of() const;
void log() const;
void log_match(const CloseSessionResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CancelRequestRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_requestHandle;
public:
  CancelRequestRequest();
  CancelRequestRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_requestHandle);
  CancelRequestRequest(const CancelRequestRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CancelRequestRequest& operator=(const CancelRequestRequest& other_value);
  boolean operator==(const CancelRequestRequest& other_value) const;
  inline boolean operator!=(const CancelRequestRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& requestHandle()
    {return field_requestHandle;}
  inline const INTEGER& requestHandle() const
    {return field_requestHandle;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CancelRequestRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CancelRequestRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CancelRequestRequest& other_value);
void copy_template(const CancelRequestRequest_template& other_value);

public:
CancelRequestRequest_template();
CancelRequestRequest_template(template_sel other_value);
CancelRequestRequest_template(const CancelRequestRequest& other_value);
CancelRequestRequest_template(const OPTIONAL<CancelRequestRequest>& other_value);
CancelRequestRequest_template(const CancelRequestRequest_template& other_value);
~CancelRequestRequest_template();
CancelRequestRequest_template& operator=(template_sel other_value);
CancelRequestRequest_template& operator=(const CancelRequestRequest& other_value);
CancelRequestRequest_template& operator=(const OPTIONAL<CancelRequestRequest>& other_value);
CancelRequestRequest_template& operator=(const CancelRequestRequest_template& other_value);
boolean match(const CancelRequestRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CancelRequestRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CancelRequestRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& requestHandle();
const INTEGER_template& requestHandle() const;
int size_of() const;
void log() const;
void log_match(const CancelRequestRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CancelRequestResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  INTEGER field_cancelCount;
public:
  CancelRequestResponse();
  CancelRequestResponse(const ResponseHeader& par_responseHeader,
    const INTEGER& par_cancelCount);
  CancelRequestResponse(const CancelRequestResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CancelRequestResponse& operator=(const CancelRequestResponse& other_value);
  boolean operator==(const CancelRequestResponse& other_value) const;
  inline boolean operator!=(const CancelRequestResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline INTEGER& cancelCount()
    {return field_cancelCount;}
  inline const INTEGER& cancelCount() const
    {return field_cancelCount;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CancelRequestResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CancelRequestResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CancelRequestResponse& other_value);
void copy_template(const CancelRequestResponse_template& other_value);

public:
CancelRequestResponse_template();
CancelRequestResponse_template(template_sel other_value);
CancelRequestResponse_template(const CancelRequestResponse& other_value);
CancelRequestResponse_template(const OPTIONAL<CancelRequestResponse>& other_value);
CancelRequestResponse_template(const CancelRequestResponse_template& other_value);
~CancelRequestResponse_template();
CancelRequestResponse_template& operator=(template_sel other_value);
CancelRequestResponse_template& operator=(const CancelRequestResponse& other_value);
CancelRequestResponse_template& operator=(const OPTIONAL<CancelRequestResponse>& other_value);
CancelRequestResponse_template& operator=(const CancelRequestResponse_template& other_value);
boolean match(const CancelRequestResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CancelRequestResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CancelRequestResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
INTEGER_template& cancelCount();
const INTEGER_template& cancelCount() const;
int size_of() const;
void log() const;
void log_match(const CancelRequestResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AddNodesRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfAddNodesItem field_nodesToAdd;
public:
  AddNodesRequest();
  AddNodesRequest(const RequestHeader& par_requestHeader,
    const ListOfAddNodesItem& par_nodesToAdd);
  AddNodesRequest(const AddNodesRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AddNodesRequest& operator=(const AddNodesRequest& other_value);
  boolean operator==(const AddNodesRequest& other_value) const;
  inline boolean operator!=(const AddNodesRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfAddNodesItem& nodesToAdd()
    {return field_nodesToAdd;}
  inline const ListOfAddNodesItem& nodesToAdd() const
    {return field_nodesToAdd;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddNodesRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AddNodesRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AddNodesRequest& other_value);
void copy_template(const AddNodesRequest_template& other_value);

public:
AddNodesRequest_template();
AddNodesRequest_template(template_sel other_value);
AddNodesRequest_template(const AddNodesRequest& other_value);
AddNodesRequest_template(const OPTIONAL<AddNodesRequest>& other_value);
AddNodesRequest_template(const AddNodesRequest_template& other_value);
~AddNodesRequest_template();
AddNodesRequest_template& operator=(template_sel other_value);
AddNodesRequest_template& operator=(const AddNodesRequest& other_value);
AddNodesRequest_template& operator=(const OPTIONAL<AddNodesRequest>& other_value);
AddNodesRequest_template& operator=(const AddNodesRequest_template& other_value);
boolean match(const AddNodesRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AddNodesRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AddNodesRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfAddNodesItem_template& nodesToAdd();
const ListOfAddNodesItem_template& nodesToAdd() const;
int size_of() const;
void log() const;
void log_match(const AddNodesRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AddNodesResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfAddNodesResult field_results;
public:
  AddNodesResponse();
  AddNodesResponse(const ResponseHeader& par_responseHeader,
    const ListOfAddNodesResult& par_results);
  AddNodesResponse(const AddNodesResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AddNodesResponse& operator=(const AddNodesResponse& other_value);
  boolean operator==(const AddNodesResponse& other_value) const;
  inline boolean operator!=(const AddNodesResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfAddNodesResult& results()
    {return field_results;}
  inline const ListOfAddNodesResult& results() const
    {return field_results;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddNodesResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AddNodesResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AddNodesResponse& other_value);
void copy_template(const AddNodesResponse_template& other_value);

public:
AddNodesResponse_template();
AddNodesResponse_template(template_sel other_value);
AddNodesResponse_template(const AddNodesResponse& other_value);
AddNodesResponse_template(const OPTIONAL<AddNodesResponse>& other_value);
AddNodesResponse_template(const AddNodesResponse_template& other_value);
~AddNodesResponse_template();
AddNodesResponse_template& operator=(template_sel other_value);
AddNodesResponse_template& operator=(const AddNodesResponse& other_value);
AddNodesResponse_template& operator=(const OPTIONAL<AddNodesResponse>& other_value);
AddNodesResponse_template& operator=(const AddNodesResponse_template& other_value);
boolean match(const AddNodesResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AddNodesResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AddNodesResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfAddNodesResult_template& results();
const ListOfAddNodesResult_template& results() const;
int size_of() const;
void log() const;
void log_match(const AddNodesResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AddReferencesRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfAddReferencesItem field_referencesToAdd;
public:
  AddReferencesRequest();
  AddReferencesRequest(const RequestHeader& par_requestHeader,
    const ListOfAddReferencesItem& par_referencesToAdd);
  AddReferencesRequest(const AddReferencesRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AddReferencesRequest& operator=(const AddReferencesRequest& other_value);
  boolean operator==(const AddReferencesRequest& other_value) const;
  inline boolean operator!=(const AddReferencesRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfAddReferencesItem& referencesToAdd()
    {return field_referencesToAdd;}
  inline const ListOfAddReferencesItem& referencesToAdd() const
    {return field_referencesToAdd;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddReferencesRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AddReferencesRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AddReferencesRequest& other_value);
void copy_template(const AddReferencesRequest_template& other_value);

public:
AddReferencesRequest_template();
AddReferencesRequest_template(template_sel other_value);
AddReferencesRequest_template(const AddReferencesRequest& other_value);
AddReferencesRequest_template(const OPTIONAL<AddReferencesRequest>& other_value);
AddReferencesRequest_template(const AddReferencesRequest_template& other_value);
~AddReferencesRequest_template();
AddReferencesRequest_template& operator=(template_sel other_value);
AddReferencesRequest_template& operator=(const AddReferencesRequest& other_value);
AddReferencesRequest_template& operator=(const OPTIONAL<AddReferencesRequest>& other_value);
AddReferencesRequest_template& operator=(const AddReferencesRequest_template& other_value);
boolean match(const AddReferencesRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AddReferencesRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AddReferencesRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfAddReferencesItem_template& referencesToAdd();
const ListOfAddReferencesItem_template& referencesToAdd() const;
int size_of() const;
void log() const;
void log_match(const AddReferencesRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class AddReferencesResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  AddReferencesResponse();
  AddReferencesResponse(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  AddReferencesResponse(const AddReferencesResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  AddReferencesResponse& operator=(const AddReferencesResponse& other_value);
  boolean operator==(const AddReferencesResponse& other_value) const;
  inline boolean operator!=(const AddReferencesResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class AddReferencesResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
AddReferencesResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const AddReferencesResponse& other_value);
void copy_template(const AddReferencesResponse_template& other_value);

public:
AddReferencesResponse_template();
AddReferencesResponse_template(template_sel other_value);
AddReferencesResponse_template(const AddReferencesResponse& other_value);
AddReferencesResponse_template(const OPTIONAL<AddReferencesResponse>& other_value);
AddReferencesResponse_template(const AddReferencesResponse_template& other_value);
~AddReferencesResponse_template();
AddReferencesResponse_template& operator=(template_sel other_value);
AddReferencesResponse_template& operator=(const AddReferencesResponse& other_value);
AddReferencesResponse_template& operator=(const OPTIONAL<AddReferencesResponse>& other_value);
AddReferencesResponse_template& operator=(const AddReferencesResponse_template& other_value);
boolean match(const AddReferencesResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
AddReferencesResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
AddReferencesResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const AddReferencesResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteNodesRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfDeleteNodesItem field_nodesToDelete;
public:
  DeleteNodesRequest();
  DeleteNodesRequest(const RequestHeader& par_requestHeader,
    const ListOfDeleteNodesItem& par_nodesToDelete);
  DeleteNodesRequest(const DeleteNodesRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteNodesRequest& operator=(const DeleteNodesRequest& other_value);
  boolean operator==(const DeleteNodesRequest& other_value) const;
  inline boolean operator!=(const DeleteNodesRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfDeleteNodesItem& nodesToDelete()
    {return field_nodesToDelete;}
  inline const ListOfDeleteNodesItem& nodesToDelete() const
    {return field_nodesToDelete;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteNodesRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteNodesRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteNodesRequest& other_value);
void copy_template(const DeleteNodesRequest_template& other_value);

public:
DeleteNodesRequest_template();
DeleteNodesRequest_template(template_sel other_value);
DeleteNodesRequest_template(const DeleteNodesRequest& other_value);
DeleteNodesRequest_template(const OPTIONAL<DeleteNodesRequest>& other_value);
DeleteNodesRequest_template(const DeleteNodesRequest_template& other_value);
~DeleteNodesRequest_template();
DeleteNodesRequest_template& operator=(template_sel other_value);
DeleteNodesRequest_template& operator=(const DeleteNodesRequest& other_value);
DeleteNodesRequest_template& operator=(const OPTIONAL<DeleteNodesRequest>& other_value);
DeleteNodesRequest_template& operator=(const DeleteNodesRequest_template& other_value);
boolean match(const DeleteNodesRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteNodesRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteNodesRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfDeleteNodesItem_template& nodesToDelete();
const ListOfDeleteNodesItem_template& nodesToDelete() const;
int size_of() const;
void log() const;
void log_match(const DeleteNodesRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteNodesResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  DeleteNodesResponse();
  DeleteNodesResponse(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  DeleteNodesResponse(const DeleteNodesResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteNodesResponse& operator=(const DeleteNodesResponse& other_value);
  boolean operator==(const DeleteNodesResponse& other_value) const;
  inline boolean operator!=(const DeleteNodesResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteNodesResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteNodesResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteNodesResponse& other_value);
void copy_template(const DeleteNodesResponse_template& other_value);

public:
DeleteNodesResponse_template();
DeleteNodesResponse_template(template_sel other_value);
DeleteNodesResponse_template(const DeleteNodesResponse& other_value);
DeleteNodesResponse_template(const OPTIONAL<DeleteNodesResponse>& other_value);
DeleteNodesResponse_template(const DeleteNodesResponse_template& other_value);
~DeleteNodesResponse_template();
DeleteNodesResponse_template& operator=(template_sel other_value);
DeleteNodesResponse_template& operator=(const DeleteNodesResponse& other_value);
DeleteNodesResponse_template& operator=(const OPTIONAL<DeleteNodesResponse>& other_value);
DeleteNodesResponse_template& operator=(const DeleteNodesResponse_template& other_value);
boolean match(const DeleteNodesResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteNodesResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteNodesResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const DeleteNodesResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteReferencesRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfDeleteReferencesItem field_referencesToDelete;
public:
  DeleteReferencesRequest();
  DeleteReferencesRequest(const RequestHeader& par_requestHeader,
    const ListOfDeleteReferencesItem& par_referencesToDelete);
  DeleteReferencesRequest(const DeleteReferencesRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteReferencesRequest& operator=(const DeleteReferencesRequest& other_value);
  boolean operator==(const DeleteReferencesRequest& other_value) const;
  inline boolean operator!=(const DeleteReferencesRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfDeleteReferencesItem& referencesToDelete()
    {return field_referencesToDelete;}
  inline const ListOfDeleteReferencesItem& referencesToDelete() const
    {return field_referencesToDelete;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteReferencesRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteReferencesRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteReferencesRequest& other_value);
void copy_template(const DeleteReferencesRequest_template& other_value);

public:
DeleteReferencesRequest_template();
DeleteReferencesRequest_template(template_sel other_value);
DeleteReferencesRequest_template(const DeleteReferencesRequest& other_value);
DeleteReferencesRequest_template(const OPTIONAL<DeleteReferencesRequest>& other_value);
DeleteReferencesRequest_template(const DeleteReferencesRequest_template& other_value);
~DeleteReferencesRequest_template();
DeleteReferencesRequest_template& operator=(template_sel other_value);
DeleteReferencesRequest_template& operator=(const DeleteReferencesRequest& other_value);
DeleteReferencesRequest_template& operator=(const OPTIONAL<DeleteReferencesRequest>& other_value);
DeleteReferencesRequest_template& operator=(const DeleteReferencesRequest_template& other_value);
boolean match(const DeleteReferencesRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteReferencesRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteReferencesRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfDeleteReferencesItem_template& referencesToDelete();
const ListOfDeleteReferencesItem_template& referencesToDelete() const;
int size_of() const;
void log() const;
void log_match(const DeleteReferencesRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteReferencesResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  DeleteReferencesResponse();
  DeleteReferencesResponse(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  DeleteReferencesResponse(const DeleteReferencesResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteReferencesResponse& operator=(const DeleteReferencesResponse& other_value);
  boolean operator==(const DeleteReferencesResponse& other_value) const;
  inline boolean operator!=(const DeleteReferencesResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteReferencesResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteReferencesResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteReferencesResponse& other_value);
void copy_template(const DeleteReferencesResponse_template& other_value);

public:
DeleteReferencesResponse_template();
DeleteReferencesResponse_template(template_sel other_value);
DeleteReferencesResponse_template(const DeleteReferencesResponse& other_value);
DeleteReferencesResponse_template(const OPTIONAL<DeleteReferencesResponse>& other_value);
DeleteReferencesResponse_template(const DeleteReferencesResponse_template& other_value);
~DeleteReferencesResponse_template();
DeleteReferencesResponse_template& operator=(template_sel other_value);
DeleteReferencesResponse_template& operator=(const DeleteReferencesResponse& other_value);
DeleteReferencesResponse_template& operator=(const OPTIONAL<DeleteReferencesResponse>& other_value);
DeleteReferencesResponse_template& operator=(const DeleteReferencesResponse_template& other_value);
boolean match(const DeleteReferencesResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteReferencesResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteReferencesResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const DeleteReferencesResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowseRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ViewDescription field_view;
  INTEGER field_requestedMaxReferencesPerNode;
  ListOfBrowseDescription field_nodesToBrowse;
public:
  BrowseRequest();
  BrowseRequest(const RequestHeader& par_requestHeader,
    const ViewDescription& par_view,
    const INTEGER& par_requestedMaxReferencesPerNode,
    const ListOfBrowseDescription& par_nodesToBrowse);
  BrowseRequest(const BrowseRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowseRequest& operator=(const BrowseRequest& other_value);
  boolean operator==(const BrowseRequest& other_value) const;
  inline boolean operator!=(const BrowseRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ViewDescription& view()
    {return field_view;}
  inline const ViewDescription& view() const
    {return field_view;}
  inline INTEGER& requestedMaxReferencesPerNode()
    {return field_requestedMaxReferencesPerNode;}
  inline const INTEGER& requestedMaxReferencesPerNode() const
    {return field_requestedMaxReferencesPerNode;}
  inline ListOfBrowseDescription& nodesToBrowse()
    {return field_nodesToBrowse;}
  inline const ListOfBrowseDescription& nodesToBrowse() const
    {return field_nodesToBrowse;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowseRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowseRequest& other_value);
void copy_template(const BrowseRequest_template& other_value);

public:
BrowseRequest_template();
BrowseRequest_template(template_sel other_value);
BrowseRequest_template(const BrowseRequest& other_value);
BrowseRequest_template(const OPTIONAL<BrowseRequest>& other_value);
BrowseRequest_template(const BrowseRequest_template& other_value);
~BrowseRequest_template();
BrowseRequest_template& operator=(template_sel other_value);
BrowseRequest_template& operator=(const BrowseRequest& other_value);
BrowseRequest_template& operator=(const OPTIONAL<BrowseRequest>& other_value);
BrowseRequest_template& operator=(const BrowseRequest_template& other_value);
boolean match(const BrowseRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowseRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowseRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ViewDescription_template& view();
const ViewDescription_template& view() const;
INTEGER_template& requestedMaxReferencesPerNode();
const INTEGER_template& requestedMaxReferencesPerNode() const;
ListOfBrowseDescription_template& nodesToBrowse();
const ListOfBrowseDescription_template& nodesToBrowse() const;
int size_of() const;
void log() const;
void log_match(const BrowseRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowseResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfBrowseResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  BrowseResponse();
  BrowseResponse(const ResponseHeader& par_responseHeader,
    const ListOfBrowseResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  BrowseResponse(const BrowseResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowseResponse& operator=(const BrowseResponse& other_value);
  boolean operator==(const BrowseResponse& other_value) const;
  inline boolean operator!=(const BrowseResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfBrowseResult& results()
    {return field_results;}
  inline const ListOfBrowseResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowseResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowseResponse& other_value);
void copy_template(const BrowseResponse_template& other_value);

public:
BrowseResponse_template();
BrowseResponse_template(template_sel other_value);
BrowseResponse_template(const BrowseResponse& other_value);
BrowseResponse_template(const OPTIONAL<BrowseResponse>& other_value);
BrowseResponse_template(const BrowseResponse_template& other_value);
~BrowseResponse_template();
BrowseResponse_template& operator=(template_sel other_value);
BrowseResponse_template& operator=(const BrowseResponse& other_value);
BrowseResponse_template& operator=(const OPTIONAL<BrowseResponse>& other_value);
BrowseResponse_template& operator=(const BrowseResponse_template& other_value);
boolean match(const BrowseResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowseResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowseResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfBrowseResult_template& results();
const ListOfBrowseResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const BrowseResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowseNextRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_releaseContinuationPoints;
  ListOfContinuationPoint field_continuationPoints;
public:
  BrowseNextRequest();
  BrowseNextRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_releaseContinuationPoints,
    const ListOfContinuationPoint& par_continuationPoints);
  BrowseNextRequest(const BrowseNextRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowseNextRequest& operator=(const BrowseNextRequest& other_value);
  boolean operator==(const BrowseNextRequest& other_value) const;
  inline boolean operator!=(const BrowseNextRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& releaseContinuationPoints()
    {return field_releaseContinuationPoints;}
  inline const INTEGER& releaseContinuationPoints() const
    {return field_releaseContinuationPoints;}
  inline ListOfContinuationPoint& continuationPoints()
    {return field_continuationPoints;}
  inline const ListOfContinuationPoint& continuationPoints() const
    {return field_continuationPoints;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseNextRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowseNextRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowseNextRequest& other_value);
void copy_template(const BrowseNextRequest_template& other_value);

public:
BrowseNextRequest_template();
BrowseNextRequest_template(template_sel other_value);
BrowseNextRequest_template(const BrowseNextRequest& other_value);
BrowseNextRequest_template(const OPTIONAL<BrowseNextRequest>& other_value);
BrowseNextRequest_template(const BrowseNextRequest_template& other_value);
~BrowseNextRequest_template();
BrowseNextRequest_template& operator=(template_sel other_value);
BrowseNextRequest_template& operator=(const BrowseNextRequest& other_value);
BrowseNextRequest_template& operator=(const OPTIONAL<BrowseNextRequest>& other_value);
BrowseNextRequest_template& operator=(const BrowseNextRequest_template& other_value);
boolean match(const BrowseNextRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowseNextRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowseNextRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& releaseContinuationPoints();
const INTEGER_template& releaseContinuationPoints() const;
ListOfContinuationPoint_template& continuationPoints();
const ListOfContinuationPoint_template& continuationPoints() const;
int size_of() const;
void log() const;
void log_match(const BrowseNextRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class BrowseNextResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfBrowseResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  BrowseNextResponse();
  BrowseNextResponse(const ResponseHeader& par_responseHeader,
    const ListOfBrowseResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  BrowseNextResponse(const BrowseNextResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  BrowseNextResponse& operator=(const BrowseNextResponse& other_value);
  boolean operator==(const BrowseNextResponse& other_value) const;
  inline boolean operator!=(const BrowseNextResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfBrowseResult& results()
    {return field_results;}
  inline const ListOfBrowseResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class BrowseNextResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
BrowseNextResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const BrowseNextResponse& other_value);
void copy_template(const BrowseNextResponse_template& other_value);

public:
BrowseNextResponse_template();
BrowseNextResponse_template(template_sel other_value);
BrowseNextResponse_template(const BrowseNextResponse& other_value);
BrowseNextResponse_template(const OPTIONAL<BrowseNextResponse>& other_value);
BrowseNextResponse_template(const BrowseNextResponse_template& other_value);
~BrowseNextResponse_template();
BrowseNextResponse_template& operator=(template_sel other_value);
BrowseNextResponse_template& operator=(const BrowseNextResponse& other_value);
BrowseNextResponse_template& operator=(const OPTIONAL<BrowseNextResponse>& other_value);
BrowseNextResponse_template& operator=(const BrowseNextResponse_template& other_value);
boolean match(const BrowseNextResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
BrowseNextResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
BrowseNextResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfBrowseResult_template& results();
const ListOfBrowseResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const BrowseNextResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TranslateBrowsePathsToNodeIdsRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfBrowsePath field_browsePaths;
public:
  TranslateBrowsePathsToNodeIdsRequest();
  TranslateBrowsePathsToNodeIdsRequest(const RequestHeader& par_requestHeader,
    const ListOfBrowsePath& par_browsePaths);
  TranslateBrowsePathsToNodeIdsRequest(const TranslateBrowsePathsToNodeIdsRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TranslateBrowsePathsToNodeIdsRequest& operator=(const TranslateBrowsePathsToNodeIdsRequest& other_value);
  boolean operator==(const TranslateBrowsePathsToNodeIdsRequest& other_value) const;
  inline boolean operator!=(const TranslateBrowsePathsToNodeIdsRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfBrowsePath& browsePaths()
    {return field_browsePaths;}
  inline const ListOfBrowsePath& browsePaths() const
    {return field_browsePaths;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TranslateBrowsePathsToNodeIdsRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TranslateBrowsePathsToNodeIdsRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TranslateBrowsePathsToNodeIdsRequest& other_value);
void copy_template(const TranslateBrowsePathsToNodeIdsRequest_template& other_value);

public:
TranslateBrowsePathsToNodeIdsRequest_template();
TranslateBrowsePathsToNodeIdsRequest_template(template_sel other_value);
TranslateBrowsePathsToNodeIdsRequest_template(const TranslateBrowsePathsToNodeIdsRequest& other_value);
TranslateBrowsePathsToNodeIdsRequest_template(const OPTIONAL<TranslateBrowsePathsToNodeIdsRequest>& other_value);
TranslateBrowsePathsToNodeIdsRequest_template(const TranslateBrowsePathsToNodeIdsRequest_template& other_value);
~TranslateBrowsePathsToNodeIdsRequest_template();
TranslateBrowsePathsToNodeIdsRequest_template& operator=(template_sel other_value);
TranslateBrowsePathsToNodeIdsRequest_template& operator=(const TranslateBrowsePathsToNodeIdsRequest& other_value);
TranslateBrowsePathsToNodeIdsRequest_template& operator=(const OPTIONAL<TranslateBrowsePathsToNodeIdsRequest>& other_value);
TranslateBrowsePathsToNodeIdsRequest_template& operator=(const TranslateBrowsePathsToNodeIdsRequest_template& other_value);
boolean match(const TranslateBrowsePathsToNodeIdsRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TranslateBrowsePathsToNodeIdsRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TranslateBrowsePathsToNodeIdsRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfBrowsePath_template& browsePaths();
const ListOfBrowsePath_template& browsePaths() const;
int size_of() const;
void log() const;
void log_match(const TranslateBrowsePathsToNodeIdsRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TranslateBrowsePathsToNodeIdsResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfBrowsePathResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  TranslateBrowsePathsToNodeIdsResponse();
  TranslateBrowsePathsToNodeIdsResponse(const ResponseHeader& par_responseHeader,
    const ListOfBrowsePathResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  TranslateBrowsePathsToNodeIdsResponse(const TranslateBrowsePathsToNodeIdsResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TranslateBrowsePathsToNodeIdsResponse& operator=(const TranslateBrowsePathsToNodeIdsResponse& other_value);
  boolean operator==(const TranslateBrowsePathsToNodeIdsResponse& other_value) const;
  inline boolean operator!=(const TranslateBrowsePathsToNodeIdsResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfBrowsePathResult& results()
    {return field_results;}
  inline const ListOfBrowsePathResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TranslateBrowsePathsToNodeIdsResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TranslateBrowsePathsToNodeIdsResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TranslateBrowsePathsToNodeIdsResponse& other_value);
void copy_template(const TranslateBrowsePathsToNodeIdsResponse_template& other_value);

public:
TranslateBrowsePathsToNodeIdsResponse_template();
TranslateBrowsePathsToNodeIdsResponse_template(template_sel other_value);
TranslateBrowsePathsToNodeIdsResponse_template(const TranslateBrowsePathsToNodeIdsResponse& other_value);
TranslateBrowsePathsToNodeIdsResponse_template(const OPTIONAL<TranslateBrowsePathsToNodeIdsResponse>& other_value);
TranslateBrowsePathsToNodeIdsResponse_template(const TranslateBrowsePathsToNodeIdsResponse_template& other_value);
~TranslateBrowsePathsToNodeIdsResponse_template();
TranslateBrowsePathsToNodeIdsResponse_template& operator=(template_sel other_value);
TranslateBrowsePathsToNodeIdsResponse_template& operator=(const TranslateBrowsePathsToNodeIdsResponse& other_value);
TranslateBrowsePathsToNodeIdsResponse_template& operator=(const OPTIONAL<TranslateBrowsePathsToNodeIdsResponse>& other_value);
TranslateBrowsePathsToNodeIdsResponse_template& operator=(const TranslateBrowsePathsToNodeIdsResponse_template& other_value);
boolean match(const TranslateBrowsePathsToNodeIdsResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TranslateBrowsePathsToNodeIdsResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TranslateBrowsePathsToNodeIdsResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfBrowsePathResult_template& results();
const ListOfBrowsePathResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const TranslateBrowsePathsToNodeIdsResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegisterNodesRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfNodeId field_nodesToRegister;
public:
  RegisterNodesRequest();
  RegisterNodesRequest(const RequestHeader& par_requestHeader,
    const ListOfNodeId& par_nodesToRegister);
  RegisterNodesRequest(const RegisterNodesRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RegisterNodesRequest& operator=(const RegisterNodesRequest& other_value);
  boolean operator==(const RegisterNodesRequest& other_value) const;
  inline boolean operator!=(const RegisterNodesRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfNodeId& nodesToRegister()
    {return field_nodesToRegister;}
  inline const ListOfNodeId& nodesToRegister() const
    {return field_nodesToRegister;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RegisterNodesRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RegisterNodesRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RegisterNodesRequest& other_value);
void copy_template(const RegisterNodesRequest_template& other_value);

public:
RegisterNodesRequest_template();
RegisterNodesRequest_template(template_sel other_value);
RegisterNodesRequest_template(const RegisterNodesRequest& other_value);
RegisterNodesRequest_template(const OPTIONAL<RegisterNodesRequest>& other_value);
RegisterNodesRequest_template(const RegisterNodesRequest_template& other_value);
~RegisterNodesRequest_template();
RegisterNodesRequest_template& operator=(template_sel other_value);
RegisterNodesRequest_template& operator=(const RegisterNodesRequest& other_value);
RegisterNodesRequest_template& operator=(const OPTIONAL<RegisterNodesRequest>& other_value);
RegisterNodesRequest_template& operator=(const RegisterNodesRequest_template& other_value);
boolean match(const RegisterNodesRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegisterNodesRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegisterNodesRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfNodeId_template& nodesToRegister();
const ListOfNodeId_template& nodesToRegister() const;
int size_of() const;
void log() const;
void log_match(const RegisterNodesRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RegisterNodesResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfNodeId field_registeredNodeIds;
public:
  RegisterNodesResponse();
  RegisterNodesResponse(const ResponseHeader& par_responseHeader,
    const ListOfNodeId& par_registeredNodeIds);
  RegisterNodesResponse(const RegisterNodesResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RegisterNodesResponse& operator=(const RegisterNodesResponse& other_value);
  boolean operator==(const RegisterNodesResponse& other_value) const;
  inline boolean operator!=(const RegisterNodesResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfNodeId& registeredNodeIds()
    {return field_registeredNodeIds;}
  inline const ListOfNodeId& registeredNodeIds() const
    {return field_registeredNodeIds;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RegisterNodesResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RegisterNodesResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RegisterNodesResponse& other_value);
void copy_template(const RegisterNodesResponse_template& other_value);

public:
RegisterNodesResponse_template();
RegisterNodesResponse_template(template_sel other_value);
RegisterNodesResponse_template(const RegisterNodesResponse& other_value);
RegisterNodesResponse_template(const OPTIONAL<RegisterNodesResponse>& other_value);
RegisterNodesResponse_template(const RegisterNodesResponse_template& other_value);
~RegisterNodesResponse_template();
RegisterNodesResponse_template& operator=(template_sel other_value);
RegisterNodesResponse_template& operator=(const RegisterNodesResponse& other_value);
RegisterNodesResponse_template& operator=(const OPTIONAL<RegisterNodesResponse>& other_value);
RegisterNodesResponse_template& operator=(const RegisterNodesResponse_template& other_value);
boolean match(const RegisterNodesResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RegisterNodesResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RegisterNodesResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfNodeId_template& registeredNodeIds();
const ListOfNodeId_template& registeredNodeIds() const;
int size_of() const;
void log() const;
void log_match(const RegisterNodesResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UnregisterNodesRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfNodeId field_nodesToUnregister;
public:
  UnregisterNodesRequest();
  UnregisterNodesRequest(const RequestHeader& par_requestHeader,
    const ListOfNodeId& par_nodesToUnregister);
  UnregisterNodesRequest(const UnregisterNodesRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UnregisterNodesRequest& operator=(const UnregisterNodesRequest& other_value);
  boolean operator==(const UnregisterNodesRequest& other_value) const;
  inline boolean operator!=(const UnregisterNodesRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfNodeId& nodesToUnregister()
    {return field_nodesToUnregister;}
  inline const ListOfNodeId& nodesToUnregister() const
    {return field_nodesToUnregister;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UnregisterNodesRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UnregisterNodesRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UnregisterNodesRequest& other_value);
void copy_template(const UnregisterNodesRequest_template& other_value);

public:
UnregisterNodesRequest_template();
UnregisterNodesRequest_template(template_sel other_value);
UnregisterNodesRequest_template(const UnregisterNodesRequest& other_value);
UnregisterNodesRequest_template(const OPTIONAL<UnregisterNodesRequest>& other_value);
UnregisterNodesRequest_template(const UnregisterNodesRequest_template& other_value);
~UnregisterNodesRequest_template();
UnregisterNodesRequest_template& operator=(template_sel other_value);
UnregisterNodesRequest_template& operator=(const UnregisterNodesRequest& other_value);
UnregisterNodesRequest_template& operator=(const OPTIONAL<UnregisterNodesRequest>& other_value);
UnregisterNodesRequest_template& operator=(const UnregisterNodesRequest_template& other_value);
boolean match(const UnregisterNodesRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UnregisterNodesRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UnregisterNodesRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfNodeId_template& nodesToUnregister();
const ListOfNodeId_template& nodesToUnregister() const;
int size_of() const;
void log() const;
void log_match(const UnregisterNodesRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class UnregisterNodesResponse : public Base_Type {
  ResponseHeader field_responseHeader;
public:
  UnregisterNodesResponse();
  UnregisterNodesResponse(const ResponseHeader& par_responseHeader);
  UnregisterNodesResponse(const UnregisterNodesResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  UnregisterNodesResponse& operator=(const UnregisterNodesResponse& other_value);
  boolean operator==(const UnregisterNodesResponse& other_value) const;
  inline boolean operator!=(const UnregisterNodesResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline int size_of() const
    {return 1;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class UnregisterNodesResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
UnregisterNodesResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const UnregisterNodesResponse& other_value);
void copy_template(const UnregisterNodesResponse_template& other_value);

public:
UnregisterNodesResponse_template();
UnregisterNodesResponse_template(template_sel other_value);
UnregisterNodesResponse_template(const UnregisterNodesResponse& other_value);
UnregisterNodesResponse_template(const OPTIONAL<UnregisterNodesResponse>& other_value);
UnregisterNodesResponse_template(const UnregisterNodesResponse_template& other_value);
~UnregisterNodesResponse_template();
UnregisterNodesResponse_template& operator=(template_sel other_value);
UnregisterNodesResponse_template& operator=(const UnregisterNodesResponse& other_value);
UnregisterNodesResponse_template& operator=(const OPTIONAL<UnregisterNodesResponse>& other_value);
UnregisterNodesResponse_template& operator=(const UnregisterNodesResponse_template& other_value);
boolean match(const UnregisterNodesResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
UnregisterNodesResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
UnregisterNodesResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
int size_of() const;
void log() const;
void log_match(const UnregisterNodesResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class QueryFirstRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfNodeTypeDescription field_nodeTypes;
  ContentFilter field_filter;
  INTEGER field_maxDataSetsToReturn;
  INTEGER field_maxReferencesToReturn;
public:
  QueryFirstRequest();
  QueryFirstRequest(const RequestHeader& par_requestHeader,
    const ListOfNodeTypeDescription& par_nodeTypes,
    const ContentFilter& par_filter,
    const INTEGER& par_maxDataSetsToReturn,
    const INTEGER& par_maxReferencesToReturn);
  QueryFirstRequest(const QueryFirstRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QueryFirstRequest& operator=(const QueryFirstRequest& other_value);
  boolean operator==(const QueryFirstRequest& other_value) const;
  inline boolean operator!=(const QueryFirstRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfNodeTypeDescription& nodeTypes()
    {return field_nodeTypes;}
  inline const ListOfNodeTypeDescription& nodeTypes() const
    {return field_nodeTypes;}
  inline ContentFilter& filter()
    {return field_filter;}
  inline const ContentFilter& filter() const
    {return field_filter;}
  inline INTEGER& maxDataSetsToReturn()
    {return field_maxDataSetsToReturn;}
  inline const INTEGER& maxDataSetsToReturn() const
    {return field_maxDataSetsToReturn;}
  inline INTEGER& maxReferencesToReturn()
    {return field_maxReferencesToReturn;}
  inline const INTEGER& maxReferencesToReturn() const
    {return field_maxReferencesToReturn;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QueryFirstRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QueryFirstRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QueryFirstRequest& other_value);
void copy_template(const QueryFirstRequest_template& other_value);

public:
QueryFirstRequest_template();
QueryFirstRequest_template(template_sel other_value);
QueryFirstRequest_template(const QueryFirstRequest& other_value);
QueryFirstRequest_template(const OPTIONAL<QueryFirstRequest>& other_value);
QueryFirstRequest_template(const QueryFirstRequest_template& other_value);
~QueryFirstRequest_template();
QueryFirstRequest_template& operator=(template_sel other_value);
QueryFirstRequest_template& operator=(const QueryFirstRequest& other_value);
QueryFirstRequest_template& operator=(const OPTIONAL<QueryFirstRequest>& other_value);
QueryFirstRequest_template& operator=(const QueryFirstRequest_template& other_value);
boolean match(const QueryFirstRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QueryFirstRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QueryFirstRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfNodeTypeDescription_template& nodeTypes();
const ListOfNodeTypeDescription_template& nodeTypes() const;
ContentFilter_template& filter();
const ContentFilter_template& filter() const;
INTEGER_template& maxDataSetsToReturn();
const INTEGER_template& maxDataSetsToReturn() const;
INTEGER_template& maxReferencesToReturn();
const INTEGER_template& maxReferencesToReturn() const;
int size_of() const;
void log() const;
void log_match(const QueryFirstRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class QueryFirstResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfQueryDataSet field_queryDataSets;
  ByteString field_continuationPoint;
  ListOfParsingResult field_parsingResults;
  ListOfDiagnosticInfo field_diagnosticInfos;
  ContentFilterResult field_filterResult;
public:
  QueryFirstResponse();
  QueryFirstResponse(const ResponseHeader& par_responseHeader,
    const ListOfQueryDataSet& par_queryDataSets,
    const ByteString& par_continuationPoint,
    const ListOfParsingResult& par_parsingResults,
    const ListOfDiagnosticInfo& par_diagnosticInfos,
    const ContentFilterResult& par_filterResult);
  QueryFirstResponse(const QueryFirstResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QueryFirstResponse& operator=(const QueryFirstResponse& other_value);
  boolean operator==(const QueryFirstResponse& other_value) const;
  inline boolean operator!=(const QueryFirstResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfQueryDataSet& queryDataSets()
    {return field_queryDataSets;}
  inline const ListOfQueryDataSet& queryDataSets() const
    {return field_queryDataSets;}
  inline ByteString& continuationPoint()
    {return field_continuationPoint;}
  inline const ByteString& continuationPoint() const
    {return field_continuationPoint;}
  inline ListOfParsingResult& parsingResults()
    {return field_parsingResults;}
  inline const ListOfParsingResult& parsingResults() const
    {return field_parsingResults;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline ContentFilterResult& filterResult()
    {return field_filterResult;}
  inline const ContentFilterResult& filterResult() const
    {return field_filterResult;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QueryFirstResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QueryFirstResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QueryFirstResponse& other_value);
void copy_template(const QueryFirstResponse_template& other_value);

public:
QueryFirstResponse_template();
QueryFirstResponse_template(template_sel other_value);
QueryFirstResponse_template(const QueryFirstResponse& other_value);
QueryFirstResponse_template(const OPTIONAL<QueryFirstResponse>& other_value);
QueryFirstResponse_template(const QueryFirstResponse_template& other_value);
~QueryFirstResponse_template();
QueryFirstResponse_template& operator=(template_sel other_value);
QueryFirstResponse_template& operator=(const QueryFirstResponse& other_value);
QueryFirstResponse_template& operator=(const OPTIONAL<QueryFirstResponse>& other_value);
QueryFirstResponse_template& operator=(const QueryFirstResponse_template& other_value);
boolean match(const QueryFirstResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QueryFirstResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QueryFirstResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfQueryDataSet_template& queryDataSets();
const ListOfQueryDataSet_template& queryDataSets() const;
ByteString_template& continuationPoint();
const ByteString_template& continuationPoint() const;
ListOfParsingResult_template& parsingResults();
const ListOfParsingResult_template& parsingResults() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
ContentFilterResult_template& filterResult();
const ContentFilterResult_template& filterResult() const;
int size_of() const;
void log() const;
void log_match(const QueryFirstResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class QueryNextRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_releaseContinuationPoint;
  ByteString field_continuationPoint;
public:
  QueryNextRequest();
  QueryNextRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_releaseContinuationPoint,
    const ByteString& par_continuationPoint);
  QueryNextRequest(const QueryNextRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QueryNextRequest& operator=(const QueryNextRequest& other_value);
  boolean operator==(const QueryNextRequest& other_value) const;
  inline boolean operator!=(const QueryNextRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& releaseContinuationPoint()
    {return field_releaseContinuationPoint;}
  inline const INTEGER& releaseContinuationPoint() const
    {return field_releaseContinuationPoint;}
  inline ByteString& continuationPoint()
    {return field_continuationPoint;}
  inline const ByteString& continuationPoint() const
    {return field_continuationPoint;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QueryNextRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QueryNextRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QueryNextRequest& other_value);
void copy_template(const QueryNextRequest_template& other_value);

public:
QueryNextRequest_template();
QueryNextRequest_template(template_sel other_value);
QueryNextRequest_template(const QueryNextRequest& other_value);
QueryNextRequest_template(const OPTIONAL<QueryNextRequest>& other_value);
QueryNextRequest_template(const QueryNextRequest_template& other_value);
~QueryNextRequest_template();
QueryNextRequest_template& operator=(template_sel other_value);
QueryNextRequest_template& operator=(const QueryNextRequest& other_value);
QueryNextRequest_template& operator=(const OPTIONAL<QueryNextRequest>& other_value);
QueryNextRequest_template& operator=(const QueryNextRequest_template& other_value);
boolean match(const QueryNextRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QueryNextRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QueryNextRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& releaseContinuationPoint();
const INTEGER_template& releaseContinuationPoint() const;
ByteString_template& continuationPoint();
const ByteString_template& continuationPoint() const;
int size_of() const;
void log() const;
void log_match(const QueryNextRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class QueryNextResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfQueryDataSet field_queryDataSets;
  ByteString field_revisedContinuationPoint;
public:
  QueryNextResponse();
  QueryNextResponse(const ResponseHeader& par_responseHeader,
    const ListOfQueryDataSet& par_queryDataSets,
    const ByteString& par_revisedContinuationPoint);
  QueryNextResponse(const QueryNextResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  QueryNextResponse& operator=(const QueryNextResponse& other_value);
  boolean operator==(const QueryNextResponse& other_value) const;
  inline boolean operator!=(const QueryNextResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfQueryDataSet& queryDataSets()
    {return field_queryDataSets;}
  inline const ListOfQueryDataSet& queryDataSets() const
    {return field_queryDataSets;}
  inline ByteString& revisedContinuationPoint()
    {return field_revisedContinuationPoint;}
  inline const ByteString& revisedContinuationPoint() const
    {return field_revisedContinuationPoint;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class QueryNextResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
QueryNextResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const QueryNextResponse& other_value);
void copy_template(const QueryNextResponse_template& other_value);

public:
QueryNextResponse_template();
QueryNextResponse_template(template_sel other_value);
QueryNextResponse_template(const QueryNextResponse& other_value);
QueryNextResponse_template(const OPTIONAL<QueryNextResponse>& other_value);
QueryNextResponse_template(const QueryNextResponse_template& other_value);
~QueryNextResponse_template();
QueryNextResponse_template& operator=(template_sel other_value);
QueryNextResponse_template& operator=(const QueryNextResponse& other_value);
QueryNextResponse_template& operator=(const OPTIONAL<QueryNextResponse>& other_value);
QueryNextResponse_template& operator=(const QueryNextResponse_template& other_value);
boolean match(const QueryNextResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
QueryNextResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
QueryNextResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfQueryDataSet_template& queryDataSets();
const ListOfQueryDataSet_template& queryDataSets() const;
ByteString_template& revisedContinuationPoint();
const ByteString_template& revisedContinuationPoint() const;
int size_of() const;
void log() const;
void log_match(const QueryNextResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReadRequest : public Base_Type {
  RequestHeader field_requestHeader;
  FLOAT field_maxAge;
  TimestampsToReturn field_timestampsToReturn;
  ListOfReadValueId field_nodesToRead;
public:
  ReadRequest();
  ReadRequest(const RequestHeader& par_requestHeader,
    const FLOAT& par_maxAge,
    const TimestampsToReturn& par_timestampsToReturn,
    const ListOfReadValueId& par_nodesToRead);
  ReadRequest(const ReadRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReadRequest& operator=(const ReadRequest& other_value);
  boolean operator==(const ReadRequest& other_value) const;
  inline boolean operator!=(const ReadRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline FLOAT& maxAge()
    {return field_maxAge;}
  inline const FLOAT& maxAge() const
    {return field_maxAge;}
  inline TimestampsToReturn& timestampsToReturn()
    {return field_timestampsToReturn;}
  inline const TimestampsToReturn& timestampsToReturn() const
    {return field_timestampsToReturn;}
  inline ListOfReadValueId& nodesToRead()
    {return field_nodesToRead;}
  inline const ListOfReadValueId& nodesToRead() const
    {return field_nodesToRead;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReadRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReadRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReadRequest& other_value);
void copy_template(const ReadRequest_template& other_value);

public:
ReadRequest_template();
ReadRequest_template(template_sel other_value);
ReadRequest_template(const ReadRequest& other_value);
ReadRequest_template(const OPTIONAL<ReadRequest>& other_value);
ReadRequest_template(const ReadRequest_template& other_value);
~ReadRequest_template();
ReadRequest_template& operator=(template_sel other_value);
ReadRequest_template& operator=(const ReadRequest& other_value);
ReadRequest_template& operator=(const OPTIONAL<ReadRequest>& other_value);
ReadRequest_template& operator=(const ReadRequest_template& other_value);
boolean match(const ReadRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReadRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReadRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
FLOAT_template& maxAge();
const FLOAT_template& maxAge() const;
TimestampsToReturn_template& timestampsToReturn();
const TimestampsToReturn_template& timestampsToReturn() const;
ListOfReadValueId_template& nodesToRead();
const ListOfReadValueId_template& nodesToRead() const;
int size_of() const;
void log() const;
void log_match(const ReadRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ReadResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfDataValue field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  ReadResponse();
  ReadResponse(const ResponseHeader& par_responseHeader,
    const ListOfDataValue& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  ReadResponse(const ReadResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ReadResponse& operator=(const ReadResponse& other_value);
  boolean operator==(const ReadResponse& other_value) const;
  inline boolean operator!=(const ReadResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfDataValue& results()
    {return field_results;}
  inline const ListOfDataValue& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ReadResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ReadResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ReadResponse& other_value);
void copy_template(const ReadResponse_template& other_value);

public:
ReadResponse_template();
ReadResponse_template(template_sel other_value);
ReadResponse_template(const ReadResponse& other_value);
ReadResponse_template(const OPTIONAL<ReadResponse>& other_value);
ReadResponse_template(const ReadResponse_template& other_value);
~ReadResponse_template();
ReadResponse_template& operator=(template_sel other_value);
ReadResponse_template& operator=(const ReadResponse& other_value);
ReadResponse_template& operator=(const OPTIONAL<ReadResponse>& other_value);
ReadResponse_template& operator=(const ReadResponse_template& other_value);
boolean match(const ReadResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ReadResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ReadResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfDataValue_template& results();
const ListOfDataValue_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const ReadResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HistoryReadRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ExtensibleParameter field_historyReadDetails;
  TimestampsToReturn field_timestampsToReturn;
  INTEGER field_releaseContinuationPoints;
  ListOfHistoryReadValueId field_nodesToRead;
public:
  HistoryReadRequest();
  HistoryReadRequest(const RequestHeader& par_requestHeader,
    const ExtensibleParameter& par_historyReadDetails,
    const TimestampsToReturn& par_timestampsToReturn,
    const INTEGER& par_releaseContinuationPoints,
    const ListOfHistoryReadValueId& par_nodesToRead);
  HistoryReadRequest(const HistoryReadRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HistoryReadRequest& operator=(const HistoryReadRequest& other_value);
  boolean operator==(const HistoryReadRequest& other_value) const;
  inline boolean operator!=(const HistoryReadRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ExtensibleParameter& historyReadDetails()
    {return field_historyReadDetails;}
  inline const ExtensibleParameter& historyReadDetails() const
    {return field_historyReadDetails;}
  inline TimestampsToReturn& timestampsToReturn()
    {return field_timestampsToReturn;}
  inline const TimestampsToReturn& timestampsToReturn() const
    {return field_timestampsToReturn;}
  inline INTEGER& releaseContinuationPoints()
    {return field_releaseContinuationPoints;}
  inline const INTEGER& releaseContinuationPoints() const
    {return field_releaseContinuationPoints;}
  inline ListOfHistoryReadValueId& nodesToRead()
    {return field_nodesToRead;}
  inline const ListOfHistoryReadValueId& nodesToRead() const
    {return field_nodesToRead;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryReadRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HistoryReadRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HistoryReadRequest& other_value);
void copy_template(const HistoryReadRequest_template& other_value);

public:
HistoryReadRequest_template();
HistoryReadRequest_template(template_sel other_value);
HistoryReadRequest_template(const HistoryReadRequest& other_value);
HistoryReadRequest_template(const OPTIONAL<HistoryReadRequest>& other_value);
HistoryReadRequest_template(const HistoryReadRequest_template& other_value);
~HistoryReadRequest_template();
HistoryReadRequest_template& operator=(template_sel other_value);
HistoryReadRequest_template& operator=(const HistoryReadRequest& other_value);
HistoryReadRequest_template& operator=(const OPTIONAL<HistoryReadRequest>& other_value);
HistoryReadRequest_template& operator=(const HistoryReadRequest_template& other_value);
boolean match(const HistoryReadRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HistoryReadRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HistoryReadRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ExtensibleParameter_template& historyReadDetails();
const ExtensibleParameter_template& historyReadDetails() const;
TimestampsToReturn_template& timestampsToReturn();
const TimestampsToReturn_template& timestampsToReturn() const;
INTEGER_template& releaseContinuationPoints();
const INTEGER_template& releaseContinuationPoints() const;
ListOfHistoryReadValueId_template& nodesToRead();
const ListOfHistoryReadValueId_template& nodesToRead() const;
int size_of() const;
void log() const;
void log_match(const HistoryReadRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HistoryReadResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfHistoryReadResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  HistoryReadResponse();
  HistoryReadResponse(const ResponseHeader& par_responseHeader,
    const ListOfHistoryReadResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  HistoryReadResponse(const HistoryReadResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HistoryReadResponse& operator=(const HistoryReadResponse& other_value);
  boolean operator==(const HistoryReadResponse& other_value) const;
  inline boolean operator!=(const HistoryReadResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfHistoryReadResult& results()
    {return field_results;}
  inline const ListOfHistoryReadResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryReadResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HistoryReadResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HistoryReadResponse& other_value);
void copy_template(const HistoryReadResponse_template& other_value);

public:
HistoryReadResponse_template();
HistoryReadResponse_template(template_sel other_value);
HistoryReadResponse_template(const HistoryReadResponse& other_value);
HistoryReadResponse_template(const OPTIONAL<HistoryReadResponse>& other_value);
HistoryReadResponse_template(const HistoryReadResponse_template& other_value);
~HistoryReadResponse_template();
HistoryReadResponse_template& operator=(template_sel other_value);
HistoryReadResponse_template& operator=(const HistoryReadResponse& other_value);
HistoryReadResponse_template& operator=(const OPTIONAL<HistoryReadResponse>& other_value);
HistoryReadResponse_template& operator=(const HistoryReadResponse_template& other_value);
boolean match(const HistoryReadResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HistoryReadResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HistoryReadResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfHistoryReadResult_template& results();
const ListOfHistoryReadResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const HistoryReadResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class WriteRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfWriteValue field_nodesToWrite;
public:
  WriteRequest();
  WriteRequest(const RequestHeader& par_requestHeader,
    const ListOfWriteValue& par_nodesToWrite);
  WriteRequest(const WriteRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  WriteRequest& operator=(const WriteRequest& other_value);
  boolean operator==(const WriteRequest& other_value) const;
  inline boolean operator!=(const WriteRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfWriteValue& nodesToWrite()
    {return field_nodesToWrite;}
  inline const ListOfWriteValue& nodesToWrite() const
    {return field_nodesToWrite;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class WriteRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
WriteRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const WriteRequest& other_value);
void copy_template(const WriteRequest_template& other_value);

public:
WriteRequest_template();
WriteRequest_template(template_sel other_value);
WriteRequest_template(const WriteRequest& other_value);
WriteRequest_template(const OPTIONAL<WriteRequest>& other_value);
WriteRequest_template(const WriteRequest_template& other_value);
~WriteRequest_template();
WriteRequest_template& operator=(template_sel other_value);
WriteRequest_template& operator=(const WriteRequest& other_value);
WriteRequest_template& operator=(const OPTIONAL<WriteRequest>& other_value);
WriteRequest_template& operator=(const WriteRequest_template& other_value);
boolean match(const WriteRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
WriteRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
WriteRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfWriteValue_template& nodesToWrite();
const ListOfWriteValue_template& nodesToWrite() const;
int size_of() const;
void log() const;
void log_match(const WriteRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class WriteResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  WriteResponse();
  WriteResponse(const ResponseHeader& par_responseHeader,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  WriteResponse(const WriteResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  WriteResponse& operator=(const WriteResponse& other_value);
  boolean operator==(const WriteResponse& other_value) const;
  inline boolean operator!=(const WriteResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class WriteResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
WriteResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const WriteResponse& other_value);
void copy_template(const WriteResponse_template& other_value);

public:
WriteResponse_template();
WriteResponse_template(template_sel other_value);
WriteResponse_template(const WriteResponse& other_value);
WriteResponse_template(const OPTIONAL<WriteResponse>& other_value);
WriteResponse_template(const WriteResponse_template& other_value);
~WriteResponse_template();
WriteResponse_template& operator=(template_sel other_value);
WriteResponse_template& operator=(const WriteResponse& other_value);
WriteResponse_template& operator=(const OPTIONAL<WriteResponse>& other_value);
WriteResponse_template& operator=(const WriteResponse_template& other_value);
boolean match(const WriteResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
WriteResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
WriteResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const WriteResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HistoryUpdateRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfExtensibleParameter field_historyUpdateDetails;
public:
  HistoryUpdateRequest();
  HistoryUpdateRequest(const RequestHeader& par_requestHeader,
    const ListOfExtensibleParameter& par_historyUpdateDetails);
  HistoryUpdateRequest(const HistoryUpdateRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HistoryUpdateRequest& operator=(const HistoryUpdateRequest& other_value);
  boolean operator==(const HistoryUpdateRequest& other_value) const;
  inline boolean operator!=(const HistoryUpdateRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfExtensibleParameter& historyUpdateDetails()
    {return field_historyUpdateDetails;}
  inline const ListOfExtensibleParameter& historyUpdateDetails() const
    {return field_historyUpdateDetails;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryUpdateRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HistoryUpdateRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HistoryUpdateRequest& other_value);
void copy_template(const HistoryUpdateRequest_template& other_value);

public:
HistoryUpdateRequest_template();
HistoryUpdateRequest_template(template_sel other_value);
HistoryUpdateRequest_template(const HistoryUpdateRequest& other_value);
HistoryUpdateRequest_template(const OPTIONAL<HistoryUpdateRequest>& other_value);
HistoryUpdateRequest_template(const HistoryUpdateRequest_template& other_value);
~HistoryUpdateRequest_template();
HistoryUpdateRequest_template& operator=(template_sel other_value);
HistoryUpdateRequest_template& operator=(const HistoryUpdateRequest& other_value);
HistoryUpdateRequest_template& operator=(const OPTIONAL<HistoryUpdateRequest>& other_value);
HistoryUpdateRequest_template& operator=(const HistoryUpdateRequest_template& other_value);
boolean match(const HistoryUpdateRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HistoryUpdateRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HistoryUpdateRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfExtensibleParameter_template& historyUpdateDetails();
const ListOfExtensibleParameter_template& historyUpdateDetails() const;
int size_of() const;
void log() const;
void log_match(const HistoryUpdateRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class HistoryUpdateResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfHistoryUpdateResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  HistoryUpdateResponse();
  HistoryUpdateResponse(const ResponseHeader& par_responseHeader,
    const ListOfHistoryUpdateResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  HistoryUpdateResponse(const HistoryUpdateResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  HistoryUpdateResponse& operator=(const HistoryUpdateResponse& other_value);
  boolean operator==(const HistoryUpdateResponse& other_value) const;
  inline boolean operator!=(const HistoryUpdateResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfHistoryUpdateResult& results()
    {return field_results;}
  inline const ListOfHistoryUpdateResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class HistoryUpdateResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
HistoryUpdateResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const HistoryUpdateResponse& other_value);
void copy_template(const HistoryUpdateResponse_template& other_value);

public:
HistoryUpdateResponse_template();
HistoryUpdateResponse_template(template_sel other_value);
HistoryUpdateResponse_template(const HistoryUpdateResponse& other_value);
HistoryUpdateResponse_template(const OPTIONAL<HistoryUpdateResponse>& other_value);
HistoryUpdateResponse_template(const HistoryUpdateResponse_template& other_value);
~HistoryUpdateResponse_template();
HistoryUpdateResponse_template& operator=(template_sel other_value);
HistoryUpdateResponse_template& operator=(const HistoryUpdateResponse& other_value);
HistoryUpdateResponse_template& operator=(const OPTIONAL<HistoryUpdateResponse>& other_value);
HistoryUpdateResponse_template& operator=(const HistoryUpdateResponse_template& other_value);
boolean match(const HistoryUpdateResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
HistoryUpdateResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
HistoryUpdateResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfHistoryUpdateResult_template& results();
const ListOfHistoryUpdateResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const HistoryUpdateResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CallRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfCallMethodRequest field_methodsToCall;
public:
  CallRequest();
  CallRequest(const RequestHeader& par_requestHeader,
    const ListOfCallMethodRequest& par_methodsToCall);
  CallRequest(const CallRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CallRequest& operator=(const CallRequest& other_value);
  boolean operator==(const CallRequest& other_value) const;
  inline boolean operator!=(const CallRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfCallMethodRequest& methodsToCall()
    {return field_methodsToCall;}
  inline const ListOfCallMethodRequest& methodsToCall() const
    {return field_methodsToCall;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CallRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CallRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CallRequest& other_value);
void copy_template(const CallRequest_template& other_value);

public:
CallRequest_template();
CallRequest_template(template_sel other_value);
CallRequest_template(const CallRequest& other_value);
CallRequest_template(const OPTIONAL<CallRequest>& other_value);
CallRequest_template(const CallRequest_template& other_value);
~CallRequest_template();
CallRequest_template& operator=(template_sel other_value);
CallRequest_template& operator=(const CallRequest& other_value);
CallRequest_template& operator=(const OPTIONAL<CallRequest>& other_value);
CallRequest_template& operator=(const CallRequest_template& other_value);
boolean match(const CallRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CallRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CallRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfCallMethodRequest_template& methodsToCall();
const ListOfCallMethodRequest_template& methodsToCall() const;
int size_of() const;
void log() const;
void log_match(const CallRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CallResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfCallMethodResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  CallResponse();
  CallResponse(const ResponseHeader& par_responseHeader,
    const ListOfCallMethodResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  CallResponse(const CallResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CallResponse& operator=(const CallResponse& other_value);
  boolean operator==(const CallResponse& other_value) const;
  inline boolean operator!=(const CallResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfCallMethodResult& results()
    {return field_results;}
  inline const ListOfCallMethodResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CallResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CallResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CallResponse& other_value);
void copy_template(const CallResponse_template& other_value);

public:
CallResponse_template();
CallResponse_template(template_sel other_value);
CallResponse_template(const CallResponse& other_value);
CallResponse_template(const OPTIONAL<CallResponse>& other_value);
CallResponse_template(const CallResponse_template& other_value);
~CallResponse_template();
CallResponse_template& operator=(template_sel other_value);
CallResponse_template& operator=(const CallResponse& other_value);
CallResponse_template& operator=(const OPTIONAL<CallResponse>& other_value);
CallResponse_template& operator=(const CallResponse_template& other_value);
boolean match(const CallResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CallResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CallResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfCallMethodResult_template& results();
const ListOfCallMethodResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const CallResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CreateMonitoredItemsRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_subscriptionId;
  TimestampsToReturn field_timestampsToReturn;
  ListOfMonitoredItemCreateRequest field_itemsToCreate;
public:
  CreateMonitoredItemsRequest();
  CreateMonitoredItemsRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_subscriptionId,
    const TimestampsToReturn& par_timestampsToReturn,
    const ListOfMonitoredItemCreateRequest& par_itemsToCreate);
  CreateMonitoredItemsRequest(const CreateMonitoredItemsRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CreateMonitoredItemsRequest& operator=(const CreateMonitoredItemsRequest& other_value);
  boolean operator==(const CreateMonitoredItemsRequest& other_value) const;
  inline boolean operator!=(const CreateMonitoredItemsRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline TimestampsToReturn& timestampsToReturn()
    {return field_timestampsToReturn;}
  inline const TimestampsToReturn& timestampsToReturn() const
    {return field_timestampsToReturn;}
  inline ListOfMonitoredItemCreateRequest& itemsToCreate()
    {return field_itemsToCreate;}
  inline const ListOfMonitoredItemCreateRequest& itemsToCreate() const
    {return field_itemsToCreate;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CreateMonitoredItemsRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CreateMonitoredItemsRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CreateMonitoredItemsRequest& other_value);
void copy_template(const CreateMonitoredItemsRequest_template& other_value);

public:
CreateMonitoredItemsRequest_template();
CreateMonitoredItemsRequest_template(template_sel other_value);
CreateMonitoredItemsRequest_template(const CreateMonitoredItemsRequest& other_value);
CreateMonitoredItemsRequest_template(const OPTIONAL<CreateMonitoredItemsRequest>& other_value);
CreateMonitoredItemsRequest_template(const CreateMonitoredItemsRequest_template& other_value);
~CreateMonitoredItemsRequest_template();
CreateMonitoredItemsRequest_template& operator=(template_sel other_value);
CreateMonitoredItemsRequest_template& operator=(const CreateMonitoredItemsRequest& other_value);
CreateMonitoredItemsRequest_template& operator=(const OPTIONAL<CreateMonitoredItemsRequest>& other_value);
CreateMonitoredItemsRequest_template& operator=(const CreateMonitoredItemsRequest_template& other_value);
boolean match(const CreateMonitoredItemsRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CreateMonitoredItemsRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CreateMonitoredItemsRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
TimestampsToReturn_template& timestampsToReturn();
const TimestampsToReturn_template& timestampsToReturn() const;
ListOfMonitoredItemCreateRequest_template& itemsToCreate();
const ListOfMonitoredItemCreateRequest_template& itemsToCreate() const;
int size_of() const;
void log() const;
void log_match(const CreateMonitoredItemsRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CreateMonitoredItemsResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfMonitoredItemCreateResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  CreateMonitoredItemsResponse();
  CreateMonitoredItemsResponse(const ResponseHeader& par_responseHeader,
    const ListOfMonitoredItemCreateResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  CreateMonitoredItemsResponse(const CreateMonitoredItemsResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CreateMonitoredItemsResponse& operator=(const CreateMonitoredItemsResponse& other_value);
  boolean operator==(const CreateMonitoredItemsResponse& other_value) const;
  inline boolean operator!=(const CreateMonitoredItemsResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfMonitoredItemCreateResult& results()
    {return field_results;}
  inline const ListOfMonitoredItemCreateResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CreateMonitoredItemsResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CreateMonitoredItemsResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CreateMonitoredItemsResponse& other_value);
void copy_template(const CreateMonitoredItemsResponse_template& other_value);

public:
CreateMonitoredItemsResponse_template();
CreateMonitoredItemsResponse_template(template_sel other_value);
CreateMonitoredItemsResponse_template(const CreateMonitoredItemsResponse& other_value);
CreateMonitoredItemsResponse_template(const OPTIONAL<CreateMonitoredItemsResponse>& other_value);
CreateMonitoredItemsResponse_template(const CreateMonitoredItemsResponse_template& other_value);
~CreateMonitoredItemsResponse_template();
CreateMonitoredItemsResponse_template& operator=(template_sel other_value);
CreateMonitoredItemsResponse_template& operator=(const CreateMonitoredItemsResponse& other_value);
CreateMonitoredItemsResponse_template& operator=(const OPTIONAL<CreateMonitoredItemsResponse>& other_value);
CreateMonitoredItemsResponse_template& operator=(const CreateMonitoredItemsResponse_template& other_value);
boolean match(const CreateMonitoredItemsResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CreateMonitoredItemsResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CreateMonitoredItemsResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfMonitoredItemCreateResult_template& results();
const ListOfMonitoredItemCreateResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const CreateMonitoredItemsResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ModifyMonitoredItemsRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_subscriptionId;
  TimestampsToReturn field_timestampsToReturn;
  ListOfMonitoredItemModifyRequest field_itemsToModify;
public:
  ModifyMonitoredItemsRequest();
  ModifyMonitoredItemsRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_subscriptionId,
    const TimestampsToReturn& par_timestampsToReturn,
    const ListOfMonitoredItemModifyRequest& par_itemsToModify);
  ModifyMonitoredItemsRequest(const ModifyMonitoredItemsRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ModifyMonitoredItemsRequest& operator=(const ModifyMonitoredItemsRequest& other_value);
  boolean operator==(const ModifyMonitoredItemsRequest& other_value) const;
  inline boolean operator!=(const ModifyMonitoredItemsRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline TimestampsToReturn& timestampsToReturn()
    {return field_timestampsToReturn;}
  inline const TimestampsToReturn& timestampsToReturn() const
    {return field_timestampsToReturn;}
  inline ListOfMonitoredItemModifyRequest& itemsToModify()
    {return field_itemsToModify;}
  inline const ListOfMonitoredItemModifyRequest& itemsToModify() const
    {return field_itemsToModify;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ModifyMonitoredItemsRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ModifyMonitoredItemsRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ModifyMonitoredItemsRequest& other_value);
void copy_template(const ModifyMonitoredItemsRequest_template& other_value);

public:
ModifyMonitoredItemsRequest_template();
ModifyMonitoredItemsRequest_template(template_sel other_value);
ModifyMonitoredItemsRequest_template(const ModifyMonitoredItemsRequest& other_value);
ModifyMonitoredItemsRequest_template(const OPTIONAL<ModifyMonitoredItemsRequest>& other_value);
ModifyMonitoredItemsRequest_template(const ModifyMonitoredItemsRequest_template& other_value);
~ModifyMonitoredItemsRequest_template();
ModifyMonitoredItemsRequest_template& operator=(template_sel other_value);
ModifyMonitoredItemsRequest_template& operator=(const ModifyMonitoredItemsRequest& other_value);
ModifyMonitoredItemsRequest_template& operator=(const OPTIONAL<ModifyMonitoredItemsRequest>& other_value);
ModifyMonitoredItemsRequest_template& operator=(const ModifyMonitoredItemsRequest_template& other_value);
boolean match(const ModifyMonitoredItemsRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ModifyMonitoredItemsRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ModifyMonitoredItemsRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
TimestampsToReturn_template& timestampsToReturn();
const TimestampsToReturn_template& timestampsToReturn() const;
ListOfMonitoredItemModifyRequest_template& itemsToModify();
const ListOfMonitoredItemModifyRequest_template& itemsToModify() const;
int size_of() const;
void log() const;
void log_match(const ModifyMonitoredItemsRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ModifyMonitoredItemsResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfMonitoredItemModifyResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  ModifyMonitoredItemsResponse();
  ModifyMonitoredItemsResponse(const ResponseHeader& par_responseHeader,
    const ListOfMonitoredItemModifyResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  ModifyMonitoredItemsResponse(const ModifyMonitoredItemsResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ModifyMonitoredItemsResponse& operator=(const ModifyMonitoredItemsResponse& other_value);
  boolean operator==(const ModifyMonitoredItemsResponse& other_value) const;
  inline boolean operator!=(const ModifyMonitoredItemsResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfMonitoredItemModifyResult& results()
    {return field_results;}
  inline const ListOfMonitoredItemModifyResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ModifyMonitoredItemsResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ModifyMonitoredItemsResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ModifyMonitoredItemsResponse& other_value);
void copy_template(const ModifyMonitoredItemsResponse_template& other_value);

public:
ModifyMonitoredItemsResponse_template();
ModifyMonitoredItemsResponse_template(template_sel other_value);
ModifyMonitoredItemsResponse_template(const ModifyMonitoredItemsResponse& other_value);
ModifyMonitoredItemsResponse_template(const OPTIONAL<ModifyMonitoredItemsResponse>& other_value);
ModifyMonitoredItemsResponse_template(const ModifyMonitoredItemsResponse_template& other_value);
~ModifyMonitoredItemsResponse_template();
ModifyMonitoredItemsResponse_template& operator=(template_sel other_value);
ModifyMonitoredItemsResponse_template& operator=(const ModifyMonitoredItemsResponse& other_value);
ModifyMonitoredItemsResponse_template& operator=(const OPTIONAL<ModifyMonitoredItemsResponse>& other_value);
ModifyMonitoredItemsResponse_template& operator=(const ModifyMonitoredItemsResponse_template& other_value);
boolean match(const ModifyMonitoredItemsResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ModifyMonitoredItemsResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ModifyMonitoredItemsResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfMonitoredItemModifyResult_template& results();
const ListOfMonitoredItemModifyResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const ModifyMonitoredItemsResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SetMonitoringModeRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_subscriptionId;
  MonitoringMode field_monitoringMode;
  ListOfIntegerId field_monitoredItemIds;
public:
  SetMonitoringModeRequest();
  SetMonitoringModeRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_subscriptionId,
    const MonitoringMode& par_monitoringMode,
    const ListOfIntegerId& par_monitoredItemIds);
  SetMonitoringModeRequest(const SetMonitoringModeRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SetMonitoringModeRequest& operator=(const SetMonitoringModeRequest& other_value);
  boolean operator==(const SetMonitoringModeRequest& other_value) const;
  inline boolean operator!=(const SetMonitoringModeRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline MonitoringMode& monitoringMode()
    {return field_monitoringMode;}
  inline const MonitoringMode& monitoringMode() const
    {return field_monitoringMode;}
  inline ListOfIntegerId& monitoredItemIds()
    {return field_monitoredItemIds;}
  inline const ListOfIntegerId& monitoredItemIds() const
    {return field_monitoredItemIds;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SetMonitoringModeRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SetMonitoringModeRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SetMonitoringModeRequest& other_value);
void copy_template(const SetMonitoringModeRequest_template& other_value);

public:
SetMonitoringModeRequest_template();
SetMonitoringModeRequest_template(template_sel other_value);
SetMonitoringModeRequest_template(const SetMonitoringModeRequest& other_value);
SetMonitoringModeRequest_template(const OPTIONAL<SetMonitoringModeRequest>& other_value);
SetMonitoringModeRequest_template(const SetMonitoringModeRequest_template& other_value);
~SetMonitoringModeRequest_template();
SetMonitoringModeRequest_template& operator=(template_sel other_value);
SetMonitoringModeRequest_template& operator=(const SetMonitoringModeRequest& other_value);
SetMonitoringModeRequest_template& operator=(const OPTIONAL<SetMonitoringModeRequest>& other_value);
SetMonitoringModeRequest_template& operator=(const SetMonitoringModeRequest_template& other_value);
boolean match(const SetMonitoringModeRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SetMonitoringModeRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SetMonitoringModeRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
MonitoringMode_template& monitoringMode();
const MonitoringMode_template& monitoringMode() const;
ListOfIntegerId_template& monitoredItemIds();
const ListOfIntegerId_template& monitoredItemIds() const;
int size_of() const;
void log() const;
void log_match(const SetMonitoringModeRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SetMonitoringModeResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  SetMonitoringModeResponse();
  SetMonitoringModeResponse(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  SetMonitoringModeResponse(const SetMonitoringModeResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SetMonitoringModeResponse& operator=(const SetMonitoringModeResponse& other_value);
  boolean operator==(const SetMonitoringModeResponse& other_value) const;
  inline boolean operator!=(const SetMonitoringModeResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SetMonitoringModeResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SetMonitoringModeResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SetMonitoringModeResponse& other_value);
void copy_template(const SetMonitoringModeResponse_template& other_value);

public:
SetMonitoringModeResponse_template();
SetMonitoringModeResponse_template(template_sel other_value);
SetMonitoringModeResponse_template(const SetMonitoringModeResponse& other_value);
SetMonitoringModeResponse_template(const OPTIONAL<SetMonitoringModeResponse>& other_value);
SetMonitoringModeResponse_template(const SetMonitoringModeResponse_template& other_value);
~SetMonitoringModeResponse_template();
SetMonitoringModeResponse_template& operator=(template_sel other_value);
SetMonitoringModeResponse_template& operator=(const SetMonitoringModeResponse& other_value);
SetMonitoringModeResponse_template& operator=(const OPTIONAL<SetMonitoringModeResponse>& other_value);
SetMonitoringModeResponse_template& operator=(const SetMonitoringModeResponse_template& other_value);
boolean match(const SetMonitoringModeResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SetMonitoringModeResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SetMonitoringModeResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const SetMonitoringModeResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SetTriggeringRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_subscriptionId;
  INTEGER field_triggeringItemId;
  ListOfIntegerId field_linksToAdd;
  INTEGER field_linksToRemove;
public:
  SetTriggeringRequest();
  SetTriggeringRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_subscriptionId,
    const INTEGER& par_triggeringItemId,
    const ListOfIntegerId& par_linksToAdd,
    const INTEGER& par_linksToRemove);
  SetTriggeringRequest(const SetTriggeringRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SetTriggeringRequest& operator=(const SetTriggeringRequest& other_value);
  boolean operator==(const SetTriggeringRequest& other_value) const;
  inline boolean operator!=(const SetTriggeringRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline INTEGER& triggeringItemId()
    {return field_triggeringItemId;}
  inline const INTEGER& triggeringItemId() const
    {return field_triggeringItemId;}
  inline ListOfIntegerId& linksToAdd()
    {return field_linksToAdd;}
  inline const ListOfIntegerId& linksToAdd() const
    {return field_linksToAdd;}
  inline INTEGER& linksToRemove()
    {return field_linksToRemove;}
  inline const INTEGER& linksToRemove() const
    {return field_linksToRemove;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SetTriggeringRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SetTriggeringRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SetTriggeringRequest& other_value);
void copy_template(const SetTriggeringRequest_template& other_value);

public:
SetTriggeringRequest_template();
SetTriggeringRequest_template(template_sel other_value);
SetTriggeringRequest_template(const SetTriggeringRequest& other_value);
SetTriggeringRequest_template(const OPTIONAL<SetTriggeringRequest>& other_value);
SetTriggeringRequest_template(const SetTriggeringRequest_template& other_value);
~SetTriggeringRequest_template();
SetTriggeringRequest_template& operator=(template_sel other_value);
SetTriggeringRequest_template& operator=(const SetTriggeringRequest& other_value);
SetTriggeringRequest_template& operator=(const OPTIONAL<SetTriggeringRequest>& other_value);
SetTriggeringRequest_template& operator=(const SetTriggeringRequest_template& other_value);
boolean match(const SetTriggeringRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SetTriggeringRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SetTriggeringRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
INTEGER_template& triggeringItemId();
const INTEGER_template& triggeringItemId() const;
ListOfIntegerId_template& linksToAdd();
const ListOfIntegerId_template& linksToAdd() const;
INTEGER_template& linksToRemove();
const INTEGER_template& linksToRemove() const;
int size_of() const;
void log() const;
void log_match(const SetTriggeringRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SetTriggeringResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_addResults;
  ListOfDiagnosticInfo field_addDiagnosticInfos;
  ListOfStatusCode field_removeResults;
  ListOfDiagnosticInfo field_removeDiagnosticInfos;
public:
  SetTriggeringResponse();
  SetTriggeringResponse(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_addResults,
    const ListOfDiagnosticInfo& par_addDiagnosticInfos,
    const ListOfStatusCode& par_removeResults,
    const ListOfDiagnosticInfo& par_removeDiagnosticInfos);
  SetTriggeringResponse(const SetTriggeringResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SetTriggeringResponse& operator=(const SetTriggeringResponse& other_value);
  boolean operator==(const SetTriggeringResponse& other_value) const;
  inline boolean operator!=(const SetTriggeringResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& addResults()
    {return field_addResults;}
  inline const ListOfStatusCode& addResults() const
    {return field_addResults;}
  inline ListOfDiagnosticInfo& addDiagnosticInfos()
    {return field_addDiagnosticInfos;}
  inline const ListOfDiagnosticInfo& addDiagnosticInfos() const
    {return field_addDiagnosticInfos;}
  inline ListOfStatusCode& removeResults()
    {return field_removeResults;}
  inline const ListOfStatusCode& removeResults() const
    {return field_removeResults;}
  inline ListOfDiagnosticInfo& removeDiagnosticInfos()
    {return field_removeDiagnosticInfos;}
  inline const ListOfDiagnosticInfo& removeDiagnosticInfos() const
    {return field_removeDiagnosticInfos;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SetTriggeringResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SetTriggeringResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SetTriggeringResponse& other_value);
void copy_template(const SetTriggeringResponse_template& other_value);

public:
SetTriggeringResponse_template();
SetTriggeringResponse_template(template_sel other_value);
SetTriggeringResponse_template(const SetTriggeringResponse& other_value);
SetTriggeringResponse_template(const OPTIONAL<SetTriggeringResponse>& other_value);
SetTriggeringResponse_template(const SetTriggeringResponse_template& other_value);
~SetTriggeringResponse_template();
SetTriggeringResponse_template& operator=(template_sel other_value);
SetTriggeringResponse_template& operator=(const SetTriggeringResponse& other_value);
SetTriggeringResponse_template& operator=(const OPTIONAL<SetTriggeringResponse>& other_value);
SetTriggeringResponse_template& operator=(const SetTriggeringResponse_template& other_value);
boolean match(const SetTriggeringResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SetTriggeringResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SetTriggeringResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& addResults();
const ListOfStatusCode_template& addResults() const;
ListOfDiagnosticInfo_template& addDiagnosticInfos();
const ListOfDiagnosticInfo_template& addDiagnosticInfos() const;
ListOfStatusCode_template& removeResults();
const ListOfStatusCode_template& removeResults() const;
ListOfDiagnosticInfo_template& removeDiagnosticInfos();
const ListOfDiagnosticInfo_template& removeDiagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const SetTriggeringResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteMonitoredItemsRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_subscriptionId;
  ListOfIntegerId field_monitoredItemIds;
public:
  DeleteMonitoredItemsRequest();
  DeleteMonitoredItemsRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_subscriptionId,
    const ListOfIntegerId& par_monitoredItemIds);
  DeleteMonitoredItemsRequest(const DeleteMonitoredItemsRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteMonitoredItemsRequest& operator=(const DeleteMonitoredItemsRequest& other_value);
  boolean operator==(const DeleteMonitoredItemsRequest& other_value) const;
  inline boolean operator!=(const DeleteMonitoredItemsRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline ListOfIntegerId& monitoredItemIds()
    {return field_monitoredItemIds;}
  inline const ListOfIntegerId& monitoredItemIds() const
    {return field_monitoredItemIds;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteMonitoredItemsRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteMonitoredItemsRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteMonitoredItemsRequest& other_value);
void copy_template(const DeleteMonitoredItemsRequest_template& other_value);

public:
DeleteMonitoredItemsRequest_template();
DeleteMonitoredItemsRequest_template(template_sel other_value);
DeleteMonitoredItemsRequest_template(const DeleteMonitoredItemsRequest& other_value);
DeleteMonitoredItemsRequest_template(const OPTIONAL<DeleteMonitoredItemsRequest>& other_value);
DeleteMonitoredItemsRequest_template(const DeleteMonitoredItemsRequest_template& other_value);
~DeleteMonitoredItemsRequest_template();
DeleteMonitoredItemsRequest_template& operator=(template_sel other_value);
DeleteMonitoredItemsRequest_template& operator=(const DeleteMonitoredItemsRequest& other_value);
DeleteMonitoredItemsRequest_template& operator=(const OPTIONAL<DeleteMonitoredItemsRequest>& other_value);
DeleteMonitoredItemsRequest_template& operator=(const DeleteMonitoredItemsRequest_template& other_value);
boolean match(const DeleteMonitoredItemsRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteMonitoredItemsRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteMonitoredItemsRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
ListOfIntegerId_template& monitoredItemIds();
const ListOfIntegerId_template& monitoredItemIds() const;
int size_of() const;
void log() const;
void log_match(const DeleteMonitoredItemsRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteMonitoredItemsResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  DeleteMonitoredItemsResponse();
  DeleteMonitoredItemsResponse(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  DeleteMonitoredItemsResponse(const DeleteMonitoredItemsResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteMonitoredItemsResponse& operator=(const DeleteMonitoredItemsResponse& other_value);
  boolean operator==(const DeleteMonitoredItemsResponse& other_value) const;
  inline boolean operator!=(const DeleteMonitoredItemsResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteMonitoredItemsResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteMonitoredItemsResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteMonitoredItemsResponse& other_value);
void copy_template(const DeleteMonitoredItemsResponse_template& other_value);

public:
DeleteMonitoredItemsResponse_template();
DeleteMonitoredItemsResponse_template(template_sel other_value);
DeleteMonitoredItemsResponse_template(const DeleteMonitoredItemsResponse& other_value);
DeleteMonitoredItemsResponse_template(const OPTIONAL<DeleteMonitoredItemsResponse>& other_value);
DeleteMonitoredItemsResponse_template(const DeleteMonitoredItemsResponse_template& other_value);
~DeleteMonitoredItemsResponse_template();
DeleteMonitoredItemsResponse_template& operator=(template_sel other_value);
DeleteMonitoredItemsResponse_template& operator=(const DeleteMonitoredItemsResponse& other_value);
DeleteMonitoredItemsResponse_template& operator=(const OPTIONAL<DeleteMonitoredItemsResponse>& other_value);
DeleteMonitoredItemsResponse_template& operator=(const DeleteMonitoredItemsResponse_template& other_value);
boolean match(const DeleteMonitoredItemsResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteMonitoredItemsResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteMonitoredItemsResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const DeleteMonitoredItemsResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CreateSubscriptionRequest : public Base_Type {
  RequestHeader field_requestHeader;
  FLOAT field_requestedPublishingInterval;
  INTEGER field_requestedLifetimeCount;
  INTEGER field_requestedMaxKeepAliveCount;
  INTEGER field_maxNotificationsPerPublish;
  INTEGER field_publishingEnabled;
  INTEGER field_priorityInt32;
public:
  CreateSubscriptionRequest();
  CreateSubscriptionRequest(const RequestHeader& par_requestHeader,
    const FLOAT& par_requestedPublishingInterval,
    const INTEGER& par_requestedLifetimeCount,
    const INTEGER& par_requestedMaxKeepAliveCount,
    const INTEGER& par_maxNotificationsPerPublish,
    const INTEGER& par_publishingEnabled,
    const INTEGER& par_priorityInt32);
  CreateSubscriptionRequest(const CreateSubscriptionRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CreateSubscriptionRequest& operator=(const CreateSubscriptionRequest& other_value);
  boolean operator==(const CreateSubscriptionRequest& other_value) const;
  inline boolean operator!=(const CreateSubscriptionRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline FLOAT& requestedPublishingInterval()
    {return field_requestedPublishingInterval;}
  inline const FLOAT& requestedPublishingInterval() const
    {return field_requestedPublishingInterval;}
  inline INTEGER& requestedLifetimeCount()
    {return field_requestedLifetimeCount;}
  inline const INTEGER& requestedLifetimeCount() const
    {return field_requestedLifetimeCount;}
  inline INTEGER& requestedMaxKeepAliveCount()
    {return field_requestedMaxKeepAliveCount;}
  inline const INTEGER& requestedMaxKeepAliveCount() const
    {return field_requestedMaxKeepAliveCount;}
  inline INTEGER& maxNotificationsPerPublish()
    {return field_maxNotificationsPerPublish;}
  inline const INTEGER& maxNotificationsPerPublish() const
    {return field_maxNotificationsPerPublish;}
  inline INTEGER& publishingEnabled()
    {return field_publishingEnabled;}
  inline const INTEGER& publishingEnabled() const
    {return field_publishingEnabled;}
  inline INTEGER& priorityInt32()
    {return field_priorityInt32;}
  inline const INTEGER& priorityInt32() const
    {return field_priorityInt32;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CreateSubscriptionRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CreateSubscriptionRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CreateSubscriptionRequest& other_value);
void copy_template(const CreateSubscriptionRequest_template& other_value);

public:
CreateSubscriptionRequest_template();
CreateSubscriptionRequest_template(template_sel other_value);
CreateSubscriptionRequest_template(const CreateSubscriptionRequest& other_value);
CreateSubscriptionRequest_template(const OPTIONAL<CreateSubscriptionRequest>& other_value);
CreateSubscriptionRequest_template(const CreateSubscriptionRequest_template& other_value);
~CreateSubscriptionRequest_template();
CreateSubscriptionRequest_template& operator=(template_sel other_value);
CreateSubscriptionRequest_template& operator=(const CreateSubscriptionRequest& other_value);
CreateSubscriptionRequest_template& operator=(const OPTIONAL<CreateSubscriptionRequest>& other_value);
CreateSubscriptionRequest_template& operator=(const CreateSubscriptionRequest_template& other_value);
boolean match(const CreateSubscriptionRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CreateSubscriptionRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CreateSubscriptionRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
FLOAT_template& requestedPublishingInterval();
const FLOAT_template& requestedPublishingInterval() const;
INTEGER_template& requestedLifetimeCount();
const INTEGER_template& requestedLifetimeCount() const;
INTEGER_template& requestedMaxKeepAliveCount();
const INTEGER_template& requestedMaxKeepAliveCount() const;
INTEGER_template& maxNotificationsPerPublish();
const INTEGER_template& maxNotificationsPerPublish() const;
INTEGER_template& publishingEnabled();
const INTEGER_template& publishingEnabled() const;
INTEGER_template& priorityInt32();
const INTEGER_template& priorityInt32() const;
int size_of() const;
void log() const;
void log_match(const CreateSubscriptionRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class CreateSubscriptionResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  INTEGER field_subscriptionId;
  FLOAT field_revisedPublishingInterval;
  INTEGER field_revisedLifetimeCount;
  INTEGER field_revisedMaxKeepAliveCount;
public:
  CreateSubscriptionResponse();
  CreateSubscriptionResponse(const ResponseHeader& par_responseHeader,
    const INTEGER& par_subscriptionId,
    const FLOAT& par_revisedPublishingInterval,
    const INTEGER& par_revisedLifetimeCount,
    const INTEGER& par_revisedMaxKeepAliveCount);
  CreateSubscriptionResponse(const CreateSubscriptionResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  CreateSubscriptionResponse& operator=(const CreateSubscriptionResponse& other_value);
  boolean operator==(const CreateSubscriptionResponse& other_value) const;
  inline boolean operator!=(const CreateSubscriptionResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline FLOAT& revisedPublishingInterval()
    {return field_revisedPublishingInterval;}
  inline const FLOAT& revisedPublishingInterval() const
    {return field_revisedPublishingInterval;}
  inline INTEGER& revisedLifetimeCount()
    {return field_revisedLifetimeCount;}
  inline const INTEGER& revisedLifetimeCount() const
    {return field_revisedLifetimeCount;}
  inline INTEGER& revisedMaxKeepAliveCount()
    {return field_revisedMaxKeepAliveCount;}
  inline const INTEGER& revisedMaxKeepAliveCount() const
    {return field_revisedMaxKeepAliveCount;}
  inline int size_of() const
    {return 5;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class CreateSubscriptionResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
CreateSubscriptionResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const CreateSubscriptionResponse& other_value);
void copy_template(const CreateSubscriptionResponse_template& other_value);

public:
CreateSubscriptionResponse_template();
CreateSubscriptionResponse_template(template_sel other_value);
CreateSubscriptionResponse_template(const CreateSubscriptionResponse& other_value);
CreateSubscriptionResponse_template(const OPTIONAL<CreateSubscriptionResponse>& other_value);
CreateSubscriptionResponse_template(const CreateSubscriptionResponse_template& other_value);
~CreateSubscriptionResponse_template();
CreateSubscriptionResponse_template& operator=(template_sel other_value);
CreateSubscriptionResponse_template& operator=(const CreateSubscriptionResponse& other_value);
CreateSubscriptionResponse_template& operator=(const OPTIONAL<CreateSubscriptionResponse>& other_value);
CreateSubscriptionResponse_template& operator=(const CreateSubscriptionResponse_template& other_value);
boolean match(const CreateSubscriptionResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
CreateSubscriptionResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
CreateSubscriptionResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
FLOAT_template& revisedPublishingInterval();
const FLOAT_template& revisedPublishingInterval() const;
INTEGER_template& revisedLifetimeCount();
const INTEGER_template& revisedLifetimeCount() const;
INTEGER_template& revisedMaxKeepAliveCount();
const INTEGER_template& revisedMaxKeepAliveCount() const;
int size_of() const;
void log() const;
void log_match(const CreateSubscriptionResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ModifySubscriptionRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_subscriptionId;
  FLOAT field_requestedPublishingInterval;
  INTEGER field_requestedLifetimeCount;
  INTEGER field_requestedMaxKeepAliveCount;
  INTEGER field_maxNotificationsPerPublish;
  INTEGER field_priority;
public:
  ModifySubscriptionRequest();
  ModifySubscriptionRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_subscriptionId,
    const FLOAT& par_requestedPublishingInterval,
    const INTEGER& par_requestedLifetimeCount,
    const INTEGER& par_requestedMaxKeepAliveCount,
    const INTEGER& par_maxNotificationsPerPublish,
    const INTEGER& par_priority);
  ModifySubscriptionRequest(const ModifySubscriptionRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ModifySubscriptionRequest& operator=(const ModifySubscriptionRequest& other_value);
  boolean operator==(const ModifySubscriptionRequest& other_value) const;
  inline boolean operator!=(const ModifySubscriptionRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline FLOAT& requestedPublishingInterval()
    {return field_requestedPublishingInterval;}
  inline const FLOAT& requestedPublishingInterval() const
    {return field_requestedPublishingInterval;}
  inline INTEGER& requestedLifetimeCount()
    {return field_requestedLifetimeCount;}
  inline const INTEGER& requestedLifetimeCount() const
    {return field_requestedLifetimeCount;}
  inline INTEGER& requestedMaxKeepAliveCount()
    {return field_requestedMaxKeepAliveCount;}
  inline const INTEGER& requestedMaxKeepAliveCount() const
    {return field_requestedMaxKeepAliveCount;}
  inline INTEGER& maxNotificationsPerPublish()
    {return field_maxNotificationsPerPublish;}
  inline const INTEGER& maxNotificationsPerPublish() const
    {return field_maxNotificationsPerPublish;}
  inline INTEGER& priority()
    {return field_priority;}
  inline const INTEGER& priority() const
    {return field_priority;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ModifySubscriptionRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ModifySubscriptionRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ModifySubscriptionRequest& other_value);
void copy_template(const ModifySubscriptionRequest_template& other_value);

public:
ModifySubscriptionRequest_template();
ModifySubscriptionRequest_template(template_sel other_value);
ModifySubscriptionRequest_template(const ModifySubscriptionRequest& other_value);
ModifySubscriptionRequest_template(const OPTIONAL<ModifySubscriptionRequest>& other_value);
ModifySubscriptionRequest_template(const ModifySubscriptionRequest_template& other_value);
~ModifySubscriptionRequest_template();
ModifySubscriptionRequest_template& operator=(template_sel other_value);
ModifySubscriptionRequest_template& operator=(const ModifySubscriptionRequest& other_value);
ModifySubscriptionRequest_template& operator=(const OPTIONAL<ModifySubscriptionRequest>& other_value);
ModifySubscriptionRequest_template& operator=(const ModifySubscriptionRequest_template& other_value);
boolean match(const ModifySubscriptionRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ModifySubscriptionRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ModifySubscriptionRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
FLOAT_template& requestedPublishingInterval();
const FLOAT_template& requestedPublishingInterval() const;
INTEGER_template& requestedLifetimeCount();
const INTEGER_template& requestedLifetimeCount() const;
INTEGER_template& requestedMaxKeepAliveCount();
const INTEGER_template& requestedMaxKeepAliveCount() const;
INTEGER_template& maxNotificationsPerPublish();
const INTEGER_template& maxNotificationsPerPublish() const;
INTEGER_template& priority();
const INTEGER_template& priority() const;
int size_of() const;
void log() const;
void log_match(const ModifySubscriptionRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ModifySubscriptionResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  FLOAT field_revisedPublishingInterval;
  INTEGER field_revisedLifetimeCount;
  INTEGER field_revisedMaxKeepAliveCount;
public:
  ModifySubscriptionResponse();
  ModifySubscriptionResponse(const ResponseHeader& par_responseHeader,
    const FLOAT& par_revisedPublishingInterval,
    const INTEGER& par_revisedLifetimeCount,
    const INTEGER& par_revisedMaxKeepAliveCount);
  ModifySubscriptionResponse(const ModifySubscriptionResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ModifySubscriptionResponse& operator=(const ModifySubscriptionResponse& other_value);
  boolean operator==(const ModifySubscriptionResponse& other_value) const;
  inline boolean operator!=(const ModifySubscriptionResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline FLOAT& revisedPublishingInterval()
    {return field_revisedPublishingInterval;}
  inline const FLOAT& revisedPublishingInterval() const
    {return field_revisedPublishingInterval;}
  inline INTEGER& revisedLifetimeCount()
    {return field_revisedLifetimeCount;}
  inline const INTEGER& revisedLifetimeCount() const
    {return field_revisedLifetimeCount;}
  inline INTEGER& revisedMaxKeepAliveCount()
    {return field_revisedMaxKeepAliveCount;}
  inline const INTEGER& revisedMaxKeepAliveCount() const
    {return field_revisedMaxKeepAliveCount;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ModifySubscriptionResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ModifySubscriptionResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ModifySubscriptionResponse& other_value);
void copy_template(const ModifySubscriptionResponse_template& other_value);

public:
ModifySubscriptionResponse_template();
ModifySubscriptionResponse_template(template_sel other_value);
ModifySubscriptionResponse_template(const ModifySubscriptionResponse& other_value);
ModifySubscriptionResponse_template(const OPTIONAL<ModifySubscriptionResponse>& other_value);
ModifySubscriptionResponse_template(const ModifySubscriptionResponse_template& other_value);
~ModifySubscriptionResponse_template();
ModifySubscriptionResponse_template& operator=(template_sel other_value);
ModifySubscriptionResponse_template& operator=(const ModifySubscriptionResponse& other_value);
ModifySubscriptionResponse_template& operator=(const OPTIONAL<ModifySubscriptionResponse>& other_value);
ModifySubscriptionResponse_template& operator=(const ModifySubscriptionResponse_template& other_value);
boolean match(const ModifySubscriptionResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ModifySubscriptionResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ModifySubscriptionResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
FLOAT_template& revisedPublishingInterval();
const FLOAT_template& revisedPublishingInterval() const;
INTEGER_template& revisedLifetimeCount();
const INTEGER_template& revisedLifetimeCount() const;
INTEGER_template& revisedMaxKeepAliveCount();
const INTEGER_template& revisedMaxKeepAliveCount() const;
int size_of() const;
void log() const;
void log_match(const ModifySubscriptionResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SetPublishingModeRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_publishingEnabled;
  ListOfIntegerId field_subscriptionIds;
public:
  SetPublishingModeRequest();
  SetPublishingModeRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_publishingEnabled,
    const ListOfIntegerId& par_subscriptionIds);
  SetPublishingModeRequest(const SetPublishingModeRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SetPublishingModeRequest& operator=(const SetPublishingModeRequest& other_value);
  boolean operator==(const SetPublishingModeRequest& other_value) const;
  inline boolean operator!=(const SetPublishingModeRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& publishingEnabled()
    {return field_publishingEnabled;}
  inline const INTEGER& publishingEnabled() const
    {return field_publishingEnabled;}
  inline ListOfIntegerId& subscriptionIds()
    {return field_subscriptionIds;}
  inline const ListOfIntegerId& subscriptionIds() const
    {return field_subscriptionIds;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SetPublishingModeRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SetPublishingModeRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SetPublishingModeRequest& other_value);
void copy_template(const SetPublishingModeRequest_template& other_value);

public:
SetPublishingModeRequest_template();
SetPublishingModeRequest_template(template_sel other_value);
SetPublishingModeRequest_template(const SetPublishingModeRequest& other_value);
SetPublishingModeRequest_template(const OPTIONAL<SetPublishingModeRequest>& other_value);
SetPublishingModeRequest_template(const SetPublishingModeRequest_template& other_value);
~SetPublishingModeRequest_template();
SetPublishingModeRequest_template& operator=(template_sel other_value);
SetPublishingModeRequest_template& operator=(const SetPublishingModeRequest& other_value);
SetPublishingModeRequest_template& operator=(const OPTIONAL<SetPublishingModeRequest>& other_value);
SetPublishingModeRequest_template& operator=(const SetPublishingModeRequest_template& other_value);
boolean match(const SetPublishingModeRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SetPublishingModeRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SetPublishingModeRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& publishingEnabled();
const INTEGER_template& publishingEnabled() const;
ListOfIntegerId_template& subscriptionIds();
const ListOfIntegerId_template& subscriptionIds() const;
int size_of() const;
void log() const;
void log_match(const SetPublishingModeRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SetPublishingModeResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  SetPublishingModeResponse();
  SetPublishingModeResponse(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  SetPublishingModeResponse(const SetPublishingModeResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SetPublishingModeResponse& operator=(const SetPublishingModeResponse& other_value);
  boolean operator==(const SetPublishingModeResponse& other_value) const;
  inline boolean operator!=(const SetPublishingModeResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SetPublishingModeResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SetPublishingModeResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SetPublishingModeResponse& other_value);
void copy_template(const SetPublishingModeResponse_template& other_value);

public:
SetPublishingModeResponse_template();
SetPublishingModeResponse_template(template_sel other_value);
SetPublishingModeResponse_template(const SetPublishingModeResponse& other_value);
SetPublishingModeResponse_template(const OPTIONAL<SetPublishingModeResponse>& other_value);
SetPublishingModeResponse_template(const SetPublishingModeResponse_template& other_value);
~SetPublishingModeResponse_template();
SetPublishingModeResponse_template& operator=(template_sel other_value);
SetPublishingModeResponse_template& operator=(const SetPublishingModeResponse& other_value);
SetPublishingModeResponse_template& operator=(const OPTIONAL<SetPublishingModeResponse>& other_value);
SetPublishingModeResponse_template& operator=(const SetPublishingModeResponse_template& other_value);
boolean match(const SetPublishingModeResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SetPublishingModeResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SetPublishingModeResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const SetPublishingModeResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PublishRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfSubscriptionAcknowledgement field_subscriptionAcknowledgements;
public:
  PublishRequest();
  PublishRequest(const RequestHeader& par_requestHeader,
    const ListOfSubscriptionAcknowledgement& par_subscriptionAcknowledgements);
  PublishRequest(const PublishRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PublishRequest& operator=(const PublishRequest& other_value);
  boolean operator==(const PublishRequest& other_value) const;
  inline boolean operator!=(const PublishRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfSubscriptionAcknowledgement& subscriptionAcknowledgements()
    {return field_subscriptionAcknowledgements;}
  inline const ListOfSubscriptionAcknowledgement& subscriptionAcknowledgements() const
    {return field_subscriptionAcknowledgements;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class PublishRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PublishRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PublishRequest& other_value);
void copy_template(const PublishRequest_template& other_value);

public:
PublishRequest_template();
PublishRequest_template(template_sel other_value);
PublishRequest_template(const PublishRequest& other_value);
PublishRequest_template(const OPTIONAL<PublishRequest>& other_value);
PublishRequest_template(const PublishRequest_template& other_value);
~PublishRequest_template();
PublishRequest_template& operator=(template_sel other_value);
PublishRequest_template& operator=(const PublishRequest& other_value);
PublishRequest_template& operator=(const OPTIONAL<PublishRequest>& other_value);
PublishRequest_template& operator=(const PublishRequest_template& other_value);
boolean match(const PublishRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PublishRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PublishRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfSubscriptionAcknowledgement_template& subscriptionAcknowledgements();
const ListOfSubscriptionAcknowledgement_template& subscriptionAcknowledgements() const;
int size_of() const;
void log() const;
void log_match(const PublishRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class PublishResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  INTEGER field_subscriptionId;
  ListOfCounter field_availableSequenceNumbers;
  INTEGER field_moreNotifications;
  NotificationMessage field_notificationMessage;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  PublishResponse();
  PublishResponse(const ResponseHeader& par_responseHeader,
    const INTEGER& par_subscriptionId,
    const ListOfCounter& par_availableSequenceNumbers,
    const INTEGER& par_moreNotifications,
    const NotificationMessage& par_notificationMessage,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  PublishResponse(const PublishResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  PublishResponse& operator=(const PublishResponse& other_value);
  boolean operator==(const PublishResponse& other_value) const;
  inline boolean operator!=(const PublishResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline ListOfCounter& availableSequenceNumbers()
    {return field_availableSequenceNumbers;}
  inline const ListOfCounter& availableSequenceNumbers() const
    {return field_availableSequenceNumbers;}
  inline INTEGER& moreNotifications()
    {return field_moreNotifications;}
  inline const INTEGER& moreNotifications() const
    {return field_moreNotifications;}
  inline NotificationMessage& notificationMessage()
    {return field_notificationMessage;}
  inline const NotificationMessage& notificationMessage() const
    {return field_notificationMessage;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 7;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class PublishResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
PublishResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const PublishResponse& other_value);
void copy_template(const PublishResponse_template& other_value);

public:
PublishResponse_template();
PublishResponse_template(template_sel other_value);
PublishResponse_template(const PublishResponse& other_value);
PublishResponse_template(const OPTIONAL<PublishResponse>& other_value);
PublishResponse_template(const PublishResponse_template& other_value);
~PublishResponse_template();
PublishResponse_template& operator=(template_sel other_value);
PublishResponse_template& operator=(const PublishResponse& other_value);
PublishResponse_template& operator=(const OPTIONAL<PublishResponse>& other_value);
PublishResponse_template& operator=(const PublishResponse_template& other_value);
boolean match(const PublishResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
PublishResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
PublishResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
ListOfCounter_template& availableSequenceNumbers();
const ListOfCounter_template& availableSequenceNumbers() const;
INTEGER_template& moreNotifications();
const INTEGER_template& moreNotifications() const;
NotificationMessage_template& notificationMessage();
const NotificationMessage_template& notificationMessage() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const PublishResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RepublishRequest : public Base_Type {
  RequestHeader field_requestHeader;
  INTEGER field_subscriptionId;
  INTEGER field_retransmitSequenceNumber;
public:
  RepublishRequest();
  RepublishRequest(const RequestHeader& par_requestHeader,
    const INTEGER& par_subscriptionId,
    const INTEGER& par_retransmitSequenceNumber);
  RepublishRequest(const RepublishRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RepublishRequest& operator=(const RepublishRequest& other_value);
  boolean operator==(const RepublishRequest& other_value) const;
  inline boolean operator!=(const RepublishRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline INTEGER& subscriptionId()
    {return field_subscriptionId;}
  inline const INTEGER& subscriptionId() const
    {return field_subscriptionId;}
  inline INTEGER& retransmitSequenceNumber()
    {return field_retransmitSequenceNumber;}
  inline const INTEGER& retransmitSequenceNumber() const
    {return field_retransmitSequenceNumber;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RepublishRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RepublishRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RepublishRequest& other_value);
void copy_template(const RepublishRequest_template& other_value);

public:
RepublishRequest_template();
RepublishRequest_template(template_sel other_value);
RepublishRequest_template(const RepublishRequest& other_value);
RepublishRequest_template(const OPTIONAL<RepublishRequest>& other_value);
RepublishRequest_template(const RepublishRequest_template& other_value);
~RepublishRequest_template();
RepublishRequest_template& operator=(template_sel other_value);
RepublishRequest_template& operator=(const RepublishRequest& other_value);
RepublishRequest_template& operator=(const OPTIONAL<RepublishRequest>& other_value);
RepublishRequest_template& operator=(const RepublishRequest_template& other_value);
boolean match(const RepublishRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RepublishRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RepublishRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
INTEGER_template& subscriptionId();
const INTEGER_template& subscriptionId() const;
INTEGER_template& retransmitSequenceNumber();
const INTEGER_template& retransmitSequenceNumber() const;
int size_of() const;
void log() const;
void log_match(const RepublishRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class RepublishResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  NotificationMessage field_notificationMessage;
public:
  RepublishResponse();
  RepublishResponse(const ResponseHeader& par_responseHeader,
    const NotificationMessage& par_notificationMessage);
  RepublishResponse(const RepublishResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  RepublishResponse& operator=(const RepublishResponse& other_value);
  boolean operator==(const RepublishResponse& other_value) const;
  inline boolean operator!=(const RepublishResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline NotificationMessage& notificationMessage()
    {return field_notificationMessage;}
  inline const NotificationMessage& notificationMessage() const
    {return field_notificationMessage;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class RepublishResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
RepublishResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const RepublishResponse& other_value);
void copy_template(const RepublishResponse_template& other_value);

public:
RepublishResponse_template();
RepublishResponse_template(template_sel other_value);
RepublishResponse_template(const RepublishResponse& other_value);
RepublishResponse_template(const OPTIONAL<RepublishResponse>& other_value);
RepublishResponse_template(const RepublishResponse_template& other_value);
~RepublishResponse_template();
RepublishResponse_template& operator=(template_sel other_value);
RepublishResponse_template& operator=(const RepublishResponse& other_value);
RepublishResponse_template& operator=(const OPTIONAL<RepublishResponse>& other_value);
RepublishResponse_template& operator=(const RepublishResponse_template& other_value);
boolean match(const RepublishResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
RepublishResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
RepublishResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
NotificationMessage_template& notificationMessage();
const NotificationMessage_template& notificationMessage() const;
int size_of() const;
void log() const;
void log_match(const RepublishResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TransferSubscriptionsRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfIntegerId field_subscriptionIds;
  INTEGER field_sendInitialValues;
public:
  TransferSubscriptionsRequest();
  TransferSubscriptionsRequest(const RequestHeader& par_requestHeader,
    const ListOfIntegerId& par_subscriptionIds,
    const INTEGER& par_sendInitialValues);
  TransferSubscriptionsRequest(const TransferSubscriptionsRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TransferSubscriptionsRequest& operator=(const TransferSubscriptionsRequest& other_value);
  boolean operator==(const TransferSubscriptionsRequest& other_value) const;
  inline boolean operator!=(const TransferSubscriptionsRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfIntegerId& subscriptionIds()
    {return field_subscriptionIds;}
  inline const ListOfIntegerId& subscriptionIds() const
    {return field_subscriptionIds;}
  inline INTEGER& sendInitialValues()
    {return field_sendInitialValues;}
  inline const INTEGER& sendInitialValues() const
    {return field_sendInitialValues;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TransferSubscriptionsRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TransferSubscriptionsRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TransferSubscriptionsRequest& other_value);
void copy_template(const TransferSubscriptionsRequest_template& other_value);

public:
TransferSubscriptionsRequest_template();
TransferSubscriptionsRequest_template(template_sel other_value);
TransferSubscriptionsRequest_template(const TransferSubscriptionsRequest& other_value);
TransferSubscriptionsRequest_template(const OPTIONAL<TransferSubscriptionsRequest>& other_value);
TransferSubscriptionsRequest_template(const TransferSubscriptionsRequest_template& other_value);
~TransferSubscriptionsRequest_template();
TransferSubscriptionsRequest_template& operator=(template_sel other_value);
TransferSubscriptionsRequest_template& operator=(const TransferSubscriptionsRequest& other_value);
TransferSubscriptionsRequest_template& operator=(const OPTIONAL<TransferSubscriptionsRequest>& other_value);
TransferSubscriptionsRequest_template& operator=(const TransferSubscriptionsRequest_template& other_value);
boolean match(const TransferSubscriptionsRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TransferSubscriptionsRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TransferSubscriptionsRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfIntegerId_template& subscriptionIds();
const ListOfIntegerId_template& subscriptionIds() const;
INTEGER_template& sendInitialValues();
const INTEGER_template& sendInitialValues() const;
int size_of() const;
void log() const;
void log_match(const TransferSubscriptionsRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class TransferSubscriptionsResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfTransferResult field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  TransferSubscriptionsResponse();
  TransferSubscriptionsResponse(const ResponseHeader& par_responseHeader,
    const ListOfTransferResult& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  TransferSubscriptionsResponse(const TransferSubscriptionsResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  TransferSubscriptionsResponse& operator=(const TransferSubscriptionsResponse& other_value);
  boolean operator==(const TransferSubscriptionsResponse& other_value) const;
  inline boolean operator!=(const TransferSubscriptionsResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfTransferResult& results()
    {return field_results;}
  inline const ListOfTransferResult& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class TransferSubscriptionsResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
TransferSubscriptionsResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const TransferSubscriptionsResponse& other_value);
void copy_template(const TransferSubscriptionsResponse_template& other_value);

public:
TransferSubscriptionsResponse_template();
TransferSubscriptionsResponse_template(template_sel other_value);
TransferSubscriptionsResponse_template(const TransferSubscriptionsResponse& other_value);
TransferSubscriptionsResponse_template(const OPTIONAL<TransferSubscriptionsResponse>& other_value);
TransferSubscriptionsResponse_template(const TransferSubscriptionsResponse_template& other_value);
~TransferSubscriptionsResponse_template();
TransferSubscriptionsResponse_template& operator=(template_sel other_value);
TransferSubscriptionsResponse_template& operator=(const TransferSubscriptionsResponse& other_value);
TransferSubscriptionsResponse_template& operator=(const OPTIONAL<TransferSubscriptionsResponse>& other_value);
TransferSubscriptionsResponse_template& operator=(const TransferSubscriptionsResponse_template& other_value);
boolean match(const TransferSubscriptionsResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
TransferSubscriptionsResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
TransferSubscriptionsResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfTransferResult_template& results();
const ListOfTransferResult_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const TransferSubscriptionsResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteSubscriptionsRequest : public Base_Type {
  RequestHeader field_requestHeader;
  ListOfIntegerId field_subscriptionIds;
public:
  DeleteSubscriptionsRequest();
  DeleteSubscriptionsRequest(const RequestHeader& par_requestHeader,
    const ListOfIntegerId& par_subscriptionIds);
  DeleteSubscriptionsRequest(const DeleteSubscriptionsRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteSubscriptionsRequest& operator=(const DeleteSubscriptionsRequest& other_value);
  boolean operator==(const DeleteSubscriptionsRequest& other_value) const;
  inline boolean operator!=(const DeleteSubscriptionsRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline RequestHeader& requestHeader()
    {return field_requestHeader;}
  inline const RequestHeader& requestHeader() const
    {return field_requestHeader;}
  inline ListOfIntegerId& subscriptionIds()
    {return field_subscriptionIds;}
  inline const ListOfIntegerId& subscriptionIds() const
    {return field_subscriptionIds;}
  inline int size_of() const
    {return 2;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteSubscriptionsRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteSubscriptionsRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteSubscriptionsRequest& other_value);
void copy_template(const DeleteSubscriptionsRequest_template& other_value);

public:
DeleteSubscriptionsRequest_template();
DeleteSubscriptionsRequest_template(template_sel other_value);
DeleteSubscriptionsRequest_template(const DeleteSubscriptionsRequest& other_value);
DeleteSubscriptionsRequest_template(const OPTIONAL<DeleteSubscriptionsRequest>& other_value);
DeleteSubscriptionsRequest_template(const DeleteSubscriptionsRequest_template& other_value);
~DeleteSubscriptionsRequest_template();
DeleteSubscriptionsRequest_template& operator=(template_sel other_value);
DeleteSubscriptionsRequest_template& operator=(const DeleteSubscriptionsRequest& other_value);
DeleteSubscriptionsRequest_template& operator=(const OPTIONAL<DeleteSubscriptionsRequest>& other_value);
DeleteSubscriptionsRequest_template& operator=(const DeleteSubscriptionsRequest_template& other_value);
boolean match(const DeleteSubscriptionsRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteSubscriptionsRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteSubscriptionsRequest_template& list_item(unsigned int list_index) const;
RequestHeader_template& requestHeader();
const RequestHeader_template& requestHeader() const;
ListOfIntegerId_template& subscriptionIds();
const ListOfIntegerId_template& subscriptionIds() const;
int size_of() const;
void log() const;
void log_match(const DeleteSubscriptionsRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class DeleteSubscriptionsResponse : public Base_Type {
  ResponseHeader field_responseHeader;
  ListOfStatusCode field_results;
  ListOfDiagnosticInfo field_diagnosticInfos;
public:
  DeleteSubscriptionsResponse();
  DeleteSubscriptionsResponse(const ResponseHeader& par_responseHeader,
    const ListOfStatusCode& par_results,
    const ListOfDiagnosticInfo& par_diagnosticInfos);
  DeleteSubscriptionsResponse(const DeleteSubscriptionsResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  DeleteSubscriptionsResponse& operator=(const DeleteSubscriptionsResponse& other_value);
  boolean operator==(const DeleteSubscriptionsResponse& other_value) const;
  inline boolean operator!=(const DeleteSubscriptionsResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ResponseHeader& responseHeader()
    {return field_responseHeader;}
  inline const ResponseHeader& responseHeader() const
    {return field_responseHeader;}
  inline ListOfStatusCode& results()
    {return field_results;}
  inline const ListOfStatusCode& results() const
    {return field_results;}
  inline ListOfDiagnosticInfo& diagnosticInfos()
    {return field_diagnosticInfos;}
  inline const ListOfDiagnosticInfo& diagnosticInfos() const
    {return field_diagnosticInfos;}
  inline int size_of() const
    {return 3;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class DeleteSubscriptionsResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
DeleteSubscriptionsResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const DeleteSubscriptionsResponse& other_value);
void copy_template(const DeleteSubscriptionsResponse_template& other_value);

public:
DeleteSubscriptionsResponse_template();
DeleteSubscriptionsResponse_template(template_sel other_value);
DeleteSubscriptionsResponse_template(const DeleteSubscriptionsResponse& other_value);
DeleteSubscriptionsResponse_template(const OPTIONAL<DeleteSubscriptionsResponse>& other_value);
DeleteSubscriptionsResponse_template(const DeleteSubscriptionsResponse_template& other_value);
~DeleteSubscriptionsResponse_template();
DeleteSubscriptionsResponse_template& operator=(template_sel other_value);
DeleteSubscriptionsResponse_template& operator=(const DeleteSubscriptionsResponse& other_value);
DeleteSubscriptionsResponse_template& operator=(const OPTIONAL<DeleteSubscriptionsResponse>& other_value);
DeleteSubscriptionsResponse_template& operator=(const DeleteSubscriptionsResponse_template& other_value);
boolean match(const DeleteSubscriptionsResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
DeleteSubscriptionsResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
DeleteSubscriptionsResponse_template& list_item(unsigned int list_index) const;
ResponseHeader_template& responseHeader();
const ResponseHeader_template& responseHeader() const;
ListOfStatusCode_template& results();
const ListOfStatusCode_template& results() const;
ListOfDiagnosticInfo_template& diagnosticInfos();
const ListOfDiagnosticInfo_template& diagnosticInfos() const;
int size_of() const;
void log() const;
void log_match(const DeleteSubscriptionsResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SessionlessServices : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_SessionlessInvokeResponse = 1, ALT_readRequest = 2, ALT_readResponse = 3, ALT_writeRequest = 4, ALT_writeResponse = 5, ALT_callRequest = 6, ALT_callResponse = 7 };
private:
union_selection_type union_selection;
union {
OpcUa__Types__Binary::SessionlessInvokeResponse *field_SessionlessInvokeResponse;
ReadRequest *field_readRequest;
ReadResponse *field_readResponse;
WriteRequest *field_writeRequest;
WriteResponse *field_writeResponse;
CallRequest *field_callRequest;
CallResponse *field_callResponse;
};
void copy_value(const SessionlessServices& other_value);

public:
SessionlessServices();
SessionlessServices(const SessionlessServices& other_value);
~SessionlessServices();
SessionlessServices& operator=(const SessionlessServices& other_value);
boolean operator==(const SessionlessServices& other_value) const;
inline boolean operator!=(const SessionlessServices& other_value) const { return !(*this == other_value); }
OpcUa__Types__Binary::SessionlessInvokeResponse& SessionlessInvokeResponse();
const OpcUa__Types__Binary::SessionlessInvokeResponse& SessionlessInvokeResponse() const;
ReadRequest& readRequest();
const ReadRequest& readRequest() const;
ReadResponse& readResponse();
const ReadResponse& readResponse() const;
WriteRequest& writeRequest();
const WriteRequest& writeRequest() const;
WriteResponse& writeResponse();
const WriteResponse& writeResponse() const;
CallRequest& callRequest();
const CallRequest& callRequest() const;
CallResponse& callResponse();
const CallResponse& callResponse() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SessionlessServices_template : public Base_Template {
union {
struct {
SessionlessServices::union_selection_type union_selection;
union {
OpcUa__Types__Binary::SessionlessInvokeResponse_template *field_SessionlessInvokeResponse;
ReadRequest_template *field_readRequest;
ReadResponse_template *field_readResponse;
WriteRequest_template *field_writeRequest;
WriteResponse_template *field_writeResponse;
CallRequest_template *field_callRequest;
CallResponse_template *field_callResponse;
};
} single_value;
struct {
unsigned int n_values;
SessionlessServices_template *list_value;
} value_list;
};
void copy_value(const SessionlessServices& other_value);

void copy_template(const SessionlessServices_template& other_value);

public:
SessionlessServices_template();
SessionlessServices_template(template_sel other_value);
SessionlessServices_template(const SessionlessServices& other_value);
SessionlessServices_template(const OPTIONAL<SessionlessServices>& other_value);
SessionlessServices_template(const SessionlessServices_template& other_value);
~SessionlessServices_template();
void clean_up();
SessionlessServices_template& operator=(template_sel other_value);
SessionlessServices_template& operator=(const SessionlessServices& other_value);
SessionlessServices_template& operator=(const OPTIONAL<SessionlessServices>& other_value);
SessionlessServices_template& operator=(const SessionlessServices_template& other_value);
boolean match(const SessionlessServices& other_value, boolean legacy = FALSE) const;
boolean is_value() const;SessionlessServices valueof() const;
SessionlessServices_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
OpcUa__Types__Binary::SessionlessInvokeResponse_template& SessionlessInvokeResponse();
const OpcUa__Types__Binary::SessionlessInvokeResponse_template& SessionlessInvokeResponse() const;
ReadRequest_template& readRequest();
const ReadRequest_template& readRequest() const;
ReadResponse_template& readResponse();
const ReadResponse_template& readResponse() const;
WriteRequest_template& writeRequest();
const WriteRequest_template& writeRequest() const;
WriteResponse_template& writeResponse();
const WriteResponse_template& writeResponse() const;
CallRequest_template& callRequest();
const CallRequest_template& callRequest() const;
CallResponse_template& callResponse();
const CallResponse_template& callResponse() const;
boolean ischosen(SessionlessServices::union_selection_type checked_selection) const;
void log() const;
void log_match(const SessionlessServices& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class SessionlessInvokeResponse : public Base_Type {
  ListOfString field_namespaceUris;
  ListOfString field_serverUris;
  INTEGER field_serviceId;
  SessionlessServices field_body;
public:
  SessionlessInvokeResponse();
  SessionlessInvokeResponse(const ListOfString& par_namespaceUris,
    const ListOfString& par_serverUris,
    const INTEGER& par_serviceId,
    const SessionlessServices& par_body);
  SessionlessInvokeResponse(const SessionlessInvokeResponse& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SessionlessInvokeResponse& operator=(const SessionlessInvokeResponse& other_value);
  boolean operator==(const SessionlessInvokeResponse& other_value) const;
  inline boolean operator!=(const SessionlessInvokeResponse& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline ListOfString& namespaceUris()
    {return field_namespaceUris;}
  inline const ListOfString& namespaceUris() const
    {return field_namespaceUris;}
  inline ListOfString& serverUris()
    {return field_serverUris;}
  inline const ListOfString& serverUris() const
    {return field_serverUris;}
  inline INTEGER& serviceId()
    {return field_serviceId;}
  inline const INTEGER& serviceId() const
    {return field_serviceId;}
  inline SessionlessServices& body()
    {return field_body;}
  inline const SessionlessServices& body() const
    {return field_body;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class SessionlessInvokeResponse_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SessionlessInvokeResponse_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SessionlessInvokeResponse& other_value);
void copy_template(const SessionlessInvokeResponse_template& other_value);

public:
SessionlessInvokeResponse_template();
SessionlessInvokeResponse_template(template_sel other_value);
SessionlessInvokeResponse_template(const SessionlessInvokeResponse& other_value);
SessionlessInvokeResponse_template(const OPTIONAL<SessionlessInvokeResponse>& other_value);
SessionlessInvokeResponse_template(const SessionlessInvokeResponse_template& other_value);
~SessionlessInvokeResponse_template();
SessionlessInvokeResponse_template& operator=(template_sel other_value);
SessionlessInvokeResponse_template& operator=(const SessionlessInvokeResponse& other_value);
SessionlessInvokeResponse_template& operator=(const OPTIONAL<SessionlessInvokeResponse>& other_value);
SessionlessInvokeResponse_template& operator=(const SessionlessInvokeResponse_template& other_value);
boolean match(const SessionlessInvokeResponse& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SessionlessInvokeResponse valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SessionlessInvokeResponse_template& list_item(unsigned int list_index) const;
ListOfString_template& namespaceUris();
const ListOfString_template& namespaceUris() const;
ListOfString_template& serverUris();
const ListOfString_template& serverUris() const;
INTEGER_template& serviceId();
const INTEGER_template& serviceId() const;
SessionlessServices_template& body();
const SessionlessServices_template& body() const;
int size_of() const;
void log() const;
void log_match(const SessionlessInvokeResponse& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class SessionlessInvokeRequest {
  INTEGER field_urisVersion;
  ListOfString field_namespaceUris;
  ListOfString field_serverUris;
  ListOfLocaleId field_localeIds;
  INTEGER field_serviceId;
  SessionlessServices field_body;
public:
  SessionlessInvokeRequest();
  SessionlessInvokeRequest(const INTEGER& par_urisVersion,
    const ListOfString& par_namespaceUris,
    const ListOfString& par_serverUris,
    const ListOfLocaleId& par_localeIds,
    const INTEGER& par_serviceId,
    const SessionlessServices& par_body);
  SessionlessInvokeRequest(const SessionlessInvokeRequest& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  SessionlessInvokeRequest& operator=(const SessionlessInvokeRequest& other_value);
  boolean operator==(const SessionlessInvokeRequest& other_value) const;
  inline boolean operator!=(const SessionlessInvokeRequest& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& urisVersion()
    {return field_urisVersion;}
  inline const INTEGER& urisVersion() const
    {return field_urisVersion;}
  inline ListOfString& namespaceUris()
    {return field_namespaceUris;}
  inline const ListOfString& namespaceUris() const
    {return field_namespaceUris;}
  inline ListOfString& serverUris()
    {return field_serverUris;}
  inline const ListOfString& serverUris() const
    {return field_serverUris;}
  inline ListOfLocaleId& localeIds()
    {return field_localeIds;}
  inline const ListOfLocaleId& localeIds() const
    {return field_localeIds;}
  inline INTEGER& serviceId()
    {return field_serviceId;}
  inline const INTEGER& serviceId() const
    {return field_serviceId;}
  inline SessionlessServices& body()
    {return field_body;}
  inline const SessionlessServices& body() const
    {return field_body;}
  inline int size_of() const
    {return 6;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
};

class SessionlessInvokeRequest_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
SessionlessInvokeRequest_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const SessionlessInvokeRequest& other_value);
void copy_template(const SessionlessInvokeRequest_template& other_value);

public:
SessionlessInvokeRequest_template();
SessionlessInvokeRequest_template(template_sel other_value);
SessionlessInvokeRequest_template(const SessionlessInvokeRequest& other_value);
SessionlessInvokeRequest_template(const OPTIONAL<SessionlessInvokeRequest>& other_value);
SessionlessInvokeRequest_template(const SessionlessInvokeRequest_template& other_value);
~SessionlessInvokeRequest_template();
SessionlessInvokeRequest_template& operator=(template_sel other_value);
SessionlessInvokeRequest_template& operator=(const SessionlessInvokeRequest& other_value);
SessionlessInvokeRequest_template& operator=(const OPTIONAL<SessionlessInvokeRequest>& other_value);
SessionlessInvokeRequest_template& operator=(const SessionlessInvokeRequest_template& other_value);
boolean match(const SessionlessInvokeRequest& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
SessionlessInvokeRequest valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
SessionlessInvokeRequest_template& list_item(unsigned int list_index) const;
INTEGER_template& urisVersion();
const INTEGER_template& urisVersion() const;
ListOfString_template& namespaceUris();
const ListOfString_template& namespaceUris() const;
ListOfString_template& serverUris();
const ListOfString_template& serverUris() const;
ListOfLocaleId_template& localeIds();
const ListOfLocaleId_template& localeIds() const;
INTEGER_template& serviceId();
const INTEGER_template& serviceId() const;
SessionlessServices_template& body();
const SessionlessServices_template& body() const;
int size_of() const;
void log() const;
void log_match(const SessionlessInvokeRequest& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ServiceList : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_FindServiceRequest = 1, ALT_FindServiceResponse = 2, ALT_FindServersOnNetworkRequest = 3, ALT_FindServersOnNetworkResponse = 4, ALT_GetEndpointsRequest = 5, ALT_GetEndpointsResponse = 6, ALT_RegisterServerRequest = 7, ALT_RegisterServerResponse = 8, ALT_RegisterServer2Request = 9, ALT_RegisterServer2Response = 10, ALT_OpenSecureChannelRequest = 11, ALT_OpenSecureChannelResponse = 12, ALT_CloseSecureChannelRequest = 13, ALT_CloseSecureChannelResponse = 14, ALT_CreateSessionRequest = 15, ALT_CreateSessionResponse = 16, ALT_ActivateSessionRequest = 17, ALT_ActivateSessionResponse = 18, ALT_CloseSessionRequest = 19, ALT_CloseSessionResponse = 20, ALT_CancelRequestRequest = 21, ALT_CancelRequestResponse = 22, ALT_AddNodesRequest = 23, ALT_AddNodesResponse = 24, ALT_AddReferencesRequest = 25, ALT_AddReferencesResponse = 26, ALT_DeleteNodesRequest = 27, ALT_DeleteNodesResponse = 28, ALT_DeleteReferencesRequest = 29, ALT_DeleteReferencesResponse = 30, ALT_BrowseRequest = 31, ALT_BrowseResponse = 32, ALT_BrowseNextRequest = 33, ALT_BrowseNextResponse = 34, ALT_TranslateBrowsePathsToNodeIdsRequest = 35, ALT_TranslateBrowsePathsToNodeIdsResponse = 36, ALT_RegisterNodesRequest = 37, ALT_RegisterNodesResponse = 38, ALT_UnregisterNodesRequest = 39, ALT_UnregisterNodesResponse = 40, ALT_QueryFirstRequest = 41, ALT_QueryFirstResponse = 42, ALT_QueryNextRequest = 43, ALT_QueryNextResponse = 44, ALT_ReadRequest = 45, ALT_ReadResponse = 46, ALT_HistoryReadRequest = 47, ALT_HistoryReadResponse = 48, ALT_WriteRequest = 49, ALT_WriteResponse = 50, ALT_HistoryUpdateRequest = 51, ALT_HistoryUpdateResponse = 52, ALT_CallRequest = 53, ALT_CallResponse = 54, ALT_CreateMonitoredItemsRequest = 55, ALT_CreateMonitoredItemsResponse = 56, ALT_ModifyMonitoredItemsRequest = 57, ALT_ModifyMonitoredItemsResponse = 58, ALT_SetMonitoringModeRequest = 59, ALT_SetMonitoringModeResponse = 60, ALT_SetTriggeringRequest = 61, ALT_SetTriggeringResponse = 62, ALT_DeleteMonitoredItemsRequest = 63, ALT_DeleteMonitoredItemsResponse = 64, ALT_CreateSubscriptionRequest = 65, ALT_CreateSubscriptionResponse = 66, ALT_ModifySubscriptionRequest = 67, ALT_ModifySubscriptionResponse = 68, ALT_SetPublishingModeRequest = 69, ALT_SetPublishingModeResponse = 70, ALT_PublishRequest = 71, ALT_PublishResponse = 72, ALT_RepublishRequest = 73, ALT_RepublishResponse = 74, ALT_TransferSubscriptionsRequest = 75, ALT_TransferSubscriptionsResponse = 76, ALT_DeleteSubscriptionsRequest = 77, ALT_DeleteSubscriptionsResponse = 78 };
private:
union_selection_type union_selection;
union {
OpcUa__Types__Binary::FindServiceRequest *field_FindServiceRequest;
OpcUa__Types__Binary::FindServiceResponse *field_FindServiceResponse;
OpcUa__Types__Binary::FindServersOnNetworkRequest *field_FindServersOnNetworkRequest;
OpcUa__Types__Binary::FindServersOnNetworkResponse *field_FindServersOnNetworkResponse;
OpcUa__Types__Binary::GetEndpointsRequest *field_GetEndpointsRequest;
OpcUa__Types__Binary::GetEndpointsResponse *field_GetEndpointsResponse;
OpcUa__Types__Binary::RegisterServerRequest *field_RegisterServerRequest;
OpcUa__Types__Binary::RegisterServerResponse *field_RegisterServerResponse;
OpcUa__Types__Binary::RegisterServer2Request *field_RegisterServer2Request;
OpcUa__Types__Binary::RegisterServer2Response *field_RegisterServer2Response;
OpcUa__Types__Binary::OpenSecureChannelRequest *field_OpenSecureChannelRequest;
OpcUa__Types__Binary::OpenSecureChannelResponse *field_OpenSecureChannelResponse;
OpcUa__Types__Binary::CloseSecureChannelRequest *field_CloseSecureChannelRequest;
OpcUa__Types__Binary::CloseSecureChannelResponse *field_CloseSecureChannelResponse;
OpcUa__Types__Binary::CreateSessionRequest *field_CreateSessionRequest;
OpcUa__Types__Binary::CreateSessionResponse *field_CreateSessionResponse;
OpcUa__Types__Binary::ActivateSessionRequest *field_ActivateSessionRequest;
OpcUa__Types__Binary::ActivateSessionResponse *field_ActivateSessionResponse;
OpcUa__Types__Binary::CloseSessionRequest *field_CloseSessionRequest;
OpcUa__Types__Binary::CloseSessionResponse *field_CloseSessionResponse;
OpcUa__Types__Binary::CancelRequestRequest *field_CancelRequestRequest;
OpcUa__Types__Binary::CancelRequestResponse *field_CancelRequestResponse;
OpcUa__Types__Binary::AddNodesRequest *field_AddNodesRequest;
OpcUa__Types__Binary::AddNodesResponse *field_AddNodesResponse;
OpcUa__Types__Binary::AddReferencesRequest *field_AddReferencesRequest;
OpcUa__Types__Binary::AddReferencesResponse *field_AddReferencesResponse;
OpcUa__Types__Binary::DeleteNodesRequest *field_DeleteNodesRequest;
OpcUa__Types__Binary::DeleteNodesResponse *field_DeleteNodesResponse;
OpcUa__Types__Binary::DeleteReferencesRequest *field_DeleteReferencesRequest;
OpcUa__Types__Binary::DeleteReferencesResponse *field_DeleteReferencesResponse;
OpcUa__Types__Binary::BrowseRequest *field_BrowseRequest;
OpcUa__Types__Binary::BrowseResponse *field_BrowseResponse;
OpcUa__Types__Binary::BrowseNextRequest *field_BrowseNextRequest;
OpcUa__Types__Binary::BrowseNextResponse *field_BrowseNextResponse;
OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsRequest *field_TranslateBrowsePathsToNodeIdsRequest;
OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsResponse *field_TranslateBrowsePathsToNodeIdsResponse;
OpcUa__Types__Binary::RegisterNodesRequest *field_RegisterNodesRequest;
OpcUa__Types__Binary::RegisterNodesResponse *field_RegisterNodesResponse;
OpcUa__Types__Binary::UnregisterNodesRequest *field_UnregisterNodesRequest;
OpcUa__Types__Binary::UnregisterNodesResponse *field_UnregisterNodesResponse;
OpcUa__Types__Binary::QueryFirstRequest *field_QueryFirstRequest;
OpcUa__Types__Binary::QueryFirstResponse *field_QueryFirstResponse;
OpcUa__Types__Binary::QueryNextRequest *field_QueryNextRequest;
OpcUa__Types__Binary::QueryNextResponse *field_QueryNextResponse;
OpcUa__Types__Binary::ReadRequest *field_ReadRequest;
OpcUa__Types__Binary::ReadResponse *field_ReadResponse;
OpcUa__Types__Binary::HistoryReadRequest *field_HistoryReadRequest;
OpcUa__Types__Binary::HistoryReadResponse *field_HistoryReadResponse;
OpcUa__Types__Binary::WriteRequest *field_WriteRequest;
OpcUa__Types__Binary::WriteResponse *field_WriteResponse;
OpcUa__Types__Binary::HistoryUpdateRequest *field_HistoryUpdateRequest;
OpcUa__Types__Binary::HistoryUpdateResponse *field_HistoryUpdateResponse;
OpcUa__Types__Binary::CallRequest *field_CallRequest;
OpcUa__Types__Binary::CallResponse *field_CallResponse;
OpcUa__Types__Binary::CreateMonitoredItemsRequest *field_CreateMonitoredItemsRequest;
OpcUa__Types__Binary::CreateMonitoredItemsResponse *field_CreateMonitoredItemsResponse;
OpcUa__Types__Binary::ModifyMonitoredItemsRequest *field_ModifyMonitoredItemsRequest;
OpcUa__Types__Binary::ModifyMonitoredItemsResponse *field_ModifyMonitoredItemsResponse;
OpcUa__Types__Binary::SetMonitoringModeRequest *field_SetMonitoringModeRequest;
OpcUa__Types__Binary::SetMonitoringModeResponse *field_SetMonitoringModeResponse;
OpcUa__Types__Binary::SetTriggeringRequest *field_SetTriggeringRequest;
OpcUa__Types__Binary::SetTriggeringResponse *field_SetTriggeringResponse;
OpcUa__Types__Binary::DeleteMonitoredItemsRequest *field_DeleteMonitoredItemsRequest;
OpcUa__Types__Binary::DeleteMonitoredItemsResponse *field_DeleteMonitoredItemsResponse;
OpcUa__Types__Binary::CreateSubscriptionRequest *field_CreateSubscriptionRequest;
OpcUa__Types__Binary::CreateSubscriptionResponse *field_CreateSubscriptionResponse;
OpcUa__Types__Binary::ModifySubscriptionRequest *field_ModifySubscriptionRequest;
OpcUa__Types__Binary::ModifySubscriptionResponse *field_ModifySubscriptionResponse;
OpcUa__Types__Binary::SetPublishingModeRequest *field_SetPublishingModeRequest;
OpcUa__Types__Binary::SetPublishingModeResponse *field_SetPublishingModeResponse;
OpcUa__Types__Binary::PublishRequest *field_PublishRequest;
OpcUa__Types__Binary::PublishResponse *field_PublishResponse;
OpcUa__Types__Binary::RepublishRequest *field_RepublishRequest;
OpcUa__Types__Binary::RepublishResponse *field_RepublishResponse;
OpcUa__Types__Binary::TransferSubscriptionsRequest *field_TransferSubscriptionsRequest;
OpcUa__Types__Binary::TransferSubscriptionsResponse *field_TransferSubscriptionsResponse;
OpcUa__Types__Binary::DeleteSubscriptionsRequest *field_DeleteSubscriptionsRequest;
OpcUa__Types__Binary::DeleteSubscriptionsResponse *field_DeleteSubscriptionsResponse;
};
void copy_value(const ServiceList& other_value);

public:
ServiceList();
ServiceList(const ServiceList& other_value);
~ServiceList();
ServiceList& operator=(const ServiceList& other_value);
boolean operator==(const ServiceList& other_value) const;
inline boolean operator!=(const ServiceList& other_value) const { return !(*this == other_value); }
OpcUa__Types__Binary::FindServiceRequest& FindServiceRequest();
const OpcUa__Types__Binary::FindServiceRequest& FindServiceRequest() const;
OpcUa__Types__Binary::FindServiceResponse& FindServiceResponse();
const OpcUa__Types__Binary::FindServiceResponse& FindServiceResponse() const;
OpcUa__Types__Binary::FindServersOnNetworkRequest& FindServersOnNetworkRequest();
const OpcUa__Types__Binary::FindServersOnNetworkRequest& FindServersOnNetworkRequest() const;
OpcUa__Types__Binary::FindServersOnNetworkResponse& FindServersOnNetworkResponse();
const OpcUa__Types__Binary::FindServersOnNetworkResponse& FindServersOnNetworkResponse() const;
OpcUa__Types__Binary::GetEndpointsRequest& GetEndpointsRequest();
const OpcUa__Types__Binary::GetEndpointsRequest& GetEndpointsRequest() const;
OpcUa__Types__Binary::GetEndpointsResponse& GetEndpointsResponse();
const OpcUa__Types__Binary::GetEndpointsResponse& GetEndpointsResponse() const;
OpcUa__Types__Binary::RegisterServerRequest& RegisterServerRequest();
const OpcUa__Types__Binary::RegisterServerRequest& RegisterServerRequest() const;
OpcUa__Types__Binary::RegisterServerResponse& RegisterServerResponse();
const OpcUa__Types__Binary::RegisterServerResponse& RegisterServerResponse() const;
OpcUa__Types__Binary::RegisterServer2Request& RegisterServer2Request();
const OpcUa__Types__Binary::RegisterServer2Request& RegisterServer2Request() const;
OpcUa__Types__Binary::RegisterServer2Response& RegisterServer2Response();
const OpcUa__Types__Binary::RegisterServer2Response& RegisterServer2Response() const;
OpcUa__Types__Binary::OpenSecureChannelRequest& OpenSecureChannelRequest();
const OpcUa__Types__Binary::OpenSecureChannelRequest& OpenSecureChannelRequest() const;
OpcUa__Types__Binary::OpenSecureChannelResponse& OpenSecureChannelResponse();
const OpcUa__Types__Binary::OpenSecureChannelResponse& OpenSecureChannelResponse() const;
OpcUa__Types__Binary::CloseSecureChannelRequest& CloseSecureChannelRequest();
const OpcUa__Types__Binary::CloseSecureChannelRequest& CloseSecureChannelRequest() const;
OpcUa__Types__Binary::CloseSecureChannelResponse& CloseSecureChannelResponse();
const OpcUa__Types__Binary::CloseSecureChannelResponse& CloseSecureChannelResponse() const;
OpcUa__Types__Binary::CreateSessionRequest& CreateSessionRequest();
const OpcUa__Types__Binary::CreateSessionRequest& CreateSessionRequest() const;
OpcUa__Types__Binary::CreateSessionResponse& CreateSessionResponse();
const OpcUa__Types__Binary::CreateSessionResponse& CreateSessionResponse() const;
OpcUa__Types__Binary::ActivateSessionRequest& ActivateSessionRequest();
const OpcUa__Types__Binary::ActivateSessionRequest& ActivateSessionRequest() const;
OpcUa__Types__Binary::ActivateSessionResponse& ActivateSessionResponse();
const OpcUa__Types__Binary::ActivateSessionResponse& ActivateSessionResponse() const;
OpcUa__Types__Binary::CloseSessionRequest& CloseSessionRequest();
const OpcUa__Types__Binary::CloseSessionRequest& CloseSessionRequest() const;
OpcUa__Types__Binary::CloseSessionResponse& CloseSessionResponse();
const OpcUa__Types__Binary::CloseSessionResponse& CloseSessionResponse() const;
OpcUa__Types__Binary::CancelRequestRequest& CancelRequestRequest();
const OpcUa__Types__Binary::CancelRequestRequest& CancelRequestRequest() const;
OpcUa__Types__Binary::CancelRequestResponse& CancelRequestResponse();
const OpcUa__Types__Binary::CancelRequestResponse& CancelRequestResponse() const;
OpcUa__Types__Binary::AddNodesRequest& AddNodesRequest();
const OpcUa__Types__Binary::AddNodesRequest& AddNodesRequest() const;
OpcUa__Types__Binary::AddNodesResponse& AddNodesResponse();
const OpcUa__Types__Binary::AddNodesResponse& AddNodesResponse() const;
OpcUa__Types__Binary::AddReferencesRequest& AddReferencesRequest();
const OpcUa__Types__Binary::AddReferencesRequest& AddReferencesRequest() const;
OpcUa__Types__Binary::AddReferencesResponse& AddReferencesResponse();
const OpcUa__Types__Binary::AddReferencesResponse& AddReferencesResponse() const;
OpcUa__Types__Binary::DeleteNodesRequest& DeleteNodesRequest();
const OpcUa__Types__Binary::DeleteNodesRequest& DeleteNodesRequest() const;
OpcUa__Types__Binary::DeleteNodesResponse& DeleteNodesResponse();
const OpcUa__Types__Binary::DeleteNodesResponse& DeleteNodesResponse() const;
OpcUa__Types__Binary::DeleteReferencesRequest& DeleteReferencesRequest();
const OpcUa__Types__Binary::DeleteReferencesRequest& DeleteReferencesRequest() const;
OpcUa__Types__Binary::DeleteReferencesResponse& DeleteReferencesResponse();
const OpcUa__Types__Binary::DeleteReferencesResponse& DeleteReferencesResponse() const;
OpcUa__Types__Binary::BrowseRequest& BrowseRequest();
const OpcUa__Types__Binary::BrowseRequest& BrowseRequest() const;
OpcUa__Types__Binary::BrowseResponse& BrowseResponse();
const OpcUa__Types__Binary::BrowseResponse& BrowseResponse() const;
OpcUa__Types__Binary::BrowseNextRequest& BrowseNextRequest();
const OpcUa__Types__Binary::BrowseNextRequest& BrowseNextRequest() const;
OpcUa__Types__Binary::BrowseNextResponse& BrowseNextResponse();
const OpcUa__Types__Binary::BrowseNextResponse& BrowseNextResponse() const;
OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsRequest& TranslateBrowsePathsToNodeIdsRequest();
const OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsRequest& TranslateBrowsePathsToNodeIdsRequest() const;
OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsResponse& TranslateBrowsePathsToNodeIdsResponse();
const OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsResponse& TranslateBrowsePathsToNodeIdsResponse() const;
OpcUa__Types__Binary::RegisterNodesRequest& RegisterNodesRequest();
const OpcUa__Types__Binary::RegisterNodesRequest& RegisterNodesRequest() const;
OpcUa__Types__Binary::RegisterNodesResponse& RegisterNodesResponse();
const OpcUa__Types__Binary::RegisterNodesResponse& RegisterNodesResponse() const;
OpcUa__Types__Binary::UnregisterNodesRequest& UnregisterNodesRequest();
const OpcUa__Types__Binary::UnregisterNodesRequest& UnregisterNodesRequest() const;
OpcUa__Types__Binary::UnregisterNodesResponse& UnregisterNodesResponse();
const OpcUa__Types__Binary::UnregisterNodesResponse& UnregisterNodesResponse() const;
OpcUa__Types__Binary::QueryFirstRequest& QueryFirstRequest();
const OpcUa__Types__Binary::QueryFirstRequest& QueryFirstRequest() const;
OpcUa__Types__Binary::QueryFirstResponse& QueryFirstResponse();
const OpcUa__Types__Binary::QueryFirstResponse& QueryFirstResponse() const;
OpcUa__Types__Binary::QueryNextRequest& QueryNextRequest();
const OpcUa__Types__Binary::QueryNextRequest& QueryNextRequest() const;
OpcUa__Types__Binary::QueryNextResponse& QueryNextResponse();
const OpcUa__Types__Binary::QueryNextResponse& QueryNextResponse() const;
OpcUa__Types__Binary::ReadRequest& ReadRequest();
const OpcUa__Types__Binary::ReadRequest& ReadRequest() const;
OpcUa__Types__Binary::ReadResponse& ReadResponse();
const OpcUa__Types__Binary::ReadResponse& ReadResponse() const;
OpcUa__Types__Binary::HistoryReadRequest& HistoryReadRequest();
const OpcUa__Types__Binary::HistoryReadRequest& HistoryReadRequest() const;
OpcUa__Types__Binary::HistoryReadResponse& HistoryReadResponse();
const OpcUa__Types__Binary::HistoryReadResponse& HistoryReadResponse() const;
OpcUa__Types__Binary::WriteRequest& WriteRequest();
const OpcUa__Types__Binary::WriteRequest& WriteRequest() const;
OpcUa__Types__Binary::WriteResponse& WriteResponse();
const OpcUa__Types__Binary::WriteResponse& WriteResponse() const;
OpcUa__Types__Binary::HistoryUpdateRequest& HistoryUpdateRequest();
const OpcUa__Types__Binary::HistoryUpdateRequest& HistoryUpdateRequest() const;
OpcUa__Types__Binary::HistoryUpdateResponse& HistoryUpdateResponse();
const OpcUa__Types__Binary::HistoryUpdateResponse& HistoryUpdateResponse() const;
OpcUa__Types__Binary::CallRequest& CallRequest();
const OpcUa__Types__Binary::CallRequest& CallRequest() const;
OpcUa__Types__Binary::CallResponse& CallResponse();
const OpcUa__Types__Binary::CallResponse& CallResponse() const;
OpcUa__Types__Binary::CreateMonitoredItemsRequest& CreateMonitoredItemsRequest();
const OpcUa__Types__Binary::CreateMonitoredItemsRequest& CreateMonitoredItemsRequest() const;
OpcUa__Types__Binary::CreateMonitoredItemsResponse& CreateMonitoredItemsResponse();
const OpcUa__Types__Binary::CreateMonitoredItemsResponse& CreateMonitoredItemsResponse() const;
OpcUa__Types__Binary::ModifyMonitoredItemsRequest& ModifyMonitoredItemsRequest();
const OpcUa__Types__Binary::ModifyMonitoredItemsRequest& ModifyMonitoredItemsRequest() const;
OpcUa__Types__Binary::ModifyMonitoredItemsResponse& ModifyMonitoredItemsResponse();
const OpcUa__Types__Binary::ModifyMonitoredItemsResponse& ModifyMonitoredItemsResponse() const;
OpcUa__Types__Binary::SetMonitoringModeRequest& SetMonitoringModeRequest();
const OpcUa__Types__Binary::SetMonitoringModeRequest& SetMonitoringModeRequest() const;
OpcUa__Types__Binary::SetMonitoringModeResponse& SetMonitoringModeResponse();
const OpcUa__Types__Binary::SetMonitoringModeResponse& SetMonitoringModeResponse() const;
OpcUa__Types__Binary::SetTriggeringRequest& SetTriggeringRequest();
const OpcUa__Types__Binary::SetTriggeringRequest& SetTriggeringRequest() const;
OpcUa__Types__Binary::SetTriggeringResponse& SetTriggeringResponse();
const OpcUa__Types__Binary::SetTriggeringResponse& SetTriggeringResponse() const;
OpcUa__Types__Binary::DeleteMonitoredItemsRequest& DeleteMonitoredItemsRequest();
const OpcUa__Types__Binary::DeleteMonitoredItemsRequest& DeleteMonitoredItemsRequest() const;
OpcUa__Types__Binary::DeleteMonitoredItemsResponse& DeleteMonitoredItemsResponse();
const OpcUa__Types__Binary::DeleteMonitoredItemsResponse& DeleteMonitoredItemsResponse() const;
OpcUa__Types__Binary::CreateSubscriptionRequest& CreateSubscriptionRequest();
const OpcUa__Types__Binary::CreateSubscriptionRequest& CreateSubscriptionRequest() const;
OpcUa__Types__Binary::CreateSubscriptionResponse& CreateSubscriptionResponse();
const OpcUa__Types__Binary::CreateSubscriptionResponse& CreateSubscriptionResponse() const;
OpcUa__Types__Binary::ModifySubscriptionRequest& ModifySubscriptionRequest();
const OpcUa__Types__Binary::ModifySubscriptionRequest& ModifySubscriptionRequest() const;
OpcUa__Types__Binary::ModifySubscriptionResponse& ModifySubscriptionResponse();
const OpcUa__Types__Binary::ModifySubscriptionResponse& ModifySubscriptionResponse() const;
OpcUa__Types__Binary::SetPublishingModeRequest& SetPublishingModeRequest();
const OpcUa__Types__Binary::SetPublishingModeRequest& SetPublishingModeRequest() const;
OpcUa__Types__Binary::SetPublishingModeResponse& SetPublishingModeResponse();
const OpcUa__Types__Binary::SetPublishingModeResponse& SetPublishingModeResponse() const;
OpcUa__Types__Binary::PublishRequest& PublishRequest();
const OpcUa__Types__Binary::PublishRequest& PublishRequest() const;
OpcUa__Types__Binary::PublishResponse& PublishResponse();
const OpcUa__Types__Binary::PublishResponse& PublishResponse() const;
OpcUa__Types__Binary::RepublishRequest& RepublishRequest();
const OpcUa__Types__Binary::RepublishRequest& RepublishRequest() const;
OpcUa__Types__Binary::RepublishResponse& RepublishResponse();
const OpcUa__Types__Binary::RepublishResponse& RepublishResponse() const;
OpcUa__Types__Binary::TransferSubscriptionsRequest& TransferSubscriptionsRequest();
const OpcUa__Types__Binary::TransferSubscriptionsRequest& TransferSubscriptionsRequest() const;
OpcUa__Types__Binary::TransferSubscriptionsResponse& TransferSubscriptionsResponse();
const OpcUa__Types__Binary::TransferSubscriptionsResponse& TransferSubscriptionsResponse() const;
OpcUa__Types__Binary::DeleteSubscriptionsRequest& DeleteSubscriptionsRequest();
const OpcUa__Types__Binary::DeleteSubscriptionsRequest& DeleteSubscriptionsRequest() const;
OpcUa__Types__Binary::DeleteSubscriptionsResponse& DeleteSubscriptionsResponse();
const OpcUa__Types__Binary::DeleteSubscriptionsResponse& DeleteSubscriptionsResponse() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ServiceList_template : public Base_Template {
union {
struct {
ServiceList::union_selection_type union_selection;
union {
OpcUa__Types__Binary::FindServiceRequest_template *field_FindServiceRequest;
OpcUa__Types__Binary::FindServiceResponse_template *field_FindServiceResponse;
OpcUa__Types__Binary::FindServersOnNetworkRequest_template *field_FindServersOnNetworkRequest;
OpcUa__Types__Binary::FindServersOnNetworkResponse_template *field_FindServersOnNetworkResponse;
OpcUa__Types__Binary::GetEndpointsRequest_template *field_GetEndpointsRequest;
OpcUa__Types__Binary::GetEndpointsResponse_template *field_GetEndpointsResponse;
OpcUa__Types__Binary::RegisterServerRequest_template *field_RegisterServerRequest;
OpcUa__Types__Binary::RegisterServerResponse_template *field_RegisterServerResponse;
OpcUa__Types__Binary::RegisterServer2Request_template *field_RegisterServer2Request;
OpcUa__Types__Binary::RegisterServer2Response_template *field_RegisterServer2Response;
OpcUa__Types__Binary::OpenSecureChannelRequest_template *field_OpenSecureChannelRequest;
OpcUa__Types__Binary::OpenSecureChannelResponse_template *field_OpenSecureChannelResponse;
OpcUa__Types__Binary::CloseSecureChannelRequest_template *field_CloseSecureChannelRequest;
OpcUa__Types__Binary::CloseSecureChannelResponse_template *field_CloseSecureChannelResponse;
OpcUa__Types__Binary::CreateSessionRequest_template *field_CreateSessionRequest;
OpcUa__Types__Binary::CreateSessionResponse_template *field_CreateSessionResponse;
OpcUa__Types__Binary::ActivateSessionRequest_template *field_ActivateSessionRequest;
OpcUa__Types__Binary::ActivateSessionResponse_template *field_ActivateSessionResponse;
OpcUa__Types__Binary::CloseSessionRequest_template *field_CloseSessionRequest;
OpcUa__Types__Binary::CloseSessionResponse_template *field_CloseSessionResponse;
OpcUa__Types__Binary::CancelRequestRequest_template *field_CancelRequestRequest;
OpcUa__Types__Binary::CancelRequestResponse_template *field_CancelRequestResponse;
OpcUa__Types__Binary::AddNodesRequest_template *field_AddNodesRequest;
OpcUa__Types__Binary::AddNodesResponse_template *field_AddNodesResponse;
OpcUa__Types__Binary::AddReferencesRequest_template *field_AddReferencesRequest;
OpcUa__Types__Binary::AddReferencesResponse_template *field_AddReferencesResponse;
OpcUa__Types__Binary::DeleteNodesRequest_template *field_DeleteNodesRequest;
OpcUa__Types__Binary::DeleteNodesResponse_template *field_DeleteNodesResponse;
OpcUa__Types__Binary::DeleteReferencesRequest_template *field_DeleteReferencesRequest;
OpcUa__Types__Binary::DeleteReferencesResponse_template *field_DeleteReferencesResponse;
OpcUa__Types__Binary::BrowseRequest_template *field_BrowseRequest;
OpcUa__Types__Binary::BrowseResponse_template *field_BrowseResponse;
OpcUa__Types__Binary::BrowseNextRequest_template *field_BrowseNextRequest;
OpcUa__Types__Binary::BrowseNextResponse_template *field_BrowseNextResponse;
OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsRequest_template *field_TranslateBrowsePathsToNodeIdsRequest;
OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsResponse_template *field_TranslateBrowsePathsToNodeIdsResponse;
OpcUa__Types__Binary::RegisterNodesRequest_template *field_RegisterNodesRequest;
OpcUa__Types__Binary::RegisterNodesResponse_template *field_RegisterNodesResponse;
OpcUa__Types__Binary::UnregisterNodesRequest_template *field_UnregisterNodesRequest;
OpcUa__Types__Binary::UnregisterNodesResponse_template *field_UnregisterNodesResponse;
OpcUa__Types__Binary::QueryFirstRequest_template *field_QueryFirstRequest;
OpcUa__Types__Binary::QueryFirstResponse_template *field_QueryFirstResponse;
OpcUa__Types__Binary::QueryNextRequest_template *field_QueryNextRequest;
OpcUa__Types__Binary::QueryNextResponse_template *field_QueryNextResponse;
OpcUa__Types__Binary::ReadRequest_template *field_ReadRequest;
OpcUa__Types__Binary::ReadResponse_template *field_ReadResponse;
OpcUa__Types__Binary::HistoryReadRequest_template *field_HistoryReadRequest;
OpcUa__Types__Binary::HistoryReadResponse_template *field_HistoryReadResponse;
OpcUa__Types__Binary::WriteRequest_template *field_WriteRequest;
OpcUa__Types__Binary::WriteResponse_template *field_WriteResponse;
OpcUa__Types__Binary::HistoryUpdateRequest_template *field_HistoryUpdateRequest;
OpcUa__Types__Binary::HistoryUpdateResponse_template *field_HistoryUpdateResponse;
OpcUa__Types__Binary::CallRequest_template *field_CallRequest;
OpcUa__Types__Binary::CallResponse_template *field_CallResponse;
OpcUa__Types__Binary::CreateMonitoredItemsRequest_template *field_CreateMonitoredItemsRequest;
OpcUa__Types__Binary::CreateMonitoredItemsResponse_template *field_CreateMonitoredItemsResponse;
OpcUa__Types__Binary::ModifyMonitoredItemsRequest_template *field_ModifyMonitoredItemsRequest;
OpcUa__Types__Binary::ModifyMonitoredItemsResponse_template *field_ModifyMonitoredItemsResponse;
OpcUa__Types__Binary::SetMonitoringModeRequest_template *field_SetMonitoringModeRequest;
OpcUa__Types__Binary::SetMonitoringModeResponse_template *field_SetMonitoringModeResponse;
OpcUa__Types__Binary::SetTriggeringRequest_template *field_SetTriggeringRequest;
OpcUa__Types__Binary::SetTriggeringResponse_template *field_SetTriggeringResponse;
OpcUa__Types__Binary::DeleteMonitoredItemsRequest_template *field_DeleteMonitoredItemsRequest;
OpcUa__Types__Binary::DeleteMonitoredItemsResponse_template *field_DeleteMonitoredItemsResponse;
OpcUa__Types__Binary::CreateSubscriptionRequest_template *field_CreateSubscriptionRequest;
OpcUa__Types__Binary::CreateSubscriptionResponse_template *field_CreateSubscriptionResponse;
OpcUa__Types__Binary::ModifySubscriptionRequest_template *field_ModifySubscriptionRequest;
OpcUa__Types__Binary::ModifySubscriptionResponse_template *field_ModifySubscriptionResponse;
OpcUa__Types__Binary::SetPublishingModeRequest_template *field_SetPublishingModeRequest;
OpcUa__Types__Binary::SetPublishingModeResponse_template *field_SetPublishingModeResponse;
OpcUa__Types__Binary::PublishRequest_template *field_PublishRequest;
OpcUa__Types__Binary::PublishResponse_template *field_PublishResponse;
OpcUa__Types__Binary::RepublishRequest_template *field_RepublishRequest;
OpcUa__Types__Binary::RepublishResponse_template *field_RepublishResponse;
OpcUa__Types__Binary::TransferSubscriptionsRequest_template *field_TransferSubscriptionsRequest;
OpcUa__Types__Binary::TransferSubscriptionsResponse_template *field_TransferSubscriptionsResponse;
OpcUa__Types__Binary::DeleteSubscriptionsRequest_template *field_DeleteSubscriptionsRequest;
OpcUa__Types__Binary::DeleteSubscriptionsResponse_template *field_DeleteSubscriptionsResponse;
};
} single_value;
struct {
unsigned int n_values;
ServiceList_template *list_value;
} value_list;
};
void copy_value(const ServiceList& other_value);

void copy_template(const ServiceList_template& other_value);

public:
ServiceList_template();
ServiceList_template(template_sel other_value);
ServiceList_template(const ServiceList& other_value);
ServiceList_template(const OPTIONAL<ServiceList>& other_value);
ServiceList_template(const ServiceList_template& other_value);
~ServiceList_template();
void clean_up();
ServiceList_template& operator=(template_sel other_value);
ServiceList_template& operator=(const ServiceList& other_value);
ServiceList_template& operator=(const OPTIONAL<ServiceList>& other_value);
ServiceList_template& operator=(const ServiceList_template& other_value);
boolean match(const ServiceList& other_value, boolean legacy = FALSE) const;
boolean is_value() const;ServiceList valueof() const;
ServiceList_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
OpcUa__Types__Binary::FindServiceRequest_template& FindServiceRequest();
const OpcUa__Types__Binary::FindServiceRequest_template& FindServiceRequest() const;
OpcUa__Types__Binary::FindServiceResponse_template& FindServiceResponse();
const OpcUa__Types__Binary::FindServiceResponse_template& FindServiceResponse() const;
OpcUa__Types__Binary::FindServersOnNetworkRequest_template& FindServersOnNetworkRequest();
const OpcUa__Types__Binary::FindServersOnNetworkRequest_template& FindServersOnNetworkRequest() const;
OpcUa__Types__Binary::FindServersOnNetworkResponse_template& FindServersOnNetworkResponse();
const OpcUa__Types__Binary::FindServersOnNetworkResponse_template& FindServersOnNetworkResponse() const;
OpcUa__Types__Binary::GetEndpointsRequest_template& GetEndpointsRequest();
const OpcUa__Types__Binary::GetEndpointsRequest_template& GetEndpointsRequest() const;
OpcUa__Types__Binary::GetEndpointsResponse_template& GetEndpointsResponse();
const OpcUa__Types__Binary::GetEndpointsResponse_template& GetEndpointsResponse() const;
OpcUa__Types__Binary::RegisterServerRequest_template& RegisterServerRequest();
const OpcUa__Types__Binary::RegisterServerRequest_template& RegisterServerRequest() const;
OpcUa__Types__Binary::RegisterServerResponse_template& RegisterServerResponse();
const OpcUa__Types__Binary::RegisterServerResponse_template& RegisterServerResponse() const;
OpcUa__Types__Binary::RegisterServer2Request_template& RegisterServer2Request();
const OpcUa__Types__Binary::RegisterServer2Request_template& RegisterServer2Request() const;
OpcUa__Types__Binary::RegisterServer2Response_template& RegisterServer2Response();
const OpcUa__Types__Binary::RegisterServer2Response_template& RegisterServer2Response() const;
OpcUa__Types__Binary::OpenSecureChannelRequest_template& OpenSecureChannelRequest();
const OpcUa__Types__Binary::OpenSecureChannelRequest_template& OpenSecureChannelRequest() const;
OpcUa__Types__Binary::OpenSecureChannelResponse_template& OpenSecureChannelResponse();
const OpcUa__Types__Binary::OpenSecureChannelResponse_template& OpenSecureChannelResponse() const;
OpcUa__Types__Binary::CloseSecureChannelRequest_template& CloseSecureChannelRequest();
const OpcUa__Types__Binary::CloseSecureChannelRequest_template& CloseSecureChannelRequest() const;
OpcUa__Types__Binary::CloseSecureChannelResponse_template& CloseSecureChannelResponse();
const OpcUa__Types__Binary::CloseSecureChannelResponse_template& CloseSecureChannelResponse() const;
OpcUa__Types__Binary::CreateSessionRequest_template& CreateSessionRequest();
const OpcUa__Types__Binary::CreateSessionRequest_template& CreateSessionRequest() const;
OpcUa__Types__Binary::CreateSessionResponse_template& CreateSessionResponse();
const OpcUa__Types__Binary::CreateSessionResponse_template& CreateSessionResponse() const;
OpcUa__Types__Binary::ActivateSessionRequest_template& ActivateSessionRequest();
const OpcUa__Types__Binary::ActivateSessionRequest_template& ActivateSessionRequest() const;
OpcUa__Types__Binary::ActivateSessionResponse_template& ActivateSessionResponse();
const OpcUa__Types__Binary::ActivateSessionResponse_template& ActivateSessionResponse() const;
OpcUa__Types__Binary::CloseSessionRequest_template& CloseSessionRequest();
const OpcUa__Types__Binary::CloseSessionRequest_template& CloseSessionRequest() const;
OpcUa__Types__Binary::CloseSessionResponse_template& CloseSessionResponse();
const OpcUa__Types__Binary::CloseSessionResponse_template& CloseSessionResponse() const;
OpcUa__Types__Binary::CancelRequestRequest_template& CancelRequestRequest();
const OpcUa__Types__Binary::CancelRequestRequest_template& CancelRequestRequest() const;
OpcUa__Types__Binary::CancelRequestResponse_template& CancelRequestResponse();
const OpcUa__Types__Binary::CancelRequestResponse_template& CancelRequestResponse() const;
OpcUa__Types__Binary::AddNodesRequest_template& AddNodesRequest();
const OpcUa__Types__Binary::AddNodesRequest_template& AddNodesRequest() const;
OpcUa__Types__Binary::AddNodesResponse_template& AddNodesResponse();
const OpcUa__Types__Binary::AddNodesResponse_template& AddNodesResponse() const;
OpcUa__Types__Binary::AddReferencesRequest_template& AddReferencesRequest();
const OpcUa__Types__Binary::AddReferencesRequest_template& AddReferencesRequest() const;
OpcUa__Types__Binary::AddReferencesResponse_template& AddReferencesResponse();
const OpcUa__Types__Binary::AddReferencesResponse_template& AddReferencesResponse() const;
OpcUa__Types__Binary::DeleteNodesRequest_template& DeleteNodesRequest();
const OpcUa__Types__Binary::DeleteNodesRequest_template& DeleteNodesRequest() const;
OpcUa__Types__Binary::DeleteNodesResponse_template& DeleteNodesResponse();
const OpcUa__Types__Binary::DeleteNodesResponse_template& DeleteNodesResponse() const;
OpcUa__Types__Binary::DeleteReferencesRequest_template& DeleteReferencesRequest();
const OpcUa__Types__Binary::DeleteReferencesRequest_template& DeleteReferencesRequest() const;
OpcUa__Types__Binary::DeleteReferencesResponse_template& DeleteReferencesResponse();
const OpcUa__Types__Binary::DeleteReferencesResponse_template& DeleteReferencesResponse() const;
OpcUa__Types__Binary::BrowseRequest_template& BrowseRequest();
const OpcUa__Types__Binary::BrowseRequest_template& BrowseRequest() const;
OpcUa__Types__Binary::BrowseResponse_template& BrowseResponse();
const OpcUa__Types__Binary::BrowseResponse_template& BrowseResponse() const;
OpcUa__Types__Binary::BrowseNextRequest_template& BrowseNextRequest();
const OpcUa__Types__Binary::BrowseNextRequest_template& BrowseNextRequest() const;
OpcUa__Types__Binary::BrowseNextResponse_template& BrowseNextResponse();
const OpcUa__Types__Binary::BrowseNextResponse_template& BrowseNextResponse() const;
OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsRequest_template& TranslateBrowsePathsToNodeIdsRequest();
const OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsRequest_template& TranslateBrowsePathsToNodeIdsRequest() const;
OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsResponse_template& TranslateBrowsePathsToNodeIdsResponse();
const OpcUa__Types__Binary::TranslateBrowsePathsToNodeIdsResponse_template& TranslateBrowsePathsToNodeIdsResponse() const;
OpcUa__Types__Binary::RegisterNodesRequest_template& RegisterNodesRequest();
const OpcUa__Types__Binary::RegisterNodesRequest_template& RegisterNodesRequest() const;
OpcUa__Types__Binary::RegisterNodesResponse_template& RegisterNodesResponse();
const OpcUa__Types__Binary::RegisterNodesResponse_template& RegisterNodesResponse() const;
OpcUa__Types__Binary::UnregisterNodesRequest_template& UnregisterNodesRequest();
const OpcUa__Types__Binary::UnregisterNodesRequest_template& UnregisterNodesRequest() const;
OpcUa__Types__Binary::UnregisterNodesResponse_template& UnregisterNodesResponse();
const OpcUa__Types__Binary::UnregisterNodesResponse_template& UnregisterNodesResponse() const;
OpcUa__Types__Binary::QueryFirstRequest_template& QueryFirstRequest();
const OpcUa__Types__Binary::QueryFirstRequest_template& QueryFirstRequest() const;
OpcUa__Types__Binary::QueryFirstResponse_template& QueryFirstResponse();
const OpcUa__Types__Binary::QueryFirstResponse_template& QueryFirstResponse() const;
OpcUa__Types__Binary::QueryNextRequest_template& QueryNextRequest();
const OpcUa__Types__Binary::QueryNextRequest_template& QueryNextRequest() const;
OpcUa__Types__Binary::QueryNextResponse_template& QueryNextResponse();
const OpcUa__Types__Binary::QueryNextResponse_template& QueryNextResponse() const;
OpcUa__Types__Binary::ReadRequest_template& ReadRequest();
const OpcUa__Types__Binary::ReadRequest_template& ReadRequest() const;
OpcUa__Types__Binary::ReadResponse_template& ReadResponse();
const OpcUa__Types__Binary::ReadResponse_template& ReadResponse() const;
OpcUa__Types__Binary::HistoryReadRequest_template& HistoryReadRequest();
const OpcUa__Types__Binary::HistoryReadRequest_template& HistoryReadRequest() const;
OpcUa__Types__Binary::HistoryReadResponse_template& HistoryReadResponse();
const OpcUa__Types__Binary::HistoryReadResponse_template& HistoryReadResponse() const;
OpcUa__Types__Binary::WriteRequest_template& WriteRequest();
const OpcUa__Types__Binary::WriteRequest_template& WriteRequest() const;
OpcUa__Types__Binary::WriteResponse_template& WriteResponse();
const OpcUa__Types__Binary::WriteResponse_template& WriteResponse() const;
OpcUa__Types__Binary::HistoryUpdateRequest_template& HistoryUpdateRequest();
const OpcUa__Types__Binary::HistoryUpdateRequest_template& HistoryUpdateRequest() const;
OpcUa__Types__Binary::HistoryUpdateResponse_template& HistoryUpdateResponse();
const OpcUa__Types__Binary::HistoryUpdateResponse_template& HistoryUpdateResponse() const;
OpcUa__Types__Binary::CallRequest_template& CallRequest();
const OpcUa__Types__Binary::CallRequest_template& CallRequest() const;
OpcUa__Types__Binary::CallResponse_template& CallResponse();
const OpcUa__Types__Binary::CallResponse_template& CallResponse() const;
OpcUa__Types__Binary::CreateMonitoredItemsRequest_template& CreateMonitoredItemsRequest();
const OpcUa__Types__Binary::CreateMonitoredItemsRequest_template& CreateMonitoredItemsRequest() const;
OpcUa__Types__Binary::CreateMonitoredItemsResponse_template& CreateMonitoredItemsResponse();
const OpcUa__Types__Binary::CreateMonitoredItemsResponse_template& CreateMonitoredItemsResponse() const;
OpcUa__Types__Binary::ModifyMonitoredItemsRequest_template& ModifyMonitoredItemsRequest();
const OpcUa__Types__Binary::ModifyMonitoredItemsRequest_template& ModifyMonitoredItemsRequest() const;
OpcUa__Types__Binary::ModifyMonitoredItemsResponse_template& ModifyMonitoredItemsResponse();
const OpcUa__Types__Binary::ModifyMonitoredItemsResponse_template& ModifyMonitoredItemsResponse() const;
OpcUa__Types__Binary::SetMonitoringModeRequest_template& SetMonitoringModeRequest();
const OpcUa__Types__Binary::SetMonitoringModeRequest_template& SetMonitoringModeRequest() const;
OpcUa__Types__Binary::SetMonitoringModeResponse_template& SetMonitoringModeResponse();
const OpcUa__Types__Binary::SetMonitoringModeResponse_template& SetMonitoringModeResponse() const;
OpcUa__Types__Binary::SetTriggeringRequest_template& SetTriggeringRequest();
const OpcUa__Types__Binary::SetTriggeringRequest_template& SetTriggeringRequest() const;
OpcUa__Types__Binary::SetTriggeringResponse_template& SetTriggeringResponse();
const OpcUa__Types__Binary::SetTriggeringResponse_template& SetTriggeringResponse() const;
OpcUa__Types__Binary::DeleteMonitoredItemsRequest_template& DeleteMonitoredItemsRequest();
const OpcUa__Types__Binary::DeleteMonitoredItemsRequest_template& DeleteMonitoredItemsRequest() const;
OpcUa__Types__Binary::DeleteMonitoredItemsResponse_template& DeleteMonitoredItemsResponse();
const OpcUa__Types__Binary::DeleteMonitoredItemsResponse_template& DeleteMonitoredItemsResponse() const;
OpcUa__Types__Binary::CreateSubscriptionRequest_template& CreateSubscriptionRequest();
const OpcUa__Types__Binary::CreateSubscriptionRequest_template& CreateSubscriptionRequest() const;
OpcUa__Types__Binary::CreateSubscriptionResponse_template& CreateSubscriptionResponse();
const OpcUa__Types__Binary::CreateSubscriptionResponse_template& CreateSubscriptionResponse() const;
OpcUa__Types__Binary::ModifySubscriptionRequest_template& ModifySubscriptionRequest();
const OpcUa__Types__Binary::ModifySubscriptionRequest_template& ModifySubscriptionRequest() const;
OpcUa__Types__Binary::ModifySubscriptionResponse_template& ModifySubscriptionResponse();
const OpcUa__Types__Binary::ModifySubscriptionResponse_template& ModifySubscriptionResponse() const;
OpcUa__Types__Binary::SetPublishingModeRequest_template& SetPublishingModeRequest();
const OpcUa__Types__Binary::SetPublishingModeRequest_template& SetPublishingModeRequest() const;
OpcUa__Types__Binary::SetPublishingModeResponse_template& SetPublishingModeResponse();
const OpcUa__Types__Binary::SetPublishingModeResponse_template& SetPublishingModeResponse() const;
OpcUa__Types__Binary::PublishRequest_template& PublishRequest();
const OpcUa__Types__Binary::PublishRequest_template& PublishRequest() const;
OpcUa__Types__Binary::PublishResponse_template& PublishResponse();
const OpcUa__Types__Binary::PublishResponse_template& PublishResponse() const;
OpcUa__Types__Binary::RepublishRequest_template& RepublishRequest();
const OpcUa__Types__Binary::RepublishRequest_template& RepublishRequest() const;
OpcUa__Types__Binary::RepublishResponse_template& RepublishResponse();
const OpcUa__Types__Binary::RepublishResponse_template& RepublishResponse() const;
OpcUa__Types__Binary::TransferSubscriptionsRequest_template& TransferSubscriptionsRequest();
const OpcUa__Types__Binary::TransferSubscriptionsRequest_template& TransferSubscriptionsRequest() const;
OpcUa__Types__Binary::TransferSubscriptionsResponse_template& TransferSubscriptionsResponse();
const OpcUa__Types__Binary::TransferSubscriptionsResponse_template& TransferSubscriptionsResponse() const;
OpcUa__Types__Binary::DeleteSubscriptionsRequest_template& DeleteSubscriptionsRequest();
const OpcUa__Types__Binary::DeleteSubscriptionsRequest_template& DeleteSubscriptionsRequest() const;
OpcUa__Types__Binary::DeleteSubscriptionsResponse_template& DeleteSubscriptionsResponse();
const OpcUa__Types__Binary::DeleteSubscriptionsResponse_template& DeleteSubscriptionsResponse() const;
boolean ischosen(ServiceList::union_selection_type checked_selection) const;
void log() const;
void log_match(const ServiceList& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class OpcMessages : public Base_Type {
public:
enum union_selection_type { UNBOUND_VALUE = 0, ALT_helloMessage = 1, ALT_ackMessage = 2, ALT_errorMessage = 3, ALT_reverseHelloMessage = 4 };
private:
union_selection_type union_selection;
union {
HelloMessage *field_helloMessage;
AckMessage *field_ackMessage;
ErrorMessage *field_errorMessage;
ReverseHelloMessage *field_reverseHelloMessage;
};
void copy_value(const OpcMessages& other_value);

public:
OpcMessages();
OpcMessages(const OpcMessages& other_value);
~OpcMessages();
OpcMessages& operator=(const OpcMessages& other_value);
boolean operator==(const OpcMessages& other_value) const;
inline boolean operator!=(const OpcMessages& other_value) const { return !(*this == other_value); }
HelloMessage& helloMessage();
const HelloMessage& helloMessage() const;
AckMessage& ackMessage();
const AckMessage& ackMessage() const;
ErrorMessage& errorMessage();
const ErrorMessage& errorMessage() const;
ReverseHelloMessage& reverseHelloMessage();
const ReverseHelloMessage& reverseHelloMessage() const;
inline union_selection_type get_selection() const { return union_selection; }
boolean ischosen(union_selection_type checked_selection) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
inline boolean is_present() const { return is_bound(); }
void log() const;
void set_param(Module_Param& param);
  void set_implicit_omit();
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class OpcMessages_template : public Base_Template {
union {
struct {
OpcMessages::union_selection_type union_selection;
union {
HelloMessage_template *field_helloMessage;
AckMessage_template *field_ackMessage;
ErrorMessage_template *field_errorMessage;
ReverseHelloMessage_template *field_reverseHelloMessage;
};
} single_value;
struct {
unsigned int n_values;
OpcMessages_template *list_value;
} value_list;
};
void copy_value(const OpcMessages& other_value);

void copy_template(const OpcMessages_template& other_value);

public:
OpcMessages_template();
OpcMessages_template(template_sel other_value);
OpcMessages_template(const OpcMessages& other_value);
OpcMessages_template(const OPTIONAL<OpcMessages>& other_value);
OpcMessages_template(const OpcMessages_template& other_value);
~OpcMessages_template();
void clean_up();
OpcMessages_template& operator=(template_sel other_value);
OpcMessages_template& operator=(const OpcMessages& other_value);
OpcMessages_template& operator=(const OPTIONAL<OpcMessages>& other_value);
OpcMessages_template& operator=(const OpcMessages_template& other_value);
boolean match(const OpcMessages& other_value, boolean legacy = FALSE) const;
boolean is_value() const;OpcMessages valueof() const;
OpcMessages_template& list_item(unsigned int list_index) const;
void set_type(template_sel template_type, unsigned int list_length);
HelloMessage_template& helloMessage();
const HelloMessage_template& helloMessage() const;
AckMessage_template& ackMessage();
const AckMessage_template& ackMessage() const;
ErrorMessage_template& errorMessage();
const ErrorMessage_template& errorMessage() const;
ReverseHelloMessage_template& reverseHelloMessage();
const ReverseHelloMessage_template& reverseHelloMessage() const;
boolean ischosen(OpcMessages::union_selection_type checked_selection) const;
void log() const;
void log_match(const OpcMessages& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
};

class MessageChunk : public Base_Type {
  MessageHeader field_header;
  OPTIONAL<OpcMessages> field_transportMessage;
  OPTIONAL<INTEGER> field_securityChannelId;
  OPTIONAL<ListOfByte> field_securePolicyUri;
  OPTIONAL<ListOfByte> field_senderCertificate;
  OPTIONAL<ListOfByte> field_receiverCertificateThumbprint;
  OPTIONAL<INTEGER> field_securityTokenId;
  OPTIONAL<SequenceHeader> field_sequenceHeader;
  OPTIONAL<OCTETSTRING> field_body;
public:
  MessageChunk();
  MessageChunk(const MessageHeader& par_header,
    const OPTIONAL<OpcMessages>& par_transportMessage,
    const OPTIONAL<INTEGER>& par_securityChannelId,
    const OPTIONAL<ListOfByte>& par_securePolicyUri,
    const OPTIONAL<ListOfByte>& par_senderCertificate,
    const OPTIONAL<ListOfByte>& par_receiverCertificateThumbprint,
    const OPTIONAL<INTEGER>& par_securityTokenId,
    const OPTIONAL<SequenceHeader>& par_sequenceHeader,
    const OPTIONAL<OCTETSTRING>& par_body);
  MessageChunk(const MessageChunk& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  MessageChunk& operator=(const MessageChunk& other_value);
  boolean operator==(const MessageChunk& other_value) const;
  inline boolean operator!=(const MessageChunk& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline MessageHeader& header()
    {return field_header;}
  inline const MessageHeader& header() const
    {return field_header;}
  inline OPTIONAL<OpcMessages>& transportMessage()
    {return field_transportMessage;}
  inline const OPTIONAL<OpcMessages>& transportMessage() const
    {return field_transportMessage;}
  inline OPTIONAL<INTEGER>& securityChannelId()
    {return field_securityChannelId;}
  inline const OPTIONAL<INTEGER>& securityChannelId() const
    {return field_securityChannelId;}
  inline OPTIONAL<ListOfByte>& securePolicyUri()
    {return field_securePolicyUri;}
  inline const OPTIONAL<ListOfByte>& securePolicyUri() const
    {return field_securePolicyUri;}
  inline OPTIONAL<ListOfByte>& senderCertificate()
    {return field_senderCertificate;}
  inline const OPTIONAL<ListOfByte>& senderCertificate() const
    {return field_senderCertificate;}
  inline OPTIONAL<ListOfByte>& receiverCertificateThumbprint()
    {return field_receiverCertificateThumbprint;}
  inline const OPTIONAL<ListOfByte>& receiverCertificateThumbprint() const
    {return field_receiverCertificateThumbprint;}
  inline OPTIONAL<INTEGER>& securityTokenId()
    {return field_securityTokenId;}
  inline const OPTIONAL<INTEGER>& securityTokenId() const
    {return field_securityTokenId;}
  inline OPTIONAL<SequenceHeader>& sequenceHeader()
    {return field_sequenceHeader;}
  inline const OPTIONAL<SequenceHeader>& sequenceHeader() const
    {return field_sequenceHeader;}
  inline OPTIONAL<OCTETSTRING>& body()
    {return field_body;}
  inline const OPTIONAL<OCTETSTRING>& body() const
    {return field_body;}
  int size_of() const;
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class MessageChunk_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
MessageChunk_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const MessageChunk& other_value);
void copy_template(const MessageChunk_template& other_value);

public:
MessageChunk_template();
MessageChunk_template(template_sel other_value);
MessageChunk_template(const MessageChunk& other_value);
MessageChunk_template(const OPTIONAL<MessageChunk>& other_value);
MessageChunk_template(const MessageChunk_template& other_value);
~MessageChunk_template();
MessageChunk_template& operator=(template_sel other_value);
MessageChunk_template& operator=(const MessageChunk& other_value);
MessageChunk_template& operator=(const OPTIONAL<MessageChunk>& other_value);
MessageChunk_template& operator=(const MessageChunk_template& other_value);
boolean match(const MessageChunk& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
MessageChunk valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
MessageChunk_template& list_item(unsigned int list_index) const;
MessageHeader_template& header();
const MessageHeader_template& header() const;
OpcMessages_template& transportMessage();
const OpcMessages_template& transportMessage() const;
INTEGER_template& securityChannelId();
const INTEGER_template& securityChannelId() const;
ListOfByte_template& securePolicyUri();
const ListOfByte_template& securePolicyUri() const;
ListOfByte_template& senderCertificate();
const ListOfByte_template& senderCertificate() const;
ListOfByte_template& receiverCertificateThumbprint();
const ListOfByte_template& receiverCertificateThumbprint() const;
INTEGER_template& securityTokenId();
const INTEGER_template& securityTokenId() const;
SequenceHeader_template& sequenceHeader();
const SequenceHeader_template& sequenceHeader() const;
OCTETSTRING_template& body();
const OCTETSTRING_template& body() const;
int size_of() const;
void log() const;
void log_match(const MessageChunk& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};

class ServiceBody : public Base_Type {
  INTEGER field_encodingByte;
  INTEGER field_namespaceIndex;
  INTEGER field_nodeValue;
  ServiceList field_list;
public:
  ServiceBody();
  ServiceBody(const INTEGER& par_encodingByte,
    const INTEGER& par_namespaceIndex,
    const INTEGER& par_nodeValue,
    const ServiceList& par_list);
  ServiceBody(const ServiceBody& other_value);
  inline boolean is_component() { return FALSE; }
  void clean_up();
  ServiceBody& operator=(const ServiceBody& other_value);
  boolean operator==(const ServiceBody& other_value) const;
  inline boolean operator!=(const ServiceBody& other_value) const
    { return !(*this == other_value); }

  boolean is_bound() const;

inline boolean is_present() const { return is_bound(); }
  boolean is_value() const;

  inline INTEGER& encodingByte()
    {return field_encodingByte;}
  inline const INTEGER& encodingByte() const
    {return field_encodingByte;}
  inline INTEGER& namespaceIndex()
    {return field_namespaceIndex;}
  inline const INTEGER& namespaceIndex() const
    {return field_namespaceIndex;}
  inline INTEGER& nodeValue()
    {return field_nodeValue;}
  inline const INTEGER& nodeValue() const
    {return field_nodeValue;}
  inline ServiceList& list()
    {return field_list;}
  inline const ServiceList& list() const
    {return field_list;}
  inline int size_of() const
    {return 4;}
  void log() const;
  void set_param(Module_Param& param);
  void set_implicit_omit();
  void encode_text(Text_Buf& text_buf) const;
  void decode_text(Text_Buf& text_buf);
void encode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...) const;
void decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, TTCN_EncDec::coding_t, ...);
int RAW_encode(const TTCN_Typedescriptor_t&, RAW_enc_tree&) const;
int RAW_decode(const TTCN_Typedescriptor_t&, TTCN_Buffer&, int, raw_order_t, boolean no_err=FALSE,int sel_field=-1, boolean first_call=TRUE);
};

class ServiceBody_template : public Base_Template {
struct single_value_struct;
union {
single_value_struct *single_value;
struct {
unsigned int n_values;
ServiceBody_template *list_value;
} value_list;
};

void set_specific();
void copy_value(const ServiceBody& other_value);
void copy_template(const ServiceBody_template& other_value);

public:
ServiceBody_template();
ServiceBody_template(template_sel other_value);
ServiceBody_template(const ServiceBody& other_value);
ServiceBody_template(const OPTIONAL<ServiceBody>& other_value);
ServiceBody_template(const ServiceBody_template& other_value);
~ServiceBody_template();
ServiceBody_template& operator=(template_sel other_value);
ServiceBody_template& operator=(const ServiceBody& other_value);
ServiceBody_template& operator=(const OPTIONAL<ServiceBody>& other_value);
ServiceBody_template& operator=(const ServiceBody_template& other_value);
boolean match(const ServiceBody& other_value, boolean legacy = FALSE) const;
boolean is_bound() const;
boolean is_value() const;
void clean_up();
ServiceBody valueof() const;
void set_type(template_sel template_type, unsigned int list_length);
ServiceBody_template& list_item(unsigned int list_index) const;
INTEGER_template& encodingByte();
const INTEGER_template& encodingByte() const;
INTEGER_template& namespaceIndex();
const INTEGER_template& namespaceIndex() const;
INTEGER_template& nodeValue();
const INTEGER_template& nodeValue() const;
ServiceList_template& list();
const ServiceList_template& list() const;
int size_of() const;
void log() const;
void log_match(const ServiceBody& match_value, boolean legacy = FALSE) const;
void encode_text(Text_Buf& text_buf) const;
void decode_text(Text_Buf& text_buf);
void set_param(Module_Param& param);
void check_restriction(template_res t_res, const char* t_name=NULL, boolean legacy = FALSE) const;
boolean is_present(boolean legacy = FALSE) const;
boolean match_omit(boolean legacy = FALSE) const;
};


/* Function prototypes */

extern OCTETSTRING enc__MessageChunk(const MessageChunk& msg);
extern INTEGER dec__MessageChunk(const OCTETSTRING& p__oct, MessageChunk& msg);
extern OCTETSTRING enc__ServiceBody(const ServiceBody& msg);
extern INTEGER dec__ServiceBody(const OCTETSTRING& p__oct, ServiceBody& msg);
extern boolean operator==(null_type null_value, const VariantArray& other_value);
inline boolean operator!=(null_type null_value, const VariantArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const StringArray& other_value);
inline boolean operator!=(null_type null_value, const StringArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const GuidArray& other_value);
inline boolean operator!=(null_type null_value, const GuidArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ByteStringArray& other_value);
inline boolean operator!=(null_type null_value, const ByteStringArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const XmlElementArray& other_value);
inline boolean operator!=(null_type null_value, const XmlElementArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const NodeIdArray& other_value);
inline boolean operator!=(null_type null_value, const NodeIdArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ExpandedNodeIdArray& other_value);
inline boolean operator!=(null_type null_value, const ExpandedNodeIdArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const QualifiedNameArray& other_value);
inline boolean operator!=(null_type null_value, const QualifiedNameArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const LocalizedTextArray& other_value);
inline boolean operator!=(null_type null_value, const LocalizedTextArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ExtensionObjectArray& other_value);
inline boolean operator!=(null_type null_value, const ExtensionObjectArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const DataValueArray& other_value);
inline boolean operator!=(null_type null_value, const DataValueArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const DiagnosticInfoArray& other_value);
inline boolean operator!=(null_type null_value, const DiagnosticInfoArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const RelativePathElementArray& other_value);
inline boolean operator!=(null_type null_value, const RelativePathElementArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const SimpleAttributeOperandArray& other_value);
inline boolean operator!=(null_type null_value, const SimpleAttributeOperandArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ContentFilterElementArray& other_value);
inline boolean operator!=(null_type null_value, const ContentFilterElementArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ExtensibleParameterArray& other_value);
inline boolean operator!=(null_type null_value, const ExtensibleParameterArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ContentFilterElementResultArray& other_value);
inline boolean operator!=(null_type null_value, const ContentFilterElementResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const GenericAttributeValueArray& other_value);
inline boolean operator!=(null_type null_value, const GenericAttributeValueArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MonitoredItemNotificationArray& other_value);
inline boolean operator!=(null_type null_value, const MonitoredItemNotificationArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const EventFieldListArray& other_value);
inline boolean operator!=(null_type null_value, const EventFieldListArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ListOfBaseDataType& other_value);
inline boolean operator!=(null_type null_value, const ListOfBaseDataType& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const StructureFieldArray& other_value);
inline boolean operator!=(null_type null_value, const StructureFieldArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const EnumFieldArray& other_value);
inline boolean operator!=(null_type null_value, const EnumFieldArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const LocaleIdArray& other_value);
inline boolean operator!=(null_type null_value, const LocaleIdArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ContinuationPointArray& other_value);
inline boolean operator!=(null_type null_value, const ContinuationPointArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const DecimalArray& other_value);
inline boolean operator!=(null_type null_value, const DecimalArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const EnumValueTypeArray& other_value);
inline boolean operator!=(null_type null_value, const EnumValueTypeArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ApplicationDescriptionArray& other_value);
inline boolean operator!=(null_type null_value, const ApplicationDescriptionArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const BrowseResultArray& other_value);
inline boolean operator!=(null_type null_value, const BrowseResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ReferenceDescriptionArray& other_value);
inline boolean operator!=(null_type null_value, const ReferenceDescriptionArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const EndpointDescriptionArray& other_value);
inline boolean operator!=(null_type null_value, const EndpointDescriptionArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const UserTokenPolicyArray& other_value);
inline boolean operator!=(null_type null_value, const UserTokenPolicyArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MonitoringParametersArray& other_value);
inline boolean operator!=(null_type null_value, const MonitoringParametersArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const QueryDataSetArray& other_value);
inline boolean operator!=(null_type null_value, const QueryDataSetArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ReadValueIdArray& other_value);
inline boolean operator!=(null_type null_value, const ReadValueIdArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ApplicationInstanceCertificateArray& other_value);
inline boolean operator!=(null_type null_value, const ApplicationInstanceCertificateArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ChannelSecurityTokenArray& other_value);
inline boolean operator!=(null_type null_value, const ChannelSecurityTokenArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ServerOnNetworkArray& other_value);
inline boolean operator!=(null_type null_value, const ServerOnNetworkArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AddNodesItemArray& other_value);
inline boolean operator!=(null_type null_value, const AddNodesItemArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AddNodesResultArray& other_value);
inline boolean operator!=(null_type null_value, const AddNodesResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const AddReferencesItemArray& other_value);
inline boolean operator!=(null_type null_value, const AddReferencesItemArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const DeleteNodesItemArray& other_value);
inline boolean operator!=(null_type null_value, const DeleteNodesItemArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const DeleteReferencesItemArray& other_value);
inline boolean operator!=(null_type null_value, const DeleteReferencesItemArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const SignedSoftwareCertificateArray& other_value);
inline boolean operator!=(null_type null_value, const SignedSoftwareCertificateArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const BrowseDescriptionArray& other_value);
inline boolean operator!=(null_type null_value, const BrowseDescriptionArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const BrowsePathArray& other_value);
inline boolean operator!=(null_type null_value, const BrowsePathArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const BrowsePathResultArray& other_value);
inline boolean operator!=(null_type null_value, const BrowsePathResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const BrowsePathTargetArray& other_value);
inline boolean operator!=(null_type null_value, const BrowsePathTargetArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const NodeTypeDescriptionArray& other_value);
inline boolean operator!=(null_type null_value, const NodeTypeDescriptionArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const QueryDataDescriptionArray& other_value);
inline boolean operator!=(null_type null_value, const QueryDataDescriptionArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const ParsingResultArray& other_value);
inline boolean operator!=(null_type null_value, const ParsingResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const HistoryReadValueIdArray& other_value);
inline boolean operator!=(null_type null_value, const HistoryReadValueIdArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const HistoryReadResultArray& other_value);
inline boolean operator!=(null_type null_value, const HistoryReadResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const WriteValueArray& other_value);
inline boolean operator!=(null_type null_value, const WriteValueArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const HistoryUpdateResultArray& other_value);
inline boolean operator!=(null_type null_value, const HistoryUpdateResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const CallMethodRequestArray& other_value);
inline boolean operator!=(null_type null_value, const CallMethodRequestArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const CallMethodResultArray& other_value);
inline boolean operator!=(null_type null_value, const CallMethodResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MonitoredItemCreateRequestArray& other_value);
inline boolean operator!=(null_type null_value, const MonitoredItemCreateRequestArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MonitoredItemCreateResultArray& other_value);
inline boolean operator!=(null_type null_value, const MonitoredItemCreateResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MonitoredItemModifyRequestArray& other_value);
inline boolean operator!=(null_type null_value, const MonitoredItemModifyRequestArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const MonitoredItemModifyResultArray& other_value);
inline boolean operator!=(null_type null_value, const MonitoredItemModifyResultArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const SubscriptionAcknowledgementArray& other_value);
inline boolean operator!=(null_type null_value, const SubscriptionAcknowledgementArray& other_value) { return !(null_value == other_value); }
extern boolean operator==(null_type null_value, const TransferResultArray& other_value);
inline boolean operator!=(null_type null_value, const TransferResultArray& other_value) { return !(null_value == other_value); }

/* Global variable declarations */

extern const INTEGER& Null__Value;
extern const INTEGER& HelloHeaderMsgType;
extern const INTEGER& AckHeaderMsgType;
extern const INTEGER& ErrorHeaderMsgType;
extern const INTEGER& ReverseHelloHeaderMsgType;
extern const INTEGER& OpenSecureChannelMsgType;
extern const INTEGER& CloseSecureChannelMsgType;
extern const INTEGER& ServicesMsgType;
extern const INTEGER& FinalChunk;
extern const INTEGER& IntermediateChunk;
extern const INTEGER& ErrorChunk;
extern const TTCN_RAWdescriptor_t MessageSecurityMode_raw_;
extern const TTCN_Typedescriptor_t MessageSecurityMode_descr_;
extern const TTCN_RAWdescriptor_t SecurityTokenRequestType_raw_;
extern const TTCN_Typedescriptor_t SecurityTokenRequestType_descr_;
extern const TTCN_RAWdescriptor_t NodeClass_raw_;
extern const TTCN_Typedescriptor_t NodeClass_descr_;
extern const TTCN_RAWdescriptor_t StructureType_raw_;
extern const TTCN_Typedescriptor_t StructureType_descr_;
extern const TTCN_RAWdescriptor_t ApplicationType_raw_;
extern const TTCN_Typedescriptor_t ApplicationType_descr_;
extern const TTCN_RAWdescriptor_t DataChangeTrigger_raw_;
extern const TTCN_Typedescriptor_t DataChangeTrigger_descr_;
extern const TTCN_RAWdescriptor_t MonitoringMode_raw_;
extern const TTCN_Typedescriptor_t MonitoringMode_descr_;
extern const TTCN_RAWdescriptor_t BrowseDirection_raw_;
extern const TTCN_Typedescriptor_t BrowseDirection_descr_;
extern const TTCN_RAWdescriptor_t TimestampsToReturn_raw_;
extern const TTCN_Typedescriptor_t TimestampsToReturn_descr_;
extern const TTCN_RAWdescriptor_t UserIdentityTokenType_raw_;
extern const TTCN_Typedescriptor_t UserIdentityTokenType_descr_;
extern const TTCN_RAWdescriptor_t PerformUpdateType_raw_;
extern const TTCN_Typedescriptor_t PerformUpdateType_descr_;
extern const TTCN_RAWdescriptor_t PerformUpdateTypeExtended_raw_;
extern const TTCN_Typedescriptor_t PerformUpdateTypeExtended_descr_;
extern const TTCN_RAWdescriptor_t IdType_raw_;
extern const TTCN_Typedescriptor_t IdType_descr_;
extern const TTCN_RAWdescriptor_t FilterOperator_raw_;
extern const TTCN_Typedescriptor_t FilterOperator_descr_;
extern const TTCN_RAWdescriptor_t OpenFileMode_raw_;
extern const TTCN_Typedescriptor_t OpenFileMode_descr_;
extern const TTCN_RAWdescriptor_t TrustListMasks_raw_;
extern const TTCN_Typedescriptor_t TrustListMasks_descr_;
extern const TTCN_RAWdescriptor_t Byte_raw_;
extern const XERdescriptor_t Byte_xer_;
extern const TTCN_JSONdescriptor_t Byte_json_;
extern const TTCN_OERdescriptor_t Byte_oer_;
extern const TTCN_Typedescriptor_t Byte_descr_;
extern const XERdescriptor_t Boolean_xer_;
extern const TTCN_JSONdescriptor_t Boolean_json_;
extern const TTCN_OERdescriptor_t Boolean_oer_;
extern const TTCN_Typedescriptor_t Boolean_descr_;
extern const TTCN_RAWdescriptor_t Bit_raw_;
extern const XERdescriptor_t Bit_xer_;
extern const TTCN_JSONdescriptor_t Bit_json_;
extern const TTCN_OERdescriptor_t Bit_oer_;
extern const TTCN_Typedescriptor_t Bit_descr_;
extern const TTCN_RAWdescriptor_t Bit4_raw_;
extern const XERdescriptor_t Bit4_xer_;
extern const TTCN_JSONdescriptor_t Bit4_json_;
extern const TTCN_OERdescriptor_t Bit4_oer_;
extern const TTCN_Typedescriptor_t Bit4_descr_;
extern const TTCN_RAWdescriptor_t Bit6_raw_;
extern const XERdescriptor_t Bit6_xer_;
extern const TTCN_JSONdescriptor_t Bit6_json_;
extern const TTCN_OERdescriptor_t Bit6_oer_;
extern const TTCN_Typedescriptor_t Bit6_descr_;
extern const TTCN_RAWdescriptor_t SByte_raw_;
extern const XERdescriptor_t SByte_xer_;
extern const TTCN_JSONdescriptor_t SByte_json_;
extern const TTCN_OERdescriptor_t SByte_oer_;
extern const TTCN_Typedescriptor_t SByte_descr_;
extern const TTCN_RAWdescriptor_t Int16_raw_;
extern const XERdescriptor_t Int16_xer_;
extern const TTCN_JSONdescriptor_t Int16_json_;
extern const TTCN_OERdescriptor_t Int16_oer_;
extern const TTCN_Typedescriptor_t Int16_descr_;
extern const TTCN_RAWdescriptor_t UInt16_raw_;
extern const XERdescriptor_t UInt16_xer_;
extern const TTCN_JSONdescriptor_t UInt16_json_;
extern const TTCN_OERdescriptor_t UInt16_oer_;
extern const TTCN_Typedescriptor_t UInt16_descr_;
extern const TTCN_RAWdescriptor_t UInt24_raw_;
extern const XERdescriptor_t UInt24_xer_;
extern const TTCN_JSONdescriptor_t UInt24_json_;
extern const TTCN_OERdescriptor_t UInt24_oer_;
extern const TTCN_Typedescriptor_t UInt24_descr_;
extern const TTCN_RAWdescriptor_t Int32_raw_;
extern const XERdescriptor_t Int32_xer_;
extern const TTCN_JSONdescriptor_t Int32_json_;
extern const TTCN_OERdescriptor_t Int32_oer_;
extern const TTCN_Typedescriptor_t Int32_descr_;
extern const TTCN_RAWdescriptor_t UInt32_raw_;
extern const XERdescriptor_t UInt32_xer_;
extern const TTCN_JSONdescriptor_t UInt32_json_;
extern const TTCN_OERdescriptor_t UInt32_oer_;
extern const TTCN_Typedescriptor_t UInt32_descr_;
extern const TTCN_RAWdescriptor_t Int64_raw_;
extern const XERdescriptor_t Int64_xer_;
extern const TTCN_JSONdescriptor_t Int64_json_;
extern const TTCN_OERdescriptor_t Int64_oer_;
extern const TTCN_Typedescriptor_t Int64_descr_;
extern const TTCN_RAWdescriptor_t UInt64_raw_;
extern const XERdescriptor_t UInt64_xer_;
extern const TTCN_JSONdescriptor_t UInt64_json_;
extern const TTCN_OERdescriptor_t UInt64_oer_;
extern const TTCN_Typedescriptor_t UInt64_descr_;
extern const TTCN_RAWdescriptor_t Float_raw_;
extern const XERdescriptor_t Float_xer_;
extern const TTCN_JSONdescriptor_t Float_json_;
extern const TTCN_OERdescriptor_t Float_oer_;
extern const TTCN_Typedescriptor_t Float_descr_;
extern const TTCN_RAWdescriptor_t Double_raw_;
extern const XERdescriptor_t Double_xer_;
extern const TTCN_JSONdescriptor_t Double_json_;
extern const TTCN_OERdescriptor_t Double_oer_;
extern const TTCN_Typedescriptor_t Double_descr_;
extern const TTCN_RAWdescriptor_t Duration_raw_;
extern const XERdescriptor_t Duration_xer_;
extern const TTCN_JSONdescriptor_t Duration_json_;
extern const TTCN_OERdescriptor_t Duration_oer_;
extern const TTCN_Typedescriptor_t Duration_descr_;
extern const TTCN_RAWdescriptor_t DateTime_raw_;
extern const XERdescriptor_t DateTime_xer_;
extern const TTCN_JSONdescriptor_t DateTime_json_;
extern const TTCN_OERdescriptor_t DateTime_oer_;
extern const TTCN_Typedescriptor_t DateTime_descr_;
extern const XERdescriptor_t UtcTime_xer_;
extern const TTCN_JSONdescriptor_t UtcTime_json_;
extern const TTCN_OERdescriptor_t UtcTime_oer_;
extern const TTCN_Typedescriptor_t UtcTime_descr_;
extern const XERdescriptor_t VersionTime_xer_;
extern const TTCN_JSONdescriptor_t VersionTime_json_;
extern const TTCN_OERdescriptor_t VersionTime_oer_;
extern const TTCN_Typedescriptor_t VersionTime_descr_;
extern const XERdescriptor_t Counter_xer_;
extern const TTCN_JSONdescriptor_t Counter_json_;
extern const TTCN_OERdescriptor_t Counter_oer_;
extern const TTCN_Typedescriptor_t Counter_descr_;
extern const XERdescriptor_t Index_xer_;
extern const TTCN_JSONdescriptor_t Index_json_;
extern const TTCN_OERdescriptor_t Index_oer_;
extern const TTCN_Typedescriptor_t Index_descr_;
extern const XERdescriptor_t IntegerId_xer_;
extern const TTCN_JSONdescriptor_t IntegerId_json_;
extern const TTCN_OERdescriptor_t IntegerId_oer_;
extern const TTCN_Typedescriptor_t IntegerId_descr_;
extern const XERdescriptor_t Image_xer_;
extern const TTCN_JSONdescriptor_t Image_json_;
extern const TTCN_OERdescriptor_t Image_oer_;
extern const TTCN_Typedescriptor_t Image_descr_;
extern const XERdescriptor_t ImageBMP_xer_;
extern const TTCN_JSONdescriptor_t ImageBMP_json_;
extern const TTCN_OERdescriptor_t ImageBMP_oer_;
extern const TTCN_Typedescriptor_t ImageBMP_descr_;
extern const XERdescriptor_t ImageGIF_xer_;
extern const TTCN_JSONdescriptor_t ImageGIF_json_;
extern const TTCN_OERdescriptor_t ImageGIF_oer_;
extern const TTCN_Typedescriptor_t ImageGIF_descr_;
extern const XERdescriptor_t ImageJPG_xer_;
extern const TTCN_JSONdescriptor_t ImageJPG_json_;
extern const TTCN_OERdescriptor_t ImageJPG_oer_;
extern const TTCN_Typedescriptor_t ImageJPG_descr_;
extern const XERdescriptor_t ImagePNG_xer_;
extern const TTCN_JSONdescriptor_t ImagePNG_json_;
extern const TTCN_OERdescriptor_t ImagePNG_oer_;
extern const TTCN_Typedescriptor_t ImagePNG_descr_;
extern const TTCN_RAWdescriptor_t ByteString_raw_;
extern const TTCN_Typedescriptor_t ByteString_descr_;
extern const XERdescriptor_t NullArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t NullArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t NullArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t NullArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t NullArray_raw_;
extern const TTCN_Typedescriptor_t NullArray_descr_;
extern const TTCN_RAWdescriptor_t RealByteString_lengthValue_raw_;
extern const XERdescriptor_t RealByteString_lengthValue_xer_;
extern const TTCN_JSONdescriptor_t RealByteString_lengthValue_json_;
extern const TTCN_OERdescriptor_t RealByteString_lengthValue_oer_;
extern const TTCN_Typedescriptor_t RealByteString_lengthValue_descr_;
extern const TTCN_RAWdescriptor_t ByteArray_raw_;
extern const TTCN_Typedescriptor_t ByteArray_descr_;
extern const XERdescriptor_t ByteArray_0_xer_;
extern const TTCN_JSONdescriptor_t ByteArray_0_json_;
extern const TTCN_OERdescriptor_t ByteArray_0_oer_;
extern const TTCN_Typedescriptor_t ByteArray_0_descr_;
extern const TTCN_RAWdescriptor_t RealByteString_raw_;
extern const TTCN_Typedescriptor_t RealByteString_descr_;
extern const TTCN_Typedescriptor_t& AudioData_descr_;
extern const TTCN_RAWdescriptor_t String_raw_;
extern const TTCN_Typedescriptor_t String_descr_;
extern const TTCN_RAWdescriptor_t NonNullString_stringLength_raw_;
extern const XERdescriptor_t NonNullString_stringLength_xer_;
extern const TTCN_JSONdescriptor_t NonNullString_stringLength_json_;
extern const TTCN_OERdescriptor_t NonNullString_stringLength_oer_;
extern const TTCN_Typedescriptor_t NonNullString_stringLength_descr_;
extern const XERdescriptor_t NonNullString_stringValue_xer_;
extern const TTCN_JSONdescriptor_t NonNullString_stringValue_json_;
extern const TTCN_Typedescriptor_t NonNullString_stringValue_descr_;
extern const TTCN_RAWdescriptor_t NonNullString_raw_;
extern const TTCN_Typedescriptor_t NonNullString_descr_;
extern const TTCN_Typedescriptor_t& LocaleId_descr_;
extern const TTCN_Typedescriptor_t& ContinuationPoint_descr_;
extern const TTCN_Typedescriptor_t& NumericRange_descr_;
extern const XERdescriptor_t NodeId_mask_xer_;
extern const TTCN_JSONdescriptor_t NodeId_mask_json_;
extern const TTCN_OERdescriptor_t NodeId_mask_oer_;
extern const TTCN_Typedescriptor_t NodeId_mask_descr_;
extern const XERdescriptor_t NodeId_namespaceUriBit_xer_;
extern const TTCN_JSONdescriptor_t NodeId_namespaceUriBit_json_;
extern const TTCN_OERdescriptor_t NodeId_namespaceUriBit_oer_;
extern const TTCN_Typedescriptor_t NodeId_namespaceUriBit_descr_;
extern const XERdescriptor_t NodeId_serverIndexBit_xer_;
extern const TTCN_JSONdescriptor_t NodeId_serverIndexBit_json_;
extern const TTCN_OERdescriptor_t NodeId_serverIndexBit_oer_;
extern const TTCN_Typedescriptor_t NodeId_serverIndexBit_descr_;
extern const XERdescriptor_t NodeId_reservedBit1_xer_;
extern const TTCN_JSONdescriptor_t NodeId_reservedBit1_json_;
extern const TTCN_OERdescriptor_t NodeId_reservedBit1_oer_;
extern const TTCN_Typedescriptor_t NodeId_reservedBit1_descr_;
extern const XERdescriptor_t NodeId_reservedBit2_xer_;
extern const TTCN_JSONdescriptor_t NodeId_reservedBit2_json_;
extern const TTCN_OERdescriptor_t NodeId_reservedBit2_oer_;
extern const TTCN_Typedescriptor_t NodeId_reservedBit2_descr_;
extern const TTCN_RAWdescriptor_t NodeIdType_raw_;
extern const TTCN_Typedescriptor_t NodeIdType_descr_;
extern const XERdescriptor_t TwoByteNodeId_nodeValue_xer_;
extern const TTCN_JSONdescriptor_t TwoByteNodeId_nodeValue_json_;
extern const TTCN_OERdescriptor_t TwoByteNodeId_nodeValue_oer_;
extern const TTCN_Typedescriptor_t TwoByteNodeId_nodeValue_descr_;
extern const TTCN_RAWdescriptor_t TwoByteNodeId_raw_;
extern const TTCN_Typedescriptor_t TwoByteNodeId_descr_;
extern const XERdescriptor_t FourByteNodeId_nameSpace_xer_;
extern const TTCN_JSONdescriptor_t FourByteNodeId_nameSpace_json_;
extern const TTCN_OERdescriptor_t FourByteNodeId_nameSpace_oer_;
extern const TTCN_Typedescriptor_t FourByteNodeId_nameSpace_descr_;
extern const XERdescriptor_t FourByteNodeId_nodeValue_xer_;
extern const TTCN_JSONdescriptor_t FourByteNodeId_nodeValue_json_;
extern const TTCN_OERdescriptor_t FourByteNodeId_nodeValue_oer_;
extern const TTCN_Typedescriptor_t FourByteNodeId_nodeValue_descr_;
extern const TTCN_RAWdescriptor_t FourByteNodeId_raw_;
extern const TTCN_Typedescriptor_t FourByteNodeId_descr_;
extern const XERdescriptor_t NumericNodeId_nameSpace_xer_;
extern const TTCN_JSONdescriptor_t NumericNodeId_nameSpace_json_;
extern const TTCN_OERdescriptor_t NumericNodeId_nameSpace_oer_;
extern const TTCN_Typedescriptor_t NumericNodeId_nameSpace_descr_;
extern const XERdescriptor_t NumericNodeId_nodeValue_xer_;
extern const TTCN_JSONdescriptor_t NumericNodeId_nodeValue_json_;
extern const TTCN_OERdescriptor_t NumericNodeId_nodeValue_oer_;
extern const TTCN_Typedescriptor_t NumericNodeId_nodeValue_descr_;
extern const TTCN_RAWdescriptor_t NumericNodeId_raw_;
extern const TTCN_Typedescriptor_t NumericNodeId_descr_;
extern const XERdescriptor_t StringNodeId_nameSpace_xer_;
extern const TTCN_JSONdescriptor_t StringNodeId_nameSpace_json_;
extern const TTCN_OERdescriptor_t StringNodeId_nameSpace_oer_;
extern const TTCN_Typedescriptor_t StringNodeId_nameSpace_descr_;
extern const TTCN_RAWdescriptor_t StringNodeId_raw_;
extern const TTCN_Typedescriptor_t StringNodeId_descr_;
extern const XERdescriptor_t GuidNodeId_nameSpace_xer_;
extern const TTCN_JSONdescriptor_t GuidNodeId_nameSpace_json_;
extern const TTCN_OERdescriptor_t GuidNodeId_nameSpace_oer_;
extern const TTCN_Typedescriptor_t GuidNodeId_nameSpace_descr_;
extern const XERdescriptor_t Guid_data1_xer_;
extern const TTCN_JSONdescriptor_t Guid_data1_json_;
extern const TTCN_OERdescriptor_t Guid_data1_oer_;
extern const TTCN_Typedescriptor_t Guid_data1_descr_;
extern const XERdescriptor_t Guid_data2_xer_;
extern const TTCN_JSONdescriptor_t Guid_data2_json_;
extern const TTCN_OERdescriptor_t Guid_data2_oer_;
extern const TTCN_Typedescriptor_t Guid_data2_descr_;
extern const XERdescriptor_t Guid_data3_xer_;
extern const TTCN_JSONdescriptor_t Guid_data3_json_;
extern const TTCN_OERdescriptor_t Guid_data3_oer_;
extern const TTCN_Typedescriptor_t Guid_data3_descr_;
extern const XERdescriptor_t Guid_data41_xer_;
extern const TTCN_JSONdescriptor_t Guid_data41_json_;
extern const TTCN_OERdescriptor_t Guid_data41_oer_;
extern const TTCN_Typedescriptor_t Guid_data41_descr_;
extern const XERdescriptor_t Guid_data42_xer_;
extern const TTCN_JSONdescriptor_t Guid_data42_json_;
extern const TTCN_OERdescriptor_t Guid_data42_oer_;
extern const TTCN_Typedescriptor_t Guid_data42_descr_;
extern const XERdescriptor_t Guid_data43_xer_;
extern const TTCN_JSONdescriptor_t Guid_data43_json_;
extern const TTCN_OERdescriptor_t Guid_data43_oer_;
extern const TTCN_Typedescriptor_t Guid_data43_descr_;
extern const XERdescriptor_t Guid_data44_xer_;
extern const TTCN_JSONdescriptor_t Guid_data44_json_;
extern const TTCN_OERdescriptor_t Guid_data44_oer_;
extern const TTCN_Typedescriptor_t Guid_data44_descr_;
extern const XERdescriptor_t Guid_data45_xer_;
extern const TTCN_JSONdescriptor_t Guid_data45_json_;
extern const TTCN_OERdescriptor_t Guid_data45_oer_;
extern const TTCN_Typedescriptor_t Guid_data45_descr_;
extern const XERdescriptor_t Guid_data46_xer_;
extern const TTCN_JSONdescriptor_t Guid_data46_json_;
extern const TTCN_OERdescriptor_t Guid_data46_oer_;
extern const TTCN_Typedescriptor_t Guid_data46_descr_;
extern const XERdescriptor_t Guid_data47_xer_;
extern const TTCN_JSONdescriptor_t Guid_data47_json_;
extern const TTCN_OERdescriptor_t Guid_data47_oer_;
extern const TTCN_Typedescriptor_t Guid_data47_descr_;
extern const XERdescriptor_t Guid_data48_xer_;
extern const TTCN_JSONdescriptor_t Guid_data48_json_;
extern const TTCN_OERdescriptor_t Guid_data48_oer_;
extern const TTCN_Typedescriptor_t Guid_data48_descr_;
extern const TTCN_RAWdescriptor_t Guid_raw_;
extern const TTCN_Typedescriptor_t Guid_descr_;
extern const TTCN_RAWdescriptor_t GuidNodeId_raw_;
extern const TTCN_Typedescriptor_t GuidNodeId_descr_;
extern const XERdescriptor_t ByteStringNodeId_nameSpace_xer_;
extern const TTCN_JSONdescriptor_t ByteStringNodeId_nameSpace_json_;
extern const TTCN_OERdescriptor_t ByteStringNodeId_nameSpace_oer_;
extern const TTCN_Typedescriptor_t ByteStringNodeId_nameSpace_descr_;
extern const TTCN_RAWdescriptor_t ByteStringNodeId_raw_;
extern const TTCN_Typedescriptor_t ByteStringNodeId_descr_;
extern const TTCN_RAWdescriptor_t NodeId_IdType_raw_;
extern const TTCN_Typedescriptor_t NodeId_IdType_descr_;
extern const TTCN_RAWdescriptor_t NodeId_raw_;
extern const TTCN_Typedescriptor_t NodeId_descr_;
extern const TTCN_Typedescriptor_t& SessionAuthenticationToken_descr_;
extern const TTCN_Typedescriptor_t& XmlElement_descr_;
extern const TTCN_RAWdescriptor_t ExpandedNodeId_raw_;
extern const TTCN_Typedescriptor_t ExpandedNodeId_descr_;
extern const TTCN_RAWdescriptor_t ExpandedNodeId_namespaceUri_raw_;
extern const TTCN_Typedescriptor_t ExpandedNodeId_namespaceUri_descr_;
extern const TTCN_RAWdescriptor_t ExpandedNodeId_serverIndex_raw_;
extern const XERdescriptor_t ExpandedNodeId_serverIndex_xer_;
extern const TTCN_JSONdescriptor_t ExpandedNodeId_serverIndex_json_;
extern const TTCN_OERdescriptor_t ExpandedNodeId_serverIndex_oer_;
extern const TTCN_Typedescriptor_t ExpandedNodeId_serverIndex_descr_;
extern const XERdescriptor_t ExtensibleParameter_encodingByte_xer_;
extern const TTCN_JSONdescriptor_t ExtensibleParameter_encodingByte_json_;
extern const TTCN_OERdescriptor_t ExtensibleParameter_encodingByte_oer_;
extern const TTCN_Typedescriptor_t ExtensibleParameter_encodingByte_descr_;
extern const XERdescriptor_t ExtensibleParameter_encoding_xer_;
extern const TTCN_JSONdescriptor_t ExtensibleParameter_encoding_json_;
extern const TTCN_OERdescriptor_t ExtensibleParameter_encoding_oer_;
extern const TTCN_Typedescriptor_t ExtensibleParameter_encoding_descr_;
extern const TTCN_RAWdescriptor_t ExtensibleParameter_raw_;
extern const TTCN_Typedescriptor_t ExtensibleParameter_descr_;
extern const TTCN_RAWdescriptor_t ExtensibleParameter_twoByteNodeValue_raw_;
extern const XERdescriptor_t ExtensibleParameter_twoByteNodeValue_xer_;
extern const TTCN_JSONdescriptor_t ExtensibleParameter_twoByteNodeValue_json_;
extern const TTCN_OERdescriptor_t ExtensibleParameter_twoByteNodeValue_oer_;
extern const TTCN_Typedescriptor_t ExtensibleParameter_twoByteNodeValue_descr_;
extern const TTCN_RAWdescriptor_t ExtensibleParameter_namespaceIndex_raw_;
extern const XERdescriptor_t ExtensibleParameter_namespaceIndex_xer_;
extern const TTCN_JSONdescriptor_t ExtensibleParameter_namespaceIndex_json_;
extern const TTCN_OERdescriptor_t ExtensibleParameter_namespaceIndex_oer_;
extern const TTCN_Typedescriptor_t ExtensibleParameter_namespaceIndex_descr_;
extern const TTCN_RAWdescriptor_t ExtensibleParameter_fourByteNodeValue_raw_;
extern const XERdescriptor_t ExtensibleParameter_fourByteNodeValue_xer_;
extern const TTCN_JSONdescriptor_t ExtensibleParameter_fourByteNodeValue_json_;
extern const TTCN_OERdescriptor_t ExtensibleParameter_fourByteNodeValue_oer_;
extern const TTCN_Typedescriptor_t ExtensibleParameter_fourByteNodeValue_descr_;
extern const TTCN_RAWdescriptor_t ExtensibleParameter_parameterLength_raw_;
extern const XERdescriptor_t ExtensibleParameter_parameterLength_xer_;
extern const TTCN_JSONdescriptor_t ExtensibleParameter_parameterLength_json_;
extern const TTCN_OERdescriptor_t ExtensibleParameter_parameterLength_oer_;
extern const TTCN_Typedescriptor_t ExtensibleParameter_parameterLength_descr_;
extern const TTCN_RAWdescriptor_t ExtensibleParameterBody_raw_;
extern const TTCN_Typedescriptor_t ExtensibleParameterBody_descr_;
extern const XERdescriptor_t ElementOperand_index_xer_;
extern const TTCN_JSONdescriptor_t ElementOperand_index_json_;
extern const TTCN_OERdescriptor_t ElementOperand_index_oer_;
extern const TTCN_Typedescriptor_t ElementOperand_index_descr_;
extern const TTCN_RAWdescriptor_t ElementOperand_raw_;
extern const TTCN_Typedescriptor_t ElementOperand_descr_;
extern const XERdescriptor_t Variant_encodingBits_xer_;
extern const TTCN_JSONdescriptor_t Variant_encodingBits_json_;
extern const TTCN_OERdescriptor_t Variant_encodingBits_oer_;
extern const TTCN_Typedescriptor_t Variant_encodingBits_descr_;
extern const XERdescriptor_t Variant_arrayDimensionsBit_xer_;
extern const TTCN_JSONdescriptor_t Variant_arrayDimensionsBit_json_;
extern const TTCN_OERdescriptor_t Variant_arrayDimensionsBit_oer_;
extern const TTCN_Typedescriptor_t Variant_arrayDimensionsBit_descr_;
extern const XERdescriptor_t Variant_arrayEncodedBit_xer_;
extern const TTCN_JSONdescriptor_t Variant_arrayEncodedBit_json_;
extern const TTCN_OERdescriptor_t Variant_arrayEncodedBit_oer_;
extern const TTCN_Typedescriptor_t Variant_arrayEncodedBit_descr_;
extern const TTCN_RAWdescriptor_t Variant_raw_;
extern const TTCN_Typedescriptor_t Variant_descr_;
extern const TTCN_RAWdescriptor_t Variant_arrayLength_raw_;
extern const XERdescriptor_t Variant_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t Variant_arrayLength_json_;
extern const TTCN_OERdescriptor_t Variant_arrayLength_oer_;
extern const TTCN_Typedescriptor_t Variant_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t VariantSingleValue_raw_;
extern const TTCN_Typedescriptor_t VariantSingleValue_descr_;
extern const XERdescriptor_t VariantSingleValue_bool__xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_bool__json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_bool__oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_bool__descr_;
extern const XERdescriptor_t VariantSingleValue_sbyte_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_sbyte_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_sbyte_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_sbyte_descr_;
extern const XERdescriptor_t VariantSingleValue_byte_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_byte_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_byte_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_byte_descr_;
extern const XERdescriptor_t VariantSingleValue_int16_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_int16_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_int16_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_int16_descr_;
extern const XERdescriptor_t VariantSingleValue_uint16_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_uint16_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_uint16_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_uint16_descr_;
extern const XERdescriptor_t VariantSingleValue_int32_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_int32_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_int32_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_int32_descr_;
extern const XERdescriptor_t VariantSingleValue_uint32_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_uint32_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_uint32_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_uint32_descr_;
extern const XERdescriptor_t VariantSingleValue_int64_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_int64_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_int64_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_int64_descr_;
extern const XERdescriptor_t VariantSingleValue_uint64_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_uint64_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_uint64_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_uint64_descr_;
extern const XERdescriptor_t VariantSingleValue_floatValue_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_floatValue_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_floatValue_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_floatValue_descr_;
extern const XERdescriptor_t VariantSingleValue_double__xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_double__json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_double__oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_double__descr_;
extern const XERdescriptor_t VariantSingleValue_datetime_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_datetime_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_datetime_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_datetime_descr_;
extern const XERdescriptor_t StatusCode_xer_;
extern const TTCN_JSONdescriptor_t StatusCode_json_;
extern const TTCN_OERdescriptor_t StatusCode_oer_;
extern const TTCN_Typedescriptor_t StatusCode_descr_;
extern const XERdescriptor_t VariantSingleValue_statuscode_xer_;
extern const TTCN_JSONdescriptor_t VariantSingleValue_statuscode_json_;
extern const TTCN_OERdescriptor_t VariantSingleValue_statuscode_oer_;
extern const TTCN_Typedescriptor_t VariantSingleValue_statuscode_descr_;
extern const XERdescriptor_t QualifiedName_namespaceIndex_xer_;
extern const TTCN_JSONdescriptor_t QualifiedName_namespaceIndex_json_;
extern const TTCN_OERdescriptor_t QualifiedName_namespaceIndex_oer_;
extern const TTCN_Typedescriptor_t QualifiedName_namespaceIndex_descr_;
extern const TTCN_RAWdescriptor_t QualifiedName_raw_;
extern const TTCN_Typedescriptor_t QualifiedName_descr_;
extern const XERdescriptor_t LocalizedText_localeBit_xer_;
extern const TTCN_JSONdescriptor_t LocalizedText_localeBit_json_;
extern const TTCN_OERdescriptor_t LocalizedText_localeBit_oer_;
extern const TTCN_Typedescriptor_t LocalizedText_localeBit_descr_;
extern const XERdescriptor_t LocalizedText_textBit_xer_;
extern const TTCN_JSONdescriptor_t LocalizedText_textBit_json_;
extern const TTCN_OERdescriptor_t LocalizedText_textBit_oer_;
extern const TTCN_Typedescriptor_t LocalizedText_textBit_descr_;
extern const XERdescriptor_t LocalizedText_spareBit1_xer_;
extern const TTCN_JSONdescriptor_t LocalizedText_spareBit1_json_;
extern const TTCN_OERdescriptor_t LocalizedText_spareBit1_oer_;
extern const TTCN_Typedescriptor_t LocalizedText_spareBit1_descr_;
extern const XERdescriptor_t LocalizedText_spareBit2_xer_;
extern const TTCN_JSONdescriptor_t LocalizedText_spareBit2_json_;
extern const TTCN_OERdescriptor_t LocalizedText_spareBit2_oer_;
extern const TTCN_Typedescriptor_t LocalizedText_spareBit2_descr_;
extern const XERdescriptor_t LocalizedText_spareBit3_xer_;
extern const TTCN_JSONdescriptor_t LocalizedText_spareBit3_json_;
extern const TTCN_OERdescriptor_t LocalizedText_spareBit3_oer_;
extern const TTCN_Typedescriptor_t LocalizedText_spareBit3_descr_;
extern const XERdescriptor_t LocalizedText_spareBit4_xer_;
extern const TTCN_JSONdescriptor_t LocalizedText_spareBit4_json_;
extern const TTCN_OERdescriptor_t LocalizedText_spareBit4_oer_;
extern const TTCN_Typedescriptor_t LocalizedText_spareBit4_descr_;
extern const XERdescriptor_t LocalizedText_spareBit5_xer_;
extern const TTCN_JSONdescriptor_t LocalizedText_spareBit5_json_;
extern const TTCN_OERdescriptor_t LocalizedText_spareBit5_oer_;
extern const TTCN_Typedescriptor_t LocalizedText_spareBit5_descr_;
extern const XERdescriptor_t LocalizedText_spareBit6_xer_;
extern const TTCN_JSONdescriptor_t LocalizedText_spareBit6_json_;
extern const TTCN_OERdescriptor_t LocalizedText_spareBit6_oer_;
extern const TTCN_Typedescriptor_t LocalizedText_spareBit6_descr_;
extern const TTCN_RAWdescriptor_t LocalizedText_raw_;
extern const TTCN_Typedescriptor_t LocalizedText_descr_;
extern const TTCN_RAWdescriptor_t LocalizedText_locale_raw_;
extern const TTCN_Typedescriptor_t LocalizedText_locale_descr_;
extern const TTCN_RAWdescriptor_t LocalizedText_text_raw_;
extern const TTCN_Typedescriptor_t LocalizedText_text_descr_;
extern const XERdescriptor_t ExtensionObject_encoding_xer_;
extern const TTCN_JSONdescriptor_t ExtensionObject_encoding_json_;
extern const TTCN_OERdescriptor_t ExtensionObject_encoding_oer_;
extern const TTCN_Typedescriptor_t ExtensionObject_encoding_descr_;
extern const XERdescriptor_t ExtensionObject_Length_xer_;
extern const TTCN_JSONdescriptor_t ExtensionObject_Length_json_;
extern const TTCN_OERdescriptor_t ExtensionObject_Length_oer_;
extern const TTCN_Typedescriptor_t ExtensionObject_Length_descr_;
extern const TTCN_RAWdescriptor_t ExtensionObject_raw_;
extern const TTCN_Typedescriptor_t ExtensionObject_descr_;
extern const TTCN_RAWdescriptor_t ExtensionObjectBody_raw_;
extern const TTCN_Typedescriptor_t ExtensionObjectBody_descr_;
extern const TTCN_RAWdescriptor_t ListOfByte_raw_;
extern const TTCN_Typedescriptor_t ListOfByte_descr_;
extern const TTCN_RAWdescriptor_t ListOfByteArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfByteArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfByteArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfByteArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfByteArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfByteArray_raw_;
extern const TTCN_Typedescriptor_t ListOfByteArray_descr_;
extern const XERdescriptor_t ExtensionObjectBody_xmlElement_xer_;
extern const TTCN_JSONdescriptor_t ExtensionObjectBody_xmlElement_json_;
extern const TTCN_OERdescriptor_t ExtensionObjectBody_xmlElement_oer_;
extern const TTCN_Typedescriptor_t ExtensionObjectBody_xmlElement_descr_;
extern const TTCN_RAWdescriptor_t ExtensionObject_body_raw_;
extern const TTCN_Typedescriptor_t ExtensionObject_body_descr_;
extern const XERdescriptor_t DataValue_ValueBit_xer_;
extern const TTCN_JSONdescriptor_t DataValue_ValueBit_json_;
extern const TTCN_OERdescriptor_t DataValue_ValueBit_oer_;
extern const TTCN_Typedescriptor_t DataValue_ValueBit_descr_;
extern const XERdescriptor_t DataValue_statusBit_xer_;
extern const TTCN_JSONdescriptor_t DataValue_statusBit_json_;
extern const TTCN_OERdescriptor_t DataValue_statusBit_oer_;
extern const TTCN_Typedescriptor_t DataValue_statusBit_descr_;
extern const XERdescriptor_t DataValue_sourceTimestampBit_xer_;
extern const TTCN_JSONdescriptor_t DataValue_sourceTimestampBit_json_;
extern const TTCN_OERdescriptor_t DataValue_sourceTimestampBit_oer_;
extern const TTCN_Typedescriptor_t DataValue_sourceTimestampBit_descr_;
extern const XERdescriptor_t DataValue_serverTimestampBit_xer_;
extern const TTCN_JSONdescriptor_t DataValue_serverTimestampBit_json_;
extern const TTCN_OERdescriptor_t DataValue_serverTimestampBit_oer_;
extern const TTCN_Typedescriptor_t DataValue_serverTimestampBit_descr_;
extern const XERdescriptor_t DataValue_sourcePicoSecondsBit_xer_;
extern const TTCN_JSONdescriptor_t DataValue_sourcePicoSecondsBit_json_;
extern const TTCN_OERdescriptor_t DataValue_sourcePicoSecondsBit_oer_;
extern const TTCN_Typedescriptor_t DataValue_sourcePicoSecondsBit_descr_;
extern const XERdescriptor_t DataValue_serverPicoSecondsBit_xer_;
extern const TTCN_JSONdescriptor_t DataValue_serverPicoSecondsBit_json_;
extern const TTCN_OERdescriptor_t DataValue_serverPicoSecondsBit_oer_;
extern const TTCN_Typedescriptor_t DataValue_serverPicoSecondsBit_descr_;
extern const XERdescriptor_t DataValue_spareBit1_xer_;
extern const TTCN_JSONdescriptor_t DataValue_spareBit1_json_;
extern const TTCN_OERdescriptor_t DataValue_spareBit1_oer_;
extern const TTCN_Typedescriptor_t DataValue_spareBit1_descr_;
extern const XERdescriptor_t DataValue_spareBit2_xer_;
extern const TTCN_JSONdescriptor_t DataValue_spareBit2_json_;
extern const TTCN_OERdescriptor_t DataValue_spareBit2_oer_;
extern const TTCN_Typedescriptor_t DataValue_spareBit2_descr_;
extern const TTCN_RAWdescriptor_t DataValue_raw_;
extern const TTCN_Typedescriptor_t DataValue_descr_;
extern const TTCN_RAWdescriptor_t DataValue_Value_raw_;
extern const TTCN_Typedescriptor_t DataValue_Value_descr_;
extern const TTCN_RAWdescriptor_t DataValue_status_raw_;
extern const XERdescriptor_t DataValue_status_xer_;
extern const TTCN_JSONdescriptor_t DataValue_status_json_;
extern const TTCN_OERdescriptor_t DataValue_status_oer_;
extern const TTCN_Typedescriptor_t DataValue_status_descr_;
extern const TTCN_RAWdescriptor_t DataValue_sourceTimestamp_raw_;
extern const XERdescriptor_t DataValue_sourceTimestamp_xer_;
extern const TTCN_JSONdescriptor_t DataValue_sourceTimestamp_json_;
extern const TTCN_OERdescriptor_t DataValue_sourceTimestamp_oer_;
extern const TTCN_Typedescriptor_t DataValue_sourceTimestamp_descr_;
extern const TTCN_RAWdescriptor_t DataValue_sourcePicoSeconds_raw_;
extern const XERdescriptor_t DataValue_sourcePicoSeconds_xer_;
extern const TTCN_JSONdescriptor_t DataValue_sourcePicoSeconds_json_;
extern const TTCN_OERdescriptor_t DataValue_sourcePicoSeconds_oer_;
extern const TTCN_Typedescriptor_t DataValue_sourcePicoSeconds_descr_;
extern const TTCN_RAWdescriptor_t DataValue_serverTimestamp_raw_;
extern const XERdescriptor_t DataValue_serverTimestamp_xer_;
extern const TTCN_JSONdescriptor_t DataValue_serverTimestamp_json_;
extern const TTCN_OERdescriptor_t DataValue_serverTimestamp_oer_;
extern const TTCN_Typedescriptor_t DataValue_serverTimestamp_descr_;
extern const TTCN_RAWdescriptor_t DataValue_serverPicoSeconds_raw_;
extern const XERdescriptor_t DataValue_serverPicoSeconds_xer_;
extern const TTCN_JSONdescriptor_t DataValue_serverPicoSeconds_json_;
extern const TTCN_OERdescriptor_t DataValue_serverPicoSeconds_oer_;
extern const TTCN_Typedescriptor_t DataValue_serverPicoSeconds_descr_;
extern const TTCN_RAWdescriptor_t ListOfVariant_raw_;
extern const TTCN_Typedescriptor_t ListOfVariant_descr_;
extern const TTCN_RAWdescriptor_t ListOfVariantArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfVariantArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfVariantArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfVariantArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfVariantArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t VariantArray_raw_;
extern const TTCN_Typedescriptor_t VariantArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfVariantArray_raw_;
extern const TTCN_Typedescriptor_t ListOfVariantArray_descr_;
extern const XERdescriptor_t DiagnosticInfo_symbolicIdBit_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_symbolicIdBit_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_symbolicIdBit_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_symbolicIdBit_descr_;
extern const XERdescriptor_t DiagnosticInfo_namespaceUriBit_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_namespaceUriBit_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_namespaceUriBit_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_namespaceUriBit_descr_;
extern const XERdescriptor_t DiagnosticInfo_localeBit_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_localeBit_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_localeBit_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_localeBit_descr_;
extern const XERdescriptor_t DiagnosticInfo_localisedTextBit_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_localisedTextBit_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_localisedTextBit_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_localisedTextBit_descr_;
extern const XERdescriptor_t DiagnosticInfo_additionalInfoBit_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_additionalInfoBit_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_additionalInfoBit_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_additionalInfoBit_descr_;
extern const XERdescriptor_t DiagnosticInfo_innerStatusCodeBit_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_innerStatusCodeBit_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_innerStatusCodeBit_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_innerStatusCodeBit_descr_;
extern const XERdescriptor_t DiagnosticInfo_innerDiagnosticInfoBit_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_innerDiagnosticInfoBit_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_innerDiagnosticInfoBit_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_innerDiagnosticInfoBit_descr_;
extern const XERdescriptor_t DiagnosticInfo_reserveBit_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_reserveBit_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_reserveBit_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_reserveBit_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfo_raw_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfo_symbolicId_raw_;
extern const XERdescriptor_t DiagnosticInfo_symbolicId_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_symbolicId_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_symbolicId_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_symbolicId_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfo_namespaceUri_raw_;
extern const XERdescriptor_t DiagnosticInfo_namespaceUri_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_namespaceUri_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_namespaceUri_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_namespaceUri_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfo_locale_raw_;
extern const XERdescriptor_t DiagnosticInfo_locale_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_locale_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_locale_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_locale_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfo_localisedText_raw_;
extern const XERdescriptor_t DiagnosticInfo_localisedText_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_localisedText_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_localisedText_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_localisedText_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfo_additionalInfo_raw_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_additionalInfo_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfo_innerStatusCode_raw_;
extern const XERdescriptor_t DiagnosticInfo_innerStatusCode_xer_;
extern const TTCN_JSONdescriptor_t DiagnosticInfo_innerStatusCode_json_;
extern const TTCN_OERdescriptor_t DiagnosticInfo_innerStatusCode_oer_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_innerStatusCode_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfo_innerDiagnosticInfo_raw_;
extern const TTCN_Typedescriptor_t DiagnosticInfo_innerDiagnosticInfo_descr_;
extern const TTCN_RAWdescriptor_t Variant_ValueSingle_raw_;
extern const TTCN_Typedescriptor_t Variant_ValueSingle_descr_;
extern const TTCN_RAWdescriptor_t VariantArrayValue_raw_;
extern const TTCN_Typedescriptor_t VariantArrayValue_descr_;
extern const TTCN_RAWdescriptor_t ListOfBoolean_raw_;
extern const TTCN_Typedescriptor_t ListOfBoolean_descr_;
extern const TTCN_RAWdescriptor_t ListOfBooleanArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfBooleanArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfBooleanArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfBooleanArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfBooleanArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t BooleanArray_raw_;
extern const TTCN_Typedescriptor_t BooleanArray_descr_;
extern const XERdescriptor_t BooleanArray_0_xer_;
extern const TTCN_JSONdescriptor_t BooleanArray_0_json_;
extern const TTCN_OERdescriptor_t BooleanArray_0_oer_;
extern const TTCN_Typedescriptor_t BooleanArray_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfBooleanArray_raw_;
extern const TTCN_Typedescriptor_t ListOfBooleanArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfSByte_raw_;
extern const TTCN_Typedescriptor_t ListOfSByte_descr_;
extern const TTCN_RAWdescriptor_t ListOfSByteArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfSByteArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfSByteArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfSByteArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfSByteArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t SByteArray_raw_;
extern const TTCN_Typedescriptor_t SByteArray_descr_;
extern const XERdescriptor_t SByteArray_0_xer_;
extern const TTCN_JSONdescriptor_t SByteArray_0_json_;
extern const TTCN_OERdescriptor_t SByteArray_0_oer_;
extern const TTCN_Typedescriptor_t SByteArray_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfSByteArray_raw_;
extern const TTCN_Typedescriptor_t ListOfSByteArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt16_raw_;
extern const TTCN_Typedescriptor_t ListOfInt16_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt16Array_arrayLength_raw_;
extern const XERdescriptor_t ListOfInt16Array_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfInt16Array_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfInt16Array_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfInt16Array_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t Int16Array_raw_;
extern const TTCN_Typedescriptor_t Int16Array_descr_;
extern const XERdescriptor_t Int16Array_0_xer_;
extern const TTCN_JSONdescriptor_t Int16Array_0_json_;
extern const TTCN_OERdescriptor_t Int16Array_0_oer_;
extern const TTCN_Typedescriptor_t Int16Array_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt16Array_raw_;
extern const TTCN_Typedescriptor_t ListOfInt16Array_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt16_raw_;
extern const TTCN_Typedescriptor_t ListOfUInt16_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt16Array_arrayLength_raw_;
extern const XERdescriptor_t ListOfUInt16Array_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfUInt16Array_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfUInt16Array_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfUInt16Array_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t UInt16Array_raw_;
extern const TTCN_Typedescriptor_t UInt16Array_descr_;
extern const XERdescriptor_t UInt16Array_0_xer_;
extern const TTCN_JSONdescriptor_t UInt16Array_0_json_;
extern const TTCN_OERdescriptor_t UInt16Array_0_oer_;
extern const TTCN_Typedescriptor_t UInt16Array_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt16Array_raw_;
extern const TTCN_Typedescriptor_t ListOfUInt16Array_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt32_raw_;
extern const TTCN_Typedescriptor_t ListOfInt32_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt32Array_arrayLength_raw_;
extern const XERdescriptor_t ListOfInt32Array_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfInt32Array_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfInt32Array_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfInt32Array_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t Int32Array_raw_;
extern const TTCN_Typedescriptor_t Int32Array_descr_;
extern const XERdescriptor_t Int32Array_0_xer_;
extern const TTCN_JSONdescriptor_t Int32Array_0_json_;
extern const TTCN_OERdescriptor_t Int32Array_0_oer_;
extern const TTCN_Typedescriptor_t Int32Array_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt32Array_raw_;
extern const TTCN_Typedescriptor_t ListOfInt32Array_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt32_raw_;
extern const TTCN_Typedescriptor_t ListOfUInt32_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt32Array_arrayLength_raw_;
extern const XERdescriptor_t ListOfUInt32Array_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfUInt32Array_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfUInt32Array_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfUInt32Array_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t UInt32Array_raw_;
extern const TTCN_Typedescriptor_t UInt32Array_descr_;
extern const XERdescriptor_t UInt32Array_0_xer_;
extern const TTCN_JSONdescriptor_t UInt32Array_0_json_;
extern const TTCN_OERdescriptor_t UInt32Array_0_oer_;
extern const TTCN_Typedescriptor_t UInt32Array_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt32Array_raw_;
extern const TTCN_Typedescriptor_t ListOfUInt32Array_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt64_raw_;
extern const TTCN_Typedescriptor_t ListOfInt64_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt64Array_arrayLength_raw_;
extern const XERdescriptor_t ListOfInt64Array_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfInt64Array_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfInt64Array_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfInt64Array_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t Int64Array_raw_;
extern const TTCN_Typedescriptor_t Int64Array_descr_;
extern const XERdescriptor_t Int64Array_0_xer_;
extern const TTCN_JSONdescriptor_t Int64Array_0_json_;
extern const TTCN_OERdescriptor_t Int64Array_0_oer_;
extern const TTCN_Typedescriptor_t Int64Array_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfInt64Array_raw_;
extern const TTCN_Typedescriptor_t ListOfInt64Array_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt64_raw_;
extern const TTCN_Typedescriptor_t ListOfUInt64_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt64Array_arrayLength_raw_;
extern const XERdescriptor_t ListOfUInt64Array_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfUInt64Array_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfUInt64Array_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfUInt64Array_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t UInt64Array_raw_;
extern const TTCN_Typedescriptor_t UInt64Array_descr_;
extern const XERdescriptor_t UInt64Array_0_xer_;
extern const TTCN_JSONdescriptor_t UInt64Array_0_json_;
extern const TTCN_OERdescriptor_t UInt64Array_0_oer_;
extern const TTCN_Typedescriptor_t UInt64Array_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfUInt64Array_raw_;
extern const TTCN_Typedescriptor_t ListOfUInt64Array_descr_;
extern const TTCN_RAWdescriptor_t ListOfFloat_raw_;
extern const TTCN_Typedescriptor_t ListOfFloat_descr_;
extern const TTCN_RAWdescriptor_t ListOfFloatArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfFloatArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfFloatArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfFloatArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfFloatArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t FloatArray_raw_;
extern const TTCN_Typedescriptor_t FloatArray_descr_;
extern const XERdescriptor_t FloatArray_0_xer_;
extern const TTCN_JSONdescriptor_t FloatArray_0_json_;
extern const TTCN_OERdescriptor_t FloatArray_0_oer_;
extern const TTCN_Typedescriptor_t FloatArray_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfFloatArray_raw_;
extern const TTCN_Typedescriptor_t ListOfFloatArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDouble_raw_;
extern const TTCN_Typedescriptor_t ListOfDouble_descr_;
extern const TTCN_RAWdescriptor_t ListOfDoubleArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfDoubleArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfDoubleArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfDoubleArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfDoubleArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t DoubleArray_raw_;
extern const TTCN_Typedescriptor_t DoubleArray_descr_;
extern const XERdescriptor_t DoubleArray_0_xer_;
extern const TTCN_JSONdescriptor_t DoubleArray_0_json_;
extern const TTCN_OERdescriptor_t DoubleArray_0_oer_;
extern const TTCN_Typedescriptor_t DoubleArray_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfDoubleArray_raw_;
extern const TTCN_Typedescriptor_t ListOfDoubleArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfString_raw_;
extern const TTCN_Typedescriptor_t ListOfString_descr_;
extern const TTCN_RAWdescriptor_t ListOfStringArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfStringArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfStringArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfStringArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfStringArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t StringArray_raw_;
extern const TTCN_Typedescriptor_t StringArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfStringArray_raw_;
extern const TTCN_Typedescriptor_t ListOfStringArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDateTime_raw_;
extern const TTCN_Typedescriptor_t ListOfDateTime_descr_;
extern const TTCN_RAWdescriptor_t ListOfDateTimeArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfDateTimeArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfDateTimeArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfDateTimeArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfDateTimeArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t DateTimeArray_raw_;
extern const TTCN_Typedescriptor_t DateTimeArray_descr_;
extern const XERdescriptor_t DateTimeArray_0_xer_;
extern const TTCN_JSONdescriptor_t DateTimeArray_0_json_;
extern const TTCN_OERdescriptor_t DateTimeArray_0_oer_;
extern const TTCN_Typedescriptor_t DateTimeArray_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfDateTimeArray_raw_;
extern const TTCN_Typedescriptor_t ListOfDateTimeArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfGuid_raw_;
extern const TTCN_Typedescriptor_t ListOfGuid_descr_;
extern const TTCN_RAWdescriptor_t ListOfGuidArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfGuidArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfGuidArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfGuidArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfGuidArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t GuidArray_raw_;
extern const TTCN_Typedescriptor_t GuidArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfGuidArray_raw_;
extern const TTCN_Typedescriptor_t ListOfGuidArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfByteString_raw_;
extern const TTCN_Typedescriptor_t ListOfByteString_descr_;
extern const TTCN_RAWdescriptor_t ListOfByteStringArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfByteStringArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfByteStringArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfByteStringArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfByteStringArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ByteStringArray_raw_;
extern const TTCN_Typedescriptor_t ByteStringArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfByteStringArray_raw_;
extern const TTCN_Typedescriptor_t ListOfByteStringArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfXmlElement_raw_;
extern const TTCN_Typedescriptor_t ListOfXmlElement_descr_;
extern const TTCN_RAWdescriptor_t ListOfXmlElementArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfXmlElementArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfXmlElementArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfXmlElementArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfXmlElementArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t XmlElementArray_raw_;
extern const TTCN_Typedescriptor_t XmlElementArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfXmlElementArray_raw_;
extern const TTCN_Typedescriptor_t ListOfXmlElementArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfNodeId_raw_;
extern const TTCN_Typedescriptor_t ListOfNodeId_descr_;
extern const TTCN_RAWdescriptor_t ListOfNodeIdArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfNodeIdArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfNodeIdArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfNodeIdArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfNodeIdArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t NodeIdArray_raw_;
extern const TTCN_Typedescriptor_t NodeIdArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfNodeIdArray_raw_;
extern const TTCN_Typedescriptor_t ListOfNodeIdArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfExpandedNodeId_raw_;
extern const TTCN_Typedescriptor_t ListOfExpandedNodeId_descr_;
extern const TTCN_RAWdescriptor_t ListOfExpandedNodeIdArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfExpandedNodeIdArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfExpandedNodeIdArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfExpandedNodeIdArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfExpandedNodeIdArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ExpandedNodeIdArray_raw_;
extern const TTCN_Typedescriptor_t ExpandedNodeIdArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfExpandedNodeIdArray_raw_;
extern const TTCN_Typedescriptor_t ListOfExpandedNodeIdArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfStatusCode_raw_;
extern const TTCN_Typedescriptor_t ListOfStatusCode_descr_;
extern const TTCN_RAWdescriptor_t ListOfStatusCodeArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfStatusCodeArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfStatusCodeArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfStatusCodeArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfStatusCodeArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t StatusCodeArray_raw_;
extern const TTCN_Typedescriptor_t StatusCodeArray_descr_;
extern const XERdescriptor_t StatusCodeArray_0_xer_;
extern const TTCN_JSONdescriptor_t StatusCodeArray_0_json_;
extern const TTCN_OERdescriptor_t StatusCodeArray_0_oer_;
extern const TTCN_Typedescriptor_t StatusCodeArray_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfStatusCodeArray_raw_;
extern const TTCN_Typedescriptor_t ListOfStatusCodeArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfQualifiedName_raw_;
extern const TTCN_Typedescriptor_t ListOfQualifiedName_descr_;
extern const TTCN_RAWdescriptor_t ListOfQualifiedNameArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfQualifiedNameArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfQualifiedNameArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfQualifiedNameArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfQualifiedNameArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t QualifiedNameArray_raw_;
extern const TTCN_Typedescriptor_t QualifiedNameArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfQualifiedNameArray_raw_;
extern const TTCN_Typedescriptor_t ListOfQualifiedNameArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfLocalizedText_raw_;
extern const TTCN_Typedescriptor_t ListOfLocalizedText_descr_;
extern const TTCN_RAWdescriptor_t ListOfLocalizedTextArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfLocalizedTextArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfLocalizedTextArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfLocalizedTextArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfLocalizedTextArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t LocalizedTextArray_raw_;
extern const TTCN_Typedescriptor_t LocalizedTextArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfLocalizedTextArray_raw_;
extern const TTCN_Typedescriptor_t ListOfLocalizedTextArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfExtensionObject_raw_;
extern const TTCN_Typedescriptor_t ListOfExtensionObject_descr_;
extern const TTCN_RAWdescriptor_t ListOfExtensionObjectArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfExtensionObjectArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfExtensionObjectArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfExtensionObjectArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfExtensionObjectArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ExtensionObjectArray_raw_;
extern const TTCN_Typedescriptor_t ExtensionObjectArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfExtensionObjectArray_raw_;
extern const TTCN_Typedescriptor_t ListOfExtensionObjectArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDataValue_raw_;
extern const TTCN_Typedescriptor_t ListOfDataValue_descr_;
extern const TTCN_RAWdescriptor_t ListOfDataValueArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfDataValueArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfDataValueArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfDataValueArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfDataValueArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t DataValueArray_raw_;
extern const TTCN_Typedescriptor_t DataValueArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDataValueArray_raw_;
extern const TTCN_Typedescriptor_t ListOfDataValueArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDiagnosticInfo_raw_;
extern const TTCN_Typedescriptor_t ListOfDiagnosticInfo_descr_;
extern const TTCN_RAWdescriptor_t ListOfDiagnosticInfoArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfDiagnosticInfoArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfDiagnosticInfoArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfDiagnosticInfoArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfDiagnosticInfoArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t DiagnosticInfoArray_raw_;
extern const TTCN_Typedescriptor_t DiagnosticInfoArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDiagnosticInfoArray_raw_;
extern const TTCN_Typedescriptor_t ListOfDiagnosticInfoArray_descr_;
extern const TTCN_RAWdescriptor_t Variant_ValueArray_raw_;
extern const TTCN_Typedescriptor_t Variant_ValueArray_descr_;
extern const TTCN_RAWdescriptor_t Variant_arrayDimensionsLenght_raw_;
extern const XERdescriptor_t Variant_arrayDimensionsLenght_xer_;
extern const TTCN_JSONdescriptor_t Variant_arrayDimensionsLenght_json_;
extern const TTCN_OERdescriptor_t Variant_arrayDimensionsLenght_oer_;
extern const TTCN_Typedescriptor_t Variant_arrayDimensionsLenght_descr_;
extern const TTCN_RAWdescriptor_t Variant_arrayDimensions_raw_;
extern const TTCN_Typedescriptor_t Variant_arrayDimensions_descr_;
extern const TTCN_Typedescriptor_t& BaseDataType_descr_;
extern const TTCN_RAWdescriptor_t LiteralOperand_raw_;
extern const TTCN_Typedescriptor_t LiteralOperand_descr_;
extern const TTCN_RAWdescriptor_t ListOfRelativePathElement_raw_;
extern const TTCN_Typedescriptor_t ListOfRelativePathElement_descr_;
extern const TTCN_RAWdescriptor_t ListOfRelativePathElementArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfRelativePathElementArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfRelativePathElementArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfRelativePathElementArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfRelativePathElementArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t RelativePathElementArray_raw_;
extern const TTCN_Typedescriptor_t RelativePathElementArray_descr_;
extern const XERdescriptor_t RelativePathElement_isInverse_xer_;
extern const TTCN_JSONdescriptor_t RelativePathElement_isInverse_json_;
extern const TTCN_OERdescriptor_t RelativePathElement_isInverse_oer_;
extern const TTCN_Typedescriptor_t RelativePathElement_isInverse_descr_;
extern const XERdescriptor_t RelativePathElement_includeSubtypes_xer_;
extern const TTCN_JSONdescriptor_t RelativePathElement_includeSubtypes_json_;
extern const TTCN_OERdescriptor_t RelativePathElement_includeSubtypes_oer_;
extern const TTCN_Typedescriptor_t RelativePathElement_includeSubtypes_descr_;
extern const TTCN_RAWdescriptor_t RelativePathElement_raw_;
extern const TTCN_Typedescriptor_t RelativePathElement_descr_;
extern const TTCN_RAWdescriptor_t ListOfRelativePathElementArray_raw_;
extern const TTCN_Typedescriptor_t ListOfRelativePathElementArray_descr_;
extern const TTCN_RAWdescriptor_t RelativePath_raw_;
extern const TTCN_Typedescriptor_t RelativePath_descr_;
extern const XERdescriptor_t AttributeOperand_attributeId_xer_;
extern const TTCN_JSONdescriptor_t AttributeOperand_attributeId_json_;
extern const TTCN_OERdescriptor_t AttributeOperand_attributeId_oer_;
extern const TTCN_Typedescriptor_t AttributeOperand_attributeId_descr_;
extern const TTCN_RAWdescriptor_t AttributeOperand_raw_;
extern const TTCN_Typedescriptor_t AttributeOperand_descr_;
extern const XERdescriptor_t SimpleAttributeOperand_attributeId_xer_;
extern const TTCN_JSONdescriptor_t SimpleAttributeOperand_attributeId_json_;
extern const TTCN_OERdescriptor_t SimpleAttributeOperand_attributeId_oer_;
extern const TTCN_Typedescriptor_t SimpleAttributeOperand_attributeId_descr_;
extern const TTCN_RAWdescriptor_t SimpleAttributeOperand_raw_;
extern const TTCN_Typedescriptor_t SimpleAttributeOperand_descr_;
extern const XERdescriptor_t DataChangeFilter_deadbandType_xer_;
extern const TTCN_JSONdescriptor_t DataChangeFilter_deadbandType_json_;
extern const TTCN_OERdescriptor_t DataChangeFilter_deadbandType_oer_;
extern const TTCN_Typedescriptor_t DataChangeFilter_deadbandType_descr_;
extern const XERdescriptor_t DataChangeFilter_deadbandValue_xer_;
extern const TTCN_JSONdescriptor_t DataChangeFilter_deadbandValue_json_;
extern const TTCN_OERdescriptor_t DataChangeFilter_deadbandValue_oer_;
extern const TTCN_Typedescriptor_t DataChangeFilter_deadbandValue_descr_;
extern const TTCN_RAWdescriptor_t DataChangeFilter_raw_;
extern const TTCN_Typedescriptor_t DataChangeFilter_descr_;
extern const TTCN_RAWdescriptor_t ListOfSimpleAttributeOperand_raw_;
extern const TTCN_Typedescriptor_t ListOfSimpleAttributeOperand_descr_;
extern const TTCN_RAWdescriptor_t ListOfSimpleAttributeOperandArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfSimpleAttributeOperandArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfSimpleAttributeOperandArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfSimpleAttributeOperandArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfSimpleAttributeOperandArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t SimpleAttributeOperandArray_raw_;
extern const TTCN_Typedescriptor_t SimpleAttributeOperandArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfSimpleAttributeOperandArray_raw_;
extern const TTCN_Typedescriptor_t ListOfSimpleAttributeOperandArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfContentFilterElement_raw_;
extern const TTCN_Typedescriptor_t ListOfContentFilterElement_descr_;
extern const TTCN_RAWdescriptor_t ListOfContentFilterElementArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfContentFilterElementArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfContentFilterElementArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfContentFilterElementArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfContentFilterElementArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ContentFilterElementArray_raw_;
extern const TTCN_Typedescriptor_t ContentFilterElementArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfExtensibleParameter_raw_;
extern const TTCN_Typedescriptor_t ListOfExtensibleParameter_descr_;
extern const TTCN_RAWdescriptor_t ListOfExtensibleParameterArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfExtensibleParameterArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfExtensibleParameterArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfExtensibleParameterArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfExtensibleParameterArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ExtensibleParameterArray_raw_;
extern const TTCN_Typedescriptor_t ExtensibleParameterArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfExtensibleParameterArray_raw_;
extern const TTCN_Typedescriptor_t ListOfExtensibleParameterArray_descr_;
extern const TTCN_RAWdescriptor_t ContentFilterElement_raw_;
extern const TTCN_Typedescriptor_t ContentFilterElement_descr_;
extern const TTCN_RAWdescriptor_t ListOfContentFilterElementArray_raw_;
extern const TTCN_Typedescriptor_t ListOfContentFilterElementArray_descr_;
extern const TTCN_RAWdescriptor_t ContentFilter_raw_;
extern const TTCN_Typedescriptor_t ContentFilter_descr_;
extern const TTCN_RAWdescriptor_t EventFilter_raw_;
extern const TTCN_Typedescriptor_t EventFilter_descr_;
extern const XERdescriptor_t AggregateFilter_startTime_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilter_startTime_json_;
extern const TTCN_OERdescriptor_t AggregateFilter_startTime_oer_;
extern const TTCN_Typedescriptor_t AggregateFilter_startTime_descr_;
extern const XERdescriptor_t AggregateFilter_processingInterval_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilter_processingInterval_json_;
extern const TTCN_OERdescriptor_t AggregateFilter_processingInterval_oer_;
extern const TTCN_Typedescriptor_t AggregateFilter_processingInterval_descr_;
extern const XERdescriptor_t AggregateConfiguration_TreatUncertainAsBad_xer_;
extern const TTCN_JSONdescriptor_t AggregateConfiguration_TreatUncertainAsBad_json_;
extern const TTCN_OERdescriptor_t AggregateConfiguration_TreatUncertainAsBad_oer_;
extern const TTCN_Typedescriptor_t AggregateConfiguration_TreatUncertainAsBad_descr_;
extern const XERdescriptor_t AggregateConfiguration_useSeverCapabilitiesDefaults_xer_;
extern const TTCN_JSONdescriptor_t AggregateConfiguration_useSeverCapabilitiesDefaults_json_;
extern const TTCN_OERdescriptor_t AggregateConfiguration_useSeverCapabilitiesDefaults_oer_;
extern const TTCN_Typedescriptor_t AggregateConfiguration_useSeverCapabilitiesDefaults_descr_;
extern const XERdescriptor_t AggregateConfiguration_PercentDataBad_xer_;
extern const TTCN_JSONdescriptor_t AggregateConfiguration_PercentDataBad_json_;
extern const TTCN_OERdescriptor_t AggregateConfiguration_PercentDataBad_oer_;
extern const TTCN_Typedescriptor_t AggregateConfiguration_PercentDataBad_descr_;
extern const XERdescriptor_t AggregateConfiguration_PercentDataGood_xer_;
extern const TTCN_JSONdescriptor_t AggregateConfiguration_PercentDataGood_json_;
extern const TTCN_OERdescriptor_t AggregateConfiguration_PercentDataGood_oer_;
extern const TTCN_Typedescriptor_t AggregateConfiguration_PercentDataGood_descr_;
extern const XERdescriptor_t AggregateConfiguration_UseSlopedExtrapolation_xer_;
extern const TTCN_JSONdescriptor_t AggregateConfiguration_UseSlopedExtrapolation_json_;
extern const TTCN_OERdescriptor_t AggregateConfiguration_UseSlopedExtrapolation_oer_;
extern const TTCN_Typedescriptor_t AggregateConfiguration_UseSlopedExtrapolation_descr_;
extern const TTCN_RAWdescriptor_t AggregateConfiguration_raw_;
extern const TTCN_Typedescriptor_t AggregateConfiguration_descr_;
extern const XERdescriptor_t AggregateFilter_useServerCapabilitiesDefaults_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilter_useServerCapabilitiesDefaults_json_;
extern const TTCN_OERdescriptor_t AggregateFilter_useServerCapabilitiesDefaults_oer_;
extern const TTCN_Typedescriptor_t AggregateFilter_useServerCapabilitiesDefaults_descr_;
extern const XERdescriptor_t AggregateFilter_treatUncertainAsBad_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilter_treatUncertainAsBad_json_;
extern const TTCN_OERdescriptor_t AggregateFilter_treatUncertainAsBad_oer_;
extern const TTCN_Typedescriptor_t AggregateFilter_treatUncertainAsBad_descr_;
extern const XERdescriptor_t AggregateFilter_percentDataBad_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilter_percentDataBad_json_;
extern const TTCN_OERdescriptor_t AggregateFilter_percentDataBad_oer_;
extern const TTCN_Typedescriptor_t AggregateFilter_percentDataBad_descr_;
extern const XERdescriptor_t AggregateFilter_percentDataGood_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilter_percentDataGood_json_;
extern const TTCN_OERdescriptor_t AggregateFilter_percentDataGood_oer_;
extern const TTCN_Typedescriptor_t AggregateFilter_percentDataGood_descr_;
extern const XERdescriptor_t AggregateFilter_useSlopedExtrapolation_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilter_useSlopedExtrapolation_json_;
extern const TTCN_OERdescriptor_t AggregateFilter_useSlopedExtrapolation_oer_;
extern const TTCN_Typedescriptor_t AggregateFilter_useSlopedExtrapolation_descr_;
extern const TTCN_RAWdescriptor_t AggregateFilter_raw_;
extern const TTCN_Typedescriptor_t AggregateFilter_descr_;
extern const TTCN_RAWdescriptor_t ListOfContentFilterElementResult_raw_;
extern const TTCN_Typedescriptor_t ListOfContentFilterElementResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfContentFilterElementResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfContentFilterElementResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfContentFilterElementResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfContentFilterElementResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfContentFilterElementResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ContentFilterElementResultArray_raw_;
extern const TTCN_Typedescriptor_t ContentFilterElementResultArray_descr_;
extern const XERdescriptor_t ContentFilterElementResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t ContentFilterElementResult_statusCode_json_;
extern const TTCN_OERdescriptor_t ContentFilterElementResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t ContentFilterElementResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t ContentFilterElementResult_raw_;
extern const TTCN_Typedescriptor_t ContentFilterElementResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfContentFilterElementResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfContentFilterElementResultArray_descr_;
extern const TTCN_RAWdescriptor_t ContentFilterResult_raw_;
extern const TTCN_Typedescriptor_t ContentFilterResult_descr_;
extern const TTCN_RAWdescriptor_t EventFilterResult_raw_;
extern const TTCN_Typedescriptor_t EventFilterResult_descr_;
extern const XERdescriptor_t AggregateFilterResult_revisedStartTime_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilterResult_revisedStartTime_json_;
extern const TTCN_OERdescriptor_t AggregateFilterResult_revisedStartTime_oer_;
extern const TTCN_Typedescriptor_t AggregateFilterResult_revisedStartTime_descr_;
extern const XERdescriptor_t AggregateFilterResult_revisedProcessingInterval_xer_;
extern const TTCN_JSONdescriptor_t AggregateFilterResult_revisedProcessingInterval_json_;
extern const TTCN_OERdescriptor_t AggregateFilterResult_revisedProcessingInterval_oer_;
extern const TTCN_Typedescriptor_t AggregateFilterResult_revisedProcessingInterval_descr_;
extern const TTCN_RAWdescriptor_t AggregateFilterResult_raw_;
extern const TTCN_Typedescriptor_t AggregateFilterResult_descr_;
extern const XERdescriptor_t ObjectAttributes_displayNameBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectAttributes_displayNameBit_json_;
extern const TTCN_OERdescriptor_t ObjectAttributes_displayNameBit_oer_;
extern const TTCN_Typedescriptor_t ObjectAttributes_displayNameBit_descr_;
extern const XERdescriptor_t ObjectAttributes_descriptionBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectAttributes_descriptionBit_json_;
extern const TTCN_OERdescriptor_t ObjectAttributes_descriptionBit_oer_;
extern const TTCN_Typedescriptor_t ObjectAttributes_descriptionBit_descr_;
extern const XERdescriptor_t ObjectAttributes_eventNotifierBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectAttributes_eventNotifierBit_json_;
extern const TTCN_OERdescriptor_t ObjectAttributes_eventNotifierBit_oer_;
extern const TTCN_Typedescriptor_t ObjectAttributes_eventNotifierBit_descr_;
extern const XERdescriptor_t ObjectAttributes_writeMaskBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectAttributes_writeMaskBit_json_;
extern const TTCN_OERdescriptor_t ObjectAttributes_writeMaskBit_oer_;
extern const TTCN_Typedescriptor_t ObjectAttributes_writeMaskBit_descr_;
extern const XERdescriptor_t ObjectAttributes_userWriteMaskBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectAttributes_userWriteMaskBit_json_;
extern const TTCN_OERdescriptor_t ObjectAttributes_userWriteMaskBit_oer_;
extern const TTCN_Typedescriptor_t ObjectAttributes_userWriteMaskBit_descr_;
extern const TTCN_Typedescriptor_t ObjectAttributes_reserveBits_descr_;
extern const TTCN_RAWdescriptor_t ObjectAttributes_raw_;
extern const TTCN_Typedescriptor_t ObjectAttributes_descr_;
extern const TTCN_RAWdescriptor_t ObjectAttributes_displayName_raw_;
extern const TTCN_Typedescriptor_t ObjectAttributes_displayName_descr_;
extern const TTCN_RAWdescriptor_t ObjectAttributes_description_raw_;
extern const TTCN_Typedescriptor_t ObjectAttributes_description_descr_;
extern const TTCN_RAWdescriptor_t ObjectAttributes_eventNotifier_raw_;
extern const XERdescriptor_t ObjectAttributes_eventNotifier_xer_;
extern const TTCN_JSONdescriptor_t ObjectAttributes_eventNotifier_json_;
extern const TTCN_OERdescriptor_t ObjectAttributes_eventNotifier_oer_;
extern const TTCN_Typedescriptor_t ObjectAttributes_eventNotifier_descr_;
extern const TTCN_RAWdescriptor_t ObjectAttributes_writeMask_raw_;
extern const XERdescriptor_t ObjectAttributes_writeMask_xer_;
extern const TTCN_JSONdescriptor_t ObjectAttributes_writeMask_json_;
extern const TTCN_OERdescriptor_t ObjectAttributes_writeMask_oer_;
extern const TTCN_Typedescriptor_t ObjectAttributes_writeMask_descr_;
extern const TTCN_RAWdescriptor_t ObjectAttributes_userWriteMask_raw_;
extern const XERdescriptor_t ObjectAttributes_userWriteMask_xer_;
extern const TTCN_JSONdescriptor_t ObjectAttributes_userWriteMask_json_;
extern const TTCN_OERdescriptor_t ObjectAttributes_userWriteMask_oer_;
extern const TTCN_Typedescriptor_t ObjectAttributes_userWriteMask_descr_;
extern const XERdescriptor_t VariableAttributes_displayNameBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_displayNameBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_displayNameBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_displayNameBit_descr_;
extern const XERdescriptor_t VariableAttributes_descriptionBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_descriptionBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_descriptionBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_descriptionBit_descr_;
extern const XERdescriptor_t VariableAttributes_ValueBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_ValueBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_ValueBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_ValueBit_descr_;
extern const XERdescriptor_t VariableAttributes_dataTypeBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_dataTypeBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_dataTypeBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_dataTypeBit_descr_;
extern const XERdescriptor_t VariableAttributes_valueRankBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_valueRankBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_valueRankBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_valueRankBit_descr_;
extern const XERdescriptor_t VariableAttributes_arrayDimensionsBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_arrayDimensionsBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_arrayDimensionsBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_arrayDimensionsBit_descr_;
extern const XERdescriptor_t VariableAttributes_accessLevelBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_accessLevelBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_accessLevelBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_accessLevelBit_descr_;
extern const XERdescriptor_t VariableAttributes_userAccessLevelBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_userAccessLevelBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_userAccessLevelBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_userAccessLevelBit_descr_;
extern const XERdescriptor_t VariableAttributes_minimumSamplingIntervalBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_minimumSamplingIntervalBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_minimumSamplingIntervalBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_minimumSamplingIntervalBit_descr_;
extern const XERdescriptor_t VariableAttributes_historizingBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_historizingBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_historizingBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_historizingBit_descr_;
extern const XERdescriptor_t VariableAttributes_writeMaskBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_writeMaskBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_writeMaskBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_writeMaskBit_descr_;
extern const XERdescriptor_t VariableAttributes_userWriteMaskBit_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_userWriteMaskBit_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_userWriteMaskBit_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_userWriteMaskBit_descr_;
extern const TTCN_Typedescriptor_t VariableAttributes_reserveBits_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_raw_;
extern const TTCN_Typedescriptor_t VariableAttributes_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_displayName_raw_;
extern const TTCN_Typedescriptor_t VariableAttributes_displayName_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_description_raw_;
extern const TTCN_Typedescriptor_t VariableAttributes_description_descr_;
extern const XERdescriptor_t DataType_xer_;
extern const TTCN_JSONdescriptor_t DataType_json_;
extern const TTCN_OERdescriptor_t DataType_oer_;
extern const TTCN_Typedescriptor_t DataType_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_Value_raw_;
extern const XERdescriptor_t VariableAttributes_Value_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_Value_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_Value_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_Value_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_dataType_raw_;
extern const TTCN_Typedescriptor_t VariableAttributes_dataType_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_valueRank_raw_;
extern const XERdescriptor_t VariableAttributes_valueRank_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_valueRank_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_valueRank_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_valueRank_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_arrayDimensions_raw_;
extern const TTCN_Typedescriptor_t VariableAttributes_arrayDimensions_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_accessLevel_raw_;
extern const XERdescriptor_t VariableAttributes_accessLevel_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_accessLevel_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_accessLevel_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_accessLevel_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_userAccessLevel_raw_;
extern const XERdescriptor_t VariableAttributes_userAccessLevel_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_userAccessLevel_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_userAccessLevel_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_userAccessLevel_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_minimumSamplingInterval_raw_;
extern const XERdescriptor_t VariableAttributes_minimumSamplingInterval_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_minimumSamplingInterval_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_minimumSamplingInterval_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_minimumSamplingInterval_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_historizing_raw_;
extern const XERdescriptor_t VariableAttributes_historizing_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_historizing_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_historizing_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_historizing_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_writeMask_raw_;
extern const XERdescriptor_t VariableAttributes_writeMask_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_writeMask_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_writeMask_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_writeMask_descr_;
extern const TTCN_RAWdescriptor_t VariableAttributes_userWriteMask_raw_;
extern const XERdescriptor_t VariableAttributes_userWriteMask_xer_;
extern const TTCN_JSONdescriptor_t VariableAttributes_userWriteMask_json_;
extern const TTCN_OERdescriptor_t VariableAttributes_userWriteMask_oer_;
extern const TTCN_Typedescriptor_t VariableAttributes_userWriteMask_descr_;
extern const XERdescriptor_t MethodAttributes_displayNameBit_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_displayNameBit_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_displayNameBit_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_displayNameBit_descr_;
extern const XERdescriptor_t MethodAttributes_descriptionBit_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_descriptionBit_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_descriptionBit_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_descriptionBit_descr_;
extern const XERdescriptor_t MethodAttributes_executableBit_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_executableBit_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_executableBit_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_executableBit_descr_;
extern const XERdescriptor_t MethodAttributes_userExecutableBit_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_userExecutableBit_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_userExecutableBit_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_userExecutableBit_descr_;
extern const XERdescriptor_t MethodAttributes_writeMaskBit_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_writeMaskBit_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_writeMaskBit_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_writeMaskBit_descr_;
extern const XERdescriptor_t MethodAttributes_userWriteMaskBit_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_userWriteMaskBit_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_userWriteMaskBit_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_userWriteMaskBit_descr_;
extern const TTCN_Typedescriptor_t MethodAttributes_reserveBits_descr_;
extern const TTCN_RAWdescriptor_t MethodAttributes_raw_;
extern const TTCN_Typedescriptor_t MethodAttributes_descr_;
extern const TTCN_RAWdescriptor_t MethodAttributes_displayName_raw_;
extern const TTCN_Typedescriptor_t MethodAttributes_displayName_descr_;
extern const TTCN_RAWdescriptor_t MethodAttributes_description_raw_;
extern const TTCN_Typedescriptor_t MethodAttributes_description_descr_;
extern const TTCN_RAWdescriptor_t MethodAttributes_executable_raw_;
extern const XERdescriptor_t MethodAttributes_executable_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_executable_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_executable_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_executable_descr_;
extern const TTCN_RAWdescriptor_t MethodAttributes_userExecutable_raw_;
extern const XERdescriptor_t MethodAttributes_userExecutable_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_userExecutable_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_userExecutable_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_userExecutable_descr_;
extern const TTCN_RAWdescriptor_t MethodAttributes_writeMask_raw_;
extern const XERdescriptor_t MethodAttributes_writeMask_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_writeMask_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_writeMask_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_writeMask_descr_;
extern const TTCN_RAWdescriptor_t MethodAttributes_userWriteMask_raw_;
extern const XERdescriptor_t MethodAttributes_userWriteMask_xer_;
extern const TTCN_JSONdescriptor_t MethodAttributes_userWriteMask_json_;
extern const TTCN_OERdescriptor_t MethodAttributes_userWriteMask_oer_;
extern const TTCN_Typedescriptor_t MethodAttributes_userWriteMask_descr_;
extern const XERdescriptor_t ObjectTypeAttributes_displayNameBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectTypeAttributes_displayNameBit_json_;
extern const TTCN_OERdescriptor_t ObjectTypeAttributes_displayNameBit_oer_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_displayNameBit_descr_;
extern const XERdescriptor_t ObjectTypeAttributes_descriptionBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectTypeAttributes_descriptionBit_json_;
extern const TTCN_OERdescriptor_t ObjectTypeAttributes_descriptionBit_oer_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_descriptionBit_descr_;
extern const XERdescriptor_t ObjectTypeAttributes_isAbstractBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectTypeAttributes_isAbstractBit_json_;
extern const TTCN_OERdescriptor_t ObjectTypeAttributes_isAbstractBit_oer_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_isAbstractBit_descr_;
extern const XERdescriptor_t ObjectTypeAttributes_writeMaskBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectTypeAttributes_writeMaskBit_json_;
extern const TTCN_OERdescriptor_t ObjectTypeAttributes_writeMaskBit_oer_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_writeMaskBit_descr_;
extern const XERdescriptor_t ObjectTypeAttributes_userWriteMaskBit_xer_;
extern const TTCN_JSONdescriptor_t ObjectTypeAttributes_userWriteMaskBit_json_;
extern const TTCN_OERdescriptor_t ObjectTypeAttributes_userWriteMaskBit_oer_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_userWriteMaskBit_descr_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_reserveBits_descr_;
extern const TTCN_RAWdescriptor_t ObjectTypeAttributes_raw_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_descr_;
extern const TTCN_RAWdescriptor_t ObjectTypeAttributes_displayName_raw_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_displayName_descr_;
extern const TTCN_RAWdescriptor_t ObjectTypeAttributes_description_raw_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_description_descr_;
extern const TTCN_RAWdescriptor_t ObjectTypeAttributes_isAbstract_raw_;
extern const XERdescriptor_t ObjectTypeAttributes_isAbstract_xer_;
extern const TTCN_JSONdescriptor_t ObjectTypeAttributes_isAbstract_json_;
extern const TTCN_OERdescriptor_t ObjectTypeAttributes_isAbstract_oer_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_isAbstract_descr_;
extern const TTCN_RAWdescriptor_t ObjectTypeAttributes_writeMask_raw_;
extern const XERdescriptor_t ObjectTypeAttributes_writeMask_xer_;
extern const TTCN_JSONdescriptor_t ObjectTypeAttributes_writeMask_json_;
extern const TTCN_OERdescriptor_t ObjectTypeAttributes_writeMask_oer_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_writeMask_descr_;
extern const TTCN_RAWdescriptor_t ObjectTypeAttributes_userWriteMask_raw_;
extern const XERdescriptor_t ObjectTypeAttributes_userWriteMask_xer_;
extern const TTCN_JSONdescriptor_t ObjectTypeAttributes_userWriteMask_json_;
extern const TTCN_OERdescriptor_t ObjectTypeAttributes_userWriteMask_oer_;
extern const TTCN_Typedescriptor_t ObjectTypeAttributes_userWriteMask_descr_;
extern const XERdescriptor_t VariableTypeAttributes_displayNameBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_displayNameBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_displayNameBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_displayNameBit_descr_;
extern const XERdescriptor_t VariableTypeAttributes_descriptionBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_descriptionBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_descriptionBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_descriptionBit_descr_;
extern const XERdescriptor_t VariableTypeAttributes_ValueBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_ValueBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_ValueBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_ValueBit_descr_;
extern const XERdescriptor_t VariableTypeAttributes_dataTypeBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_dataTypeBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_dataTypeBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_dataTypeBit_descr_;
extern const XERdescriptor_t VariableTypeAttributes_valueRankBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_valueRankBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_valueRankBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_valueRankBit_descr_;
extern const XERdescriptor_t VariableTypeAttributes_arrayDimensionsBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_arrayDimensionsBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_arrayDimensionsBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_arrayDimensionsBit_descr_;
extern const XERdescriptor_t VariableTypeAttributes_isAbstractBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_isAbstractBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_isAbstractBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_isAbstractBit_descr_;
extern const XERdescriptor_t VariableTypeAttributes_writeMaskBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_writeMaskBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_writeMaskBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_writeMaskBit_descr_;
extern const XERdescriptor_t VariableTypeAttributes_userWriteMaskBit_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_userWriteMaskBit_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_userWriteMaskBit_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_userWriteMaskBit_descr_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_reserveBits_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_raw_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_displayName_raw_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_displayName_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_description_raw_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_description_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_Value_raw_;
extern const XERdescriptor_t VariableTypeAttributes_Value_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_Value_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_Value_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_Value_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_dataType_raw_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_dataType_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_valueRank_raw_;
extern const XERdescriptor_t VariableTypeAttributes_valueRank_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_valueRank_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_valueRank_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_valueRank_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_arrayDimensions_raw_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_arrayDimensions_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_isAbstract_raw_;
extern const XERdescriptor_t VariableTypeAttributes_isAbstract_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_isAbstract_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_isAbstract_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_isAbstract_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_writeMask_raw_;
extern const XERdescriptor_t VariableTypeAttributes_writeMask_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_writeMask_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_writeMask_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_writeMask_descr_;
extern const TTCN_RAWdescriptor_t VariableTypeAttributes_userWriteMask_raw_;
extern const XERdescriptor_t VariableTypeAttributes_userWriteMask_xer_;
extern const TTCN_JSONdescriptor_t VariableTypeAttributes_userWriteMask_json_;
extern const TTCN_OERdescriptor_t VariableTypeAttributes_userWriteMask_oer_;
extern const TTCN_Typedescriptor_t VariableTypeAttributes_userWriteMask_descr_;
extern const XERdescriptor_t ReferenceTypeAttributes_displayNameBit_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_displayNameBit_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_displayNameBit_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_displayNameBit_descr_;
extern const XERdescriptor_t ReferenceTypeAttributes_descriptionBit_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_descriptionBit_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_descriptionBit_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_descriptionBit_descr_;
extern const XERdescriptor_t ReferenceTypeAttributes_isAbstractBit_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_isAbstractBit_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_isAbstractBit_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_isAbstractBit_descr_;
extern const XERdescriptor_t ReferenceTypeAttributes_symmetricBit_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_symmetricBit_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_symmetricBit_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_symmetricBit_descr_;
extern const XERdescriptor_t ReferenceTypeAttributes_inverseNameBit_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_inverseNameBit_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_inverseNameBit_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_inverseNameBit_descr_;
extern const XERdescriptor_t ReferenceTypeAttributes_writeMaskBit_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_writeMaskBit_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_writeMaskBit_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_writeMaskBit_descr_;
extern const XERdescriptor_t ReferenceTypeAttributes_userWriteMaskBit_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_userWriteMaskBit_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_userWriteMaskBit_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_userWriteMaskBit_descr_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_reserveBits_descr_;
extern const TTCN_RAWdescriptor_t ReferenceTypeAttributes_raw_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_descr_;
extern const TTCN_RAWdescriptor_t ReferenceTypeAttributes_displayName_raw_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_displayName_descr_;
extern const TTCN_RAWdescriptor_t ReferenceTypeAttributes_description_raw_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_description_descr_;
extern const TTCN_RAWdescriptor_t ReferenceTypeAttributes_isAbstract_raw_;
extern const XERdescriptor_t ReferenceTypeAttributes_isAbstract_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_isAbstract_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_isAbstract_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_isAbstract_descr_;
extern const TTCN_RAWdescriptor_t ReferenceTypeAttributes_symmetric_raw_;
extern const XERdescriptor_t ReferenceTypeAttributes_symmetric_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_symmetric_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_symmetric_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_symmetric_descr_;
extern const TTCN_RAWdescriptor_t ReferenceTypeAttributes_inverseName_raw_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_inverseName_descr_;
extern const TTCN_RAWdescriptor_t ReferenceTypeAttributes_writeMask_raw_;
extern const XERdescriptor_t ReferenceTypeAttributes_writeMask_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_writeMask_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_writeMask_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_writeMask_descr_;
extern const TTCN_RAWdescriptor_t ReferenceTypeAttributes_userWriteMask_raw_;
extern const XERdescriptor_t ReferenceTypeAttributes_userWriteMask_xer_;
extern const TTCN_JSONdescriptor_t ReferenceTypeAttributes_userWriteMask_json_;
extern const TTCN_OERdescriptor_t ReferenceTypeAttributes_userWriteMask_oer_;
extern const TTCN_Typedescriptor_t ReferenceTypeAttributes_userWriteMask_descr_;
extern const XERdescriptor_t DataTypeAttributes_displayNameBit_xer_;
extern const TTCN_JSONdescriptor_t DataTypeAttributes_displayNameBit_json_;
extern const TTCN_OERdescriptor_t DataTypeAttributes_displayNameBit_oer_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_displayNameBit_descr_;
extern const XERdescriptor_t DataTypeAttributes_descriptionBit_xer_;
extern const TTCN_JSONdescriptor_t DataTypeAttributes_descriptionBit_json_;
extern const TTCN_OERdescriptor_t DataTypeAttributes_descriptionBit_oer_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_descriptionBit_descr_;
extern const XERdescriptor_t DataTypeAttributes_isAbstractBit_xer_;
extern const TTCN_JSONdescriptor_t DataTypeAttributes_isAbstractBit_json_;
extern const TTCN_OERdescriptor_t DataTypeAttributes_isAbstractBit_oer_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_isAbstractBit_descr_;
extern const XERdescriptor_t DataTypeAttributes_writeMaskBit_xer_;
extern const TTCN_JSONdescriptor_t DataTypeAttributes_writeMaskBit_json_;
extern const TTCN_OERdescriptor_t DataTypeAttributes_writeMaskBit_oer_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_writeMaskBit_descr_;
extern const XERdescriptor_t DataTypeAttributes_userWriteMaskBit_xer_;
extern const TTCN_JSONdescriptor_t DataTypeAttributes_userWriteMaskBit_json_;
extern const TTCN_OERdescriptor_t DataTypeAttributes_userWriteMaskBit_oer_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_userWriteMaskBit_descr_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_reserveBits_descr_;
extern const TTCN_RAWdescriptor_t DataTypeAttributes_raw_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_descr_;
extern const TTCN_RAWdescriptor_t DataTypeAttributes_displayName_raw_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_displayName_descr_;
extern const TTCN_RAWdescriptor_t DataTypeAttributes_description_raw_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_description_descr_;
extern const TTCN_RAWdescriptor_t DataTypeAttributes_isAbstract_raw_;
extern const XERdescriptor_t DataTypeAttributes_isAbstract_xer_;
extern const TTCN_JSONdescriptor_t DataTypeAttributes_isAbstract_json_;
extern const TTCN_OERdescriptor_t DataTypeAttributes_isAbstract_oer_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_isAbstract_descr_;
extern const TTCN_RAWdescriptor_t DataTypeAttributes_writeMask_raw_;
extern const XERdescriptor_t DataTypeAttributes_writeMask_xer_;
extern const TTCN_JSONdescriptor_t DataTypeAttributes_writeMask_json_;
extern const TTCN_OERdescriptor_t DataTypeAttributes_writeMask_oer_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_writeMask_descr_;
extern const TTCN_RAWdescriptor_t DataTypeAttributes_userWriteMask_raw_;
extern const XERdescriptor_t DataTypeAttributes_userWriteMask_xer_;
extern const TTCN_JSONdescriptor_t DataTypeAttributes_userWriteMask_json_;
extern const TTCN_OERdescriptor_t DataTypeAttributes_userWriteMask_oer_;
extern const TTCN_Typedescriptor_t DataTypeAttributes_userWriteMask_descr_;
extern const XERdescriptor_t ViewAttributes_displayNameBit_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_displayNameBit_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_displayNameBit_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_displayNameBit_descr_;
extern const XERdescriptor_t ViewAttributes_descriptionBit_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_descriptionBit_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_descriptionBit_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_descriptionBit_descr_;
extern const XERdescriptor_t ViewAttributes_containsNoLoopsBit_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_containsNoLoopsBit_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_containsNoLoopsBit_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_containsNoLoopsBit_descr_;
extern const XERdescriptor_t ViewAttributes_eventNotifierBit_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_eventNotifierBit_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_eventNotifierBit_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_eventNotifierBit_descr_;
extern const XERdescriptor_t ViewAttributes_writeMaskBit_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_writeMaskBit_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_writeMaskBit_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_writeMaskBit_descr_;
extern const XERdescriptor_t ViewAttributes_userWriteMaskBit_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_userWriteMaskBit_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_userWriteMaskBit_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_userWriteMaskBit_descr_;
extern const TTCN_Typedescriptor_t ViewAttributes_reserveBits_descr_;
extern const TTCN_RAWdescriptor_t ViewAttributes_raw_;
extern const TTCN_Typedescriptor_t ViewAttributes_descr_;
extern const TTCN_RAWdescriptor_t ViewAttributes_displayName_raw_;
extern const TTCN_Typedescriptor_t ViewAttributes_displayName_descr_;
extern const TTCN_RAWdescriptor_t ViewAttributes_description_raw_;
extern const TTCN_Typedescriptor_t ViewAttributes_description_descr_;
extern const TTCN_RAWdescriptor_t ViewAttributes_containsNoLoops_raw_;
extern const XERdescriptor_t ViewAttributes_containsNoLoops_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_containsNoLoops_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_containsNoLoops_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_containsNoLoops_descr_;
extern const TTCN_RAWdescriptor_t ViewAttributes_eventNotifier_raw_;
extern const XERdescriptor_t ViewAttributes_eventNotifier_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_eventNotifier_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_eventNotifier_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_eventNotifier_descr_;
extern const TTCN_RAWdescriptor_t ViewAttributes_writeMask_raw_;
extern const XERdescriptor_t ViewAttributes_writeMask_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_writeMask_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_writeMask_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_writeMask_descr_;
extern const TTCN_RAWdescriptor_t ViewAttributes_userWriteMask_raw_;
extern const XERdescriptor_t ViewAttributes_userWriteMask_xer_;
extern const TTCN_JSONdescriptor_t ViewAttributes_userWriteMask_json_;
extern const TTCN_OERdescriptor_t ViewAttributes_userWriteMask_oer_;
extern const TTCN_Typedescriptor_t ViewAttributes_userWriteMask_descr_;
extern const TTCN_RAWdescriptor_t ListOfGenericAttributeValue_raw_;
extern const TTCN_Typedescriptor_t ListOfGenericAttributeValue_descr_;
extern const TTCN_RAWdescriptor_t ListOfGenericAttributeValueArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfGenericAttributeValueArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfGenericAttributeValueArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfGenericAttributeValueArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfGenericAttributeValueArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t GenericAttributeValueArray_raw_;
extern const TTCN_Typedescriptor_t GenericAttributeValueArray_descr_;
extern const XERdescriptor_t GenericAttributeValue_attributeId_xer_;
extern const TTCN_JSONdescriptor_t GenericAttributeValue_attributeId_json_;
extern const TTCN_OERdescriptor_t GenericAttributeValue_attributeId_oer_;
extern const TTCN_Typedescriptor_t GenericAttributeValue_attributeId_descr_;
extern const TTCN_RAWdescriptor_t GenericAttributeValue_raw_;
extern const TTCN_Typedescriptor_t GenericAttributeValue_descr_;
extern const TTCN_RAWdescriptor_t ListOfGenericAttributeValueArray_raw_;
extern const TTCN_Typedescriptor_t ListOfGenericAttributeValueArray_descr_;
extern const TTCN_RAWdescriptor_t GenericAttributes_raw_;
extern const TTCN_Typedescriptor_t GenericAttributes_descr_;
extern const TTCN_RAWdescriptor_t UserNameIdentityToken_raw_;
extern const TTCN_Typedescriptor_t UserNameIdentityToken_descr_;
extern const TTCN_RAWdescriptor_t X509IdentityToken_raw_;
extern const TTCN_Typedescriptor_t X509IdentityToken_descr_;
extern const TTCN_RAWdescriptor_t IssuedIdentityToken_raw_;
extern const TTCN_Typedescriptor_t IssuedIdentityToken_descr_;
extern const TTCN_RAWdescriptor_t AnonymousIdentityToken_raw_;
extern const TTCN_Typedescriptor_t AnonymousIdentityToken_descr_;
extern const TTCN_RAWdescriptor_t MdnsDiscoveryConfiguration_raw_;
extern const TTCN_Typedescriptor_t MdnsDiscoveryConfiguration_descr_;
extern const XERdescriptor_t ReadEventDetails_numValuesPerNode_xer_;
extern const TTCN_JSONdescriptor_t ReadEventDetails_numValuesPerNode_json_;
extern const TTCN_OERdescriptor_t ReadEventDetails_numValuesPerNode_oer_;
extern const TTCN_Typedescriptor_t ReadEventDetails_numValuesPerNode_descr_;
extern const XERdescriptor_t ReadEventDetails_startTime_xer_;
extern const TTCN_JSONdescriptor_t ReadEventDetails_startTime_json_;
extern const TTCN_OERdescriptor_t ReadEventDetails_startTime_oer_;
extern const TTCN_Typedescriptor_t ReadEventDetails_startTime_descr_;
extern const XERdescriptor_t ReadEventDetails_endTime_xer_;
extern const TTCN_JSONdescriptor_t ReadEventDetails_endTime_json_;
extern const TTCN_OERdescriptor_t ReadEventDetails_endTime_oer_;
extern const TTCN_Typedescriptor_t ReadEventDetails_endTime_descr_;
extern const TTCN_RAWdescriptor_t ReadEventDetails_raw_;
extern const TTCN_Typedescriptor_t ReadEventDetails_descr_;
extern const XERdescriptor_t ReadRawModifiedDetails_isReadModified_xer_;
extern const TTCN_JSONdescriptor_t ReadRawModifiedDetails_isReadModified_json_;
extern const TTCN_OERdescriptor_t ReadRawModifiedDetails_isReadModified_oer_;
extern const TTCN_Typedescriptor_t ReadRawModifiedDetails_isReadModified_descr_;
extern const XERdescriptor_t ReadRawModifiedDetails_startTime_xer_;
extern const TTCN_JSONdescriptor_t ReadRawModifiedDetails_startTime_json_;
extern const TTCN_OERdescriptor_t ReadRawModifiedDetails_startTime_oer_;
extern const TTCN_Typedescriptor_t ReadRawModifiedDetails_startTime_descr_;
extern const XERdescriptor_t ReadRawModifiedDetails_endTime_xer_;
extern const TTCN_JSONdescriptor_t ReadRawModifiedDetails_endTime_json_;
extern const TTCN_OERdescriptor_t ReadRawModifiedDetails_endTime_oer_;
extern const TTCN_Typedescriptor_t ReadRawModifiedDetails_endTime_descr_;
extern const XERdescriptor_t ReadRawModifiedDetails_numValuesPerNode_xer_;
extern const TTCN_JSONdescriptor_t ReadRawModifiedDetails_numValuesPerNode_json_;
extern const TTCN_OERdescriptor_t ReadRawModifiedDetails_numValuesPerNode_oer_;
extern const TTCN_Typedescriptor_t ReadRawModifiedDetails_numValuesPerNode_descr_;
extern const XERdescriptor_t ReadRawModifiedDetails_returnBounds_xer_;
extern const TTCN_JSONdescriptor_t ReadRawModifiedDetails_returnBounds_json_;
extern const TTCN_OERdescriptor_t ReadRawModifiedDetails_returnBounds_oer_;
extern const TTCN_Typedescriptor_t ReadRawModifiedDetails_returnBounds_descr_;
extern const TTCN_RAWdescriptor_t ReadRawModifiedDetails_raw_;
extern const TTCN_Typedescriptor_t ReadRawModifiedDetails_descr_;
extern const XERdescriptor_t ReadProcessedDetails_startTime_xer_;
extern const TTCN_JSONdescriptor_t ReadProcessedDetails_startTime_json_;
extern const TTCN_OERdescriptor_t ReadProcessedDetails_startTime_oer_;
extern const TTCN_Typedescriptor_t ReadProcessedDetails_startTime_descr_;
extern const XERdescriptor_t ReadProcessedDetails_endTime_xer_;
extern const TTCN_JSONdescriptor_t ReadProcessedDetails_endTime_json_;
extern const TTCN_OERdescriptor_t ReadProcessedDetails_endTime_oer_;
extern const TTCN_Typedescriptor_t ReadProcessedDetails_endTime_descr_;
extern const XERdescriptor_t ReadProcessedDetails_ProcessingInterval_xer_;
extern const TTCN_JSONdescriptor_t ReadProcessedDetails_ProcessingInterval_json_;
extern const TTCN_OERdescriptor_t ReadProcessedDetails_ProcessingInterval_oer_;
extern const TTCN_Typedescriptor_t ReadProcessedDetails_ProcessingInterval_descr_;
extern const TTCN_RAWdescriptor_t ReadProcessedDetails_raw_;
extern const TTCN_Typedescriptor_t ReadProcessedDetails_descr_;
extern const TTCN_RAWdescriptor_t ListOfUtcTime_raw_;
extern const TTCN_Typedescriptor_t ListOfUtcTime_descr_;
extern const TTCN_RAWdescriptor_t ListOfUtcTimeArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfUtcTimeArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfUtcTimeArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfUtcTimeArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfUtcTimeArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t UtcTimeArray_raw_;
extern const TTCN_Typedescriptor_t UtcTimeArray_descr_;
extern const XERdescriptor_t UtcTimeArray_0_xer_;
extern const TTCN_JSONdescriptor_t UtcTimeArray_0_json_;
extern const TTCN_OERdescriptor_t UtcTimeArray_0_oer_;
extern const TTCN_Typedescriptor_t UtcTimeArray_0_descr_;
extern const TTCN_RAWdescriptor_t ListOfUtcTimeArray_raw_;
extern const TTCN_Typedescriptor_t ListOfUtcTimeArray_descr_;
extern const XERdescriptor_t ReadAtTimeDetails_useSimpleBounds_xer_;
extern const TTCN_JSONdescriptor_t ReadAtTimeDetails_useSimpleBounds_json_;
extern const TTCN_OERdescriptor_t ReadAtTimeDetails_useSimpleBounds_oer_;
extern const TTCN_Typedescriptor_t ReadAtTimeDetails_useSimpleBounds_descr_;
extern const TTCN_RAWdescriptor_t ReadAtTimeDetails_raw_;
extern const TTCN_Typedescriptor_t ReadAtTimeDetails_descr_;
extern const TTCN_RAWdescriptor_t UpdateDataDetails_raw_;
extern const TTCN_Typedescriptor_t UpdateDataDetails_descr_;
extern const TTCN_RAWdescriptor_t UpdateStructureDataDetails_raw_;
extern const TTCN_Typedescriptor_t UpdateStructureDataDetails_descr_;
extern const TTCN_RAWdescriptor_t UpdateEventDetails_raw_;
extern const TTCN_Typedescriptor_t UpdateEventDetails_descr_;
extern const XERdescriptor_t DeleteRawModifiedDetails_isDeleteModified_xer_;
extern const TTCN_JSONdescriptor_t DeleteRawModifiedDetails_isDeleteModified_json_;
extern const TTCN_OERdescriptor_t DeleteRawModifiedDetails_isDeleteModified_oer_;
extern const TTCN_Typedescriptor_t DeleteRawModifiedDetails_isDeleteModified_descr_;
extern const XERdescriptor_t DeleteRawModifiedDetails_startTime_xer_;
extern const TTCN_JSONdescriptor_t DeleteRawModifiedDetails_startTime_json_;
extern const TTCN_OERdescriptor_t DeleteRawModifiedDetails_startTime_oer_;
extern const TTCN_Typedescriptor_t DeleteRawModifiedDetails_startTime_descr_;
extern const XERdescriptor_t DeleteRawModifiedDetails_endTime_xer_;
extern const TTCN_JSONdescriptor_t DeleteRawModifiedDetails_endTime_json_;
extern const TTCN_OERdescriptor_t DeleteRawModifiedDetails_endTime_oer_;
extern const TTCN_Typedescriptor_t DeleteRawModifiedDetails_endTime_descr_;
extern const TTCN_RAWdescriptor_t DeleteRawModifiedDetails_raw_;
extern const TTCN_Typedescriptor_t DeleteRawModifiedDetails_descr_;
extern const TTCN_RAWdescriptor_t DeleteAtTimeDetails_raw_;
extern const TTCN_Typedescriptor_t DeleteAtTimeDetails_descr_;
extern const TTCN_RAWdescriptor_t DeleteEventDetails_raw_;
extern const TTCN_Typedescriptor_t DeleteEventDetails_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemNotification_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemNotification_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemNotificationArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfMonitoredItemNotificationArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfMonitoredItemNotificationArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfMonitoredItemNotificationArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemNotificationArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemNotificationArray_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemNotificationArray_descr_;
extern const XERdescriptor_t MonitoredItemNotification_clientHandle_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemNotification_clientHandle_json_;
extern const TTCN_OERdescriptor_t MonitoredItemNotification_clientHandle_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemNotification_clientHandle_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemNotification_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemNotification_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemNotificationArray_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemNotificationArray_descr_;
extern const TTCN_RAWdescriptor_t DataChangeNotification_raw_;
extern const TTCN_Typedescriptor_t DataChangeNotification_descr_;
extern const TTCN_RAWdescriptor_t ListOfEventFieldList_raw_;
extern const TTCN_Typedescriptor_t ListOfEventFieldList_descr_;
extern const TTCN_RAWdescriptor_t ListOfEventFieldListArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfEventFieldListArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfEventFieldListArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfEventFieldListArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfEventFieldListArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t EventFieldListArray_raw_;
extern const TTCN_Typedescriptor_t EventFieldListArray_descr_;
extern const XERdescriptor_t EventFieldList_clientHandle_xer_;
extern const TTCN_JSONdescriptor_t EventFieldList_clientHandle_json_;
extern const TTCN_OERdescriptor_t EventFieldList_clientHandle_oer_;
extern const TTCN_Typedescriptor_t EventFieldList_clientHandle_descr_;
extern const TTCN_RAWdescriptor_t ListOfBaseDataType_raw_;
extern const TTCN_Typedescriptor_t ListOfBaseDataType_descr_;
extern const TTCN_RAWdescriptor_t EventFieldList_raw_;
extern const TTCN_Typedescriptor_t EventFieldList_descr_;
extern const TTCN_RAWdescriptor_t ListOfEventFieldListArray_raw_;
extern const TTCN_Typedescriptor_t ListOfEventFieldListArray_descr_;
extern const TTCN_RAWdescriptor_t EventNotificationList_raw_;
extern const TTCN_Typedescriptor_t EventNotificationList_descr_;
extern const XERdescriptor_t StatusChangeNotification_status_xer_;
extern const TTCN_JSONdescriptor_t StatusChangeNotification_status_json_;
extern const TTCN_OERdescriptor_t StatusChangeNotification_status_oer_;
extern const TTCN_Typedescriptor_t StatusChangeNotification_status_descr_;
extern const TTCN_RAWdescriptor_t StatusChangeNotification_raw_;
extern const TTCN_Typedescriptor_t StatusChangeNotification_descr_;
extern const TTCN_RAWdescriptor_t ExtensibleParameter_extensibleParameterBody_raw_;
extern const TTCN_Typedescriptor_t ExtensibleParameter_extensibleParameterBody_descr_;
extern const XERdescriptor_t Decimal_decimalLength_xer_;
extern const TTCN_JSONdescriptor_t Decimal_decimalLength_json_;
extern const TTCN_OERdescriptor_t Decimal_decimalLength_oer_;
extern const TTCN_Typedescriptor_t Decimal_decimalLength_descr_;
extern const XERdescriptor_t Decimal_scale_xer_;
extern const TTCN_JSONdescriptor_t Decimal_scale_json_;
extern const TTCN_OERdescriptor_t Decimal_scale_oer_;
extern const TTCN_Typedescriptor_t Decimal_scale_descr_;
extern const XERdescriptor_t Decimal_decimalValue_xer_;
extern const TTCN_JSONdescriptor_t Decimal_decimalValue_json_;
extern const TTCN_OERdescriptor_t Decimal_decimalValue_oer_;
extern const TTCN_Typedescriptor_t Decimal_decimalValue_descr_;
extern const TTCN_RAWdescriptor_t Decimal_raw_;
extern const TTCN_Typedescriptor_t Decimal_descr_;
extern const XERdescriptor_t TimeZoneDataType_offset_xer_;
extern const TTCN_JSONdescriptor_t TimeZoneDataType_offset_json_;
extern const TTCN_OERdescriptor_t TimeZoneDataType_offset_oer_;
extern const TTCN_Typedescriptor_t TimeZoneDataType_offset_descr_;
extern const XERdescriptor_t TimeZoneDataType_daylightSavingInOffset_xer_;
extern const TTCN_JSONdescriptor_t TimeZoneDataType_daylightSavingInOffset_json_;
extern const TTCN_OERdescriptor_t TimeZoneDataType_daylightSavingInOffset_oer_;
extern const TTCN_Typedescriptor_t TimeZoneDataType_daylightSavingInOffset_descr_;
extern const TTCN_Typedescriptor_t TimeZoneDataType_descr_;
extern const XERdescriptor_t Argument_valueRank_xer_;
extern const TTCN_JSONdescriptor_t Argument_valueRank_json_;
extern const TTCN_OERdescriptor_t Argument_valueRank_oer_;
extern const TTCN_Typedescriptor_t Argument_valueRank_descr_;
extern const TTCN_Typedescriptor_t Argument_descr_;
extern const XERdescriptor_t EnumValueType_Value_xer_;
extern const TTCN_JSONdescriptor_t EnumValueType_Value_json_;
extern const TTCN_OERdescriptor_t EnumValueType_Value_oer_;
extern const TTCN_Typedescriptor_t EnumValueType_Value_descr_;
extern const TTCN_RAWdescriptor_t EnumValueType_raw_;
extern const TTCN_Typedescriptor_t EnumValueType_descr_;
extern const TTCN_Typedescriptor_t OptionSet_descr_;
extern const TTCN_Typedescriptor_t ListOfStructureField_descr_;
extern const TTCN_RAWdescriptor_t ListOfStructureFieldArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfStructureFieldArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfStructureFieldArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfStructureFieldArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfStructureFieldArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t StructureFieldArray_raw_;
extern const TTCN_Typedescriptor_t StructureFieldArray_descr_;
extern const XERdescriptor_t StructureField_valueRank_xer_;
extern const TTCN_JSONdescriptor_t StructureField_valueRank_json_;
extern const TTCN_OERdescriptor_t StructureField_valueRank_oer_;
extern const TTCN_Typedescriptor_t StructureField_valueRank_descr_;
extern const XERdescriptor_t StructureField_isOptional_xer_;
extern const TTCN_JSONdescriptor_t StructureField_isOptional_json_;
extern const TTCN_OERdescriptor_t StructureField_isOptional_oer_;
extern const TTCN_Typedescriptor_t StructureField_isOptional_descr_;
extern const TTCN_RAWdescriptor_t StructureField_raw_;
extern const TTCN_Typedescriptor_t StructureField_descr_;
extern const TTCN_RAWdescriptor_t ListOfStructureFieldArray_raw_;
extern const TTCN_Typedescriptor_t ListOfStructureFieldArray_descr_;
extern const TTCN_Typedescriptor_t StructureDefinition_descr_;
extern const TTCN_Typedescriptor_t ListOfEnumField_descr_;
extern const TTCN_RAWdescriptor_t ListOfEnumFieldArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfEnumFieldArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfEnumFieldArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfEnumFieldArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfEnumFieldArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t EnumFieldArray_raw_;
extern const TTCN_Typedescriptor_t EnumFieldArray_descr_;
extern const TTCN_RAWdescriptor_t EnumField_raw_;
extern const TTCN_Typedescriptor_t EnumField_descr_;
extern const TTCN_RAWdescriptor_t ListOfEnumFieldArray_raw_;
extern const TTCN_Typedescriptor_t ListOfEnumFieldArray_descr_;
extern const TTCN_Typedescriptor_t EnumDefinition_descr_;
extern const TTCN_RAWdescriptor_t CounterArray_raw_;
extern const TTCN_Typedescriptor_t CounterArray_descr_;
extern const XERdescriptor_t CounterArray_0_xer_;
extern const TTCN_JSONdescriptor_t CounterArray_0_json_;
extern const TTCN_OERdescriptor_t CounterArray_0_oer_;
extern const TTCN_Typedescriptor_t CounterArray_0_descr_;
extern const TTCN_RAWdescriptor_t IntegerIdArray_raw_;
extern const TTCN_Typedescriptor_t IntegerIdArray_descr_;
extern const XERdescriptor_t IntegerIdArray_0_xer_;
extern const TTCN_JSONdescriptor_t IntegerIdArray_0_json_;
extern const TTCN_OERdescriptor_t IntegerIdArray_0_oer_;
extern const TTCN_Typedescriptor_t IntegerIdArray_0_descr_;
extern const TTCN_RAWdescriptor_t LocaleIdArray_raw_;
extern const TTCN_Typedescriptor_t LocaleIdArray_descr_;
extern const TTCN_RAWdescriptor_t ContinuationPointArray_raw_;
extern const TTCN_Typedescriptor_t ContinuationPointArray_descr_;
extern const TTCN_RAWdescriptor_t DecimalArray_raw_;
extern const TTCN_Typedescriptor_t DecimalArray_descr_;
extern const TTCN_RAWdescriptor_t EnumValueTypeArray_raw_;
extern const TTCN_Typedescriptor_t EnumValueTypeArray_descr_;
extern const TTCN_RAWdescriptor_t ApplicationDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t ApplicationDescriptionArray_descr_;
extern const TTCN_RAWdescriptor_t ApplicationDescription_raw_;
extern const TTCN_Typedescriptor_t ApplicationDescription_descr_;
extern const TTCN_RAWdescriptor_t BrowseResultArray_raw_;
extern const TTCN_Typedescriptor_t BrowseResultArray_descr_;
extern const XERdescriptor_t BrowseResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t BrowseResult_statusCode_json_;
extern const TTCN_OERdescriptor_t BrowseResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t BrowseResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t ListOfReferenceDescription_raw_;
extern const TTCN_Typedescriptor_t ListOfReferenceDescription_descr_;
extern const TTCN_RAWdescriptor_t ListOfReferenceDescriptionArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfReferenceDescriptionArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfReferenceDescriptionArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfReferenceDescriptionArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfReferenceDescriptionArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ReferenceDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t ReferenceDescriptionArray_descr_;
extern const XERdescriptor_t ReferenceDescription_isForward_xer_;
extern const TTCN_JSONdescriptor_t ReferenceDescription_isForward_json_;
extern const TTCN_OERdescriptor_t ReferenceDescription_isForward_oer_;
extern const TTCN_Typedescriptor_t ReferenceDescription_isForward_descr_;
extern const TTCN_RAWdescriptor_t ReferenceDescription_raw_;
extern const TTCN_Typedescriptor_t ReferenceDescription_descr_;
extern const TTCN_RAWdescriptor_t ListOfReferenceDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t ListOfReferenceDescriptionArray_descr_;
extern const TTCN_RAWdescriptor_t BrowseResult_raw_;
extern const TTCN_Typedescriptor_t BrowseResult_descr_;
extern const TTCN_RAWdescriptor_t EndpointDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t EndpointDescriptionArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfUserTokenPolicy_raw_;
extern const TTCN_Typedescriptor_t ListOfUserTokenPolicy_descr_;
extern const TTCN_RAWdescriptor_t ListOfUserTokenPolicyArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfUserTokenPolicyArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfUserTokenPolicyArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfUserTokenPolicyArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfUserTokenPolicyArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t UserTokenPolicyArray_raw_;
extern const TTCN_Typedescriptor_t UserTokenPolicyArray_descr_;
extern const TTCN_RAWdescriptor_t UserTokenPolicy_raw_;
extern const TTCN_Typedescriptor_t UserTokenPolicy_descr_;
extern const TTCN_RAWdescriptor_t ListOfUserTokenPolicyArray_raw_;
extern const TTCN_Typedescriptor_t ListOfUserTokenPolicyArray_descr_;
extern const XERdescriptor_t EndpointDescription_securityLevel_xer_;
extern const TTCN_JSONdescriptor_t EndpointDescription_securityLevel_json_;
extern const TTCN_OERdescriptor_t EndpointDescription_securityLevel_oer_;
extern const TTCN_Typedescriptor_t EndpointDescription_securityLevel_descr_;
extern const TTCN_RAWdescriptor_t EndpointDescription_raw_;
extern const TTCN_Typedescriptor_t EndpointDescription_descr_;
extern const TTCN_RAWdescriptor_t MonitoringParametersArray_raw_;
extern const TTCN_Typedescriptor_t MonitoringParametersArray_descr_;
extern const XERdescriptor_t MonitoringParameters_clientHandle_xer_;
extern const TTCN_JSONdescriptor_t MonitoringParameters_clientHandle_json_;
extern const TTCN_OERdescriptor_t MonitoringParameters_clientHandle_oer_;
extern const TTCN_Typedescriptor_t MonitoringParameters_clientHandle_descr_;
extern const XERdescriptor_t MonitoringParameters_samplingInterval_xer_;
extern const TTCN_JSONdescriptor_t MonitoringParameters_samplingInterval_json_;
extern const TTCN_OERdescriptor_t MonitoringParameters_samplingInterval_oer_;
extern const TTCN_Typedescriptor_t MonitoringParameters_samplingInterval_descr_;
extern const XERdescriptor_t MonitoringParameters_queueSize_xer_;
extern const TTCN_JSONdescriptor_t MonitoringParameters_queueSize_json_;
extern const TTCN_OERdescriptor_t MonitoringParameters_queueSize_oer_;
extern const TTCN_Typedescriptor_t MonitoringParameters_queueSize_descr_;
extern const XERdescriptor_t MonitoringParameters_discardOldest_xer_;
extern const TTCN_JSONdescriptor_t MonitoringParameters_discardOldest_json_;
extern const TTCN_OERdescriptor_t MonitoringParameters_discardOldest_oer_;
extern const TTCN_Typedescriptor_t MonitoringParameters_discardOldest_descr_;
extern const TTCN_RAWdescriptor_t MonitoringParameters_raw_;
extern const TTCN_Typedescriptor_t MonitoringParameters_descr_;
extern const TTCN_RAWdescriptor_t QueryDataSetArray_raw_;
extern const TTCN_Typedescriptor_t QueryDataSetArray_descr_;
extern const TTCN_RAWdescriptor_t QueryDataSet_raw_;
extern const TTCN_Typedescriptor_t QueryDataSet_descr_;
extern const TTCN_RAWdescriptor_t ReadValueIdArray_raw_;
extern const TTCN_Typedescriptor_t ReadValueIdArray_descr_;
extern const XERdescriptor_t ReadValueId_attributeId_xer_;
extern const TTCN_JSONdescriptor_t ReadValueId_attributeId_json_;
extern const TTCN_OERdescriptor_t ReadValueId_attributeId_oer_;
extern const TTCN_Typedescriptor_t ReadValueId_attributeId_descr_;
extern const TTCN_RAWdescriptor_t ReadValueId_raw_;
extern const TTCN_Typedescriptor_t ReadValueId_descr_;
extern const TTCN_RAWdescriptor_t ApplicationInstanceCertificateArray_raw_;
extern const TTCN_Typedescriptor_t ApplicationInstanceCertificateArray_descr_;
extern const TTCN_RAWdescriptor_t ApplicationInstanceIssuerIdentifier_raw_;
extern const TTCN_Typedescriptor_t ApplicationInstanceIssuerIdentifier_descr_;
extern const XERdescriptor_t ApplicationInstanceCertificate_validFrom_xer_;
extern const TTCN_JSONdescriptor_t ApplicationInstanceCertificate_validFrom_json_;
extern const TTCN_OERdescriptor_t ApplicationInstanceCertificate_validFrom_oer_;
extern const TTCN_Typedescriptor_t ApplicationInstanceCertificate_validFrom_descr_;
extern const XERdescriptor_t ApplicationInstanceCertificate_validTo_xer_;
extern const TTCN_JSONdescriptor_t ApplicationInstanceCertificate_validTo_json_;
extern const TTCN_OERdescriptor_t ApplicationInstanceCertificate_validTo_oer_;
extern const TTCN_Typedescriptor_t ApplicationInstanceCertificate_validTo_descr_;
extern const TTCN_RAWdescriptor_t ApplicationInstanceSubjectIdentifier_raw_;
extern const TTCN_Typedescriptor_t ApplicationInstanceSubjectIdentifier_descr_;
extern const TTCN_RAWdescriptor_t ApplicationInstanceCertificate_raw_;
extern const TTCN_Typedescriptor_t ApplicationInstanceCertificate_descr_;
extern const TTCN_RAWdescriptor_t ChannelSecurityTokenArray_raw_;
extern const TTCN_Typedescriptor_t ChannelSecurityTokenArray_descr_;
extern const XERdescriptor_t ChannelSecurityToken_channelId_xer_;
extern const TTCN_JSONdescriptor_t ChannelSecurityToken_channelId_json_;
extern const TTCN_OERdescriptor_t ChannelSecurityToken_channelId_oer_;
extern const TTCN_Typedescriptor_t ChannelSecurityToken_channelId_descr_;
extern const XERdescriptor_t ChannelSecurityToken_tokenId_xer_;
extern const TTCN_JSONdescriptor_t ChannelSecurityToken_tokenId_json_;
extern const TTCN_OERdescriptor_t ChannelSecurityToken_tokenId_oer_;
extern const TTCN_Typedescriptor_t ChannelSecurityToken_tokenId_descr_;
extern const XERdescriptor_t ChannelSecurityToken_createdAt_xer_;
extern const TTCN_JSONdescriptor_t ChannelSecurityToken_createdAt_json_;
extern const TTCN_OERdescriptor_t ChannelSecurityToken_createdAt_oer_;
extern const TTCN_Typedescriptor_t ChannelSecurityToken_createdAt_descr_;
extern const XERdescriptor_t ChannelSecurityToken_revisedLifetime_xer_;
extern const TTCN_JSONdescriptor_t ChannelSecurityToken_revisedLifetime_json_;
extern const TTCN_OERdescriptor_t ChannelSecurityToken_revisedLifetime_oer_;
extern const TTCN_Typedescriptor_t ChannelSecurityToken_revisedLifetime_descr_;
extern const TTCN_RAWdescriptor_t ChannelSecurityToken_raw_;
extern const TTCN_Typedescriptor_t ChannelSecurityToken_descr_;
extern const TTCN_RAWdescriptor_t ServerOnNetworkArray_raw_;
extern const TTCN_Typedescriptor_t ServerOnNetworkArray_descr_;
extern const XERdescriptor_t ServerOnNetwork_recordId_xer_;
extern const TTCN_JSONdescriptor_t ServerOnNetwork_recordId_json_;
extern const TTCN_OERdescriptor_t ServerOnNetwork_recordId_oer_;
extern const TTCN_Typedescriptor_t ServerOnNetwork_recordId_descr_;
extern const TTCN_RAWdescriptor_t ServerOnNetwork_raw_;
extern const TTCN_Typedescriptor_t ServerOnNetwork_descr_;
extern const TTCN_RAWdescriptor_t AddNodesItemArray_raw_;
extern const TTCN_Typedescriptor_t AddNodesItemArray_descr_;
extern const TTCN_RAWdescriptor_t AddNodesItem_raw_;
extern const TTCN_Typedescriptor_t AddNodesItem_descr_;
extern const TTCN_RAWdescriptor_t AddNodesResultArray_raw_;
extern const TTCN_Typedescriptor_t AddNodesResultArray_descr_;
extern const XERdescriptor_t AddNodesResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t AddNodesResult_statusCode_json_;
extern const TTCN_OERdescriptor_t AddNodesResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t AddNodesResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t AddNodesResult_raw_;
extern const TTCN_Typedescriptor_t AddNodesResult_descr_;
extern const TTCN_RAWdescriptor_t AddReferencesItemArray_raw_;
extern const TTCN_Typedescriptor_t AddReferencesItemArray_descr_;
extern const XERdescriptor_t AddReferencesItem_isForward_xer_;
extern const TTCN_JSONdescriptor_t AddReferencesItem_isForward_json_;
extern const TTCN_OERdescriptor_t AddReferencesItem_isForward_oer_;
extern const TTCN_Typedescriptor_t AddReferencesItem_isForward_descr_;
extern const TTCN_RAWdescriptor_t AddReferencesItem_raw_;
extern const TTCN_Typedescriptor_t AddReferencesItem_descr_;
extern const TTCN_RAWdescriptor_t DeleteNodesItemArray_raw_;
extern const TTCN_Typedescriptor_t DeleteNodesItemArray_descr_;
extern const XERdescriptor_t DeleteNodesItem_deleteTargetReferences_xer_;
extern const TTCN_JSONdescriptor_t DeleteNodesItem_deleteTargetReferences_json_;
extern const TTCN_OERdescriptor_t DeleteNodesItem_deleteTargetReferences_oer_;
extern const TTCN_Typedescriptor_t DeleteNodesItem_deleteTargetReferences_descr_;
extern const TTCN_RAWdescriptor_t DeleteNodesItem_raw_;
extern const TTCN_Typedescriptor_t DeleteNodesItem_descr_;
extern const TTCN_RAWdescriptor_t DeleteReferencesItemArray_raw_;
extern const TTCN_Typedescriptor_t DeleteReferencesItemArray_descr_;
extern const XERdescriptor_t DeleteReferencesItem_isForward_xer_;
extern const TTCN_JSONdescriptor_t DeleteReferencesItem_isForward_json_;
extern const TTCN_OERdescriptor_t DeleteReferencesItem_isForward_oer_;
extern const TTCN_Typedescriptor_t DeleteReferencesItem_isForward_descr_;
extern const XERdescriptor_t DeleteReferencesItem_deleteBidirectional_xer_;
extern const TTCN_JSONdescriptor_t DeleteReferencesItem_deleteBidirectional_json_;
extern const TTCN_OERdescriptor_t DeleteReferencesItem_deleteBidirectional_oer_;
extern const TTCN_Typedescriptor_t DeleteReferencesItem_deleteBidirectional_descr_;
extern const TTCN_RAWdescriptor_t DeleteReferencesItem_raw_;
extern const TTCN_Typedescriptor_t DeleteReferencesItem_descr_;
extern const TTCN_RAWdescriptor_t SignedSoftwareCertificateArray_raw_;
extern const TTCN_Typedescriptor_t SignedSoftwareCertificateArray_descr_;
extern const TTCN_RAWdescriptor_t SignedSoftwareCertificate_raw_;
extern const TTCN_Typedescriptor_t SignedSoftwareCertificate_descr_;
extern const TTCN_RAWdescriptor_t BrowseDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t BrowseDescriptionArray_descr_;
extern const XERdescriptor_t BrowseDescription_includeSubtypes_xer_;
extern const TTCN_JSONdescriptor_t BrowseDescription_includeSubtypes_json_;
extern const TTCN_OERdescriptor_t BrowseDescription_includeSubtypes_oer_;
extern const TTCN_Typedescriptor_t BrowseDescription_includeSubtypes_descr_;
extern const XERdescriptor_t BrowseDescription_nodeClassMask_xer_;
extern const TTCN_JSONdescriptor_t BrowseDescription_nodeClassMask_json_;
extern const TTCN_OERdescriptor_t BrowseDescription_nodeClassMask_oer_;
extern const TTCN_Typedescriptor_t BrowseDescription_nodeClassMask_descr_;
extern const XERdescriptor_t BrowseDescription_resultMask_xer_;
extern const TTCN_JSONdescriptor_t BrowseDescription_resultMask_json_;
extern const TTCN_OERdescriptor_t BrowseDescription_resultMask_oer_;
extern const TTCN_Typedescriptor_t BrowseDescription_resultMask_descr_;
extern const TTCN_RAWdescriptor_t BrowseDescription_raw_;
extern const TTCN_Typedescriptor_t BrowseDescription_descr_;
extern const TTCN_RAWdescriptor_t BrowsePathArray_raw_;
extern const TTCN_Typedescriptor_t BrowsePathArray_descr_;
extern const TTCN_RAWdescriptor_t BrowsePath_raw_;
extern const TTCN_Typedescriptor_t BrowsePath_descr_;
extern const TTCN_RAWdescriptor_t BrowsePathResultArray_raw_;
extern const TTCN_Typedescriptor_t BrowsePathResultArray_descr_;
extern const XERdescriptor_t BrowsePathResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t BrowsePathResult_statusCode_json_;
extern const TTCN_OERdescriptor_t BrowsePathResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t BrowsePathResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePathTarget_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowsePathTarget_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePathTargetArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfBrowsePathTargetArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfBrowsePathTargetArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfBrowsePathTargetArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfBrowsePathTargetArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t BrowsePathTargetArray_raw_;
extern const TTCN_Typedescriptor_t BrowsePathTargetArray_descr_;
extern const XERdescriptor_t BrowsePathTarget_remainingPathIndex_xer_;
extern const TTCN_JSONdescriptor_t BrowsePathTarget_remainingPathIndex_json_;
extern const TTCN_OERdescriptor_t BrowsePathTarget_remainingPathIndex_oer_;
extern const TTCN_Typedescriptor_t BrowsePathTarget_remainingPathIndex_descr_;
extern const TTCN_RAWdescriptor_t BrowsePathTarget_raw_;
extern const TTCN_Typedescriptor_t BrowsePathTarget_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePathTargetArray_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowsePathTargetArray_descr_;
extern const TTCN_RAWdescriptor_t BrowsePathResult_raw_;
extern const TTCN_Typedescriptor_t BrowsePathResult_descr_;
extern const TTCN_RAWdescriptor_t NodeTypeDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t NodeTypeDescriptionArray_descr_;
extern const XERdescriptor_t NodeTypeDescription_includeSubtypes_xer_;
extern const TTCN_JSONdescriptor_t NodeTypeDescription_includeSubtypes_json_;
extern const TTCN_OERdescriptor_t NodeTypeDescription_includeSubtypes_oer_;
extern const TTCN_Typedescriptor_t NodeTypeDescription_includeSubtypes_descr_;
extern const TTCN_RAWdescriptor_t ListOfQueryDataDescription_raw_;
extern const TTCN_Typedescriptor_t ListOfQueryDataDescription_descr_;
extern const TTCN_RAWdescriptor_t ListOfQueryDataDescriptionArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfQueryDataDescriptionArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfQueryDataDescriptionArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfQueryDataDescriptionArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfQueryDataDescriptionArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t QueryDataDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t QueryDataDescriptionArray_descr_;
extern const XERdescriptor_t QueryDataDescription_attributeId_xer_;
extern const TTCN_JSONdescriptor_t QueryDataDescription_attributeId_json_;
extern const TTCN_OERdescriptor_t QueryDataDescription_attributeId_oer_;
extern const TTCN_Typedescriptor_t QueryDataDescription_attributeId_descr_;
extern const TTCN_RAWdescriptor_t QueryDataDescription_raw_;
extern const TTCN_Typedescriptor_t QueryDataDescription_descr_;
extern const TTCN_RAWdescriptor_t ListOfQueryDataDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t ListOfQueryDataDescriptionArray_descr_;
extern const TTCN_RAWdescriptor_t NodeTypeDescription_raw_;
extern const TTCN_Typedescriptor_t NodeTypeDescription_descr_;
extern const TTCN_RAWdescriptor_t ParsingResultArray_raw_;
extern const TTCN_Typedescriptor_t ParsingResultArray_descr_;
extern const XERdescriptor_t ParsingResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t ParsingResult_statusCode_json_;
extern const TTCN_OERdescriptor_t ParsingResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t ParsingResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t ParsingResult_raw_;
extern const TTCN_Typedescriptor_t ParsingResult_descr_;
extern const TTCN_RAWdescriptor_t HistoryReadValueIdArray_raw_;
extern const TTCN_Typedescriptor_t HistoryReadValueIdArray_descr_;
extern const TTCN_RAWdescriptor_t HistoryReadValueId_raw_;
extern const TTCN_Typedescriptor_t HistoryReadValueId_descr_;
extern const TTCN_RAWdescriptor_t HistoryReadResultArray_raw_;
extern const TTCN_Typedescriptor_t HistoryReadResultArray_descr_;
extern const XERdescriptor_t HistoryReadResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t HistoryReadResult_statusCode_json_;
extern const TTCN_OERdescriptor_t HistoryReadResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t HistoryReadResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t HistoryReadResult_raw_;
extern const TTCN_Typedescriptor_t HistoryReadResult_descr_;
extern const TTCN_RAWdescriptor_t WriteValueArray_raw_;
extern const TTCN_Typedescriptor_t WriteValueArray_descr_;
extern const XERdescriptor_t WriteValue_attributeId_xer_;
extern const TTCN_JSONdescriptor_t WriteValue_attributeId_json_;
extern const TTCN_OERdescriptor_t WriteValue_attributeId_oer_;
extern const TTCN_Typedescriptor_t WriteValue_attributeId_descr_;
extern const TTCN_RAWdescriptor_t WriteValue_raw_;
extern const TTCN_Typedescriptor_t WriteValue_descr_;
extern const TTCN_RAWdescriptor_t HistoryUpdateResultArray_raw_;
extern const TTCN_Typedescriptor_t HistoryUpdateResultArray_descr_;
extern const XERdescriptor_t HistoryUpdateResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t HistoryUpdateResult_statusCode_json_;
extern const TTCN_OERdescriptor_t HistoryUpdateResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t HistoryUpdateResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t HistoryUpdateResult_raw_;
extern const TTCN_Typedescriptor_t HistoryUpdateResult_descr_;
extern const TTCN_RAWdescriptor_t CallMethodRequestArray_raw_;
extern const TTCN_Typedescriptor_t CallMethodRequestArray_descr_;
extern const TTCN_RAWdescriptor_t CallMethodRequest_raw_;
extern const TTCN_Typedescriptor_t CallMethodRequest_descr_;
extern const TTCN_RAWdescriptor_t CallMethodResultArray_raw_;
extern const TTCN_Typedescriptor_t CallMethodResultArray_descr_;
extern const XERdescriptor_t CallMethodResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t CallMethodResult_statusCode_json_;
extern const TTCN_OERdescriptor_t CallMethodResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t CallMethodResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t CallMethodResult_raw_;
extern const TTCN_Typedescriptor_t CallMethodResult_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemCreateRequestArray_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemCreateRequestArray_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemCreateRequest_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemCreateRequest_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemCreateResultArray_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemCreateResultArray_descr_;
extern const XERdescriptor_t MonitoredItemCreateResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemCreateResult_statusCode_json_;
extern const TTCN_OERdescriptor_t MonitoredItemCreateResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemCreateResult_statusCode_descr_;
extern const XERdescriptor_t MonitoredItemCreateResult_monitoredItemId_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemCreateResult_monitoredItemId_json_;
extern const TTCN_OERdescriptor_t MonitoredItemCreateResult_monitoredItemId_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemCreateResult_monitoredItemId_descr_;
extern const XERdescriptor_t MonitoredItemCreateResult_revisedSamplingInterval_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemCreateResult_revisedSamplingInterval_json_;
extern const TTCN_OERdescriptor_t MonitoredItemCreateResult_revisedSamplingInterval_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemCreateResult_revisedSamplingInterval_descr_;
extern const XERdescriptor_t MonitoredItemCreateResult_revisedQueueSize_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemCreateResult_revisedQueueSize_json_;
extern const TTCN_OERdescriptor_t MonitoredItemCreateResult_revisedQueueSize_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemCreateResult_revisedQueueSize_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemCreateResult_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemCreateResult_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemModifyRequestArray_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemModifyRequestArray_descr_;
extern const XERdescriptor_t MonitoredItemModifyRequest_monitoredItemId_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemModifyRequest_monitoredItemId_json_;
extern const TTCN_OERdescriptor_t MonitoredItemModifyRequest_monitoredItemId_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemModifyRequest_monitoredItemId_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemModifyRequest_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemModifyRequest_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemModifyResultArray_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemModifyResultArray_descr_;
extern const XERdescriptor_t MonitoredItemModifyResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemModifyResult_statusCode_json_;
extern const TTCN_OERdescriptor_t MonitoredItemModifyResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemModifyResult_statusCode_descr_;
extern const XERdescriptor_t MonitoredItemModifyResult_revisedSamplingInterval_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemModifyResult_revisedSamplingInterval_json_;
extern const TTCN_OERdescriptor_t MonitoredItemModifyResult_revisedSamplingInterval_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemModifyResult_revisedSamplingInterval_descr_;
extern const XERdescriptor_t MonitoredItemModifyResult_revisedQueueSize_xer_;
extern const TTCN_JSONdescriptor_t MonitoredItemModifyResult_revisedQueueSize_json_;
extern const TTCN_OERdescriptor_t MonitoredItemModifyResult_revisedQueueSize_oer_;
extern const TTCN_Typedescriptor_t MonitoredItemModifyResult_revisedQueueSize_descr_;
extern const TTCN_RAWdescriptor_t MonitoredItemModifyResult_raw_;
extern const TTCN_Typedescriptor_t MonitoredItemModifyResult_descr_;
extern const TTCN_RAWdescriptor_t SubscriptionAcknowledgementArray_raw_;
extern const TTCN_Typedescriptor_t SubscriptionAcknowledgementArray_descr_;
extern const XERdescriptor_t SubscriptionAcknowledgement_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t SubscriptionAcknowledgement_subscriptionId_json_;
extern const TTCN_OERdescriptor_t SubscriptionAcknowledgement_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t SubscriptionAcknowledgement_subscriptionId_descr_;
extern const XERdescriptor_t SubscriptionAcknowledgement_sequenceNumber_xer_;
extern const TTCN_JSONdescriptor_t SubscriptionAcknowledgement_sequenceNumber_json_;
extern const TTCN_OERdescriptor_t SubscriptionAcknowledgement_sequenceNumber_oer_;
extern const TTCN_Typedescriptor_t SubscriptionAcknowledgement_sequenceNumber_descr_;
extern const TTCN_RAWdescriptor_t SubscriptionAcknowledgement_raw_;
extern const TTCN_Typedescriptor_t SubscriptionAcknowledgement_descr_;
extern const TTCN_RAWdescriptor_t TransferResultArray_raw_;
extern const TTCN_Typedescriptor_t TransferResultArray_descr_;
extern const XERdescriptor_t TransferResult_statusCode_xer_;
extern const TTCN_JSONdescriptor_t TransferResult_statusCode_json_;
extern const TTCN_OERdescriptor_t TransferResult_statusCode_oer_;
extern const TTCN_Typedescriptor_t TransferResult_statusCode_descr_;
extern const TTCN_RAWdescriptor_t ListOfCounter_raw_;
extern const TTCN_Typedescriptor_t ListOfCounter_descr_;
extern const TTCN_RAWdescriptor_t ListOfCounterArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfCounterArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfCounterArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfCounterArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfCounterArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfCounterArray_raw_;
extern const TTCN_Typedescriptor_t ListOfCounterArray_descr_;
extern const TTCN_RAWdescriptor_t TransferResult_raw_;
extern const TTCN_Typedescriptor_t TransferResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfIntegerIdArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfIntegerIdArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfIntegerIdArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfIntegerIdArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfIntegerIdArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfIntegerIdArray_raw_;
extern const TTCN_Typedescriptor_t ListOfIntegerIdArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfLocaleIdArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfLocaleIdArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfLocaleIdArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfLocaleIdArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfLocaleIdArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfLocaleIdArray_raw_;
extern const TTCN_Typedescriptor_t ListOfLocaleIdArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfContinuationPointArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfContinuationPointArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfContinuationPointArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfContinuationPointArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfContinuationPointArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfContinuationPointArray_raw_;
extern const TTCN_Typedescriptor_t ListOfContinuationPointArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDecimalArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfDecimalArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfDecimalArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfDecimalArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfDecimalArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfDecimalArray_raw_;
extern const TTCN_Typedescriptor_t ListOfDecimalArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfEnumValueTypeArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfEnumValueTypeArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfEnumValueTypeArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfEnumValueTypeArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfEnumValueTypeArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfEnumValueTypeArray_raw_;
extern const TTCN_Typedescriptor_t ListOfEnumValueTypeArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfApplicationDescriptionArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfApplicationDescriptionArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfApplicationDescriptionArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfApplicationDescriptionArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfApplicationDescriptionArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfApplicationDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t ListOfApplicationDescriptionArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowseResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfBrowseResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfBrowseResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfBrowseResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfBrowseResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowseResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowseResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfEndpointDescriptionArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfEndpointDescriptionArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfEndpointDescriptionArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfEndpointDescriptionArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfEndpointDescriptionArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfEndpointDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t ListOfEndpointDescriptionArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoringParametersArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfMonitoringParametersArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfMonitoringParametersArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfMonitoringParametersArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfMonitoringParametersArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoringParametersArray_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoringParametersArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfQueryDataSetArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfQueryDataSetArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfQueryDataSetArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfQueryDataSetArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfQueryDataSetArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfQueryDataSetArray_raw_;
extern const TTCN_Typedescriptor_t ListOfQueryDataSetArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfReadValueIdArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfReadValueIdArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfReadValueIdArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfReadValueIdArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfReadValueIdArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfReadValueIdArray_raw_;
extern const TTCN_Typedescriptor_t ListOfReadValueIdArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfApplicationInstanceCertificateArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfApplicationInstanceCertificateArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfApplicationInstanceCertificateArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfApplicationInstanceCertificateArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfApplicationInstanceCertificateArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfApplicationInstanceCertificateArray_raw_;
extern const TTCN_Typedescriptor_t ListOfApplicationInstanceCertificateArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfChannelSecurityTokenArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfChannelSecurityTokenArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfChannelSecurityTokenArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfChannelSecurityTokenArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfChannelSecurityTokenArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfChannelSecurityTokenArray_raw_;
extern const TTCN_Typedescriptor_t ListOfChannelSecurityTokenArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfServerOnNetworkArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfServerOnNetworkArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfServerOnNetworkArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfServerOnNetworkArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfServerOnNetworkArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfServerOnNetworkArray_raw_;
extern const TTCN_Typedescriptor_t ListOfServerOnNetworkArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddNodesItemArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfAddNodesItemArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfAddNodesItemArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfAddNodesItemArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfAddNodesItemArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddNodesItemArray_raw_;
extern const TTCN_Typedescriptor_t ListOfAddNodesItemArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddNodesResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfAddNodesResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfAddNodesResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfAddNodesResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfAddNodesResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddNodesResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfAddNodesResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddReferencesItemArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfAddReferencesItemArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfAddReferencesItemArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfAddReferencesItemArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfAddReferencesItemArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddReferencesItemArray_raw_;
extern const TTCN_Typedescriptor_t ListOfAddReferencesItemArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDeleteNodesItemArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfDeleteNodesItemArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfDeleteNodesItemArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfDeleteNodesItemArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfDeleteNodesItemArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfDeleteNodesItemArray_raw_;
extern const TTCN_Typedescriptor_t ListOfDeleteNodesItemArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfDeleteReferencesItemArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfDeleteReferencesItemArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfDeleteReferencesItemArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfDeleteReferencesItemArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfDeleteReferencesItemArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfDeleteReferencesItemArray_raw_;
extern const TTCN_Typedescriptor_t ListOfDeleteReferencesItemArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfSignedSoftwareCertificateArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfSignedSoftwareCertificateArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfSignedSoftwareCertificateArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfSignedSoftwareCertificateArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfSignedSoftwareCertificateArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfSignedSoftwareCertificateArray_raw_;
extern const TTCN_Typedescriptor_t ListOfSignedSoftwareCertificateArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowseDescriptionArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfBrowseDescriptionArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfBrowseDescriptionArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfBrowseDescriptionArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfBrowseDescriptionArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowseDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowseDescriptionArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePathArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfBrowsePathArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfBrowsePathArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfBrowsePathArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfBrowsePathArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePathArray_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowsePathArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePathResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfBrowsePathResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfBrowsePathResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfBrowsePathResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfBrowsePathResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePathResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowsePathResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfNodeTypeDescriptionArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfNodeTypeDescriptionArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfNodeTypeDescriptionArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfNodeTypeDescriptionArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfNodeTypeDescriptionArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfNodeTypeDescriptionArray_raw_;
extern const TTCN_Typedescriptor_t ListOfNodeTypeDescriptionArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfParsingResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfParsingResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfParsingResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfParsingResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfParsingResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfParsingResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfParsingResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryReadValueIdArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfHistoryReadValueIdArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfHistoryReadValueIdArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfHistoryReadValueIdArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfHistoryReadValueIdArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryReadValueIdArray_raw_;
extern const TTCN_Typedescriptor_t ListOfHistoryReadValueIdArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryReadResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfHistoryReadResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfHistoryReadResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfHistoryReadResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfHistoryReadResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryReadResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfHistoryReadResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfWriteValueArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfWriteValueArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfWriteValueArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfWriteValueArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfWriteValueArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfWriteValueArray_raw_;
extern const TTCN_Typedescriptor_t ListOfWriteValueArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryUpdateResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfHistoryUpdateResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfHistoryUpdateResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfHistoryUpdateResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfHistoryUpdateResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryUpdateResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfHistoryUpdateResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfCallMethodRequestArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfCallMethodRequestArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfCallMethodRequestArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfCallMethodRequestArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfCallMethodRequestArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfCallMethodRequestArray_raw_;
extern const TTCN_Typedescriptor_t ListOfCallMethodRequestArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfCallMethodResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfCallMethodResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfCallMethodResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfCallMethodResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfCallMethodResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfCallMethodResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfCallMethodResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemCreateRequestArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfMonitoredItemCreateRequestArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfMonitoredItemCreateRequestArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfMonitoredItemCreateRequestArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemCreateRequestArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemCreateRequestArray_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemCreateRequestArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemCreateResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfMonitoredItemCreateResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfMonitoredItemCreateResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfMonitoredItemCreateResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemCreateResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemCreateResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemCreateResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemModifyRequestArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfMonitoredItemModifyRequestArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfMonitoredItemModifyRequestArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfMonitoredItemModifyRequestArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemModifyRequestArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemModifyRequestArray_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemModifyRequestArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemModifyResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfMonitoredItemModifyResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfMonitoredItemModifyResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfMonitoredItemModifyResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemModifyResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemModifyResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemModifyResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfSubscriptionAcknowledgementArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfSubscriptionAcknowledgementArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfSubscriptionAcknowledgementArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfSubscriptionAcknowledgementArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfSubscriptionAcknowledgementArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfSubscriptionAcknowledgementArray_raw_;
extern const TTCN_Typedescriptor_t ListOfSubscriptionAcknowledgementArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfTransferResultArray_arrayLength_raw_;
extern const XERdescriptor_t ListOfTransferResultArray_arrayLength_xer_;
extern const TTCN_JSONdescriptor_t ListOfTransferResultArray_arrayLength_json_;
extern const TTCN_OERdescriptor_t ListOfTransferResultArray_arrayLength_oer_;
extern const TTCN_Typedescriptor_t ListOfTransferResultArray_arrayLength_descr_;
extern const TTCN_RAWdescriptor_t ListOfTransferResultArray_raw_;
extern const TTCN_Typedescriptor_t ListOfTransferResultArray_descr_;
extern const TTCN_RAWdescriptor_t ListOfIntegerId_raw_;
extern const TTCN_Typedescriptor_t ListOfIntegerId_descr_;
extern const TTCN_RAWdescriptor_t ListOfLocaleId_raw_;
extern const TTCN_Typedescriptor_t ListOfLocaleId_descr_;
extern const TTCN_RAWdescriptor_t ListOfContinuationPoint_raw_;
extern const TTCN_Typedescriptor_t ListOfContinuationPoint_descr_;
extern const TTCN_Typedescriptor_t ListOfDecimal_descr_;
extern const TTCN_Typedescriptor_t ListOfEnumValueType_descr_;
extern const TTCN_RAWdescriptor_t ListOfApplicationDescription_raw_;
extern const TTCN_Typedescriptor_t ListOfApplicationDescription_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowseResult_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowseResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfEndpointDescription_raw_;
extern const TTCN_Typedescriptor_t ListOfEndpointDescription_descr_;
extern const TTCN_Typedescriptor_t ListOfMonitoringParameters_descr_;
extern const TTCN_RAWdescriptor_t ListOfQueryDataSet_raw_;
extern const TTCN_Typedescriptor_t ListOfQueryDataSet_descr_;
extern const TTCN_RAWdescriptor_t ListOfReadValueId_raw_;
extern const TTCN_Typedescriptor_t ListOfReadValueId_descr_;
extern const TTCN_Typedescriptor_t ListOfApplicationInstanceCertificate_descr_;
extern const TTCN_Typedescriptor_t ListOfChannelSecurityToken_descr_;
extern const TTCN_RAWdescriptor_t ListOfServerOnNetwork_raw_;
extern const TTCN_Typedescriptor_t ListOfServerOnNetwork_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddNodesItem_raw_;
extern const TTCN_Typedescriptor_t ListOfAddNodesItem_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddNodesResult_raw_;
extern const TTCN_Typedescriptor_t ListOfAddNodesResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfAddReferencesItem_raw_;
extern const TTCN_Typedescriptor_t ListOfAddReferencesItem_descr_;
extern const TTCN_RAWdescriptor_t ListOfDeleteNodesItem_raw_;
extern const TTCN_Typedescriptor_t ListOfDeleteNodesItem_descr_;
extern const TTCN_RAWdescriptor_t ListOfDeleteReferencesItem_raw_;
extern const TTCN_Typedescriptor_t ListOfDeleteReferencesItem_descr_;
extern const TTCN_RAWdescriptor_t ListOfSignedSoftwareCertificate_raw_;
extern const TTCN_Typedescriptor_t ListOfSignedSoftwareCertificate_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowseDescription_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowseDescription_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePath_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowsePath_descr_;
extern const TTCN_RAWdescriptor_t ListOfBrowsePathResult_raw_;
extern const TTCN_Typedescriptor_t ListOfBrowsePathResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfNodeTypeDescription_raw_;
extern const TTCN_Typedescriptor_t ListOfNodeTypeDescription_descr_;
extern const TTCN_RAWdescriptor_t ListOfParsingResult_raw_;
extern const TTCN_Typedescriptor_t ListOfParsingResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryReadValueId_raw_;
extern const TTCN_Typedescriptor_t ListOfHistoryReadValueId_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryReadResult_raw_;
extern const TTCN_Typedescriptor_t ListOfHistoryReadResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfWriteValue_raw_;
extern const TTCN_Typedescriptor_t ListOfWriteValue_descr_;
extern const TTCN_RAWdescriptor_t ListOfHistoryUpdateResult_raw_;
extern const TTCN_Typedescriptor_t ListOfHistoryUpdateResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfCallMethodRequest_raw_;
extern const TTCN_Typedescriptor_t ListOfCallMethodRequest_descr_;
extern const TTCN_RAWdescriptor_t ListOfCallMethodResult_raw_;
extern const TTCN_Typedescriptor_t ListOfCallMethodResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemCreateRequest_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemCreateRequest_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemCreateResult_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemCreateResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemModifyRequest_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemModifyRequest_descr_;
extern const TTCN_RAWdescriptor_t ListOfMonitoredItemModifyResult_raw_;
extern const TTCN_Typedescriptor_t ListOfMonitoredItemModifyResult_descr_;
extern const TTCN_RAWdescriptor_t ListOfSubscriptionAcknowledgement_raw_;
extern const TTCN_Typedescriptor_t ListOfSubscriptionAcknowledgement_descr_;
extern const TTCN_RAWdescriptor_t ListOfTransferResult_raw_;
extern const TTCN_Typedescriptor_t ListOfTransferResult_descr_;
extern const XERdescriptor_t NotificationMessage_sequenceNumber_xer_;
extern const TTCN_JSONdescriptor_t NotificationMessage_sequenceNumber_json_;
extern const TTCN_OERdescriptor_t NotificationMessage_sequenceNumber_oer_;
extern const TTCN_Typedescriptor_t NotificationMessage_sequenceNumber_descr_;
extern const XERdescriptor_t NotificationMessage_publishTime_xer_;
extern const TTCN_JSONdescriptor_t NotificationMessage_publishTime_json_;
extern const TTCN_OERdescriptor_t NotificationMessage_publishTime_oer_;
extern const TTCN_Typedescriptor_t NotificationMessage_publishTime_descr_;
extern const TTCN_RAWdescriptor_t NotificationMessage_raw_;
extern const TTCN_Typedescriptor_t NotificationMessage_descr_;
extern const XERdescriptor_t RegisteredServer_isOnline_xer_;
extern const TTCN_JSONdescriptor_t RegisteredServer_isOnline_json_;
extern const TTCN_OERdescriptor_t RegisteredServer_isOnline_oer_;
extern const TTCN_Typedescriptor_t RegisteredServer_isOnline_descr_;
extern const TTCN_RAWdescriptor_t RegisteredServer_raw_;
extern const TTCN_Typedescriptor_t RegisteredServer_descr_;
extern const XERdescriptor_t EncryptedSecret_EncodingMask_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_EncodingMask_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_EncodingMask_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_EncodingMask_descr_;
extern const XERdescriptor_t EncryptedSecret_Length_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_Length_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_Length_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_Length_descr_;
extern const XERdescriptor_t EncryptedSecret_SigningTime_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_SigningTime_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_SigningTime_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_SigningTime_descr_;
extern const XERdescriptor_t EncryptedSecret_PolicyHeaderLength_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_PolicyHeaderLength_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_PolicyHeaderLength_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_PolicyHeaderLength_descr_;
extern const XERdescriptor_t EncryptedSecret_PolicyHeaderPaddingSize_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_PolicyHeaderPaddingSize_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_PolicyHeaderPaddingSize_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_PolicyHeaderPaddingSize_descr_;
extern const XERdescriptor_t EncryptedSecret_PayloadPaddingSize_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_PayloadPaddingSize_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_PayloadPaddingSize_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_PayloadPaddingSize_descr_;
extern const TTCN_Typedescriptor_t EncryptedSecret_descr_;
extern const XERdescriptor_t EncryptedSecret_PolicyHeaderPadding_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_PolicyHeaderPadding_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_PolicyHeaderPadding_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_PolicyHeaderPadding_descr_;
extern const XERdescriptor_t EncryptedSecret_PayloadPadding_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_PayloadPadding_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_PayloadPadding_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_PayloadPadding_descr_;
extern const XERdescriptor_t EncryptedSecret_Signature_xer_;
extern const TTCN_JSONdescriptor_t EncryptedSecret_Signature_json_;
extern const TTCN_OERdescriptor_t EncryptedSecret_Signature_oer_;
extern const TTCN_Typedescriptor_t EncryptedSecret_Signature_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_EncodingMask_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_EncodingMask_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_EncodingMask_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_EncodingMask_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_Length_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_Length_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_Length_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_Length_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_SigningTime_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_SigningTime_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_SigningTime_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_SigningTime_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_PolicyHeaderLength_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_PolicyHeaderLength_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_PolicyHeaderLength_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_PolicyHeaderLength_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_PolicyHeaderPaddingSize_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_PolicyHeaderPaddingSize_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_PolicyHeaderPaddingSize_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_PolicyHeaderPaddingSize_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_PayloadPaddingSize_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_PayloadPaddingSize_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_PayloadPaddingSize_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_PayloadPaddingSize_descr_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_PolicyHeaderPadding_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_PolicyHeaderPadding_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_PolicyHeaderPadding_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_PolicyHeaderPadding_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_PayloadPadding_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_PayloadPadding_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_PayloadPadding_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_PayloadPadding_descr_;
extern const XERdescriptor_t RsaEncryptedSecret_Signature_xer_;
extern const TTCN_JSONdescriptor_t RsaEncryptedSecret_Signature_json_;
extern const TTCN_OERdescriptor_t RsaEncryptedSecret_Signature_oer_;
extern const TTCN_Typedescriptor_t RsaEncryptedSecret_Signature_descr_;
extern const XERdescriptor_t ViewDescription_timestamp_xer_;
extern const TTCN_JSONdescriptor_t ViewDescription_timestamp_json_;
extern const TTCN_OERdescriptor_t ViewDescription_timestamp_oer_;
extern const TTCN_Typedescriptor_t ViewDescription_timestamp_descr_;
extern const XERdescriptor_t ViewDescription_viewVersion_xer_;
extern const TTCN_JSONdescriptor_t ViewDescription_viewVersion_json_;
extern const TTCN_OERdescriptor_t ViewDescription_viewVersion_oer_;
extern const TTCN_Typedescriptor_t ViewDescription_viewVersion_descr_;
extern const TTCN_RAWdescriptor_t ViewDescription_raw_;
extern const TTCN_Typedescriptor_t ViewDescription_descr_;
extern const TTCN_Typedescriptor_t TrustListDataType_descr_;
extern const TTCN_RAWdescriptor_t SignatureData_raw_;
extern const TTCN_Typedescriptor_t SignatureData_descr_;
extern const XERdescriptor_t MessageHeader_messageType_xer_;
extern const TTCN_JSONdescriptor_t MessageHeader_messageType_json_;
extern const TTCN_OERdescriptor_t MessageHeader_messageType_oer_;
extern const TTCN_Typedescriptor_t MessageHeader_messageType_descr_;
extern const XERdescriptor_t MessageHeader_chunkType_xer_;
extern const TTCN_JSONdescriptor_t MessageHeader_chunkType_json_;
extern const TTCN_OERdescriptor_t MessageHeader_chunkType_oer_;
extern const TTCN_Typedescriptor_t MessageHeader_chunkType_descr_;
extern const XERdescriptor_t MessageHeader_messageSize_xer_;
extern const TTCN_JSONdescriptor_t MessageHeader_messageSize_json_;
extern const TTCN_OERdescriptor_t MessageHeader_messageSize_oer_;
extern const TTCN_Typedescriptor_t MessageHeader_messageSize_descr_;
extern const TTCN_RAWdescriptor_t MessageHeader_raw_;
extern const TTCN_Typedescriptor_t MessageHeader_descr_;
extern const TTCN_Typedescriptor_t SecurityHeader_descr_;
extern const XERdescriptor_t AsymmetricSecurityHeader_SecurityPolicyUriLength_xer_;
extern const TTCN_JSONdescriptor_t AsymmetricSecurityHeader_SecurityPolicyUriLength_json_;
extern const TTCN_OERdescriptor_t AsymmetricSecurityHeader_SecurityPolicyUriLength_oer_;
extern const TTCN_Typedescriptor_t AsymmetricSecurityHeader_SecurityPolicyUriLength_descr_;
extern const XERdescriptor_t AsymmetricSecurityHeader_SenderCertificateLength_xer_;
extern const TTCN_JSONdescriptor_t AsymmetricSecurityHeader_SenderCertificateLength_json_;
extern const TTCN_OERdescriptor_t AsymmetricSecurityHeader_SenderCertificateLength_oer_;
extern const TTCN_Typedescriptor_t AsymmetricSecurityHeader_SenderCertificateLength_descr_;
extern const XERdescriptor_t AsymmetricSecurityHeader_ReceiverCertificateThumbprintLength_xer_;
extern const TTCN_JSONdescriptor_t AsymmetricSecurityHeader_ReceiverCertificateThumbprintLength_json_;
extern const TTCN_OERdescriptor_t AsymmetricSecurityHeader_ReceiverCertificateThumbprintLength_oer_;
extern const TTCN_Typedescriptor_t AsymmetricSecurityHeader_ReceiverCertificateThumbprintLength_descr_;
extern const TTCN_Typedescriptor_t AsymmetricSecurityHeader_descr_;
extern const XERdescriptor_t SymmetricSecurityHeader_TokenId_xer_;
extern const TTCN_JSONdescriptor_t SymmetricSecurityHeader_TokenId_json_;
extern const TTCN_OERdescriptor_t SymmetricSecurityHeader_TokenId_oer_;
extern const TTCN_Typedescriptor_t SymmetricSecurityHeader_TokenId_descr_;
extern const TTCN_Typedescriptor_t SymmetricSecurityHeader_descr_;
extern const XERdescriptor_t SequenceHeader_SequenceNumber_xer_;
extern const TTCN_JSONdescriptor_t SequenceHeader_SequenceNumber_json_;
extern const TTCN_OERdescriptor_t SequenceHeader_SequenceNumber_oer_;
extern const TTCN_Typedescriptor_t SequenceHeader_SequenceNumber_descr_;
extern const XERdescriptor_t SequenceHeader_RequestId_xer_;
extern const TTCN_JSONdescriptor_t SequenceHeader_RequestId_json_;
extern const TTCN_OERdescriptor_t SequenceHeader_RequestId_oer_;
extern const TTCN_Typedescriptor_t SequenceHeader_RequestId_descr_;
extern const TTCN_RAWdescriptor_t SequenceHeader_raw_;
extern const TTCN_Typedescriptor_t SequenceHeader_descr_;
extern const TTCN_RAWdescriptor_t MessageFooter_raw_;
extern const TTCN_Typedescriptor_t MessageFooter_descr_;
extern const TTCN_RAWdescriptor_t MessageFooter_PaddingSize_raw_;
extern const XERdescriptor_t MessageFooter_PaddingSize_xer_;
extern const TTCN_JSONdescriptor_t MessageFooter_PaddingSize_json_;
extern const TTCN_OERdescriptor_t MessageFooter_PaddingSize_oer_;
extern const TTCN_Typedescriptor_t MessageFooter_PaddingSize_descr_;
extern const XERdescriptor_t MessageFooter_ExtraPaddingSize_xer_;
extern const TTCN_JSONdescriptor_t MessageFooter_ExtraPaddingSize_json_;
extern const TTCN_OERdescriptor_t MessageFooter_ExtraPaddingSize_oer_;
extern const TTCN_Typedescriptor_t MessageFooter_ExtraPaddingSize_descr_;
extern const XERdescriptor_t AdditionalHeader_Value_xer_;
extern const TTCN_JSONdescriptor_t AdditionalHeader_Value_json_;
extern const TTCN_OERdescriptor_t AdditionalHeader_Value_oer_;
extern const TTCN_Typedescriptor_t AdditionalHeader_Value_descr_;
extern const TTCN_RAWdescriptor_t AdditionalHeader_raw_;
extern const TTCN_Typedescriptor_t AdditionalHeader_descr_;
extern const XERdescriptor_t RequestHeader_timestamp_xer_;
extern const TTCN_JSONdescriptor_t RequestHeader_timestamp_json_;
extern const TTCN_OERdescriptor_t RequestHeader_timestamp_oer_;
extern const TTCN_Typedescriptor_t RequestHeader_timestamp_descr_;
extern const XERdescriptor_t RequestHeader_requestHandle_xer_;
extern const TTCN_JSONdescriptor_t RequestHeader_requestHandle_json_;
extern const TTCN_OERdescriptor_t RequestHeader_requestHandle_oer_;
extern const TTCN_Typedescriptor_t RequestHeader_requestHandle_descr_;
extern const XERdescriptor_t RequestHeader_returnDiagnostics_xer_;
extern const TTCN_JSONdescriptor_t RequestHeader_returnDiagnostics_json_;
extern const TTCN_OERdescriptor_t RequestHeader_returnDiagnostics_oer_;
extern const TTCN_Typedescriptor_t RequestHeader_returnDiagnostics_descr_;
extern const XERdescriptor_t RequestHeader_timeoutHint_xer_;
extern const TTCN_JSONdescriptor_t RequestHeader_timeoutHint_json_;
extern const TTCN_OERdescriptor_t RequestHeader_timeoutHint_oer_;
extern const TTCN_Typedescriptor_t RequestHeader_timeoutHint_descr_;
extern const TTCN_RAWdescriptor_t RequestHeader_raw_;
extern const TTCN_Typedescriptor_t RequestHeader_descr_;
extern const XERdescriptor_t ResponseHeader_timestamp_xer_;
extern const TTCN_JSONdescriptor_t ResponseHeader_timestamp_json_;
extern const TTCN_OERdescriptor_t ResponseHeader_timestamp_oer_;
extern const TTCN_Typedescriptor_t ResponseHeader_timestamp_descr_;
extern const XERdescriptor_t ResponseHeader_requestHandle_xer_;
extern const TTCN_JSONdescriptor_t ResponseHeader_requestHandle_json_;
extern const TTCN_OERdescriptor_t ResponseHeader_requestHandle_oer_;
extern const TTCN_Typedescriptor_t ResponseHeader_requestHandle_descr_;
extern const XERdescriptor_t ResponseHeader_serviceResult_xer_;
extern const TTCN_JSONdescriptor_t ResponseHeader_serviceResult_json_;
extern const TTCN_OERdescriptor_t ResponseHeader_serviceResult_oer_;
extern const TTCN_Typedescriptor_t ResponseHeader_serviceResult_descr_;
extern const TTCN_RAWdescriptor_t ResponseHeader_raw_;
extern const TTCN_Typedescriptor_t ResponseHeader_descr_;
extern const TTCN_Typedescriptor_t ServiceFault_descr_;
extern const XERdescriptor_t HelloMessage_version_xer_;
extern const TTCN_JSONdescriptor_t HelloMessage_version_json_;
extern const TTCN_OERdescriptor_t HelloMessage_version_oer_;
extern const TTCN_Typedescriptor_t HelloMessage_version_descr_;
extern const XERdescriptor_t HelloMessage_receiveBufferSize_xer_;
extern const TTCN_JSONdescriptor_t HelloMessage_receiveBufferSize_json_;
extern const TTCN_OERdescriptor_t HelloMessage_receiveBufferSize_oer_;
extern const TTCN_Typedescriptor_t HelloMessage_receiveBufferSize_descr_;
extern const XERdescriptor_t HelloMessage_sendBufferSize_xer_;
extern const TTCN_JSONdescriptor_t HelloMessage_sendBufferSize_json_;
extern const TTCN_OERdescriptor_t HelloMessage_sendBufferSize_oer_;
extern const TTCN_Typedescriptor_t HelloMessage_sendBufferSize_descr_;
extern const XERdescriptor_t HelloMessage_maxMessageSize_xer_;
extern const TTCN_JSONdescriptor_t HelloMessage_maxMessageSize_json_;
extern const TTCN_OERdescriptor_t HelloMessage_maxMessageSize_oer_;
extern const TTCN_Typedescriptor_t HelloMessage_maxMessageSize_descr_;
extern const XERdescriptor_t HelloMessage_maxChunkCount_xer_;
extern const TTCN_JSONdescriptor_t HelloMessage_maxChunkCount_json_;
extern const TTCN_OERdescriptor_t HelloMessage_maxChunkCount_oer_;
extern const TTCN_Typedescriptor_t HelloMessage_maxChunkCount_descr_;
extern const TTCN_RAWdescriptor_t HelloMessage_raw_;
extern const TTCN_Typedescriptor_t HelloMessage_descr_;
extern const XERdescriptor_t AckMessage_version_xer_;
extern const TTCN_JSONdescriptor_t AckMessage_version_json_;
extern const TTCN_OERdescriptor_t AckMessage_version_oer_;
extern const TTCN_Typedescriptor_t AckMessage_version_descr_;
extern const XERdescriptor_t AckMessage_receiveBufferSize_xer_;
extern const TTCN_JSONdescriptor_t AckMessage_receiveBufferSize_json_;
extern const TTCN_OERdescriptor_t AckMessage_receiveBufferSize_oer_;
extern const TTCN_Typedescriptor_t AckMessage_receiveBufferSize_descr_;
extern const XERdescriptor_t AckMessage_sendBufferSize_xer_;
extern const TTCN_JSONdescriptor_t AckMessage_sendBufferSize_json_;
extern const TTCN_OERdescriptor_t AckMessage_sendBufferSize_oer_;
extern const TTCN_Typedescriptor_t AckMessage_sendBufferSize_descr_;
extern const XERdescriptor_t AckMessage_maxMessageSize_xer_;
extern const TTCN_JSONdescriptor_t AckMessage_maxMessageSize_json_;
extern const TTCN_OERdescriptor_t AckMessage_maxMessageSize_oer_;
extern const TTCN_Typedescriptor_t AckMessage_maxMessageSize_descr_;
extern const XERdescriptor_t AckMessage_maxChunkCount_xer_;
extern const TTCN_JSONdescriptor_t AckMessage_maxChunkCount_json_;
extern const TTCN_OERdescriptor_t AckMessage_maxChunkCount_oer_;
extern const TTCN_Typedescriptor_t AckMessage_maxChunkCount_descr_;
extern const TTCN_RAWdescriptor_t AckMessage_raw_;
extern const TTCN_Typedescriptor_t AckMessage_descr_;
extern const XERdescriptor_t ErrorMessage_errorCode_xer_;
extern const TTCN_JSONdescriptor_t ErrorMessage_errorCode_json_;
extern const TTCN_OERdescriptor_t ErrorMessage_errorCode_oer_;
extern const TTCN_Typedescriptor_t ErrorMessage_errorCode_descr_;
extern const TTCN_RAWdescriptor_t ErrorMessage_raw_;
extern const TTCN_Typedescriptor_t ErrorMessage_descr_;
extern const TTCN_RAWdescriptor_t ReverseHelloMessage_raw_;
extern const TTCN_Typedescriptor_t ReverseHelloMessage_descr_;
extern const TTCN_RAWdescriptor_t FindServiceRequest_raw_;
extern const TTCN_Typedescriptor_t FindServiceRequest_descr_;
extern const TTCN_RAWdescriptor_t FindServiceResponse_raw_;
extern const TTCN_Typedescriptor_t FindServiceResponse_descr_;
extern const XERdescriptor_t FindServersOnNetworkRequest_startingRecordId_xer_;
extern const TTCN_JSONdescriptor_t FindServersOnNetworkRequest_startingRecordId_json_;
extern const TTCN_OERdescriptor_t FindServersOnNetworkRequest_startingRecordId_oer_;
extern const TTCN_Typedescriptor_t FindServersOnNetworkRequest_startingRecordId_descr_;
extern const XERdescriptor_t FindServersOnNetworkRequest_maxRecordsToReturn_xer_;
extern const TTCN_JSONdescriptor_t FindServersOnNetworkRequest_maxRecordsToReturn_json_;
extern const TTCN_OERdescriptor_t FindServersOnNetworkRequest_maxRecordsToReturn_oer_;
extern const TTCN_Typedescriptor_t FindServersOnNetworkRequest_maxRecordsToReturn_descr_;
extern const TTCN_RAWdescriptor_t FindServersOnNetworkRequest_raw_;
extern const TTCN_Typedescriptor_t FindServersOnNetworkRequest_descr_;
extern const XERdescriptor_t FindServersOnNetworkResponse_lastCounterResetTime_xer_;
extern const TTCN_JSONdescriptor_t FindServersOnNetworkResponse_lastCounterResetTime_json_;
extern const TTCN_OERdescriptor_t FindServersOnNetworkResponse_lastCounterResetTime_oer_;
extern const TTCN_Typedescriptor_t FindServersOnNetworkResponse_lastCounterResetTime_descr_;
extern const TTCN_RAWdescriptor_t FindServersOnNetworkResponse_raw_;
extern const TTCN_Typedescriptor_t FindServersOnNetworkResponse_descr_;
extern const TTCN_RAWdescriptor_t GetEndpointsRequest_raw_;
extern const TTCN_Typedescriptor_t GetEndpointsRequest_descr_;
extern const TTCN_RAWdescriptor_t GetEndpointsResponse_raw_;
extern const TTCN_Typedescriptor_t GetEndpointsResponse_descr_;
extern const TTCN_RAWdescriptor_t RegisterServerRequest_raw_;
extern const TTCN_Typedescriptor_t RegisterServerRequest_descr_;
extern const TTCN_RAWdescriptor_t RegisterServerResponse_raw_;
extern const TTCN_Typedescriptor_t RegisterServerResponse_descr_;
extern const TTCN_RAWdescriptor_t RegisterServer2Request_raw_;
extern const TTCN_Typedescriptor_t RegisterServer2Request_descr_;
extern const TTCN_RAWdescriptor_t RegisterServer2Response_raw_;
extern const TTCN_Typedescriptor_t RegisterServer2Response_descr_;
extern const XERdescriptor_t OpenSecureChannelRequest_clientProtocolVersion_xer_;
extern const TTCN_JSONdescriptor_t OpenSecureChannelRequest_clientProtocolVersion_json_;
extern const TTCN_OERdescriptor_t OpenSecureChannelRequest_clientProtocolVersion_oer_;
extern const TTCN_Typedescriptor_t OpenSecureChannelRequest_clientProtocolVersion_descr_;
extern const XERdescriptor_t OpenSecureChannelRequest_requestedLifetime_xer_;
extern const TTCN_JSONdescriptor_t OpenSecureChannelRequest_requestedLifetime_json_;
extern const TTCN_OERdescriptor_t OpenSecureChannelRequest_requestedLifetime_oer_;
extern const TTCN_Typedescriptor_t OpenSecureChannelRequest_requestedLifetime_descr_;
extern const TTCN_RAWdescriptor_t OpenSecureChannelRequest_raw_;
extern const TTCN_Typedescriptor_t OpenSecureChannelRequest_descr_;
extern const XERdescriptor_t OpenSecureChannelResponse_serverProtocolVersion_xer_;
extern const TTCN_JSONdescriptor_t OpenSecureChannelResponse_serverProtocolVersion_json_;
extern const TTCN_OERdescriptor_t OpenSecureChannelResponse_serverProtocolVersion_oer_;
extern const TTCN_Typedescriptor_t OpenSecureChannelResponse_serverProtocolVersion_descr_;
extern const TTCN_RAWdescriptor_t OpenSecureChannelResponse_raw_;
extern const TTCN_Typedescriptor_t OpenSecureChannelResponse_descr_;
extern const TTCN_RAWdescriptor_t CloseSecureChannelRequest_raw_;
extern const TTCN_Typedescriptor_t CloseSecureChannelRequest_descr_;
extern const TTCN_RAWdescriptor_t CloseSecureChannelResponse_raw_;
extern const TTCN_Typedescriptor_t CloseSecureChannelResponse_descr_;
extern const XERdescriptor_t CreateSessionRequest_requestedSessionTimeout_xer_;
extern const TTCN_JSONdescriptor_t CreateSessionRequest_requestedSessionTimeout_json_;
extern const TTCN_OERdescriptor_t CreateSessionRequest_requestedSessionTimeout_oer_;
extern const TTCN_Typedescriptor_t CreateSessionRequest_requestedSessionTimeout_descr_;
extern const XERdescriptor_t CreateSessionRequest_maxResponseMessageSize_xer_;
extern const TTCN_JSONdescriptor_t CreateSessionRequest_maxResponseMessageSize_json_;
extern const TTCN_OERdescriptor_t CreateSessionRequest_maxResponseMessageSize_oer_;
extern const TTCN_Typedescriptor_t CreateSessionRequest_maxResponseMessageSize_descr_;
extern const TTCN_RAWdescriptor_t CreateSessionRequest_raw_;
extern const TTCN_Typedescriptor_t CreateSessionRequest_descr_;
extern const XERdescriptor_t CreateSessionResponse_revisedSessionTimeout_xer_;
extern const TTCN_JSONdescriptor_t CreateSessionResponse_revisedSessionTimeout_json_;
extern const TTCN_OERdescriptor_t CreateSessionResponse_revisedSessionTimeout_oer_;
extern const TTCN_Typedescriptor_t CreateSessionResponse_revisedSessionTimeout_descr_;
extern const XERdescriptor_t CreateSessionResponse_maxRequestMessageSize_xer_;
extern const TTCN_JSONdescriptor_t CreateSessionResponse_maxRequestMessageSize_json_;
extern const TTCN_OERdescriptor_t CreateSessionResponse_maxRequestMessageSize_oer_;
extern const TTCN_Typedescriptor_t CreateSessionResponse_maxRequestMessageSize_descr_;
extern const TTCN_RAWdescriptor_t CreateSessionResponse_raw_;
extern const TTCN_Typedescriptor_t CreateSessionResponse_descr_;
extern const TTCN_RAWdescriptor_t ActivateSessionRequest_raw_;
extern const TTCN_Typedescriptor_t ActivateSessionRequest_descr_;
extern const TTCN_RAWdescriptor_t ActivateSessionResponse_raw_;
extern const TTCN_Typedescriptor_t ActivateSessionResponse_descr_;
extern const XERdescriptor_t CloseSessionRequest_deleteSubscriptions_xer_;
extern const TTCN_JSONdescriptor_t CloseSessionRequest_deleteSubscriptions_json_;
extern const TTCN_OERdescriptor_t CloseSessionRequest_deleteSubscriptions_oer_;
extern const TTCN_Typedescriptor_t CloseSessionRequest_deleteSubscriptions_descr_;
extern const TTCN_RAWdescriptor_t CloseSessionRequest_raw_;
extern const TTCN_Typedescriptor_t CloseSessionRequest_descr_;
extern const TTCN_RAWdescriptor_t CloseSessionResponse_raw_;
extern const TTCN_Typedescriptor_t CloseSessionResponse_descr_;
extern const XERdescriptor_t CancelRequestRequest_requestHandle_xer_;
extern const TTCN_JSONdescriptor_t CancelRequestRequest_requestHandle_json_;
extern const TTCN_OERdescriptor_t CancelRequestRequest_requestHandle_oer_;
extern const TTCN_Typedescriptor_t CancelRequestRequest_requestHandle_descr_;
extern const TTCN_RAWdescriptor_t CancelRequestRequest_raw_;
extern const TTCN_Typedescriptor_t CancelRequestRequest_descr_;
extern const XERdescriptor_t CancelRequestResponse_cancelCount_xer_;
extern const TTCN_JSONdescriptor_t CancelRequestResponse_cancelCount_json_;
extern const TTCN_OERdescriptor_t CancelRequestResponse_cancelCount_oer_;
extern const TTCN_Typedescriptor_t CancelRequestResponse_cancelCount_descr_;
extern const TTCN_RAWdescriptor_t CancelRequestResponse_raw_;
extern const TTCN_Typedescriptor_t CancelRequestResponse_descr_;
extern const TTCN_RAWdescriptor_t AddNodesRequest_raw_;
extern const TTCN_Typedescriptor_t AddNodesRequest_descr_;
extern const TTCN_RAWdescriptor_t AddNodesResponse_raw_;
extern const TTCN_Typedescriptor_t AddNodesResponse_descr_;
extern const TTCN_RAWdescriptor_t AddReferencesRequest_raw_;
extern const TTCN_Typedescriptor_t AddReferencesRequest_descr_;
extern const TTCN_RAWdescriptor_t AddReferencesResponse_raw_;
extern const TTCN_Typedescriptor_t AddReferencesResponse_descr_;
extern const TTCN_RAWdescriptor_t DeleteNodesRequest_raw_;
extern const TTCN_Typedescriptor_t DeleteNodesRequest_descr_;
extern const TTCN_RAWdescriptor_t DeleteNodesResponse_raw_;
extern const TTCN_Typedescriptor_t DeleteNodesResponse_descr_;
extern const TTCN_RAWdescriptor_t DeleteReferencesRequest_raw_;
extern const TTCN_Typedescriptor_t DeleteReferencesRequest_descr_;
extern const TTCN_RAWdescriptor_t DeleteReferencesResponse_raw_;
extern const TTCN_Typedescriptor_t DeleteReferencesResponse_descr_;
extern const XERdescriptor_t BrowseRequest_requestedMaxReferencesPerNode_xer_;
extern const TTCN_JSONdescriptor_t BrowseRequest_requestedMaxReferencesPerNode_json_;
extern const TTCN_OERdescriptor_t BrowseRequest_requestedMaxReferencesPerNode_oer_;
extern const TTCN_Typedescriptor_t BrowseRequest_requestedMaxReferencesPerNode_descr_;
extern const TTCN_RAWdescriptor_t BrowseRequest_raw_;
extern const TTCN_Typedescriptor_t BrowseRequest_descr_;
extern const TTCN_RAWdescriptor_t BrowseResponse_raw_;
extern const TTCN_Typedescriptor_t BrowseResponse_descr_;
extern const XERdescriptor_t BrowseNextRequest_releaseContinuationPoints_xer_;
extern const TTCN_JSONdescriptor_t BrowseNextRequest_releaseContinuationPoints_json_;
extern const TTCN_OERdescriptor_t BrowseNextRequest_releaseContinuationPoints_oer_;
extern const TTCN_Typedescriptor_t BrowseNextRequest_releaseContinuationPoints_descr_;
extern const TTCN_RAWdescriptor_t BrowseNextRequest_raw_;
extern const TTCN_Typedescriptor_t BrowseNextRequest_descr_;
extern const TTCN_RAWdescriptor_t BrowseNextResponse_raw_;
extern const TTCN_Typedescriptor_t BrowseNextResponse_descr_;
extern const TTCN_RAWdescriptor_t TranslateBrowsePathsToNodeIdsRequest_raw_;
extern const TTCN_Typedescriptor_t TranslateBrowsePathsToNodeIdsRequest_descr_;
extern const TTCN_RAWdescriptor_t TranslateBrowsePathsToNodeIdsResponse_raw_;
extern const TTCN_Typedescriptor_t TranslateBrowsePathsToNodeIdsResponse_descr_;
extern const TTCN_RAWdescriptor_t RegisterNodesRequest_raw_;
extern const TTCN_Typedescriptor_t RegisterNodesRequest_descr_;
extern const TTCN_RAWdescriptor_t RegisterNodesResponse_raw_;
extern const TTCN_Typedescriptor_t RegisterNodesResponse_descr_;
extern const TTCN_RAWdescriptor_t UnregisterNodesRequest_raw_;
extern const TTCN_Typedescriptor_t UnregisterNodesRequest_descr_;
extern const TTCN_RAWdescriptor_t UnregisterNodesResponse_raw_;
extern const TTCN_Typedescriptor_t UnregisterNodesResponse_descr_;
extern const XERdescriptor_t QueryFirstRequest_maxDataSetsToReturn_xer_;
extern const TTCN_JSONdescriptor_t QueryFirstRequest_maxDataSetsToReturn_json_;
extern const TTCN_OERdescriptor_t QueryFirstRequest_maxDataSetsToReturn_oer_;
extern const TTCN_Typedescriptor_t QueryFirstRequest_maxDataSetsToReturn_descr_;
extern const XERdescriptor_t QueryFirstRequest_maxReferencesToReturn_xer_;
extern const TTCN_JSONdescriptor_t QueryFirstRequest_maxReferencesToReturn_json_;
extern const TTCN_OERdescriptor_t QueryFirstRequest_maxReferencesToReturn_oer_;
extern const TTCN_Typedescriptor_t QueryFirstRequest_maxReferencesToReturn_descr_;
extern const TTCN_RAWdescriptor_t QueryFirstRequest_raw_;
extern const TTCN_Typedescriptor_t QueryFirstRequest_descr_;
extern const TTCN_RAWdescriptor_t QueryFirstResponse_raw_;
extern const TTCN_Typedescriptor_t QueryFirstResponse_descr_;
extern const XERdescriptor_t QueryNextRequest_releaseContinuationPoint_xer_;
extern const TTCN_JSONdescriptor_t QueryNextRequest_releaseContinuationPoint_json_;
extern const TTCN_OERdescriptor_t QueryNextRequest_releaseContinuationPoint_oer_;
extern const TTCN_Typedescriptor_t QueryNextRequest_releaseContinuationPoint_descr_;
extern const TTCN_RAWdescriptor_t QueryNextRequest_raw_;
extern const TTCN_Typedescriptor_t QueryNextRequest_descr_;
extern const TTCN_RAWdescriptor_t QueryNextResponse_raw_;
extern const TTCN_Typedescriptor_t QueryNextResponse_descr_;
extern const XERdescriptor_t ReadRequest_maxAge_xer_;
extern const TTCN_JSONdescriptor_t ReadRequest_maxAge_json_;
extern const TTCN_OERdescriptor_t ReadRequest_maxAge_oer_;
extern const TTCN_Typedescriptor_t ReadRequest_maxAge_descr_;
extern const TTCN_RAWdescriptor_t ReadRequest_raw_;
extern const TTCN_Typedescriptor_t ReadRequest_descr_;
extern const TTCN_RAWdescriptor_t ReadResponse_raw_;
extern const TTCN_Typedescriptor_t ReadResponse_descr_;
extern const XERdescriptor_t HistoryReadRequest_releaseContinuationPoints_xer_;
extern const TTCN_JSONdescriptor_t HistoryReadRequest_releaseContinuationPoints_json_;
extern const TTCN_OERdescriptor_t HistoryReadRequest_releaseContinuationPoints_oer_;
extern const TTCN_Typedescriptor_t HistoryReadRequest_releaseContinuationPoints_descr_;
extern const TTCN_RAWdescriptor_t HistoryReadRequest_raw_;
extern const TTCN_Typedescriptor_t HistoryReadRequest_descr_;
extern const TTCN_RAWdescriptor_t HistoryReadResponse_raw_;
extern const TTCN_Typedescriptor_t HistoryReadResponse_descr_;
extern const TTCN_RAWdescriptor_t WriteRequest_raw_;
extern const TTCN_Typedescriptor_t WriteRequest_descr_;
extern const TTCN_RAWdescriptor_t WriteResponse_raw_;
extern const TTCN_Typedescriptor_t WriteResponse_descr_;
extern const TTCN_RAWdescriptor_t HistoryUpdateRequest_raw_;
extern const TTCN_Typedescriptor_t HistoryUpdateRequest_descr_;
extern const TTCN_RAWdescriptor_t HistoryUpdateResponse_raw_;
extern const TTCN_Typedescriptor_t HistoryUpdateResponse_descr_;
extern const TTCN_RAWdescriptor_t CallRequest_raw_;
extern const TTCN_Typedescriptor_t CallRequest_descr_;
extern const TTCN_RAWdescriptor_t CallResponse_raw_;
extern const TTCN_Typedescriptor_t CallResponse_descr_;
extern const XERdescriptor_t CreateMonitoredItemsRequest_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t CreateMonitoredItemsRequest_subscriptionId_json_;
extern const TTCN_OERdescriptor_t CreateMonitoredItemsRequest_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t CreateMonitoredItemsRequest_subscriptionId_descr_;
extern const TTCN_RAWdescriptor_t CreateMonitoredItemsRequest_raw_;
extern const TTCN_Typedescriptor_t CreateMonitoredItemsRequest_descr_;
extern const TTCN_RAWdescriptor_t CreateMonitoredItemsResponse_raw_;
extern const TTCN_Typedescriptor_t CreateMonitoredItemsResponse_descr_;
extern const XERdescriptor_t ModifyMonitoredItemsRequest_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t ModifyMonitoredItemsRequest_subscriptionId_json_;
extern const TTCN_OERdescriptor_t ModifyMonitoredItemsRequest_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t ModifyMonitoredItemsRequest_subscriptionId_descr_;
extern const TTCN_RAWdescriptor_t ModifyMonitoredItemsRequest_raw_;
extern const TTCN_Typedescriptor_t ModifyMonitoredItemsRequest_descr_;
extern const TTCN_RAWdescriptor_t ModifyMonitoredItemsResponse_raw_;
extern const TTCN_Typedescriptor_t ModifyMonitoredItemsResponse_descr_;
extern const XERdescriptor_t SetMonitoringModeRequest_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t SetMonitoringModeRequest_subscriptionId_json_;
extern const TTCN_OERdescriptor_t SetMonitoringModeRequest_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t SetMonitoringModeRequest_subscriptionId_descr_;
extern const TTCN_RAWdescriptor_t SetMonitoringModeRequest_raw_;
extern const TTCN_Typedescriptor_t SetMonitoringModeRequest_descr_;
extern const TTCN_RAWdescriptor_t SetMonitoringModeResponse_raw_;
extern const TTCN_Typedescriptor_t SetMonitoringModeResponse_descr_;
extern const XERdescriptor_t SetTriggeringRequest_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t SetTriggeringRequest_subscriptionId_json_;
extern const TTCN_OERdescriptor_t SetTriggeringRequest_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t SetTriggeringRequest_subscriptionId_descr_;
extern const XERdescriptor_t SetTriggeringRequest_triggeringItemId_xer_;
extern const TTCN_JSONdescriptor_t SetTriggeringRequest_triggeringItemId_json_;
extern const TTCN_OERdescriptor_t SetTriggeringRequest_triggeringItemId_oer_;
extern const TTCN_Typedescriptor_t SetTriggeringRequest_triggeringItemId_descr_;
extern const XERdescriptor_t SetTriggeringRequest_linksToRemove_xer_;
extern const TTCN_JSONdescriptor_t SetTriggeringRequest_linksToRemove_json_;
extern const TTCN_OERdescriptor_t SetTriggeringRequest_linksToRemove_oer_;
extern const TTCN_Typedescriptor_t SetTriggeringRequest_linksToRemove_descr_;
extern const TTCN_RAWdescriptor_t SetTriggeringRequest_raw_;
extern const TTCN_Typedescriptor_t SetTriggeringRequest_descr_;
extern const TTCN_RAWdescriptor_t SetTriggeringResponse_raw_;
extern const TTCN_Typedescriptor_t SetTriggeringResponse_descr_;
extern const XERdescriptor_t DeleteMonitoredItemsRequest_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t DeleteMonitoredItemsRequest_subscriptionId_json_;
extern const TTCN_OERdescriptor_t DeleteMonitoredItemsRequest_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t DeleteMonitoredItemsRequest_subscriptionId_descr_;
extern const TTCN_RAWdescriptor_t DeleteMonitoredItemsRequest_raw_;
extern const TTCN_Typedescriptor_t DeleteMonitoredItemsRequest_descr_;
extern const TTCN_RAWdescriptor_t DeleteMonitoredItemsResponse_raw_;
extern const TTCN_Typedescriptor_t DeleteMonitoredItemsResponse_descr_;
extern const XERdescriptor_t CreateSubscriptionRequest_requestedPublishingInterval_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionRequest_requestedPublishingInterval_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionRequest_requestedPublishingInterval_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionRequest_requestedPublishingInterval_descr_;
extern const XERdescriptor_t CreateSubscriptionRequest_requestedLifetimeCount_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionRequest_requestedLifetimeCount_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionRequest_requestedLifetimeCount_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionRequest_requestedLifetimeCount_descr_;
extern const XERdescriptor_t CreateSubscriptionRequest_requestedMaxKeepAliveCount_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionRequest_requestedMaxKeepAliveCount_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionRequest_requestedMaxKeepAliveCount_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionRequest_requestedMaxKeepAliveCount_descr_;
extern const XERdescriptor_t CreateSubscriptionRequest_maxNotificationsPerPublish_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionRequest_maxNotificationsPerPublish_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionRequest_maxNotificationsPerPublish_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionRequest_maxNotificationsPerPublish_descr_;
extern const XERdescriptor_t CreateSubscriptionRequest_publishingEnabled_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionRequest_publishingEnabled_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionRequest_publishingEnabled_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionRequest_publishingEnabled_descr_;
extern const XERdescriptor_t CreateSubscriptionRequest_priorityInt32_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionRequest_priorityInt32_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionRequest_priorityInt32_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionRequest_priorityInt32_descr_;
extern const TTCN_RAWdescriptor_t CreateSubscriptionRequest_raw_;
extern const TTCN_Typedescriptor_t CreateSubscriptionRequest_descr_;
extern const XERdescriptor_t CreateSubscriptionResponse_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionResponse_subscriptionId_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionResponse_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionResponse_subscriptionId_descr_;
extern const XERdescriptor_t CreateSubscriptionResponse_revisedPublishingInterval_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionResponse_revisedPublishingInterval_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionResponse_revisedPublishingInterval_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionResponse_revisedPublishingInterval_descr_;
extern const XERdescriptor_t CreateSubscriptionResponse_revisedLifetimeCount_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionResponse_revisedLifetimeCount_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionResponse_revisedLifetimeCount_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionResponse_revisedLifetimeCount_descr_;
extern const XERdescriptor_t CreateSubscriptionResponse_revisedMaxKeepAliveCount_xer_;
extern const TTCN_JSONdescriptor_t CreateSubscriptionResponse_revisedMaxKeepAliveCount_json_;
extern const TTCN_OERdescriptor_t CreateSubscriptionResponse_revisedMaxKeepAliveCount_oer_;
extern const TTCN_Typedescriptor_t CreateSubscriptionResponse_revisedMaxKeepAliveCount_descr_;
extern const TTCN_RAWdescriptor_t CreateSubscriptionResponse_raw_;
extern const TTCN_Typedescriptor_t CreateSubscriptionResponse_descr_;
extern const XERdescriptor_t ModifySubscriptionRequest_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionRequest_subscriptionId_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionRequest_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionRequest_subscriptionId_descr_;
extern const XERdescriptor_t ModifySubscriptionRequest_requestedPublishingInterval_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionRequest_requestedPublishingInterval_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionRequest_requestedPublishingInterval_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionRequest_requestedPublishingInterval_descr_;
extern const XERdescriptor_t ModifySubscriptionRequest_requestedLifetimeCount_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionRequest_requestedLifetimeCount_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionRequest_requestedLifetimeCount_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionRequest_requestedLifetimeCount_descr_;
extern const XERdescriptor_t ModifySubscriptionRequest_requestedMaxKeepAliveCount_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionRequest_requestedMaxKeepAliveCount_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionRequest_requestedMaxKeepAliveCount_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionRequest_requestedMaxKeepAliveCount_descr_;
extern const XERdescriptor_t ModifySubscriptionRequest_maxNotificationsPerPublish_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionRequest_maxNotificationsPerPublish_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionRequest_maxNotificationsPerPublish_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionRequest_maxNotificationsPerPublish_descr_;
extern const XERdescriptor_t ModifySubscriptionRequest_priority_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionRequest_priority_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionRequest_priority_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionRequest_priority_descr_;
extern const TTCN_RAWdescriptor_t ModifySubscriptionRequest_raw_;
extern const TTCN_Typedescriptor_t ModifySubscriptionRequest_descr_;
extern const XERdescriptor_t ModifySubscriptionResponse_revisedPublishingInterval_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionResponse_revisedPublishingInterval_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionResponse_revisedPublishingInterval_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionResponse_revisedPublishingInterval_descr_;
extern const XERdescriptor_t ModifySubscriptionResponse_revisedLifetimeCount_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionResponse_revisedLifetimeCount_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionResponse_revisedLifetimeCount_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionResponse_revisedLifetimeCount_descr_;
extern const XERdescriptor_t ModifySubscriptionResponse_revisedMaxKeepAliveCount_xer_;
extern const TTCN_JSONdescriptor_t ModifySubscriptionResponse_revisedMaxKeepAliveCount_json_;
extern const TTCN_OERdescriptor_t ModifySubscriptionResponse_revisedMaxKeepAliveCount_oer_;
extern const TTCN_Typedescriptor_t ModifySubscriptionResponse_revisedMaxKeepAliveCount_descr_;
extern const TTCN_RAWdescriptor_t ModifySubscriptionResponse_raw_;
extern const TTCN_Typedescriptor_t ModifySubscriptionResponse_descr_;
extern const XERdescriptor_t SetPublishingModeRequest_publishingEnabled_xer_;
extern const TTCN_JSONdescriptor_t SetPublishingModeRequest_publishingEnabled_json_;
extern const TTCN_OERdescriptor_t SetPublishingModeRequest_publishingEnabled_oer_;
extern const TTCN_Typedescriptor_t SetPublishingModeRequest_publishingEnabled_descr_;
extern const TTCN_RAWdescriptor_t SetPublishingModeRequest_raw_;
extern const TTCN_Typedescriptor_t SetPublishingModeRequest_descr_;
extern const TTCN_RAWdescriptor_t SetPublishingModeResponse_raw_;
extern const TTCN_Typedescriptor_t SetPublishingModeResponse_descr_;
extern const TTCN_RAWdescriptor_t PublishRequest_raw_;
extern const TTCN_Typedescriptor_t PublishRequest_descr_;
extern const XERdescriptor_t PublishResponse_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t PublishResponse_subscriptionId_json_;
extern const TTCN_OERdescriptor_t PublishResponse_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t PublishResponse_subscriptionId_descr_;
extern const XERdescriptor_t PublishResponse_moreNotifications_xer_;
extern const TTCN_JSONdescriptor_t PublishResponse_moreNotifications_json_;
extern const TTCN_OERdescriptor_t PublishResponse_moreNotifications_oer_;
extern const TTCN_Typedescriptor_t PublishResponse_moreNotifications_descr_;
extern const TTCN_RAWdescriptor_t PublishResponse_raw_;
extern const TTCN_Typedescriptor_t PublishResponse_descr_;
extern const XERdescriptor_t RepublishRequest_subscriptionId_xer_;
extern const TTCN_JSONdescriptor_t RepublishRequest_subscriptionId_json_;
extern const TTCN_OERdescriptor_t RepublishRequest_subscriptionId_oer_;
extern const TTCN_Typedescriptor_t RepublishRequest_subscriptionId_descr_;
extern const XERdescriptor_t RepublishRequest_retransmitSequenceNumber_xer_;
extern const TTCN_JSONdescriptor_t RepublishRequest_retransmitSequenceNumber_json_;
extern const TTCN_OERdescriptor_t RepublishRequest_retransmitSequenceNumber_oer_;
extern const TTCN_Typedescriptor_t RepublishRequest_retransmitSequenceNumber_descr_;
extern const TTCN_RAWdescriptor_t RepublishRequest_raw_;
extern const TTCN_Typedescriptor_t RepublishRequest_descr_;
extern const TTCN_RAWdescriptor_t RepublishResponse_raw_;
extern const TTCN_Typedescriptor_t RepublishResponse_descr_;
extern const XERdescriptor_t TransferSubscriptionsRequest_sendInitialValues_xer_;
extern const TTCN_JSONdescriptor_t TransferSubscriptionsRequest_sendInitialValues_json_;
extern const TTCN_OERdescriptor_t TransferSubscriptionsRequest_sendInitialValues_oer_;
extern const TTCN_Typedescriptor_t TransferSubscriptionsRequest_sendInitialValues_descr_;
extern const TTCN_RAWdescriptor_t TransferSubscriptionsRequest_raw_;
extern const TTCN_Typedescriptor_t TransferSubscriptionsRequest_descr_;
extern const TTCN_RAWdescriptor_t TransferSubscriptionsResponse_raw_;
extern const TTCN_Typedescriptor_t TransferSubscriptionsResponse_descr_;
extern const TTCN_RAWdescriptor_t DeleteSubscriptionsRequest_raw_;
extern const TTCN_Typedescriptor_t DeleteSubscriptionsRequest_descr_;
extern const TTCN_RAWdescriptor_t DeleteSubscriptionsResponse_raw_;
extern const TTCN_Typedescriptor_t DeleteSubscriptionsResponse_descr_;
extern const XERdescriptor_t SessionlessInvokeRequest_urisVersion_xer_;
extern const TTCN_JSONdescriptor_t SessionlessInvokeRequest_urisVersion_json_;
extern const TTCN_OERdescriptor_t SessionlessInvokeRequest_urisVersion_oer_;
extern const TTCN_Typedescriptor_t SessionlessInvokeRequest_urisVersion_descr_;
extern const XERdescriptor_t SessionlessInvokeRequest_serviceId_xer_;
extern const TTCN_JSONdescriptor_t SessionlessInvokeRequest_serviceId_json_;
extern const TTCN_OERdescriptor_t SessionlessInvokeRequest_serviceId_oer_;
extern const TTCN_Typedescriptor_t SessionlessInvokeRequest_serviceId_descr_;
extern const TTCN_RAWdescriptor_t SessionlessServices_raw_;
extern const TTCN_Typedescriptor_t SessionlessServices_descr_;
extern const XERdescriptor_t SessionlessInvokeResponse_serviceId_xer_;
extern const TTCN_JSONdescriptor_t SessionlessInvokeResponse_serviceId_json_;
extern const TTCN_OERdescriptor_t SessionlessInvokeResponse_serviceId_oer_;
extern const TTCN_Typedescriptor_t SessionlessInvokeResponse_serviceId_descr_;
extern const TTCN_RAWdescriptor_t SessionlessInvokeResponse_raw_;
extern const TTCN_Typedescriptor_t SessionlessInvokeResponse_descr_;
extern const TTCN_Typedescriptor_t SessionlessInvokeRequest_descr_;
extern const TTCN_RAWdescriptor_t ServiceList_raw_;
extern const TTCN_Typedescriptor_t ServiceList_descr_;
extern const TTCN_RAWdescriptor_t OpcMessages_raw_;
extern const TTCN_Typedescriptor_t OpcMessages_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_header_raw_;
extern const TTCN_Typedescriptor_t MessageChunk_header_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_raw_;
extern const TTCN_Typedescriptor_t MessageChunk_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_transportMessage_raw_;
extern const TTCN_Typedescriptor_t MessageChunk_transportMessage_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_securityChannelId_raw_;
extern const XERdescriptor_t MessageChunk_securityChannelId_xer_;
extern const TTCN_JSONdescriptor_t MessageChunk_securityChannelId_json_;
extern const TTCN_OERdescriptor_t MessageChunk_securityChannelId_oer_;
extern const TTCN_Typedescriptor_t MessageChunk_securityChannelId_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_securePolicyUri_raw_;
extern const TTCN_Typedescriptor_t MessageChunk_securePolicyUri_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_senderCertificate_raw_;
extern const TTCN_Typedescriptor_t MessageChunk_senderCertificate_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_receiverCertificateThumbprint_raw_;
extern const TTCN_Typedescriptor_t MessageChunk_receiverCertificateThumbprint_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_securityTokenId_raw_;
extern const XERdescriptor_t MessageChunk_securityTokenId_xer_;
extern const TTCN_JSONdescriptor_t MessageChunk_securityTokenId_json_;
extern const TTCN_OERdescriptor_t MessageChunk_securityTokenId_oer_;
extern const TTCN_Typedescriptor_t MessageChunk_securityTokenId_descr_;
extern const TTCN_RAWdescriptor_t MessageChunk_sequenceHeader_raw_;
extern const TTCN_Typedescriptor_t MessageChunk_sequenceHeader_descr_;
extern const XERdescriptor_t MessageChunk_body_xer_;
extern const TTCN_JSONdescriptor_t MessageChunk_body_json_;
extern const TTCN_OERdescriptor_t MessageChunk_body_oer_;
extern const TTCN_Typedescriptor_t MessageChunk_body_descr_;
extern const XERdescriptor_t ServiceBody_encodingByte_xer_;
extern const TTCN_JSONdescriptor_t ServiceBody_encodingByte_json_;
extern const TTCN_OERdescriptor_t ServiceBody_encodingByte_oer_;
extern const TTCN_Typedescriptor_t ServiceBody_encodingByte_descr_;
extern const XERdescriptor_t ServiceBody_namespaceIndex_xer_;
extern const TTCN_JSONdescriptor_t ServiceBody_namespaceIndex_json_;
extern const TTCN_OERdescriptor_t ServiceBody_namespaceIndex_oer_;
extern const TTCN_Typedescriptor_t ServiceBody_namespaceIndex_descr_;
extern const XERdescriptor_t ServiceBody_nodeValue_xer_;
extern const TTCN_JSONdescriptor_t ServiceBody_nodeValue_json_;
extern const TTCN_OERdescriptor_t ServiceBody_nodeValue_oer_;
extern const TTCN_Typedescriptor_t ServiceBody_nodeValue_descr_;
extern const TTCN_RAWdescriptor_t ServiceBody_list_raw_;
extern const TTCN_Typedescriptor_t ServiceBody_list_descr_;
extern const TTCN_RAWdescriptor_t ServiceBody_raw_;
extern const TTCN_Typedescriptor_t ServiceBody_descr_;
extern TTCN_Module module_object;

} /* end of namespace */

#endif
